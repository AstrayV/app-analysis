{"version":3,"sources":["../browser/src/persistence/Subject.ts"],"names":[],"mappings":"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","file":"Subject.js","sourcesContent":["import {ObjectLiteral} from \"../common/ObjectLiteral\";\nimport {EntityMetadata} from \"../metadata/EntityMetadata\";\nimport {ColumnMetadata} from \"../metadata/ColumnMetadata\";\nimport {RelationMetadata} from \"../metadata/RelationMetadata\";\nimport {DateUtils} from \"../util/DateUtils\";\n\n/**\n * Holds information about insert operation into junction table.\n */\nexport interface JunctionInsert {\n\n    /**\n     * Relation of the junction table.\n     */\n    relation: RelationMetadata;\n\n    /**\n     * Entities that needs to be \"bind\" to the subject.\n     */\n    junctionEntities: ObjectLiteral[];\n}\n\n/**\n * Holds information about remove operation from the junction table.\n */\nexport interface JunctionRemove {\n\n    /**\n     * Relation of the junction table.\n     */\n    relation: RelationMetadata;\n\n    /**\n     * Entity ids that needs to be removed from the junction table.\n     */\n    junctionRelationIds: any[];\n}\n\n/**\n * Holds information about relation update in some subject.\n */\nexport interface RelationUpdate {\n\n    /**\n     * Relation that needs to be updated.\n     */\n    relation: RelationMetadata;\n\n    /**\n     * New value that needs to be set into into new relation.\n     */\n    value: any;\n}\n\n/**\n * Subject is a subject of persistence.\n * It holds information about each entity that needs to be persisted:\n * - what entity should be persisted\n * - what is database representation of the persisted entity\n * - what entity metadata of the persisted entity\n * - what is allowed to with persisted entity (insert/update/remove)\n *\n * Having this collection of subjects we can perform database queries.\n */\nexport class Subject {\n\n    // -------------------------------------------------------------------------\n    // Private Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Persist entity (changed entity).\n     */\n    private _persistEntity?: ObjectLiteral;\n\n    /**\n     * Database entity.\n     */\n    private _databaseEntity?: ObjectLiteral;\n\n    // -------------------------------------------------------------------------\n    // Public Readonly Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Entity metadata of the subject entity.\n     */\n    readonly metadata: EntityMetadata;\n\n    /**\n     * Date when this entity is persisted.\n     */\n    readonly date: Date = new Date();\n\n    // -------------------------------------------------------------------------\n    // Public Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Indicates if this subject can be inserted into the database.\n     * This means that this subject either is newly persisted, either can be inserted by cascades.\n     */\n    canBeInserted: boolean = false;\n\n    /**\n     * Indicates if this subject can be updated in the database.\n     * This means that this subject either was persisted, either can be updated by cascades.\n     */\n    canBeUpdated: boolean = false;\n\n    /**\n     * Indicates if this subject MUST be removed from the database.\n     * This means that this subject either was removed, either was removed by cascades.\n     */\n    mustBeRemoved: boolean = false;\n\n    /**\n     * Differentiated columns between persisted and database entities.\n     */\n    diffColumns: ColumnMetadata[] = [];\n\n    /**\n     * Differentiated relations between persisted and database entities.\n     */\n    diffRelations: RelationMetadata[] = [];\n\n    /**\n     * List of relations which need to be unset.\n     * This is used to update relation from inverse side.\n     */\n    relationUpdates: RelationUpdate[] = [];\n\n    /**\n     * Records that needs to be inserted into the junction tables of this subject.\n     */\n    junctionInserts: JunctionInsert[] = [];\n\n    /**\n     * Records that needs to be removed from the junction tables of this subject.\n     */\n    junctionRemoves: JunctionRemove[] = [];\n\n    /**\n     * When subject is newly persisted it may have a generated entity id.\n     * In this case it should be written here.\n     */\n    generatedMap?: ObjectLiteral;\n\n    /**\n     * Generated id of the parent entity. Used in the class-table-inheritance.\n     */\n    parentGeneratedId?: any;\n\n    /**\n     * Used in newly persisted entities which are tree tables.\n     */\n    treeLevel?: number;\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(metadata: EntityMetadata, entity?: ObjectLiteral, databaseEntity?: ObjectLiteral) {\n        this.metadata = metadata;\n        this._persistEntity = entity;\n        this._databaseEntity = databaseEntity;\n    }\n\n    // -------------------------------------------------------------------------\n    // Accessors\n    // -------------------------------------------------------------------------\n\n    /**\n     * Gets entity sent to the persistence (e.g. changed entity).\n     * Throws error if persisted entity was not set.\n     */\n    get entity(): ObjectLiteral {\n        if (!this._persistEntity)\n            throw new Error(`Persistence entity is not set for the given subject.`);\n\n        return this._persistEntity;\n    }\n\n    /**\n     * Checks if subject has a persisted entity.\n     */\n    get hasEntity(): boolean {\n        return !!this._persistEntity;\n    }\n\n    /**\n     * Gets entity from the database (e.g. original entity).\n     * THIS IS NOT RAW ENTITY DATA.\n     * Throws error if database entity was not set.\n     */\n    get databaseEntity(): ObjectLiteral {\n        if (!this._databaseEntity)\n            throw new Error(`Database entity is not set for the given subject.`);\n\n        return this._databaseEntity;\n    }\n\n    /**\n     * Checks if subject has a database entity.\n     */\n    get hasDatabaseEntity(): boolean {\n        return !!this._databaseEntity;\n    }\n\n    /**\n     * Sets entity from the database (e.g. original entity).\n     * Once database entity set it calculates differentiated columns and relations\n     * between persistent entity and database entity.\n     */\n    set databaseEntity(databaseEntity: ObjectLiteral) {\n        this._databaseEntity = databaseEntity;\n        this.recompute();\n    }\n\n    /**\n     * Gets entity target from the entity metadata of this subject.\n     */\n    get entityTarget(): Function|string {\n        return this.metadata.target;\n    }\n\n    /**\n     * Checks if this subject must be inserted into the database.\n     * Subject can be inserted into the database if it is allowed to be inserted (explicitly persisted or by cascades)\n     * and if it does not have database entity set.\n     */\n    get mustBeInserted() {\n        return this.canBeInserted && !this.hasDatabaseEntity;\n    }\n\n    /**\n     * Checks if this subject must be updated into the database.\n     * Subject can be updated in the database if it is allowed to be updated (explicitly persisted or by cascades)\n     * and if it does have differentiated columns or relations.\n     */\n    get mustBeUpdated() {\n        return this.canBeUpdated && (this.diffColumns.length > 0 || this.diffRelations.length > 0);\n    }\n\n    /**\n     * Checks if this subject has relations to be updated.\n     */\n    get hasRelationUpdates(): boolean {\n        return this.relationUpdates.length > 0;\n    }\n\n    /**\n     * Gets id of the persisted entity.\n     * If entity is not set then it returns undefined.\n     * If entity itself has an id then it simply returns it.\n     * If entity does not have an id then it returns newly generated id.\n\n    get getPersistedEntityIdMap(): any|undefined {\n        if (!this.hasEntity)\n            return undefined;\n\n        const entityIdMap = this.metadata.getDatabaseEntityIdMap(this.entity);\n        if (entityIdMap)\n            return entityIdMap;\n\n        if (this.newlyGeneratedId)\n            return this.metadata.createSimpleDatabaseIdMap(this.newlyGeneratedId);\n\n        return undefined;\n    }*/\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Validates this subject for errors.\n     * Subject cannot be at the same time inserted and updated, removed and inserted, removed and updated.\n     */\n    validate() {\n\n        if (this.mustBeInserted && this.mustBeRemoved)\n            throw new Error(`Removed entity ${this.metadata.name} is also scheduled for insert operation. This looks like ORM problem. Please report a github issue.`);\n\n        if (this.mustBeUpdated && this.mustBeRemoved)\n            throw new Error(`Removed entity \"${this.metadata.name}\" is also scheduled for update operation. ` +\n                `Make sure you are not updating and removing same object (note that update or remove may be executed by cascade operations).`);\n\n        if (this.mustBeInserted && this.mustBeUpdated)\n            throw new Error(`Inserted entity ${this.metadata.name} is also scheduled for updated operation. This looks like ORM problem. Please report a github issue.`);\n\n    }\n\n    /**\n     * Performs entity re-computations.\n     */\n    recompute() {\n        if (this.hasEntity && this._databaseEntity) {\n            this.computeDiffColumns();\n            this.computeDiffRelationalColumns();\n        }\n    }\n\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Differentiate columns from the updated entity and entity stored in the database.\n     */\n    protected computeDiffColumns(): void {\n        this.diffColumns = this.metadata.columns.filter(column => {\n\n            // prepare both entity and database values to make comparision\n            let entityValue = column.getEntityValue(this.entity);\n            let databaseValue = column.getEntityValue(this.databaseEntity);\n            if (entityValue === undefined)\n                return false;\n\n            // normalize special values to make proper comparision (todo: arent they already normalized at this point?!)\n            if (entityValue !== null && entityValue !== undefined) {\n                if (column.type === \"date\") {\n                    entityValue = DateUtils.mixedDateToDateString(entityValue);\n\n                } else if (column.type === \"time\") {\n                    entityValue = DateUtils.mixedDateToTimeString(entityValue);\n\n                } else if (column.type === \"datetime\" || column.type === Date) {\n                    entityValue = DateUtils.mixedDateToUtcDatetimeString(entityValue);\n                    databaseValue = DateUtils.mixedDateToUtcDatetimeString(databaseValue);\n\n                } else if (column.type === \"json\" || column.type === \"jsonb\") {\n                    entityValue = JSON.stringify(entityValue);\n                    if (databaseValue !== null && databaseValue !== undefined)\n                        databaseValue = JSON.stringify(databaseValue);\n\n                } else if (column.type === \"sample-array\") {\n                    entityValue = DateUtils.simpleArrayToString(entityValue);\n                    databaseValue = DateUtils.simpleArrayToString(databaseValue);\n                }\n            }\n            // todo: this mechanism does not get in count embeddeds in embeddeds\n\n            // if value is not defined then no need to update it\n            // if (!column.isInEmbedded && this.entity[column.propertyName] === undefined)\n            //     return false;\n            //\n            // if value is in embedded and is not defined then no need to update it\n            // if (column.isInEmbedded && (this.entity[column.embeddedProperty] === undefined || this.entity[column.embeddedProperty][column.propertyName] === undefined))\n            //     return false;\n\n            // if its a special column or value is not changed - then do nothing\n            if (column.isVirtual ||\n                column.isParentId ||\n                column.isDiscriminator ||\n                column.isUpdateDate ||\n                column.isVersion ||\n                column.isCreateDate ||\n                entityValue === databaseValue)\n                return false;\n\n            // filter out \"relational columns\" only in the case if there is a relation object in entity\n            const relation = this.metadata.findRelationWithDbName(column.databaseName);\n            if (relation) {\n                const value = relation.getEntityValue(this.entity);\n                if (value !== null && value !== undefined)\n                    return false;\n            }\n\n            return true;\n        });\n    }\n\n    /**\n     * Difference columns of the owning one-to-one and many-to-one columns.\n     */\n    protected computeDiffRelationalColumns(/*todo: updatesByRelations: UpdateByRelationOperation[], */): void {\n        this.diffRelations = this.metadata.relations.filter(relation => {\n            if (!relation.isManyToOne && !(relation.isOneToOne && relation.isOwning))\n                return false;\n\n            // here we cover two scenarios:\n            // 1. related entity can be another entity which is natural way\n            // 2. related entity can be entity id which is hacked way of updating entity\n            // todo: what to do if there is a column with relationId? (cover this too?)\n            const entityValue = relation.getEntityValue(this.entity);\n            const updatedEntityRelationId: any = entityValue instanceof Object\n                    ? relation.inverseEntityMetadata.getEntityIdMixedMap(entityValue)\n                    : entityValue;\n\n            const dbEntityRelationId = relation.getEntityValue(this.databaseEntity);\n\n            // todo: try to find if there is update by relation operation - we dont need to generate update relation operation for this\n            // todo: if (updatesByRelations.find(operation => operation.targetEntity === this && operation.updatedRelation === relation))\n            // todo:     return false;\n\n            // we don't perform operation over undefined properties\n            if (updatedEntityRelationId === undefined)\n                return false;\n\n            // if both are empty totally no need to do anything\n            if ((updatedEntityRelationId === undefined || updatedEntityRelationId === null) &&\n                (dbEntityRelationId === undefined || dbEntityRelationId === null))\n                return false;\n\n            // if relation ids aren't equal then we need to update them\n            return updatedEntityRelationId !== dbEntityRelationId;\n        });\n    }\n\n}"],"sourceRoot":".."}