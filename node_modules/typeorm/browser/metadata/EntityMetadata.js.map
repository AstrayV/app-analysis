{"version":3,"sources":["../browser/src/metadata/EntityMetadata.ts"],"names":[],"mappings":"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","file":"EntityMetadata.js","sourcesContent":["import {ColumnMetadata} from \"./ColumnMetadata\";\nimport {RelationMetadata} from \"./RelationMetadata\";\nimport {IndexMetadata} from \"./IndexMetadata\";\nimport {ForeignKeyMetadata} from \"./ForeignKeyMetadata\";\nimport {EmbeddedMetadata} from \"./EmbeddedMetadata\";\nimport {ObjectLiteral} from \"../common/ObjectLiteral\";\nimport {LazyRelationsWrapper} from \"../lazy-loading/LazyRelationsWrapper\";\nimport {RelationIdMetadata} from \"./RelationIdMetadata\";\nimport {RelationCountMetadata} from \"./RelationCountMetadata\";\nimport {TableType} from \"./types/TableTypes\";\nimport {OrderByCondition} from \"../find-options/OrderByCondition\";\nimport {OrmUtils} from \"../util/OrmUtils\";\nimport {TableMetadataArgs} from \"../metadata-args/TableMetadataArgs\";\nimport {Connection} from \"../connection/Connection\";\nimport {EntityListenerMetadata} from \"./EntityListenerMetadata\";\nimport {PropertyTypeFactory} from \"./types/PropertyTypeInFunction\";\nimport {Driver} from \"../driver/Driver\";\nimport {PostgresDriver} from \"../driver/postgres/PostgresDriver\";\nimport {SqlServerDriver} from \"../driver/sqlserver/SqlServerDriver\";\nimport {PostgresConnectionOptions} from \"../driver/postgres/PostgresConnectionOptions\";\nimport {SqlServerConnectionOptions} from \"../driver/sqlserver/SqlServerConnectionOptions\";\n\n/**\n * Contains all entity metadata.\n */\nexport class EntityMetadata {\n\n    // -------------------------------------------------------------------------\n    // Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * Used to wrap lazy relations.\n     */\n    lazyRelationsWrapper: LazyRelationsWrapper;\n\n    /**\n     * If entity's table is a closure-typed table, then this entity will have a closure junction table metadata.\n     */\n    closureJunctionTable: EntityMetadata;\n\n    /**\n     * If this is entity metadata for a junction closure table then its owner closure table metadata will be set here.\n     */\n    parentClosureEntityMetadata: EntityMetadata;\n\n    /**\n     * Parent's entity metadata. Used in inheritance patterns.\n     */\n    parentEntityMetadata: EntityMetadata;\n\n    /**\n     * Children entity metadatas. Used in inheritance patterns.\n     */\n    childEntityMetadatas: EntityMetadata[] = [];\n\n    /**\n     * Table type. Tables can be abstract, closure, junction, embedded, etc.\n     */\n    tableType: TableType = \"regular\";\n\n    /**\n     * Target class to which this entity metadata is bind.\n     * Note, that when using table inheritance patterns target can be different rather then table's target.\n     * For virtual tables which lack of real entity (like junction tables) target is equal to their table name.\n     */\n    target: Function|string;\n\n    /**\n     * Indicates if this entity metadata of a junction table, or not.\n     * Junction table is a table created by many-to-many relationship.\n     *\n     * Its also possible to understand if entity is junction via tableType.\n     */\n    isJunction: boolean = false;\n\n    /**\n     * Entity's name.\n     * Equal to entity target class's name if target is set to table.\n     * If target class is not then then it equals to table name.\n     */\n    name: string;\n\n    /**\n     * Gets the name of the target.\n     */\n    targetName: string;\n\n    /**\n     * Original user-given table name (taken from schema or @Entity(tableName) decorator).\n     * If user haven't specified a table name this property will be undefined.\n     */\n    givenTableName?: string;\n\n    /**\n     * Entity table name in the database.\n     * This is final table name of the entity.\n     * This name already passed naming strategy, and generated based on\n     * multiple criteria, including user table name and global table prefix.\n     */\n    tableName: string;\n\n    /**\n     * Entity table path. Contains database name, schema name and table name.\n     * E.g. \"myDB\".\"mySchema\".\"myTable\"\n     */\n    tablePath: string;\n\n    /**\n     * Entity schema path. Contains database name and schema name.\n     * E.g. \"myDB\".\"mySchema\"\n     */\n    schemaPath?: string;\n\n    /**\n     * Gets the table name without global table prefix.\n     * When querying table you need a table name with prefix, but in some scenarios,\n     * for example when you want to name a junction table that contains names of two other tables,\n     * you may want a table name without prefix.\n     */\n    tableNameWithoutPrefix: string;\n\n    /**\n     * Indicates if schema sync is skipped for this entity.\n     */\n    skipSync: boolean;\n\n    /**\n     * Table's database engine type (like \"InnoDB\", \"MyISAM\", etc).\n     */\n    engine?: string;\n\n    /**\n     * Database name.\n     */\n    database?: string;\n\n    /**\n     * Schema name. Used in Postgres and Sql Server.\n     */\n    schema?: string;\n\n    /**\n     * Specifies a default order by used for queries from this table when no explicit order by is specified.\n     */\n    orderBy?: OrderByCondition;\n\n    /**\n     * Entity's column metadatas defined by user.\n     */\n    ownColumns: ColumnMetadata[] = [];\n\n    /**\n     * Entity's relation metadatas.\n     */\n    ownRelations: RelationMetadata[] = [];\n\n    /**\n     * Entity's own listener metadatas.\n     */\n    ownListeners: EntityListenerMetadata[] = [];\n\n    /**\n     * Entity's own indices.\n     */\n    ownIndices: IndexMetadata[] = [];\n\n    /**\n     * Relations of the entity, including relations that are coming from the embeddeds of this entity.\n     */\n    relations: RelationMetadata[] = [];\n\n    /**\n     * List of eager relations this metadata has.\n     */\n    eagerRelations: RelationMetadata[] = [];\n\n    /**\n     * List of eager relations this metadata has.\n     */\n    lazyRelations: RelationMetadata[] = [];\n\n    /**\n     * Columns of the entity, including columns that are coming from the embeddeds of this entity.\n     */\n    columns: ColumnMetadata[] = [];\n\n    /**\n     * In the case if this entity metadata is junction table's entity metadata,\n     * this will contain all referenced columns of owner entity.\n     */\n    ownerColumns: ColumnMetadata[] = [];\n\n    /**\n     * In the case if this entity metadata is junction table's entity metadata,\n     * this will contain all referenced columns of inverse entity.\n     */\n    inverseColumns: ColumnMetadata[] = [];\n\n    /**\n     * Entity's relation id metadatas.\n     */\n    relationIds: RelationIdMetadata[] = [];\n\n    /**\n     * Entity's relation id metadatas.\n     */\n    relationCounts: RelationCountMetadata[] = [];\n\n    /**\n     * Entity's index metadatas.\n     */\n    indices: IndexMetadata[] = [];\n\n    /**\n     * Entity's foreign key metadatas.\n     */\n    foreignKeys: ForeignKeyMetadata[] = [];\n\n    /**\n     * Entity's embedded metadatas.\n     */\n    embeddeds: EmbeddedMetadata[] = [];\n\n    /**\n     * Entity listener metadatas.\n     */\n    listeners: EntityListenerMetadata[] = [];\n\n    /**\n     * If this entity metadata's table using one of the inheritance patterns,\n     * then this will contain what pattern it uses.\n     */\n    inheritanceType?: \"single-table\"|\"class-table\";\n\n    /**\n     * If this entity metadata is a child table of some table, it should have a discriminator value.\n     * Used to store a value in a discriminator column.\n     */\n    discriminatorValue?: string;\n\n    /**\n     * Checks if entity's table has multiple primary columns.\n     */\n    hasMultiplePrimaryKeys: boolean;\n\n    /**\n     * Gets the column with generated flag.\n     */\n    generatedColumns: ColumnMetadata[] = [];\n\n    /**\n     * Gets the object id column used with mongodb database.\n     */\n    objectIdColumn?: ColumnMetadata;\n\n    /**\n     * Gets entity column which contains a create date value.\n     */\n    createDateColumn?: ColumnMetadata;\n\n    /**\n     * Gets entity column which contains an update date value.\n     */\n    updateDateColumn?: ColumnMetadata;\n\n    /**\n     * Gets entity column which contains an entity version.\n     */\n    versionColumn?: ColumnMetadata;\n\n    /**\n     * Gets the discriminator column used to store entity identificator in single-table inheritance tables.\n     */\n    discriminatorColumn?: ColumnMetadata;\n\n    /**\n     * Special column that stores tree level in tree entities.\n     */\n    treeLevelColumn?: ColumnMetadata;\n\n    /**\n     * Gets the primary columns.\n     */\n    primaryColumns: ColumnMetadata[] = [];\n\n    /**\n     * Id columns in the parent table (used in table inheritance).\n     */\n    parentIdColumns: ColumnMetadata[] = [];\n\n    /**\n     * Gets only one-to-one relations of the entity.\n     */\n    oneToOneRelations: RelationMetadata[] = [];\n\n    /**\n     * Gets only owner one-to-one relations of the entity.\n     */\n    ownerOneToOneRelations: RelationMetadata[] = [];\n\n    /**\n     * Gets only one-to-many relations of the entity.\n     */\n    oneToManyRelations: RelationMetadata[] = [];\n\n    /**\n     * Gets only many-to-one relations of the entity.\n     */\n    manyToOneRelations: RelationMetadata[] = [];\n\n    /**\n     * Gets only many-to-many relations of the entity.\n     */\n    manyToManyRelations: RelationMetadata[] = [];\n\n    /**\n     * Gets only owner many-to-many relations of the entity.\n     */\n    ownerManyToManyRelations: RelationMetadata[] = [];\n\n    /**\n     * Gets only owner one-to-one and many-to-one relations.\n     */\n    relationsWithJoinColumns: RelationMetadata[] = [];\n\n    /**\n     * Tree parent relation. Used only in tree-tables.\n     */\n    treeParentRelation?: RelationMetadata;\n\n    /**\n     * Tree children relation. Used only in tree-tables.\n     */\n    treeChildrenRelation?: RelationMetadata;\n\n    /**\n     * Checks if there any non-nullable column exist in this entity.\n     */\n    hasNonNullableRelations: boolean;\n\n    /**\n     * Checks if this table is regular.\n     * All non-specific tables are just regular tables. Its a default table type.\n     */\n    isRegular: boolean;\n\n    /**\n     * Checks if this table is abstract.\n     * This type is for the tables that does not exist in the database,\n     * but provide columns and relations for the tables of the child classes who inherit them.\n     */\n    isAbstract: boolean;\n\n    /**\n     * Checks if this table is a closure table.\n     * Closure table is one of the tree-specific tables that supports closure database pattern.\n     */\n    isClosure: boolean;\n\n    /**\n     * Checks if this table is a junction table of the closure table.\n     * This type is for tables that contain junction metadata of the closure tables.\n     */\n    isClosureJunction: boolean;\n\n    /**\n     * Checks if this table is an embeddable table.\n     * Embeddable tables are not stored in the database as separate tables.\n     * Instead their columns are embed into tables who owns them.\n     */\n    isEmbeddable: boolean;\n\n    /**\n     * Checks if this table is a single table child.\n     * Special table type for tables that are mapped into single table using Single Table Inheritance pattern.\n     */\n    isSingleTableChild: boolean;\n\n    /**\n     * Checks if this table is a class table child.\n     * Special table type for tables that are mapped into multiple tables using Class Table Inheritance pattern.\n     */\n    isClassTableChild: boolean;\n\n    /**\n     * Map of columns and relations of the entity.\n     *\n     * example: Post{ id: number, name: string, counterEmbed: { count: number }, category: Category }.\n     * This method will create following object:\n     * { id: \"id\", counterEmbed: { count: \"counterEmbed.count\" }, category: \"category\" }\n     */\n    propertiesMap: ObjectLiteral;\n\n    // ---------------------------------------------------------------------\n    // Constructor\n    // ---------------------------------------------------------------------\n\n    constructor(options: {\n        connection: Connection,\n        parentClosureEntityMetadata?: EntityMetadata,\n        args: TableMetadataArgs\n    }) {\n        const namingStrategy = options.connection.namingStrategy;\n        const entityPrefix = options.connection.options.entityPrefix;\n        this.lazyRelationsWrapper = new LazyRelationsWrapper(options.connection);\n        this.parentClosureEntityMetadata = options.parentClosureEntityMetadata!;\n        this.target = options.args.target;\n        this.tableType = options.args.type;\n        this.engine = options.args.engine;\n        this.database = options.args.database;\n        this.schema = options.args.schema || (options.connection.options as PostgresConnectionOptions|SqlServerConnectionOptions).schema;\n        this.givenTableName = options.args.name;\n        this.skipSync = options.args.skipSync || false;\n        this.targetName = options.args.target instanceof Function ? (options.args.target as any).name : options.args.target;\n        this.tableNameWithoutPrefix = this.tableType === \"closure-junction\" ? namingStrategy.closureJunctionTableName(this.givenTableName!) : namingStrategy.tableName(this.targetName, this.givenTableName);\n        this.tableName = entityPrefix ? namingStrategy.prefixTableName(entityPrefix, this.tableNameWithoutPrefix) : this.tableNameWithoutPrefix;\n        this.target = this.target ? this.target : this.tableName;\n        this.name = this.targetName ? this.targetName : this.tableName;\n        this.tablePath = this.buildTablePath(options.connection.driver);\n        this.schemaPath = this.buildSchemaPath(options.connection.driver);\n\n        this.isClassTableChild = this.tableType === \"class-table-child\";\n        this.isSingleTableChild = this.tableType === \"single-table-child\";\n        this.isEmbeddable = this.tableType === \"embeddable\";\n        this.isJunction = this.tableType === \"closure-junction\" || this.tableType === \"junction\";\n        this.isClosureJunction = this.tableType === \"closure-junction\";\n        this.isClosure = this.tableType === \"closure\";\n        this.isAbstract = this.tableType === \"abstract\";\n        this.isRegular = this.tableType === \"regular\";\n        this.orderBy = (options.args.orderBy instanceof Function) ? options.args.orderBy(this.propertiesMap) : options.args.orderBy;\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Creates a new entity.\n     */\n    create(): any {\n\n        // if target is set to a function (e.g. class) that can be created then create it\n        if (this.target instanceof Function)\n            return new (<any> this.target)();\n\n        // otherwise simply return a new empty object\n        const newObject = {};\n        this.relations\n            .filter(relation => relation.isLazy)\n            .forEach(relation => this.lazyRelationsWrapper.wrap(newObject, relation));\n\n        return newObject;\n    }\n\n    /**\n     * Checks if given entity has an id.\n     */\n    hasId(entity: ObjectLiteral): boolean {\n        if (!entity)\n            return false;\n\n        return this.primaryColumns.every(primaryColumn => { /// todo: this.metadata.parentEntityMetadata ?\n            const value = primaryColumn.getEntityValue(entity);\n            return value !== null && value !== undefined && value !== \"\";\n        });\n    }\n\n    /**\n     * Compares ids of the two entities.\n     * Returns true if they match, false otherwise.\n     */\n    compareIds(firstId: ObjectLiteral|undefined, secondId: ObjectLiteral|undefined): boolean {\n        if (firstId === undefined || firstId === null || secondId === undefined || secondId === null)\n            return false;\n\n        return OrmUtils.deepCompare(firstId, secondId);\n    }\n\n    /**\n     * Compares two different entity instances by their ids.\n     * Returns true if they match, false otherwise.\n     */\n    compareEntities(firstEntity: ObjectLiteral, secondEntity: ObjectLiteral): boolean {\n\n        // if any entity ids are empty then they aren't equal\n        const isFirstEntityEmpty = this.isEntityMapEmpty(firstEntity);\n        const isSecondEntityEmpty = this.isEntityMapEmpty(secondEntity);\n        if (isFirstEntityEmpty || isSecondEntityEmpty)\n            return false;\n\n        const firstEntityIds = this.getEntityIdMap(firstEntity);\n        const secondEntityIds = this.getEntityIdMap(secondEntity);\n        return this.compareIds(firstEntityIds, secondEntityIds);\n    }\n\n    /**\n     * Checks if there is an embedded with a given property path.\n     */\n    hasEmbeddedWithPropertyPath(propertyPath: string): boolean {\n        return !!this.findEmbeddedWithPropertyPath(propertyPath);\n    }\n\n    /**\n     * Finds embedded with a given property path.\n     */\n    findEmbeddedWithPropertyPath(propertyPath: string): EmbeddedMetadata|undefined {\n        return this.embeddeds.find(embedded => {\n            return embedded.propertyPath === propertyPath;\n        });\n    }\n\n    /**\n     * Finds column with a given property name.\n     */\n    findColumnWithPropertyName(propertyName: string): ColumnMetadata|undefined {\n        return this.columns.find(column => column.propertyName === propertyName);\n    }\n\n    /**\n     * Finds column with a given property path.\n     */\n    findColumnWithPropertyPath(propertyPath: string): ColumnMetadata|undefined {\n        const column = this.columns.find(column => column.propertyPath === propertyPath);\n        if (column)\n            return column;\n\n        // in the case if column with property path was not found, try to find a relation with such property path\n        // if we find relation and it has a single join column then its the column user was seeking\n        const relation = this.relations.find(relation => relation.propertyPath === propertyPath);\n        if (relation && relation.joinColumns.length === 1)\n            return relation.joinColumns[0];\n\n        return undefined;\n    }\n\n    /**\n     * Finds columns with a given property path.\n     * Property path can match a relation, and relations can contain multiple columns.\n     */\n    findColumnsWithPropertyPath(propertyPath: string): ColumnMetadata[] {\n        const column = this.columns.find(column => column.propertyPath === propertyPath);\n        if (column)\n            return [column];\n\n        // in the case if column with property path was not found, try to find a relation with such property path\n        // if we find relation and it has a single join column then its the column user was seeking\n        const relation = this.relations.find(relation => relation.propertyPath === propertyPath);\n        if (relation && relation.joinColumns)\n            return relation.joinColumns;\n\n        return [];\n    }\n\n    /**\n     * Finds column with a given database name.\n     */\n    findColumnWithDatabaseName(databaseName: string): ColumnMetadata|undefined {\n        return this.columns.find(column => column.databaseName === databaseName);\n    }\n\n    /**\n     * Finds relation with the given name.\n     */\n    findRelationWithDbName(dbName: string): RelationMetadata|undefined {\n        return this.relationsWithJoinColumns.find(relation => {\n            return !!relation.joinColumns.find(column => column.databaseName === dbName);\n        });\n    }\n\n    /**\n     * Finds relation with the given property path.\n     */\n    findRelationWithPropertyPath(propertyPath: string): RelationMetadata|undefined {\n        return this.relations.find(relation => relation.propertyPath === propertyPath);\n    }\n\n    /**\n     * Computes property name of the entity using given PropertyTypeInFunction.\n     */\n    computePropertyPath(nameOrFn: PropertyTypeFactory<any>) {\n        return typeof nameOrFn === \"string\" ? nameOrFn : nameOrFn(this.propertiesMap);\n    }\n\n    /**\n     * Creates entity id map from the given entity ids array.\n     */\n    createEntityIdMap(ids: any|any[]) {\n        if (!(ids instanceof Array))\n            ids = [ids];\n\n        return this.primaryColumns.reduce((map, column, index) => {\n            return OrmUtils.mergeDeep(map, column.createValueMap(ids[index]));\n        }, {} as ObjectLiteral);\n    }\n\n    /**\n     * Checks each id in the given entity id map if they all aren't empty.\n     * If they all aren't empty it returns true.\n     * If at least one id in the given map is empty it returns false.\n     */\n    isEntityMapEmpty(entity: ObjectLiteral): boolean {\n        return !this.primaryColumns.every(column => {\n            const value = column.getEntityValue(entity);\n            return value !== null && value !== undefined;\n        });\n    }\n\n    /**\n     * Gets primary keys of the entity and returns them in a literal object.\n     * For example, for Post{ id: 1, title: \"hello\" } where id is primary it will return { id: 1 }\n     * For multiple primary keys it returns multiple keys in object.\n     * For primary keys inside embeds it returns complex object literal with keys in them.\n     */\n    getEntityIdMap(entity: ObjectLiteral|undefined): ObjectLiteral|undefined {\n        if (!entity) // todo: shall it accept an empty entity? try to remove this\n            return undefined;\n\n        const map = this.primaryColumns.reduce((map, column) => {\n            if (column.isObjectId)\n                return Object.assign(map, column.getEntityValueMap(entity));\n\n            return OrmUtils.mergeDeep(map, column.getEntityValueMap(entity));\n        }, {});\n        return Object.keys(map).length > 0 ? map : undefined;\n    }\n\n    /**\n     * Same as getEntityIdMap, but instead of id column property names it returns database column names.\n     */\n    getDatabaseEntityIdMap(entity: ObjectLiteral): ObjectLiteral|undefined {\n        const map: ObjectLiteral = {};\n        this.primaryColumns.forEach(column => {\n            const entityValue = column.getEntityValue(entity);\n            if (entityValue === null || entityValue === undefined)\n                return;\n\n            map[column.databaseName] = entityValue;\n        });\n        const hasAllIds = Object.keys(map).every(key => {\n            return map[key] !== undefined && map[key] !== null;\n        });\n        return hasAllIds ? map : undefined;\n    }\n\n    /**\n     * Creates a \"mixed id map\".\n     * If entity has multiple primary keys (ids) then it will return just regular id map, like what getEntityIdMap returns.\n     * But if entity has a single primary key then it will return just value of the id column of the entity, just value.\n     * This is called mixed id map.\n     */\n    getEntityIdMixedMap(entity: ObjectLiteral|undefined): ObjectLiteral|undefined {\n        if (!entity) // todo: undefined entities should not go there??\n            return entity;\n\n        const idMap = this.getEntityIdMap(entity);\n        if (this.hasMultiplePrimaryKeys) {\n            return idMap;\n        } else if (idMap) {\n            return idMap[this.primaryColumns[0].propertyName]; // todo: what about parent primary column?\n        }\n\n        return idMap;\n    }\n\n    /**\n     * Checks if given object contains ALL primary keys entity must have.\n     * Returns true if it contains all of them, false if at least one of them is not defined.\n     */\n    checkIfObjectContainsAllPrimaryKeys(object: ObjectLiteral) {\n        return this.primaryColumns.every(primaryColumn => {\n            return object.hasOwnProperty(primaryColumn.propertyName);\n        });\n    }\n\n    /**\n     * Iterates throw entity and finds and extracts all values from relations in the entity.\n     * If relation value is an array its being flattened.\n     */\n    extractRelationValuesFromEntity(entity: ObjectLiteral, relations: RelationMetadata[]): [RelationMetadata, any, EntityMetadata][] {\n        const relationsAndValues: [RelationMetadata, any, EntityMetadata][] = [];\n        relations.forEach(relation => {\n            const value = relation.getEntityValue(entity);\n            if (value instanceof Array) {\n                value.forEach(subValue => relationsAndValues.push([relation, subValue, relation.inverseEntityMetadata]));\n            } else if (value) {\n                relationsAndValues.push([relation, value, relation.inverseEntityMetadata]);\n            }\n        });\n        return relationsAndValues;\n    }\n\n    // ---------------------------------------------------------------------\n    // Public Builder Methods\n    // ---------------------------------------------------------------------\n\n    /**\n     * Registers a new column in the entity and recomputes all depend properties.\n     */\n    registerColumn(column: ColumnMetadata) {\n        this.ownColumns.push(column);\n        this.columns = this.embeddeds.reduce((columns, embedded) => columns.concat(embedded.columnsFromTree), this.ownColumns);\n        this.parentIdColumns = this.columns.filter(column => column.isParentId);\n        this.primaryColumns = this.columns.filter(column => column.isPrimary);\n        this.hasMultiplePrimaryKeys = this.primaryColumns.length > 1;\n        this.propertiesMap = this.createPropertiesMap();\n    }\n\n    /**\n     * Creates a special object - all columns and relations of the object (plus columns and relations from embeds)\n     * in a special format - { propertyName: propertyName }.\n     *\n     * example: Post{ id: number, name: string, counterEmbed: { count: number }, category: Category }.\n     * This method will create following object:\n     * { id: \"id\", counterEmbed: { count: \"counterEmbed.count\" }, category: \"category\" }\n     */\n    createPropertiesMap(): { [name: string]: string|any } {\n        const map: { [name: string]: string|any } = {};\n        this.columns.forEach(column => OrmUtils.mergeDeep(map, column.createValueMap(column.propertyPath)));\n        this.relations.forEach(relation => OrmUtils.mergeDeep(map, relation.createValueMap(relation.propertyPath)));\n        return map;\n    }\n\n    // ---------------------------------------------------------------------\n    // Protected Methods\n    // ---------------------------------------------------------------------\n\n    /**\n     * Builds table path using database name and schema name and table name.\n     */\n    protected buildTablePath(driver: Driver): string {\n        let tablePath = this.tableName;\n        if (this.schema)\n            tablePath = this.schema + \".\" + tablePath;\n        if (this.database && !(driver instanceof PostgresDriver)) {\n            if (!this.schema && driver instanceof SqlServerDriver) {\n                tablePath = this.database + \"..\" + tablePath;\n            } else {\n                tablePath = this.database + \".\" + tablePath;\n            }\n        }\n\n        return tablePath;\n    }\n\n    /**\n     * Builds table path using schema name and database name.\n     */\n    protected buildSchemaPath(driver: Driver): string|undefined {\n        if (!this.schema)\n            return undefined;\n\n        return this.database && !(driver instanceof PostgresDriver) ? this.database + \".\" + this.schema : this.schema;\n    }\n\n}"],"sourceRoot":".."}