{"version":3,"sources":["../../src/persistence/SubjectBuilder.ts"],"names":[],"mappings":"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","file":"SubjectBuilder.js","sourcesContent":["import {EntityMetadata} from \"../metadata/EntityMetadata\";\nimport {ObjectLiteral} from \"../common/ObjectLiteral\";\nimport {Connection} from \"../connection/Connection\";\nimport {Subject} from \"./Subject\";\nimport {MongoDriver} from \"../driver/mongodb/MongoDriver\";\nimport {OrmUtils} from \"../util/OrmUtils\";\nimport {QueryRunner} from \"../query-runner/QueryRunner\";\n\n/**\n * To be able to execute persistence operations we need to load all entities from the database we need.\n * Loading should be efficient - we need to load entities in as few queries as possible + load as less data as we can.\n * This is how we determine which entities needs to be loaded from db:\n *\n * 1. example with cascade updates and inserts:\n *\n * [Y] - means \"yes, we load\"\n * [N] - means \"no, we don't load\"\n * in {} braces we specify what cascade options are set between relations\n *\n * if Post is new, author is not set in the post\n *\n * [Y] Post -> {all} // yes because of \"update\" and \"insert\" cascades, no because of \"remove\"\n *   [Y] Author -> {all} // no because author is not set\n *     [Y] Photo -> {all} // no because author and its photo are not set\n *       [Y] Tag -> {all} // no because author and its photo and its tag are not set\n *\n * if Post is new, author is new (or anything else is new)\n * if Post is updated\n * if Post and/or Author are updated\n *\n * [Y] Post -> {all} // yes because of \"update\" and \"insert\" cascades, no because of \"remove\"\n *   [Y] Author -> {all} // yes because of \"update\" and \"insert\" cascades, no because of \"remove\"\n *     [Y] Photo -> {all} // yes because of \"update\" and \"insert\" cascades, no because of \"remove\"\n *       [Y] Tag -> {all} // yes because of \"update\" and \"insert\" cascades, no because of \"remove\"\n *\n * Here we load post, author, photo, tag to check if they are new or not to persist insert or update operation.\n * We load post, author, photo, tag only if they exist in the relation.\n * From these examples we can see that we always load entity relations when it has \"update\" or \"insert\" cascades.\n *\n * 2. example with cascade removes\n *\n * if entity is new its remove operations by cascades should not be executed\n * if entity is updated then values that are null or missing in array (not undefined!, undefined means skip - don't do anything) are treated as removed\n * if entity is removed then all its downside relations which has cascade remove should be removed\n *\n * Once we find removed entity - we load it, and every downside entity which has \"remove\" cascade set.\n *\n * At the end we have all entities we need to operate with.\n * Next step is to store all loaded entities to manipulate them efficiently.\n *\n * Rules of updating by cascades.\n * Insert operation can lead to:\n *  - insert operations\n *  - update operations\n * Update operation can lead to:\n *  - insert operations\n *  - update operations\n *  - remove operations\n * Remove operation can lead to:\n *  - remove operation\n */\nexport class SubjectBuilder<Entity extends ObjectLiteral> {\n\n    // -------------------------------------------------------------------------\n    // Protected properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * If this gonna be reused then what to do with marked flags?\n     * One of solution can be clone this object and reset all marked states for this persistence.\n     * Or from reused just extract databaseEntities from their subjects? (looks better)\n     */\n    operateSubjects: Subject[] = [];\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(protected connection: Connection, protected queryRunner: QueryRunner) {\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Builds operations for entity that is being inserted/updated.\n     */\n    async persist(entity: Entity, metadata: EntityMetadata): Promise<void> {\n\n        // create subject for currently persisted entity and mark that it can be inserted and updated\n        const mainSubject = new Subject(metadata, entity);\n        mainSubject.canBeInserted = true;\n        mainSubject.canBeUpdated = true;\n        this.operateSubjects.push(mainSubject);\n\n        // next step we build list of subjects we will operate with\n        // these subjects are subjects that we need to insert or update alongside with main persisted entity\n        this.buildCascadeUpdateAndInsertOperateSubjects(mainSubject);\n\n        // next step is to load database entities of all operate subjects\n        await this.loadOperateSubjectsDatabaseEntities();\n\n        // next step - we filter subjects with database entities (only for non-new entities)\n        // and find operate subjects that needs to be removed\n        // here we also find operate subjects which relations should be updated\n        // these relations usually are \"update from inverse side\" operations\n        const operateSubjectsWithDatabaseEntities = this.operateSubjects.filter(subject => subject.hasDatabaseEntity);\n        await Promise.all(operateSubjectsWithDatabaseEntities.map(subject => {\n            return this.buildCascadeRemovedAndRelationUpdateOperateSubjects(subject);\n        }));\n\n        // finally find which operate subjects have insert and remove operations in their junction tables\n        await this.buildJunctionOperations({ insert: true, remove: true });\n    }\n\n    /**\n     * Builds only remove operations for entity that is being removed.\n     */\n    async remove(entity: Entity, metadata: EntityMetadata): Promise<void> {\n\n        // create subject for currently removed entity and mark that it must be removed\n        const mainSubject = new Subject(metadata, entity);\n        mainSubject.mustBeRemoved = true;\n        this.operateSubjects.push(mainSubject);\n\n        // next step we build list of subjects we will operate with\n        // these subjects are subjects that we need to remove alongside with main removed entity\n        this.buildCascadeRemoveOperateSubjects(mainSubject);\n\n        // next step is to load database entities for all operate subjects\n        await this.loadOperateSubjectsDatabaseEntities();\n\n        // next step - we filter subjects with database entities (only for non-new entities)\n        // and find operate subjects that needs to be removed\n        // todo(this should not be in remove?) // here we also find operate subjects which relations should be updated\n        // todo(this should not be in remove?) // these relations usually are \"update from inverse side\" operations\n        const operateSubjectsWithDatabaseEntities = this.operateSubjects.filter(subject => subject.hasDatabaseEntity);\n        await Promise.all(operateSubjectsWithDatabaseEntities.map(subject => {\n            return this.buildCascadeRemovedAndRelationUpdateOperateSubjects(subject);\n        }));\n\n        // finally find which operate subjects have remove operations in their junction tables\n        await this.buildJunctionOperations({ insert: false, remove: true });\n    }\n\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Builds and pushes to array of operate entities all entities that we will work with.\n     * These are only relational entities which has insert and update cascades.\n     * All such entities will be loaded from the database, because they can be inserted or updated.\n     * That's why we load them - to understand if they should be inserted or updated, or which columns we need to update.\n     * We can't add removed entities here, because to know which entity was removed we need first to\n     * load original entity (particularly its id) from the database.\n     * That's why we first need to load all changed entities, then extract ids of the removed entities from them,\n     * and only then load removed entities by extracted ids.\n     */\n    protected buildCascadeUpdateAndInsertOperateSubjects(subject: Subject): void {\n        subject.metadata\n            .extractRelationValuesFromEntity(subject.entity, subject.metadata.relations)\n            .filter(([relation, relationEntity, relationEntityMetadata]) => {\n\n                // we need only defined values and insert or update cascades of the relation should be set\n                return  relationEntity !== undefined &&\n                        relationEntity !== null &&\n                        (relation.isCascadeInsert || relation.isCascadeUpdate);\n            })\n            .forEach(([relation, relationEntity, relationEntityMetadata]) => {\n\n                // if we already has this entity in list of operated subjects then skip it to avoid recursion\n                const alreadyExistRelationEntitySubject = this.findByEntityLike(relationEntityMetadata.target, relationEntity);\n                if (alreadyExistRelationEntitySubject) {\n                    if (alreadyExistRelationEntitySubject.canBeInserted === false) // if its not marked for insertion yet\n                        alreadyExistRelationEntitySubject.canBeInserted = relation.isCascadeInsert === true;\n                    if (alreadyExistRelationEntitySubject.canBeUpdated === false) // if its not marked for update yet\n                        alreadyExistRelationEntitySubject.canBeUpdated = relation.isCascadeUpdate === true;\n                    return;\n                }\n\n                // mark subject with what we can do with it\n                // and add to the array of subjects to load only if there is no same entity there already\n                const relationEntitySubject = new Subject(relationEntityMetadata, relationEntity);\n                relationEntitySubject.canBeInserted = relation.isCascadeInsert === true;\n                relationEntitySubject.canBeUpdated = relation.isCascadeUpdate === true;\n                this.operateSubjects.push(relationEntitySubject);\n\n                // go recursively and find other entities we need to insert/update\n                this.buildCascadeUpdateAndInsertOperateSubjects(relationEntitySubject);\n            });\n    }\n\n    /**\n     * Builds and pushes to array of operate entities all entities that must be removed.\n     */\n    protected buildCascadeRemoveOperateSubjects(subject: Subject): void {\n        subject.metadata\n            .extractRelationValuesFromEntity(subject.entity, subject.metadata.relations)\n            .filter(([relation, relationEntity, relationEntityMetadata]) => {\n\n                // we need only defined values and insert cascades of the relation should be set\n                return relationEntity !== undefined && relationEntity !== null && relation.isCascadeRemove;\n            })\n            .forEach(([relation, relationEntity, relationEntityMetadata]) => {\n\n                // if we already has this entity in list of operated subjects then skip it to avoid recursion\n                const alreadyExistValueSubject = this.findByEntityLike(relationEntityMetadata.target, relationEntity);\n                if (alreadyExistValueSubject) {\n                    alreadyExistValueSubject.mustBeRemoved = true;\n                    return;\n                }\n\n                // add to the array of subjects to load only if there is no same entity there already\n                const valueSubject = new Subject(relationEntityMetadata, relationEntity);\n                valueSubject.mustBeRemoved = true;\n                this.operateSubjects.push(valueSubject);\n\n                // go recursively and find other entities we need to remove\n                this.buildCascadeRemoveOperateSubjects(valueSubject);\n            });\n    }\n\n    /**\n     * Loads database entities for all operate subjects which do not have database entity set.\n     * All entities that we load database entities for are marked as updated or inserted.\n     * To understand which of them really needs to be inserted or updated we need to load\n     * their original representations from the database.\n     */\n    protected async loadOperateSubjectsDatabaseEntities(): Promise<void> {\n\n        // we are grouping subjects by target to perform more optimized queries using WHERE IN operator\n        // go throw the groups and perform loading of database entities of each subject in the group\n        const promises = this.groupByEntityTargets().map(async subjectGroup => {\n\n            // prepare entity ids of the subjects we need to load\n            const allIds = subjectGroup.subjects\n                .filter(subject => !subject.hasDatabaseEntity) // we don't load if subject already has a database entity loaded\n                .filter(subject => {\n                    return !subject.metadata.isEntityMapEmpty(subject.entity);\n                }) // we only need entity id\n                .map(subject => { // we don't need empty ids\n                    // console.log(subject.entity);\n                    return subject.metadata.getEntityIdMap(subject.entity);\n                    // if (mixedId instanceof Object)\n                    //     return Object.keys(mixedId).every(key => mixedId[key] !== undefined && mixedId[key] !== null && mixedId[key] !== \"\");\n                    //\n                    // return mixedId !== undefined && mixedId !== null && mixedId !== \"\";\n                });\n\n            // if there no ids found (which means all entities are new and have generated ids) - then nothing to load there\n            // console.log(\"allIds: \", allIds);\n            // console.log(\"subject.entity: \", subjectGroup.subjects);\n            // console.log(\"allIds: \", allIds);\n            if (!allIds.length)\n                return;\n            // console.log(\"Y\");\n\n            // load database entities for all given ids\n            // todo: such implementation is temporary, need to create a good abstraction there\n            // todo: its already possible to do that with repository.findByIds method however setting \"RELATION_ID_VALUES\" option is an issue\n            // todo: also custom queryRunnerProvider is an issue\n            let entities: any[];\n            if (this.connection.driver instanceof MongoDriver) {\n\n                entities = await this.connection\n                    .getMongoRepository<ObjectLiteral>(subjectGroup.target)\n                    .findByIds(allIds);\n\n            } else {\n                entities = await this.connection\n                    .getRepository<ObjectLiteral>(subjectGroup.target)\n                    .createQueryBuilder(\"subject\", this.queryRunner)\n                    .whereInIds(allIds)\n                    .loadAllRelationIds()\n                    .getMany();\n            }\n\n            // now when we have entities we need to find subject of each entity\n            // and insert that entity into database entity of the found subject\n            entities.forEach(entity => {\n                // console.log(1);\n                const subject = this.findByEntityLike(subjectGroup.target, entity);\n                if (subject)\n                    subject.databaseEntity = entity;\n            });\n\n        });\n\n        await Promise.all(promises);\n    }\n\n    /**\n     * We need to load removed entity when:\n     *  - entity with relations is not new (this can be determined only after entity is loaded from db)\n     *      (note: simple \"id\" check will not work because id can be not generated)\n     *  - entity missing relation. When relation is simple\n     *      - in the case of one-to-one owner (with join column) relation we need to load owner entity\n     *      - in the case of one-to-one (without join column) relation we need to load inverse side entity\n     *      - in the case of many-to-one relations we need to load entity itself\n     *      - in the case of one-to-many relations we need to load entities by relation from inverse side\n     *\n     *  Before loading each entity we need to check in the loaded subjects - maybe it was already loaded.\n     *\n     *  BIG NOTE: objects are being removed by cascades not only when relation is removed, but also when\n     *  relation is replaced (e.g. changed with different object).\n     */\n    protected async buildCascadeRemovedAndRelationUpdateOperateSubjects(subject: Subject): Promise<void> {\n\n        // note: we can't use extractRelationValuesFromEntity here because it does not handle empty arrays\n        const promises = subject.metadata.relations.map(async relation => {\n            const valueMetadata = relation.inverseEntityMetadata;\n            const qbAlias = valueMetadata.tableName;\n\n            // added for type-safety, but subject without databaseEntity cant come here anyway because of checks on upper levels\n            if (!subject.hasDatabaseEntity) return;\n\n            // for one-to-one owner and many-to-one relations no need to load entity to check if something removed\n            // because join column is in this side of relation and we have a database entity with which we can compare\n            // and understand if relation was removed or not\n            if (relation.isOneToOneOwner || relation.isManyToOne) {\n\n                // we only work with cascade removes here\n                if (!relation.isCascadeRemove) return;\n\n                /**\n                 * By example (one-to-one owner). Let's say we have a one-to-one relation between Post and Details.\n                 * Post contains detailsId. It means he owns relation. Post has cascade remove with details.\n                 * Now here we have a post object with removed details.\n                 * We need to remove Details if post.details = null\n                 * or if post.details != databasePost.details\n                 */\n\n                /**\n                 * By example (many-to-one). Let's say we have a many-to-one relation between Post and Details.\n                 * Post contains detailsId. It means he owns relation.\n                 * It also means that post can have only one details, and details can have multiple posts.\n                 * Post has cascade remove with details.\n                 * Now here we have a post object with removed details.\n                 * We need to remove Details (one) if post.details = null\n                 * or if post.details != databasePost.details\n                 */\n\n                // (example) \"relation\" - is a relation in post with details.\n                // (example) \"valueMetadata\" - is an entity metadata of the Details object.\n                // (example) \"persistValue\" - is a detailsId from the persisted entity\n\n                // note that if databaseEntity has relation, it can only be a relation id,\n                // because of query builder option \"RELATION_ID_VALUES\" we used\n                const relationIdInDatabaseEntity = relation.getEntityValue(subject.databaseEntity); // (example) returns post.detailsId\n\n                // if database relation id does not exist in the database object then nothing to remove\n                if (relationIdInDatabaseEntity === null || relationIdInDatabaseEntity === undefined)\n                    return;\n\n                // if this subject is persisted subject then we get its value to check if its not empty or its values changed\n                let persistValueRelationId: any = undefined, persistValue: any = undefined;\n                if (subject.hasEntity) {\n                    persistValue = relation.getEntityValue(subject.entity);\n                    if (persistValue === null) persistValueRelationId = null;\n                    if (persistValue) persistValueRelationId = relation.joinColumns.reduce((map, column) => column.referencedColumn!.getEntityValueMap(persistValue), {} as ObjectLiteral);\n                    if (persistValueRelationId === undefined) return; // skip undefined properties\n                }\n\n                // object is removed only if relation id in the persisted entity is empty or is changed\n                // if (persistValueRelationId !== null && persistValueRelationId === relationIdInDatabaseEntity)\n                //     return;\n                // console.log(\"relationIdInDatabaseEntity:\", relationIdInDatabaseEntity);\n                // console.log(\"persistValue:\", persistValue);\n                // console.log(\"compareEntities:\", relation.entityMetadata.compareEntities(relationIdInDatabaseEntity, persistValue));\n                // console.log(\"compareIds:\", relation.entityMetadata.compareIds(relationIdInDatabaseEntity, persistValue));\n                if (persistValueRelationId !== null && relation.entityMetadata.compareIds(relationIdInDatabaseEntity, persistValue))\n                    return;\n\n                // first check if we already loaded this object before load from the database\n                let alreadyLoadedRelatedDatabaseSubject = this.operateSubjects.find(relatedSubject => {\n\n                    // (example) filter only subject that has database entity loaded and its target is Details\n                    if (!relatedSubject.hasDatabaseEntity || relatedSubject.entityTarget !== valueMetadata.target)\n                        return false;\n\n                    // (example) here we seek a Details loaded from the database in the subjects\n                    // (example) here relatedSubject.databaseEntity is a Details\n                    // (example) and we need to compare details.id === post.detailsId\n                    return relation.entityMetadata.compareIds(relationIdInDatabaseEntity, relation.getEntityValue(relatedSubject.databaseEntity));\n                });\n\n                // if not loaded yet then load it from the database\n                if (!alreadyLoadedRelatedDatabaseSubject) {\n\n                    // (example) we need to load a details where details.id = post.details\n                    const qb = this.connection\n                        .getRepository<ObjectLiteral>(valueMetadata.target)\n                        .createQueryBuilder(qbAlias, this.queryRunner) // todo: this wont work for mongodb. implement this in some method and call it here instead?\n                        .loadAllRelationIds();\n\n                    const condition = relation.joinColumns.map(joinColumn => {\n                        return `${qbAlias}.${joinColumn.referencedColumn!.propertyPath} = :${joinColumn.databaseName}`;\n                    }).join(\" AND \");\n\n                    const parameters = relation.joinColumns.reduce((parameters, joinColumn) => {\n                        parameters[joinColumn.databaseName] = joinColumn.referencedColumn!.getEntityValue(relationIdInDatabaseEntity);\n                        return parameters;\n                    }, {} as ObjectLiteral);\n\n                    qb.where(condition)\n                        .setParameters(parameters);\n\n                    const databaseEntity = await qb.getOne();\n\n                    if (databaseEntity) {\n                        alreadyLoadedRelatedDatabaseSubject = new Subject(valueMetadata, undefined, databaseEntity);\n                        this.operateSubjects.push(alreadyLoadedRelatedDatabaseSubject);\n                    }\n                }\n\n                if (alreadyLoadedRelatedDatabaseSubject) {\n\n                    // if object is already marked as removed then no need to proceed because it already was proceed\n                    // if we remove this it will cause a recursion\n                    if (alreadyLoadedRelatedDatabaseSubject.mustBeRemoved)\n                        return;\n\n                    alreadyLoadedRelatedDatabaseSubject.mustBeRemoved = true;\n                    await this.buildCascadeRemovedAndRelationUpdateOperateSubjects(alreadyLoadedRelatedDatabaseSubject);\n                }\n            }\n\n            // for one-to-one not owner we need to load entity to understand that it was really removed or not,\n            // since column value that indicates relation is stored on inverse side\n            if (relation.isOneToOneNotOwner) {\n\n                // we only work with cascade removes here\n                if (!relation.isCascadeRemove) return; // todo: no\n\n                /**\n                 * By example. Let's say we have a one-to-one relation between Post and Details.\n                 * Post contains detailsId. It means he owns relation. Details has cascade remove with post.\n                 * Now here we have a details object with removed post.\n                 * We need to remove Post if details.post = null and databasePost.detailsId = details.id exist in the db,\n                 * or if databasePost.id === details.post.id (we need to load it) and databasePost.detailsId != details.id\n                 */\n\n                // (example) \"relation\" - is a relation in details with post.\n                // (example) \"valueMetadata\" - is an entity metadata of the Post object.\n                // (example) \"subject.databaseEntity\" - is a details object\n\n                // if this subject is persisted subject then we get its value to check if its not empty or its values changed\n                let persistValueRelationId: any = undefined;\n                if (subject.hasEntity && !subject.mustBeRemoved) {\n                    const persistValue = relation.getEntityValue(subject.entity);\n                    if (persistValue) persistValueRelationId = relation.inverseRelation!.getEntityValue(persistValue);\n                    if (persistValueRelationId === undefined) return; // skip undefined properties\n                }\n\n                // (example) returns us referenced column (detail's id)\n                const relationIdInDatabaseEntity = relation.inverseRelation!.joinColumns[0].referencedColumn!.getEntityValue(subject.databaseEntity);\n\n                // if database relation id does not exist then nothing to remove (but can this be possible?)\n                if (relationIdInDatabaseEntity === null || relationIdInDatabaseEntity === undefined)\n                    return;\n\n                // first check if we already have this object loaded before load from the database\n                let alreadyLoadedRelatedDatabaseSubject = this.operateSubjects.find(relatedSubject => {\n\n                    // (example) filter only subject that has database entity loaded and its target is Post\n                    if (!relatedSubject.hasDatabaseEntity || relatedSubject.entityTarget !== valueMetadata.target)\n                        return false;\n\n                    // (example) here we seek a Post loaded from the database in the subjects\n                    // (example) here relatedSubject.databaseEntity is a Post\n                    // (example) and we need to compare post.detailsId === details.id\n                    return relation.inverseRelation!.getEntityValue(relatedSubject.databaseEntity) === relationIdInDatabaseEntity;\n                });\n\n                // if not loaded yet then load it from the database\n                if (!alreadyLoadedRelatedDatabaseSubject) {\n\n                    // (example) we need to load a post where post.detailsId = details.id\n                    const databaseEntity = await this.connection\n                        .getRepository<ObjectLiteral>(valueMetadata.target)\n                        .createQueryBuilder(qbAlias, this.queryRunner) // todo: this wont work for mongodb. implement this in some method and call it here instead?\n                        .where(qbAlias + \".\" + relation.inverseSidePropertyPath + \"=:id\") // TODO relation.inverseRelation.joinColumns\n                        .setParameter(\"id\", relationIdInDatabaseEntity) // (example) subject.entity is a details here, and the value is details.id\n                        .loadAllRelationIds()\n                        .getOne();\n\n                    // add only if database entity exist - because in the case of inverse side of the one-to-one relation\n                    // we cannot check if it was removed or not until we query the database\n                    // and it can be a situation that relation wasn't exist at all. This is particular that case\n                    alreadyLoadedRelatedDatabaseSubject = new Subject(valueMetadata, undefined, databaseEntity);\n                    this.operateSubjects.push(alreadyLoadedRelatedDatabaseSubject);\n                }\n\n                // check if we really has a relation between entities. If relation not found then alreadyLoadedRelatedDatabaseSubject will be empty\n                if (alreadyLoadedRelatedDatabaseSubject && alreadyLoadedRelatedDatabaseSubject.hasDatabaseEntity) {\n\n                    // also check if relation value exist then then make sure its changed\n                    // (example) persistValue is a postFromPersistedDetails here\n                    // (example) alreadyLoadedRelatedDatabaseSubject.databaseEntity is a postFromDatabaseDetails here\n                    // (example) postFromPersistedDetails.id === postFromDatabaseDetails - means nothing changed\n                    const inverseEntityRelationId = relation.inverseRelation!.getEntityValue(alreadyLoadedRelatedDatabaseSubject.databaseEntity);\n                    if (persistValueRelationId && persistValueRelationId === inverseEntityRelationId)\n                        return;\n\n                    // if object is already marked as removed then no need to proceed because it already was proceed\n                    // if we remove this it will cause a recursion\n                    if (alreadyLoadedRelatedDatabaseSubject.mustBeRemoved)\n                        return;\n\n                    alreadyLoadedRelatedDatabaseSubject.mustBeRemoved = true;\n                    await this.buildCascadeRemovedAndRelationUpdateOperateSubjects(alreadyLoadedRelatedDatabaseSubject);\n                }\n            }\n\n            // for one-to-many we need to load entities to understand which was really removed\n            // since column value that indicates relation is stored on inverse side\n            if (relation.isOneToMany || relation.isManyToMany) {\n\n                // we only work with cascade removes here\n                // if (!relation.isCascadeRemove && !relation.isCascadeUpdate) return;\n\n                /**\n                 * By example. Let's say we have a one-to-many relation between Post and Details.\n                 * Post contains detailsId. It means he owns relation.\n                 * It also means that one details contains multiple post, and one post contain only one details.\n                 * Details has cascade remove with post.\n                 * Now here we have a details object with removed post.\n                 * There can be one or multiple removed posts, because posts is an array in details.\n                 * If details.posts is undefined then we skip it as we do with any persisted undefined property.\n                 * If details.posts is an empty array it means all its items should be removed.\n                 * If details.posts is a null it means same - all its items has been removed.\n                 * We need to remove each Post in the databaseDetails where post is missing in details.posts\n                 * but databasePost.detailsId = details.id exist in the db.\n                 */\n\n                // (example) \"relation\" - is a relation in details with post.\n                // (example) \"valueMetadata\" - is an entity metadata of the Post object.\n                // (example) \"subject.databaseEntity\" - is a details object\n\n                // if this subject is persisted subject then we get its value to check if its not empty or its values changed\n                let persistValue: any = undefined;\n                if (subject.hasEntity) {\n                    persistValue = relation.getEntityValue(subject.entity);\n                    if (persistValue === undefined) return; // skip undefined properties\n                }\n\n                // we can't get already loaded objects from loadMap because we don't know exactly how\n                // many objects are in database entity, and entities from loadMap may return us not all of them\n                // that's why we are forced to load all its entities from the database even if loaded some of them before\n                // (example) we need to load a posts where post.detailsId = details.id\n                let databaseEntities: ObjectLiteral[] = [];\n\n                // create shortcuts for better readability\n                const escape = (name: string) => this.connection.driver.escape(name);\n\n                if (relation.isManyToManyOwner) {\n\n                    // we only need to load inverse entities if cascade removes are set\n                    // because remove by cascades is the only reason we need relational entities here\n                    if (!relation.isCascadeRemove) return;\n\n                    const joinAlias = escape(\"persistenceJoinedRelation\");\n\n                    const joinColumnConditions = relation.joinColumns.map(joinColumn => {\n                        return `${joinAlias}.${joinColumn.propertyName} = :${joinColumn.propertyName}`;\n                    });\n                    const inverseJoinColumnConditions = relation.inverseJoinColumns.map(inverseJoinColumn => {\n                        return `${joinAlias}.${inverseJoinColumn.propertyName} = ${escape(qbAlias)}.${escape(inverseJoinColumn.referencedColumn!.propertyName)}`;\n                    });\n\n                    const conditions = joinColumnConditions.concat(inverseJoinColumnConditions).join(\" AND \");\n\n                    // (example) returns us referenced column (detail's id)\n                    const parameters = relation.joinColumns.reduce((parameters, joinColumn) => {\n                        parameters[joinColumn.propertyName] = joinColumn.referencedColumn!.getEntityValue(subject.databaseEntity);\n                        return parameters;\n                    }, {} as ObjectLiteral);\n\n                    databaseEntities = await this.connection\n                        .getRepository<ObjectLiteral>(valueMetadata.target)\n                        .createQueryBuilder(qbAlias, this.queryRunner) // todo: this wont work for mongodb. implement this in some method and call it here instead?\n                        .innerJoin(relation.junctionEntityMetadata!.tableName, joinAlias, conditions)\n                        .setParameters(parameters)\n                        .loadAllRelationIds()\n                        .getMany();\n\n                } else if (relation.isManyToManyNotOwner) {\n\n                    // we only need to load inverse entities if cascade removes are set\n                    // because remove by cascades is the only reason we need relational entities here\n                    if (!relation.isCascadeRemove) return;\n\n                    const joinAlias = escape(\"persistenceJoinedRelation\");\n\n                    const joinColumnConditions = relation.joinColumns.map(joinColumn => {\n                        return `${joinAlias}.${joinColumn.propertyName} = ${escape(qbAlias)}.${escape(joinColumn.referencedColumn!.propertyName)}`;\n                    });\n                    const inverseJoinColumnConditions = relation.inverseJoinColumns.map(inverseJoinColumn => {\n                        return `${joinAlias}.${inverseJoinColumn.propertyName} = :${inverseJoinColumn.propertyName}`;\n                    });\n\n                    const conditions = joinColumnConditions.concat(inverseJoinColumnConditions).join(\" AND \");\n\n                    // (example) returns us referenced column (detail's id)\n                    const parameters = relation.inverseRelation!.inverseJoinColumns.reduce((parameters, joinColumn) => {\n                        parameters[joinColumn.propertyName] = joinColumn.referencedColumn!.getEntityValue(subject.databaseEntity);\n                        return parameters;\n                    }, {} as ObjectLiteral);\n\n                    databaseEntities = await this.connection\n                        .getRepository<ObjectLiteral>(valueMetadata.target)\n                        .createQueryBuilder(qbAlias, this.queryRunner) // todo: this wont work for mongodb. implement this in some method and call it here instead?\n                        .innerJoin(relation.junctionEntityMetadata!.tableName, joinAlias, conditions)\n                        .setParameters(parameters)\n                        .loadAllRelationIds()\n                        .getMany();\n\n                } else { // this case can only be a oneToMany relation\n                    // todo: fix issues with joinColumn[0]\n                    // (example) returns us referenced column (detail's id)\n                    const relationIdInDatabaseEntity = relation.inverseRelation!.joinColumns[0].referencedColumn!.getEntityValue(subject.databaseEntity);\n\n                    // in this case we need inverse entities not only because of cascade removes\n                    // because we also need inverse entities to be able to perform update of entities\n                    // in the inverse side when entities is detached from one-to-many relation\n\n                    databaseEntities = await this.connection\n                        .getRepository<ObjectLiteral>(valueMetadata.target)\n                        .createQueryBuilder(qbAlias, this.queryRunner) // todo: this wont work for mongodb. implement this in some method and call it here instead?\n                        .where(qbAlias + \".\" + relation.inverseSidePropertyPath + \"=:id\")\n                        .setParameter(\"id\", relationIdInDatabaseEntity)\n                        .loadAllRelationIds()\n                        .getMany();\n                }\n\n                // add to loadMap loaded entities if some of them are missing\n                databaseEntities.forEach(databaseEntity => {\n                    const subjectInLoadMap = this.findByEntityLike(valueMetadata.target, databaseEntity);\n                    if (subjectInLoadMap && !subjectInLoadMap.hasDatabaseEntity) {\n                        subjectInLoadMap.databaseEntity = databaseEntity;\n\n                    } else if (!subjectInLoadMap) {\n                        const subject = new Subject(valueMetadata, undefined, databaseEntity);\n                        this.operateSubjects.push(subject);\n                    }\n                });\n\n\n                // add new relations for newly bind entities from the one-to-many relations\n                if (relation.isOneToMany && persistValue) { // todo: implement same for one-to-one\n                    const promises = (persistValue as ObjectLiteral[]).map(async persistValue => {\n\n                        // try to find in the database entities persistedValue (entity bind to this relation)\n                        const persistedValueInDatabaseEntity = databaseEntities.find(databaseEntity => {\n                            return valueMetadata.compareEntities(persistValue, databaseEntity);\n                        });\n\n                        // if it does not exist in the database entity - it means we need to bind it\n                        // to bind it we need to update related entity itself\n                        // this operation is performed only in one-to-many relations\n                        if (!persistedValueInDatabaseEntity) {\n\n                            // now find subject with\n                            let loadedSubject = this.findByDatabaseEntityLike(valueMetadata.target, persistValue);\n                            if (!loadedSubject) {\n                                const id = valueMetadata.getEntityIdMap(persistValue);\n                                if (id) { // if there is no id (for newly inserted) then we cant load\n                                    const databaseEntity = await this.connection\n                                        .getRepository<ObjectLiteral>(valueMetadata.target)\n                                        .createQueryBuilder(qbAlias, this.queryRunner) // todo: this wont work for mongodb. implement this in some method and call it here instead?\n                                        .whereInIds([id])\n                                        .loadAllRelationIds()\n                                        .getOne();\n\n                                    if (databaseEntity) {\n                                        loadedSubject = new Subject(valueMetadata, undefined, databaseEntity); // todo: what if entity like object exist in the loaded subjects but without databaseEntity?\n                                        this.operateSubjects.push(loadedSubject);\n                                    }\n                                }\n                            }\n\n                            if (loadedSubject) {\n                                loadedSubject.relationUpdates.push({\n                                    relation: relation.inverseRelation!,\n                                    value: subject.entity\n                                });\n                            }\n                        }\n                    });\n\n                    await Promise.all(promises);\n                }\n\n                // iterate throw loaded inverse entities to find out removed entities and inverse updated entities (only for one-to-many relation)\n                const promises = databaseEntities.map(async databaseEntity => {\n\n                    // find a subject object of the related database entity\n                    let relatedEntitySubject = this.findByDatabaseEntityLike(valueMetadata.target, databaseEntity);\n                    if (!relatedEntitySubject) return; // should not be possible, anyway add it for type-safety\n\n                    // if object is already marked as removed then no need to proceed because it already was proceed\n                    // if we remove this check it will cause a recursion\n                    if (relatedEntitySubject.mustBeRemoved) return;  // todo: add another check for entity in unsetRelations?\n\n                    // check if in persisted value there is a database value to understand if it was removed or not\n                    let relatedValue = ((persistValue || []) as ObjectLiteral[]).find(persistValueItem => {\n                        return valueMetadata.compareEntities(relatedEntitySubject!.databaseEntity, persistValueItem);\n                    });\n\n                    // if relation value is set to undefined then we don't do anything - simply skip any check and remove\n                    // but if relation value is set to null then it means user wants to remove each entity in this relation\n                    // OR\n                    // value was removed from persisted value - means we need to mark it as removed\n                    // and check if mark as removed all underlying entities that has cascade remove\n                    if (persistValue === null || !relatedValue) {\n\n                        // if cascade remove option is set then need to remove related entity\n                        if (relation.isCascadeRemove) {\n                            relatedEntitySubject.mustBeRemoved = true;\n\n                            // mark as removed all underlying entities that has cascade remove\n                            await this.buildCascadeRemovedAndRelationUpdateOperateSubjects(relatedEntitySubject);\n\n                        // if cascade remove option is not set then it means we simply need to remove\n                        // reference to this entity from inverse side (from loaded database entity)\n                        // this applies only on one-to-many relationship\n                        } else if (relation.isOneToMany && relation.inverseRelation) {\n                            relatedEntitySubject.relationUpdates.push({\n                                relation: relation.inverseRelation,\n                                value: null\n                            }); // todo: implement same for one-to-one\n                        }\n\n                    }\n\n                });\n\n                await Promise.all(promises);\n            }\n        });\n\n        await Promise.all(promises);\n    }\n\n    /**\n     * Builds all junction insert and remove operations used to insert new bind data into junction tables,\n     * or remove old junction records.\n     * Options specifies which junction operations should be built - insert, remove or both.\n     */\n    private async buildJunctionOperations(options: { insert: boolean, remove: boolean }): Promise<void> {\n        const promises = this.operateSubjects.filter(subject => subject.hasEntity).map(subject => {\n            const metadata = subject.metadata.parentEntityMetadata ? subject.metadata.parentEntityMetadata : subject.metadata;\n            const promises = metadata.manyToManyRelations.map(async relation => {\n                // if subject marked to be removed then all its junctions must be removed\n                if (subject.mustBeRemoved && options.remove) {\n                    // load from db all relation ids of inverse entities that are \"bind\" to the currently persisted entity\n                    // this way we gonna check which relation ids are missing and which are new (e.g. inserted or removed)\n                    const existInverseEntityRelationIds = relation.getEntityValue(subject.databaseEntity);\n\n                    // finally create a new junction remove operation and push it to the array of such operations\n                    if (existInverseEntityRelationIds.length > 0) {\n                        subject.junctionRemoves.push({\n                            relation: relation,\n                            junctionRelationIds: existInverseEntityRelationIds\n                        });\n                    }\n\n                    return;\n                }\n\n                // if entity don't have entity then no need to find something that should be inserted or removed\n                if (!subject.hasEntity)\n                    return;\n\n                // else check changed junctions in the persisted entity\n                // extract entity value - we only need to proceed if value is defined and its an array\n                const relatedValue = relation.getEntityValue(subject.entity);\n                if (!(relatedValue instanceof Array))\n                    return;\n\n                // load from db all relation ids of inverse entities that are \"bind\" to the currently persisted entity\n                // this way we gonna check which relation ids are missing and which are new (e.g. inserted or removed)\n                // we could load this relation ids with entity using however this way it may be more efficient, because\n                // this way we load only relations that come, e.g. we don't load data for empty relations set with object.\n                // this is also useful when object is being saved partial.\n                let existInverseEntityRelationIds: any[] = [];\n\n                // if subject don't have database entity it means its new and we don't need to remove something that is not exist\n                if (subject.hasDatabaseEntity) {\n                    existInverseEntityRelationIds = relation.getEntityValue(subject.databaseEntity);\n                    // console.log(\"existInverseEntityRelationIds:\", existInverseEntityRelationIds[0]);\n                }\n\n                // get all inverse entities relation ids that are \"bind\" to the currently persisted entity\n                const changedInverseEntityRelationIds = relatedValue\n                    .map(subRelationValue => {\n                        const joinColumns = relation.isOwning ? relation.inverseJoinColumns : relation.inverseRelation!.joinColumns;\n                        return joinColumns.reduce((ids, joinColumn) => {\n                            return OrmUtils.mergeDeep(ids, joinColumn.referencedColumn!.createValueMap(joinColumn.referencedColumn!.getEntityValue(subRelationValue))); // todo: duplicate. relation.createJoinColumnsIdMap(entity) ?\n                        }, {} as ObjectLiteral);\n                    })\n                    .filter(subRelationValue => subRelationValue !== undefined && subRelationValue !== null);\n                // console.log(\"changedInverseEntityRelationIds:\", changedInverseEntityRelationIds);\n\n                // now from all entities in the persisted entity find only those which aren't found in the db\n                const removedJunctionEntityIds = existInverseEntityRelationIds.filter(existRelationId => {\n                    return !changedInverseEntityRelationIds.find(changedRelationId => {\n                        return relation.inverseEntityMetadata.compareIds(changedRelationId, existRelationId);\n                    });\n                });\n                // console.log(\"removedJunctionEntityIds:\", removedJunctionEntityIds);\n\n                // now from all entities in the persisted entity find only those which aren't found in the db\n                const newJunctionEntities = relatedValue.filter(subRelatedValue => {\n                    // console.log(subRelatedValue);\n\n                    const joinColumns = relation.isOwning ? relation.inverseJoinColumns : relation.inverseRelation!.joinColumns;\n                    const ids = joinColumns.reduce((ids, joinColumn) => {\n                        return OrmUtils.mergeDeep(ids, joinColumn.referencedColumn!.createValueMap(joinColumn.referencedColumn!.getEntityValue(subRelatedValue))); // todo: duplicate. relation.createJoinColumnsIdMap(entity) ?\n                    }, {} as ObjectLiteral);\n                    // console.log(\"ids:\", ids);\n                    return !existInverseEntityRelationIds.find(relationId => {\n                        return relation.inverseEntityMetadata.compareIds(relationId, ids);\n                    });\n                });\n\n                // console.log(\"newJunctionEntities: \", newJunctionEntities);\n\n                // finally create a new junction insert operation and push it to the array of such operations\n                if (newJunctionEntities.length > 0 && options.insert) {\n                    subject.junctionInserts.push({\n                        relation: relation,\n                        junctionEntities: newJunctionEntities\n                    });\n                }\n\n                // finally create a new junction remove operation and push it to the array of such operations\n                if (removedJunctionEntityIds.length > 0 && options.remove) {\n                    subject.junctionRemoves.push({\n                        relation: relation,\n                        junctionRelationIds: removedJunctionEntityIds\n                    });\n                }\n            });\n\n            return Promise.all(promises);\n        });\n\n        await Promise.all(promises);\n    }\n\n    /**\n     * Finds subject where entity like given subject's entity.\n     * Comparision made by entity id.\n     */\n    protected findByEntityLike(entityTarget: Function|string, entity: ObjectLiteral): Subject|undefined {\n        return this.operateSubjects.find(subject => {\n            if (!subject.hasEntity)\n                return false;\n\n            if (subject.entity === entity)\n                return true;\n\n            return subject.entityTarget === entityTarget && subject.metadata.compareEntities(subject.entity, entity);\n        });\n    }\n\n    /**\n     * Finds subject where entity like given subject's database entity.\n     * Comparision made by entity id.\n     */\n    protected findByDatabaseEntityLike(entityTarget: Function|string, entity: ObjectLiteral): Subject|undefined {\n        return this.operateSubjects.find(subject => {\n            if (!subject.hasDatabaseEntity)\n                return false;\n\n            return subject.entityTarget === entityTarget && subject.metadata.compareEntities(subject.databaseEntity, entity);\n        });\n    }\n\n    /**\n     * Groups given Subject objects into groups separated by entity targets.\n     */\n    protected groupByEntityTargets(): { target: Function|string, subjects: Subject[] }[] {\n        return this.operateSubjects.reduce((groups, operatedEntity) => {\n            let group = groups.find(group => group.target === operatedEntity.entityTarget);\n            if (!group) {\n                group = { target: operatedEntity.entityTarget, subjects: [] };\n                groups.push(group);\n            }\n            group.subjects.push(operatedEntity);\n            return groups;\n        }, [] as { target: Function|string, subjects: Subject[] }[]);\n    }\n\n}"],"sourceRoot":".."}