{"version":3,"sources":["../../src/driver/websql/WebsqlQueryRunner.ts"],"names":[],"mappings":"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","file":"WebsqlQueryRunner.js","sourcesContent":["import {ObjectLiteral} from \"../../common/ObjectLiteral\";\nimport {TransactionAlreadyStartedError} from \"../../error/TransactionAlreadyStartedError\";\nimport {TransactionNotStartedError} from \"../../error/TransactionNotStartedError\";\nimport {Table} from \"../../schema-builder/schema/Table\";\nimport {QueryRunnerAlreadyReleasedError} from \"../../error/QueryRunnerAlreadyReleasedError\";\nimport {OrmUtils} from \"../../util/OrmUtils\";\nimport {InsertResult} from \"../InsertResult\";\nimport {QueryFailedError} from \"../../error/QueryFailedError\";\nimport {AbstractSqliteQueryRunner} from \"../sqlite-abstract/AbstractSqliteQueryRunner\";\nimport {WebsqlDriver} from \"./WebsqlDriver\";\n\n/**\n * Declare a global function that is only available in browsers that support WebSQL.\n */\ndeclare function openDatabase(...params: any[]): any;\n\n/**\n * Runs queries on a single websql database connection.\n */\nexport class WebsqlQueryRunner extends AbstractSqliteQueryRunner {\n    /**\n     * Real database connection from a connection pool used to perform queries.\n     */\n    protected databaseConnection: any;\n\n    /**\n     * Promise used to obtain a database connection for a first time.\n     */\n    protected databaseConnectionPromise: Promise<any>;\n\n    /**\n     * Database driver used by connection.\n     */\n    driver: WebsqlDriver;\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(driver: WebsqlDriver) {\n        super(driver);\n\n        this.driver = driver;\n        this.connection = driver.connection;\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Creates/uses database connection from the connection pool to perform further operations.\n     * Returns obtained database connection.\n     */\n    connect(): Promise<any> {\n        if (this.databaseConnection)\n            return Promise.resolve(this.databaseConnection);\n\n        if (this.databaseConnectionPromise)\n            return this.databaseConnectionPromise;\n\n        const options = Object.assign({}, {\n            database: this.driver.options.database,\n            version: this.driver.options.version,\n            description: this.driver.options.description,\n            size: this.driver.options.size,\n        }, this.driver.options.extra || {});\n\n        this.databaseConnectionPromise = new Promise<void>((ok, fail) => {\n            this.databaseConnection = openDatabase(\n                options.database,\n                options.version,\n                options.description,\n                options.size,\n            );\n            ok(this.databaseConnection);\n        });\n\n        return this.databaseConnectionPromise;\n    }\n\n    /**\n     * Starts transaction.\n     */\n    async startTransaction(): Promise<void> {\n        if (this.isReleased)\n            throw new QueryRunnerAlreadyReleasedError();\n\n        if (this.isTransactionActive)\n            throw new TransactionAlreadyStartedError();\n\n        this.isTransactionActive = true;\n        // await this.query(\"BEGIN TRANSACTION\");\n    }\n\n    /**\n     * Commits transaction.\n     * Error will be thrown if transaction was not started.\n     */\n    async commitTransaction(): Promise<void> {\n        if (this.isReleased)\n            throw new QueryRunnerAlreadyReleasedError();\n\n        if (!this.isTransactionActive)\n            throw new TransactionNotStartedError();\n\n        // await this.query(\"COMMIT\");\n        this.isTransactionActive = false;\n    }\n\n    /**\n     * Rollbacks transaction.\n     * Error will be thrown if transaction was not started.\n     */\n    async rollbackTransaction(): Promise<void> {\n        if (this.isReleased)\n            throw new QueryRunnerAlreadyReleasedError();\n\n        if (!this.isTransactionActive)\n            throw new TransactionNotStartedError();\n\n        // await this.query(\"ROLLBACK\");\n        this.isTransactionActive = false;\n    }\n\n    /**\n     * Executes a given SQL query.\n     */\n    query(query: string, parameters?: any[]): Promise<any> {\n        if (this.isReleased)\n            throw new QueryRunnerAlreadyReleasedError();\n\n        return new Promise(async (ok, fail) => {\n            try {\n                const db = await this.connect();\n                // todo(dima): check if transaction is not active\n\n                this.driver.connection.logger.logQuery(query, parameters, this);\n                const queryStartTime = +new Date();\n\n                db.transaction((tx: any) => {\n                    tx.executeSql(query, parameters, (tx: any, result: any) => {\n\n                        // log slow queries if maxQueryExecution time is set\n                        const maxQueryExecutionTime = this.driver.connection.options.maxQueryExecutionTime;\n                        const queryEndTime = +new Date();\n                        const queryExecutionTime = queryEndTime - queryStartTime;\n                        if (maxQueryExecutionTime && queryExecutionTime > maxQueryExecutionTime)\n                            this.driver.connection.logger.logQuerySlow(queryExecutionTime, query, parameters, this);\n\n                        const rows = Object\n                            .keys(result.rows)\n                            .filter(key => key !== \"length\")\n                            .map(key => result.rows[key]);\n                        ok(rows);\n\n                    }, (tx: any, err: any) => {\n                        this.driver.connection.logger.logQueryError(err, query, parameters, this);\n                        return fail(new QueryFailedError(query, parameters, err));\n                    });\n                });\n\n            } catch (err) {\n                fail(err);\n            }\n        });\n    }\n\n    /**\n     * Insert a new row with given values into the given table.\n     * Returns value of the generated column if given and generate column exist in the table.\n     */\n    async insert(tableName: string, keyValues: ObjectLiteral): Promise<InsertResult> {\n        const keys = Object.keys(keyValues);\n        const columns = keys.map(key => `\"${key}\"`).join(\", \");\n        const values = keys.map((key, index) => \"$\" + (index + 1)).join(\",\");\n        const generatedColumns = this.connection.hasMetadata(tableName) ? this.connection.getMetadata(tableName).generatedColumns : [];\n        const sql = columns.length > 0 ? (`INSERT INTO \"${tableName}\"(${columns}) VALUES (${values})`) : `INSERT INTO \"${tableName}\" DEFAULT VALUES`;\n        const parameters = keys.map(key => keyValues[key]);\n\n        return new Promise<InsertResult>(async (ok, fail) => {\n            this.driver.connection.logger.logQuery(sql, parameters, this);\n\n            const db = await this.connect();\n            // todo: check if transaction is not active\n            db.transaction((tx: any) => {\n                tx.executeSql(sql, parameters, (tx: any, result: any) => {\n                    const generatedMap = generatedColumns.reduce((map, generatedColumn) => {\n                        const value = generatedColumn.isPrimary && generatedColumn.generationStrategy === \"increment\" && result[\"insertId\"] ? result[\"insertId\"] : keyValues[generatedColumn.databaseName];\n                        if (!value) return map;\n                        return OrmUtils.mergeDeep(map, generatedColumn.createValueMap(value));\n                    }, {} as ObjectLiteral);\n\n                    ok({\n                        result: undefined,\n                        generatedMap: Object.keys(generatedMap).length > 0 ? generatedMap : undefined\n                    });\n\n                }, (tx: any, err: any) => {\n                    this.driver.connection.logger.logQueryError(err, sql, parameters, this);\n                    return fail(err);\n                });\n            });\n        });\n    }\n\n    // TODO: finish the table schema loading\n    /**\n     * Loads all tables (with given names) from the database and creates a Table from them.\n     */\n    async getTables(tableNames: string[]): Promise<Table[]> {\n\n        // if no tables given then no need to proceed\n        if (!tableNames || !tableNames.length)\n            return [];\n\n        const tableNamesString = tableNames.map(tableName => `'${tableName}'`).join(\", \");\n\n        // load tables, columns, indices and foreign keys\n        const dbTables: ObjectLiteral[] = await this.query(`SELECT * FROM sqlite_master WHERE type = 'table' AND name IN (${tableNamesString})`);\n\n        // if tables were not found in the db, no need to proceed\n        if (!dbTables || !dbTables.length)\n            return [];\n\n        // create table schemas for loaded tables\n        return Promise.all(dbTables.map(async dbTable => {\n            const table = new Table(dbTable[\"name\"]);\n\n            // load columns and indices\n            /*const [dbColumns, dbIndices, dbForeignKeys]: ObjectLiteral[][] = await Promise.all([\n                this.query(`PRAGMA table_info(\"${dbTable[\"name\"]}\")`),\n                this.query(`PRAGMA index_list(\"${dbTable[\"name\"]}\")`),\n                this.query(`PRAGMA foreign_key_list(\"${dbTable[\"name\"]}\")`),\n            ]);\n\n            // find column name with auto increment\n            let autoIncrementColumnName: string|undefined = undefined;\n            const tableSql: string = dbTable[\"sql\"];\n            if (tableSql.indexOf(\"AUTOINCREMENT\") !== -1) {\n                autoIncrementColumnName = tableSql.substr(0, tableSql.indexOf(\"AUTOINCREMENT\"));\n                const comma = autoIncrementColumnName.lastIndexOf(\",\");\n                const bracket = autoIncrementColumnName.lastIndexOf(\"(\");\n                if (comma !== -1) {\n                    autoIncrementColumnName = autoIncrementColumnName.substr(comma);\n                    autoIncrementColumnName = autoIncrementColumnName.substr(0, autoIncrementColumnName.lastIndexOf(\"\\\"\"));\n                    autoIncrementColumnName = autoIncrementColumnName.substr(autoIncrementColumnName.indexOf(\"\\\"\") + 1);\n\n                } else if (bracket !== -1) {\n                    autoIncrementColumnName = autoIncrementColumnName.substr(bracket);\n                    autoIncrementColumnName = autoIncrementColumnName.substr(0, autoIncrementColumnName.lastIndexOf(\"\\\"\"));\n                    autoIncrementColumnName = autoIncrementColumnName.substr(autoIncrementColumnName.indexOf(\"\\\"\") + 1);\n                }\n            }\n\n            // create columns from the loaded columns\n            table.columns = dbColumns.map(dbColumn => {\n                const tableColumn = new TableColumn();\n                tableColumn.name = dbColumn[\"name\"];\n                tableColumn.type = dbColumn[\"type\"].toLowerCase();\n                tableColumn.default = dbColumn[\"dflt_value\"] !== null && dbColumn[\"dflt_value\"] !== undefined ? dbColumn[\"dflt_value\"] : undefined;\n                tableColumn.isNullable = dbColumn[\"notnull\"] === 0;\n                tableColumn.isPrimary = dbColumn[\"pk\"] === 1;\n                tableColumn.comment = \"\"; // todo later\n                tableColumn.isGenerated = autoIncrementColumnName === dbColumn[\"name\"];\n                const columnForeignKeys = dbForeignKeys\n                    .filter(foreignKey => foreignKey[\"from\"] === dbColumn[\"name\"])\n                    .map(foreignKey => {\n                        const keyName = namingStrategy.foreignKeyName(dbTable[\"name\"], [foreignKey[\"from\"]], foreignKey[\"table\"], [foreignKey[\"to\"]]);\n                        return new TableForeignKey(keyName, [foreignKey[\"from\"]], [foreignKey[\"to\"]], foreignKey[\"table\"], foreignKey[\"on_delete\"]); // todo: how sqlite return from and to when they are arrays? (multiple column foreign keys)\n                    });\n                table.addForeignKeys(columnForeignKeys);\n                return tableColumn;\n            });\n\n            // create primary key schema\n            await Promise.all(dbIndices\n                .filter(index => index[\"origin\"] === \"pk\")\n                .map(async index => {\n                    const indexInfos: ObjectLiteral[] = await this.query(`PRAGMA index_info(\"${index[\"name\"]}\")`);\n                    const indexColumns = indexInfos.map(indexInfo => indexInfo[\"name\"]);\n                    indexColumns.forEach(indexColumn => {\n                        table.primaryKeys.push(new TablePrimaryKey(index[\"name\"], indexColumn));\n                    });\n                }));\n\n            // create index schemas from the loaded indices\n            const indicesPromises = dbIndices\n                .filter(dbIndex => {\n                    return  dbIndex[\"origin\"] !== \"pk\" &&\n                        (!table.foreignKeys.find(foreignKey => foreignKey.name === dbIndex[\"name\"])) &&\n                        (!table.primaryKeys.find(primaryKey => primaryKey.name === dbIndex[\"name\"]));\n                })\n                .map(dbIndex => dbIndex[\"name\"])\n                .filter((value, index, self) => self.indexOf(value) === index) // unqiue\n                .map(async dbIndexName => {\n                    const dbIndex = dbIndices.find(dbIndex => dbIndex[\"name\"] === dbIndexName);\n                    const indexInfos: ObjectLiteral[] = await this.query(`PRAGMA index_info(\"${dbIndex![\"name\"]}\")`);\n                    const indexColumns = indexInfos.map(indexInfo => indexInfo[\"name\"]);\n\n                    // check if db index is generated by sqlite itself and has special use case\n                    if (dbIndex![\"name\"].substr(0, \"sqlite_autoindex\".length) === \"sqlite_autoindex\") {\n                        if (dbIndex![\"unique\"] === 1) { // this means we have a special index generated for a column\n                            // so we find and update the column\n                            indexColumns.forEach(columnName => {\n                                const column = table.columns.find(column => column.name === columnName);\n                                if (column)\n                                    column.isUnique = true;\n                            });\n                        }\n\n                        return Promise.resolve(undefined);\n\n                    } else {\n                        return new TableIndex(dbTable[\"name\"], dbIndex![\"name\"], indexColumns, dbIndex![\"unique\"] === \"1\");\n                    }\n                });\n\n            const indices = await Promise.all(indicesPromises);\n            table.indices = indices.filter(index => !!index) as TableIndex[];*/\n\n            return table;\n        }));\n    }\n\n    /**\n     * Removes all tables from the currently connected database.\n     */\n    async clearDatabase(): Promise<void> {\n        // await this.query(`PRAGMA foreign_keys = OFF;`);\n        await this.startTransaction();\n        try {\n            const selectDropsQuery = `select 'drop table \"' || name || '\";' as query from sqlite_master where type = 'table' and name != 'sqlite_sequence'`;\n            const dropQueries: ObjectLiteral[] = await this.query(selectDropsQuery);\n            await Promise.all(dropQueries.map(q => this.query(q[\"query\"])));\n            await this.commitTransaction();\n\n        } catch (error) {\n            try { // we throw original error even if rollback thrown an error\n                await this.rollbackTransaction();\n            } catch (rollbackError) { }\n            throw error;\n\n            // await this.query(`PRAGMA foreign_keys = ON;`);\n        }\n    }\n}"],"sourceRoot":"../.."}