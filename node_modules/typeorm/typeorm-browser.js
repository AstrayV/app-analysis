var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
System.register("typeorm/driver/types/ColumnTypes", [], function (exports_1, context_1) {
    "use strict";
    var __moduleName = context_1 && context_1.id;
    return {
        setters: [],
        execute: function () {
            // "string"|"text"|"number"|"integer"|"int"|"smallint"|"bigint"|"float"|"double"|
            // "decimal"|"date"|"time"|"datetime"|"boolean"|"json"|"jsonb"|"simple_array"|"uuid";
            // -------------------------------------------------------------------------
            // Merged Types
            // -------------------------------------------------------------------------
            /*
            /!**
             * Column types where column length is used.
             *!/
            export type WithLengthColumnType =
                VarcharColumnType|
                CharColumnType|
                IntervalColumnType|
                BitColumnType|
                VarbitColumnType;
            
            /!**
             * Column types where time options are used.
             *!/
            export type WithTimeColumnType =
                TimeColumnType|
                TimestampColumnType;
            
            /!**
             * All other column types without extra options used.
             *!/
            export type SimpleColumnType =
                SmallintColumnType|
                IntegerColumnType|
                BigintColumnType|
                DecimalColumnType|
                RealColumnType|
                DoublePrecisionColumnType|
                SmallserialColumnType|
                SerialColumnType|
                BigserialColumnType|
                MoneyColumnType|
                TextColumnType|
                ByteaColumnType|
                DateColumnType|
                BooleanColumnType|
                PointColumnType|
                LineColumnType|
                LsegColumnType|
                BoxColumnType|
                CircleColumnType|
                PathColumnType|
                PolygonColumnType|
                CidrColumnType|
                InetColumnType|
                MacaddrColumnType|
                TsvectorColumnType|
                TsqueryColumnType|
                UUIDColumnType|
                XmlColumnType|
                JsonColumnType|
                JsonbColumnType;
            
            /!**
             * All column types supported by a database.
             *!/
            export type AllColumnType =
                SimpleColumnType|
                WithLengthColumnType|
                WithTimeColumnType|
                NumericColumnType|
                EnumColumnType;
            
            
            /!**
             * All data types that column can be.
             *!/
            export type ColumnType =
                "tinyint"|
                "smallint"|
                "int2"|
                "mediumint"|
                "integer"|
                "int"|
                "int4"|
                "bigint"|
                "int8"|
                "decimal"|
                "numeric"|
                "real"|
                "float4"|
                "float"|
                "double"|
                "double precision"|
                "numeric"|
                "decimal"|
                "string"|"text"|"number"|"integer"|"int"|"smallint"|"bigint"|"float"|"double"|
                                     "decimal"|"date"|"time"|"datetime"|"boolean"|"json"|"jsonb"|"simple_array"|"uuid";*/
            /*
            
            /!**
             * All data types that column can be.
             *!/
            export class ColumnTypes {
            
                /!**
                 * SQL VARCHAR type. Your class's property type should be a "string".
                 *!/
                static STRING: ColumnType = "string";
            
                /!**
                 * SQL CLOB type. Your class's property type should be a "string".
                 *!/
                static TEXT: ColumnType = "text";
            
                /!**
                 * SQL FLOAT type. Your class's property type should be a "number".
                 *!/
                static NUMBER: ColumnType = "number";
            
                /!**
                 * SQL INT type. Your class's property type should be a "number".
                 *!/
                static INTEGER: ColumnType = "integer";
            
                /!**
                 * SQL INT type. Your class's property type should be a "number".
                 *!/
                static INT: ColumnType = "int";
            
                /!**
                 * SQL SMALLINT type. Your class's property type should be a "number".
                 *!/
                static SMALLINT: ColumnType = "smallint";
            
                /!**
                 * SQL BIGINT type. Your class's property type should be a "number".
                 *!/
                static BIGINT: ColumnType = "bigint";
            
                /!**
                 * SQL FLOAT type. Your class's property type should be a "number".
                 *!/
                static FLOAT: ColumnType = "float";
            
                /!**
                 * SQL FLOAT type. Your class's property type should be a "number".
                 *!/
                static DOUBLE: ColumnType = "double";
            
                /!**
                 * SQL DECIMAL type. Your class's property type should be a "string".
                 *!/
                static DECIMAL: ColumnType = "decimal";
            
                /!**
                 * SQL DATETIME type. Your class's property type should be a "Date" object.
                 *!/
                static DATE: ColumnType = "date";
            
                /!**
                 * SQL TIME type. Your class's property type should be a "Date" object.
                 *!/
                static TIME: ColumnType = "time";
            
                /!**
                 * SQL DATETIME/TIMESTAMP type. Your class's property type should be a "Date" object.
                 *!/
                static DATETIME: ColumnType = "datetime";
            
                /!**
                 * SQL BOOLEAN type. Your class's property type should be a "boolean".
                 *!/
                static BOOLEAN: ColumnType = "boolean";
            
                /!**
                 * SQL CLOB type. Your class's property type should be any Object.
                 *!/
                static JSON: ColumnType = "json";
            
                /!**
                 * Postgres jsonb type. Your class's property type should be any Object.
                 *!/
                static JSONB: ColumnType = "jsonb";
            
                /!**
                 * SQL CLOB type. Your class's property type should be array of string. Note: value in this column should not contain
                 * a comma (",") since this symbol is used to create a string from the array, using .join(",") operator.
                 *!/
                static SIMPLE_ARRAY: ColumnType = "simple_array";
            
                /!**
                 * UUID type. Serialized to a string in typescript or javascript
                 *!/
                static UUID: ColumnType = "uuid";
            
                /!**
                 * Checks if given type in a string format is supported by ORM.
                 *!/
                static isTypeSupported(type: string) {
                    return this.supportedTypes.indexOf(<ColumnType> type) !== -1;
                }
            
                /!**
                 * Returns list of all supported types by the ORM.
                 *!/
                static get supportedTypes() {
                    return [
                        this.STRING,
                        this.TEXT,
                        this.NUMBER,
                        this.INTEGER,
                        this.INT,
                        this.SMALLINT,
                        this.BIGINT,
                        this.FLOAT,
                        this.DOUBLE,
                        this.DECIMAL,
                        this.DATE,
                        this.TIME,
                        this.DATETIME,
                        this.BOOLEAN,
                        this.JSON,
                        this.JSONB,
                        this.SIMPLE_ARRAY,
                        this.UUID
                    ];
                }
            
                /!**
                 * Tries to guess a column type from the given function.
                 *!/
                static determineTypeFromFunction(type: Function): ColumnType|undefined {
                    if (type instanceof Date) {
                        return ColumnTypes.DATETIME;
            
                    } else if (type instanceof Function) {
                        const typeName = (<any>type).name.toLowerCase();
                        switch (typeName) {
                            case "number":
                                return ColumnTypes.NUMBER;
                            case "boolean":
                                return ColumnTypes.BOOLEAN;
                            case "string":
                                return ColumnTypes.STRING;
                            case "date":
                                return ColumnTypes.DATETIME;
                            case "object":
                                return ColumnTypes.JSON;
                        }
            
                    } else if (type instanceof Object) {
                        return ColumnTypes.JSON;
            
                    }
            
                    return undefined;
                }
            
                static typeToString(type: Function): string {
                    return (type as any).name.toLowerCase();
                }
            
                /!**
                 * Checks if column type is numeric.
                 *!/
                static isNumeric(type: ColumnType) {
                    return  type === ColumnTypes.NUMBER ||
                            type === ColumnTypes.INT ||
                            type === ColumnTypes.INTEGER ||
                            type === ColumnTypes.BIGINT ||
                            type === ColumnTypes.SMALLINT ||
                            type === ColumnTypes.DOUBLE ||
                            type === ColumnTypes.FLOAT;
                }
            
            }*/
        }
    };
});
System.register("typeorm/metadata/types/RelationTypes", [], function (exports_2, context_2) {
    "use strict";
    var __moduleName = context_2 && context_2.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/naming-strategy/NamingStrategyInterface", [], function (exports_3, context_3) {
    "use strict";
    var __moduleName = context_3 && context_3.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/metadata/types/OnDeleteType", [], function (exports_4, context_4) {
    "use strict";
    var __moduleName = context_4 && context_4.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/metadata/ForeignKeyMetadata", [], function (exports_5, context_5) {
    "use strict";
    var __moduleName = context_5 && context_5.id;
    var ForeignKeyMetadata;
    return {
        setters: [],
        execute: function () {
            /**
             * Contains all information about entity's foreign key.
             */
            ForeignKeyMetadata = /** @class */ (function () {
                // ---------------------------------------------------------------------
                // Constructor
                // ---------------------------------------------------------------------
                function ForeignKeyMetadata(options) {
                    /**
                     * Array of columns of this foreign key.
                     */
                    this.columns = [];
                    /**
                     * Array of referenced columns.
                     */
                    this.referencedColumns = [];
                    /**
                     * Gets array of column names.
                     */
                    this.columnNames = [];
                    /**
                     * Gets array of referenced column names.
                     */
                    this.referencedColumnNames = [];
                    this.entityMetadata = options.entityMetadata;
                    this.referencedEntityMetadata = options.referencedEntityMetadata;
                    this.columns = options.columns;
                    this.referencedColumns = options.referencedColumns;
                    this.onDelete = options.onDelete;
                    if (options.namingStrategy)
                        this.build(options.namingStrategy);
                }
                // ---------------------------------------------------------------------
                // Public Methods
                // ---------------------------------------------------------------------
                /**
                 * Builds some depend foreign key properties.
                 * Must be called after all entity metadatas and their columns are built.
                 */
                ForeignKeyMetadata.prototype.build = function (namingStrategy) {
                    this.columnNames = this.columns.map(function (column) { return column.databaseName; });
                    this.referencedColumnNames = this.referencedColumns.map(function (column) { return column.databaseName; });
                    this.tableName = this.entityMetadata.tableName;
                    this.referencedTableName = this.referencedEntityMetadata.tableName;
                    this.name = namingStrategy.foreignKeyName(this.tableName, this.columnNames, this.referencedEntityMetadata.tableName, this.referencedColumnNames);
                };
                return ForeignKeyMetadata;
            }());
            exports_5("ForeignKeyMetadata", ForeignKeyMetadata);
        }
    };
});
System.register("typeorm/common/ObjectLiteral", [], function (exports_6, context_6) {
    "use strict";
    var __moduleName = context_6 && context_6.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/metadata-args/EmbeddedMetadataArgs", [], function (exports_7, context_7) {
    "use strict";
    var __moduleName = context_7 && context_7.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/query-builder/QueryBuilderUtils", [], function (exports_8, context_8) {
    "use strict";
    var __moduleName = context_8 && context_8.id;
    var QueryBuilderUtils;
    return {
        setters: [],
        execute: function () {
            /**
             * Helper utility functions for QueryBuilder.
             */
            QueryBuilderUtils = /** @class */ (function () {
                function QueryBuilderUtils() {
                }
                /**
                 * Checks if given value is a string representation of alias property,
                 * e.g. "post.category" or "post.id".
                 */
                QueryBuilderUtils.isAliasProperty = function (str) {
                    // alias property must be a string and must have a dot separator
                    if (typeof str !== "string" || str.indexOf(".") === -1)
                        return false;
                    // extra alias and its property relation
                    var _a = str.split("."), aliasName = _a[0], propertyName = _a[1]; // todo: what about relations in embedded?
                    if (!aliasName || !propertyName)
                        return false;
                    // alias and property must be represented in a special format
                    var aliasNameRegexp = /^[a-zA-Z0-9_-]+$/;
                    if (!aliasNameRegexp.test(aliasName) || !aliasNameRegexp.test(propertyName))
                        return false;
                    return true;
                };
                return QueryBuilderUtils;
            }());
            exports_8("QueryBuilderUtils", QueryBuilderUtils);
        }
    };
});
System.register("typeorm/query-builder/Alias", [], function (exports_9, context_9) {
    "use strict";
    var __moduleName = context_9 && context_9.id;
    var Alias;
    return {
        setters: [],
        execute: function () {
            /**
             */
            Alias = /** @class */ (function () {
                function Alias(alias) {
                    Object.assign(this, alias || {});
                }
                Object.defineProperty(Alias.prototype, "target", {
                    get: function () {
                        return this.metadata.target;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Alias.prototype, "hasMetadata", {
                    get: function () {
                        return !!this._metadata;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Alias.prototype, "metadata", {
                    get: function () {
                        if (!this._metadata)
                            throw new Error("Cannot get entity metadata for the given alias \"" + this.name + "\"");
                        return this._metadata;
                    },
                    set: function (metadata) {
                        this._metadata = metadata;
                    },
                    enumerable: true,
                    configurable: true
                });
                return Alias;
            }());
            exports_9("Alias", Alias);
        }
    };
});
System.register("typeorm/find-options/OrderByCondition", [], function (exports_10, context_10) {
    "use strict";
    var __moduleName = context_10 && context_10.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/query-builder/JoinAttribute", ["typeorm/query-builder/QueryBuilderUtils"], function (exports_11, context_11) {
    "use strict";
    var __moduleName = context_11 && context_11.id;
    var QueryBuilderUtils_1, JoinAttribute;
    return {
        setters: [
            function (QueryBuilderUtils_1_1) {
                QueryBuilderUtils_1 = QueryBuilderUtils_1_1;
            }
        ],
        execute: function () {
            /**
             * Stores all join attributes which will be used to build a JOIN query.
             */
            JoinAttribute = /** @class */ (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function JoinAttribute(connection, queryExpressionMap, joinAttribute) {
                    this.connection = connection;
                    this.queryExpressionMap = queryExpressionMap;
                    Object.assign(this, joinAttribute || {});
                }
                Object.defineProperty(JoinAttribute.prototype, "isMany", {
                    // -------------------------------------------------------------------------
                    // Public Methods
                    // -------------------------------------------------------------------------
                    get: function () {
                        if (this.isMappingMany !== undefined)
                            return this.isMappingMany;
                        if (this.relation)
                            return this.relation.isManyToMany || this.relation.isOneToMany;
                        return false;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(JoinAttribute.prototype, "tablePath", {
                    /**
                     * Name of the table which we should join.
                     */
                    get: function () {
                        return this.metadata ? this.metadata.tablePath : this.entityOrProperty;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(JoinAttribute.prototype, "parentAlias", {
                    /**
                     * Alias of the parent of this join.
                     * For example, if we join ("post.category", "categoryAlias") then "post" is a parent alias.
                     * This value is extracted from entityOrProperty value.
                     * This is available when join was made using "post.category" syntax.
                     */
                    get: function () {
                        if (!QueryBuilderUtils_1.QueryBuilderUtils.isAliasProperty(this.entityOrProperty))
                            return undefined;
                        return this.entityOrProperty.substr(0, this.entityOrProperty.indexOf("."));
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(JoinAttribute.prototype, "relationPropertyPath", {
                    /**
                     * Relation property name of the parent.
                     * This is used to understand what is joined.
                     * For example, if we join ("post.category", "categoryAlias") then "category" is a relation property.
                     * This value is extracted from entityOrProperty value.
                     * This is available when join was made using "post.category" syntax.
                     */
                    get: function () {
                        if (!QueryBuilderUtils_1.QueryBuilderUtils.isAliasProperty(this.entityOrProperty))
                            return undefined;
                        return this.entityOrProperty.substr(this.entityOrProperty.indexOf(".") + 1);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(JoinAttribute.prototype, "relation", {
                    /**
                     * Relation of the parent.
                     * This is used to understand what is joined.
                     * This is available when join was made using "post.category" syntax.
                     * Relation can be undefined if entityOrProperty is regular entity or custom table.
                     */
                    get: function () {
                        if (!QueryBuilderUtils_1.QueryBuilderUtils.isAliasProperty(this.entityOrProperty))
                            return undefined;
                        var relationOwnerSelection = this.queryExpressionMap.findAliasByName(this.parentAlias);
                        var relation = relationOwnerSelection.metadata.findRelationWithPropertyPath(this.relationPropertyPath);
                        if (relation) {
                            return relation;
                        }
                        if (relationOwnerSelection.metadata.parentEntityMetadata) {
                            relation = relationOwnerSelection.metadata.parentEntityMetadata.findRelationWithPropertyPath(this.relationPropertyPath);
                            if (relation) {
                                return relation;
                            }
                        }
                        throw new Error("Relation with property path " + this.relationPropertyPath + " in entity was not found.");
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(JoinAttribute.prototype, "metadata", {
                    /**
                     * Metadata of the joined entity.
                     * If table without entity was joined, then it will return undefined.
                     */
                    get: function () {
                        // entityOrProperty is relation, e.g. "post.category"
                        if (this.relation)
                            return this.relation.inverseEntityMetadata;
                        // entityOrProperty is Entity class
                        if (this.connection.hasMetadata(this.entityOrProperty))
                            return this.connection.getMetadata(this.entityOrProperty);
                        return undefined;
                        /*if (typeof this.entityOrProperty === "string") { // entityOrProperty is a custom table
                
                            // first try to find entity with such name, this is needed when entity does not have a target class,
                            // and its target is a string name (scenario when plain old javascript is used or entity schema is loaded from files)
                            const metadata = this.connection.entityMetadatas.find(metadata => metadata.name === this.entityOrProperty);
                            if (metadata)
                                return metadata;
                
                            // check if we have entity with such table name, and use its metadata if found
                            return this.connection.entityMetadatas.find(metadata => metadata.tableName === this.entityOrProperty);
                        }*/
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(JoinAttribute.prototype, "junctionAlias", {
                    /**
                     * Generates alias of junction table, whose ids we get.
                     */
                    get: function () {
                        if (!this.relation)
                            throw new Error("Cannot get junction table for join without relation.");
                        return this.relation.isOwning ? this.parentAlias + "_" + this.alias.name : this.alias.name + "_" + this.parentAlias;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(JoinAttribute.prototype, "mapToPropertyParentAlias", {
                    get: function () {
                        if (!this.mapToProperty)
                            return undefined;
                        return this.mapToProperty.split(".")[0];
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(JoinAttribute.prototype, "mapToPropertyPropertyName", {
                    get: function () {
                        if (!this.mapToProperty)
                            return undefined;
                        return this.mapToProperty.split(".")[1];
                    },
                    enumerable: true,
                    configurable: true
                });
                return JoinAttribute;
            }());
            exports_11("JoinAttribute", JoinAttribute);
        }
    };
});
System.register("typeorm/query-builder/relation-count/RelationCountAttribute", ["typeorm/query-builder/QueryBuilderUtils"], function (exports_12, context_12) {
    "use strict";
    var __moduleName = context_12 && context_12.id;
    var QueryBuilderUtils_2, RelationCountAttribute;
    return {
        setters: [
            function (QueryBuilderUtils_2_1) {
                QueryBuilderUtils_2 = QueryBuilderUtils_2_1;
            }
        ],
        execute: function () {
            RelationCountAttribute = /** @class */ (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function RelationCountAttribute(expressionMap, relationCountAttribute) {
                    this.expressionMap = expressionMap;
                    Object.assign(this, relationCountAttribute || {});
                }
                Object.defineProperty(RelationCountAttribute.prototype, "joinInverseSideMetadata", {
                    // -------------------------------------------------------------------------
                    // Public Methods
                    // -------------------------------------------------------------------------
                    get: function () {
                        return this.relation.inverseEntityMetadata;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(RelationCountAttribute.prototype, "parentAlias", {
                    /**
                     * Alias of the parent of this join.
                     * For example, if we join ("post.category", "categoryAlias") then "post" is a parent alias.
                     * This value is extracted from entityOrProperty value.
                     * This is available when join was made using "post.category" syntax.
                     */
                    get: function () {
                        if (!QueryBuilderUtils_2.QueryBuilderUtils.isAliasProperty(this.relationName))
                            throw new Error("Given value must be a string representation of alias property");
                        return this.relationName.split(".")[0];
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(RelationCountAttribute.prototype, "relationProperty", {
                    /**
                     * Relation property name of the parent.
                     * This is used to understand what is joined.
                     * For example, if we join ("post.category", "categoryAlias") then "category" is a relation property.
                     * This value is extracted from entityOrProperty value.
                     * This is available when join was made using "post.category" syntax.
                     */
                    get: function () {
                        if (!QueryBuilderUtils_2.QueryBuilderUtils.isAliasProperty(this.relationName))
                            throw new Error("Given value is a string representation of alias property");
                        return this.relationName.split(".")[1];
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(RelationCountAttribute.prototype, "junctionAlias", {
                    get: function () {
                        var _a = this.relationName.split("."), parentAlias = _a[0], relationProperty = _a[1];
                        return parentAlias + "_" + relationProperty + "_relation_count";
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(RelationCountAttribute.prototype, "relation", {
                    /**
                     * Relation of the parent.
                     * This is used to understand what is joined.
                     * This is available when join was made using "post.category" syntax.
                     */
                    get: function () {
                        if (!QueryBuilderUtils_2.QueryBuilderUtils.isAliasProperty(this.relationName))
                            throw new Error("Given value is a string representation of alias property");
                        var _a = this.relationName.split("."), parentAlias = _a[0], propertyPath = _a[1];
                        var relationOwnerSelection = this.expressionMap.findAliasByName(parentAlias);
                        var relation = relationOwnerSelection.metadata.findRelationWithPropertyPath(propertyPath);
                        if (!relation)
                            throw new Error("Relation with property path " + propertyPath + " in entity was not found.");
                        return relation;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(RelationCountAttribute.prototype, "metadata", {
                    /**
                     * Metadata of the joined entity.
                     * If table without entity was joined, then it will return undefined.
                     */
                    get: function () {
                        if (!QueryBuilderUtils_2.QueryBuilderUtils.isAliasProperty(this.relationName))
                            throw new Error("Given value is a string representation of alias property");
                        var parentAlias = this.relationName.split(".")[0];
                        var selection = this.expressionMap.findAliasByName(parentAlias);
                        return selection.metadata;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(RelationCountAttribute.prototype, "mapToPropertyPropertyName", {
                    get: function () {
                        return this.mapToProperty.split(".")[1];
                    },
                    enumerable: true,
                    configurable: true
                });
                return RelationCountAttribute;
            }());
            exports_12("RelationCountAttribute", RelationCountAttribute);
        }
    };
});
System.register("typeorm/query-builder/SelectQuery", [], function (exports_13, context_13) {
    "use strict";
    var __moduleName = context_13 && context_13.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/error/ConnectionIsNotSetError", [], function (exports_14, context_14) {
    "use strict";
    var __moduleName = context_14 && context_14.id;
    var ConnectionIsNotSetError;
    return {
        setters: [],
        execute: function () {
            /**
             * Thrown when user tries to execute operation that requires connection to be established.
             */
            ConnectionIsNotSetError = /** @class */ (function (_super) {
                __extends(ConnectionIsNotSetError, _super);
                function ConnectionIsNotSetError(dbType) {
                    var _this = _super.call(this) || this;
                    _this.name = "ConnectionIsNotSetError";
                    _this.message = "Connection with " + dbType + " database is not established. Check connection configuration.";
                    return _this;
                }
                return ConnectionIsNotSetError;
            }(Error));
            exports_14("ConnectionIsNotSetError", ConnectionIsNotSetError);
        }
    };
});
System.register("typeorm/error/DriverPackageNotInstalledError", [], function (exports_15, context_15) {
    "use strict";
    var __moduleName = context_15 && context_15.id;
    var DriverPackageNotInstalledError;
    return {
        setters: [],
        execute: function () {
            /**
             * Thrown when required driver's package is not installed.
             */
            DriverPackageNotInstalledError = /** @class */ (function (_super) {
                __extends(DriverPackageNotInstalledError, _super);
                function DriverPackageNotInstalledError(driverName, packageName) {
                    var _this = _super.call(this) || this;
                    _this.name = "DriverPackageNotInstalledError";
                    _this.message = driverName + " package has not been found installed. Try to install it: npm install " + packageName + " --save";
                    return _this;
                }
                return DriverPackageNotInstalledError;
            }(Error));
            exports_15("DriverPackageNotInstalledError", DriverPackageNotInstalledError);
        }
    };
});
System.register("typeorm/driver/DriverUtils", [], function (exports_16, context_16) {
    "use strict";
    var __moduleName = context_16 && context_16.id;
    var DriverUtils;
    return {
        setters: [],
        execute: function () {
            /**
             * Common driver utility functions.
             */
            DriverUtils = /** @class */ (function () {
                function DriverUtils() {
                }
                // -------------------------------------------------------------------------
                // Public Static Methods
                // -------------------------------------------------------------------------
                /**
                 * Normalizes and builds a new driver options.
                 * Extracts settings from connection url and sets to a new options object.
                 */
                DriverUtils.buildDriverOptions = function (options, buildOptions) {
                    if (options.url) {
                        var parsedUrl = this.parseConnectionUrl(options.url);
                        if (buildOptions && buildOptions.useSid) {
                            var urlDriverOptions = {
                                type: options.type,
                                host: parsedUrl.host,
                                username: parsedUrl.username,
                                password: parsedUrl.password,
                                port: parsedUrl.port,
                                sid: parsedUrl.database
                            };
                            return Object.assign(urlDriverOptions, options);
                        }
                        else {
                            var urlDriverOptions = {
                                type: options.type,
                                host: parsedUrl.host,
                                username: parsedUrl.username,
                                password: parsedUrl.password,
                                port: parsedUrl.port,
                                database: parsedUrl.database
                            };
                            return Object.assign(urlDriverOptions, options);
                        }
                    }
                    return Object.assign({}, options);
                };
                // -------------------------------------------------------------------------
                // Private Static Methods
                // -------------------------------------------------------------------------
                /**
                 * Extracts connection data from the connection url.
                 */
                DriverUtils.parseConnectionUrl = function (url) {
                    var firstSlashes = url.indexOf("//");
                    var preBase = url.substr(firstSlashes + 2);
                    var secondSlash = preBase.indexOf("/");
                    var base = (secondSlash !== -1) ? preBase.substr(0, secondSlash) : preBase;
                    var afterBase = (secondSlash !== -1) ? preBase.substr(secondSlash + 1) : undefined;
                    var lastAtSign = base.lastIndexOf("@");
                    var usernameAndPassword = base.substr(0, lastAtSign);
                    var hostAndPort = base.substr(lastAtSign + 1);
                    var firstColon = usernameAndPassword.indexOf(":");
                    var username = usernameAndPassword.substr(0, firstColon);
                    var password = usernameAndPassword.substr(firstColon + 1);
                    var _a = hostAndPort.split(":"), host = _a[0], port = _a[1];
                    return {
                        host: host,
                        username: username,
                        password: password,
                        port: port ? parseInt(port) : undefined,
                        database: afterBase || undefined
                    };
                };
                return DriverUtils;
            }());
            exports_16("DriverUtils", DriverUtils);
        }
    };
});
System.register("typeorm/error/TransactionAlreadyStartedError", [], function (exports_17, context_17) {
    "use strict";
    var __moduleName = context_17 && context_17.id;
    var TransactionAlreadyStartedError;
    return {
        setters: [],
        execute: function () {
            /**
             * Thrown when transaction is already started and user tries to run it again.
             */
            TransactionAlreadyStartedError = /** @class */ (function (_super) {
                __extends(TransactionAlreadyStartedError, _super);
                function TransactionAlreadyStartedError() {
                    var _this = _super.call(this) || this;
                    _this.name = "TransactionAlreadyStartedError";
                    _this.message = "Transaction already started for the given connection, commit current transaction before starting a new one.";
                    return _this;
                }
                return TransactionAlreadyStartedError;
            }(Error));
            exports_17("TransactionAlreadyStartedError", TransactionAlreadyStartedError);
        }
    };
});
System.register("typeorm/error/TransactionNotStartedError", [], function (exports_18, context_18) {
    "use strict";
    var __moduleName = context_18 && context_18.id;
    var TransactionNotStartedError;
    return {
        setters: [],
        execute: function () {
            /**
             * Thrown when transaction is not started yet and user tries to run commit or rollback.
             */
            TransactionNotStartedError = /** @class */ (function (_super) {
                __extends(TransactionNotStartedError, _super);
                function TransactionNotStartedError() {
                    var _this = _super.call(this) || this;
                    _this.name = "TransactionNotStartedError";
                    _this.message = "Transaction is not started yet, start transaction before committing or rolling it back.";
                    return _this;
                }
                return TransactionNotStartedError;
            }(Error));
            exports_18("TransactionNotStartedError", TransactionNotStartedError);
        }
    };
});
System.register("typeorm/metadata-args/IndexMetadataArgs", [], function (exports_19, context_19) {
    "use strict";
    var __moduleName = context_19 && context_19.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/metadata/IndexMetadata", [], function (exports_20, context_20) {
    "use strict";
    var __moduleName = context_20 && context_20.id;
    var IndexMetadata;
    return {
        setters: [],
        execute: function () {
            /**
             * Index metadata contains all information about table's index.
             */
            IndexMetadata = /** @class */ (function () {
                // ---------------------------------------------------------------------
                // Constructor
                // ---------------------------------------------------------------------
                function IndexMetadata(options) {
                    /**
                     * Indicates if this index must be unique.
                     */
                    this.isUnique = false;
                    /**
                     * Indexed columns.
                     */
                    this.columns = [];
                    /**
                     * Map of column names with order set.
                     * Used only by MongoDB driver.
                     */
                    this.columnNamesWithOrderingMap = {};
                    this.entityMetadata = options.entityMetadata;
                    this.embeddedMetadata = options.embeddedMetadata;
                    if (options.columns)
                        this.columns = options.columns;
                    if (options.args) {
                        this.target = options.args.target;
                        this.isUnique = options.args.unique;
                        this.isSparse = options.args.sparse;
                        this.givenName = options.args.name;
                        this.givenColumnNames = options.args.columns;
                    }
                }
                // ---------------------------------------------------------------------
                // Public Build Methods
                // ---------------------------------------------------------------------
                /**
                 * Builds some depend index properties.
                 * Must be called after all entity metadata's properties map, columns and relations are built.
                 */
                IndexMetadata.prototype.build = function (namingStrategy) {
                    var _this = this;
                    var map = {};
                    this.tableName = this.entityMetadata.tableName;
                    // if columns already an array of string then simply return it
                    if (this.givenColumnNames) {
                        var columnPropertyPaths = [];
                        if (this.givenColumnNames instanceof Array) {
                            columnPropertyPaths = this.givenColumnNames.map(function (columnName) {
                                if (_this.embeddedMetadata)
                                    return _this.embeddedMetadata.propertyPath + "." + columnName;
                                return columnName;
                            });
                            columnPropertyPaths.forEach(function (propertyPath) { return map[propertyPath] = 1; });
                        }
                        else { // todo: indices in embeds are not implemented in this syntax. deprecate this syntax?
                            // if columns is a function that returns array of field names then execute it and get columns names from it
                            var columnsFnResult_1 = this.givenColumnNames(this.entityMetadata.propertiesMap);
                            if (columnsFnResult_1 instanceof Array) {
                                columnPropertyPaths = columnsFnResult_1.map(function (i) { return String(i); });
                                columnPropertyPaths.forEach(function (name) { return map[name] = 1; });
                            }
                            else {
                                columnPropertyPaths = Object.keys(columnsFnResult_1).map(function (i) { return String(i); });
                                Object.keys(columnsFnResult_1).forEach(function (columnName) { return map[columnName] = columnsFnResult_1[columnName]; });
                            }
                        }
                        this.columns = columnPropertyPaths.map(function (propertyPath) {
                            var columnWithSameName = _this.entityMetadata.columns.find(function (column) { return column.propertyPath === propertyPath; });
                            if (columnWithSameName) {
                                return [columnWithSameName];
                            }
                            var relationWithSameName = _this.entityMetadata.relations.find(function (relation) { return relation.isWithJoinColumn && relation.propertyName === propertyPath; });
                            if (relationWithSameName) {
                                return relationWithSameName.joinColumns;
                            }
                            throw new Error("Index " + (_this.givenName ? "\"" + _this.givenName + "\" " : "") + "contains column that is missing in the entity: " + propertyPath);
                        })
                            .reduce(function (a, b) { return a.concat(b); });
                    }
                    this.columnNamesWithOrderingMap = Object.keys(map).reduce(function (updatedMap, key) {
                        var column = _this.entityMetadata.columns.find(function (column) { return column.propertyPath === key; });
                        if (column)
                            updatedMap[column.databaseName] = map[key];
                        return updatedMap;
                    }, {});
                    this.name = namingStrategy.indexName(this.givenName ? this.givenName : undefined, this.entityMetadata.tableName, this.columns.map(function (column) { return column.databaseName; }));
                    return this;
                };
                return IndexMetadata;
            }());
            exports_20("IndexMetadata", IndexMetadata);
        }
    };
});
System.register("typeorm/schema-builder/schema/TableIndex", [], function (exports_21, context_21) {
    "use strict";
    var __moduleName = context_21 && context_21.id;
    var TableIndex;
    return {
        setters: [],
        execute: function () {
            /**
             * Database's table index stored in this class.
             */
            TableIndex = /** @class */ (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function TableIndex(tableName, name, columnNames, isUnique) {
                    this.tableName = tableName;
                    this.name = name;
                    this.columnNames = columnNames;
                    this.isUnique = isUnique;
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Creates a new copy of this index with exactly same properties.
                 */
                TableIndex.prototype.clone = function () {
                    return new TableIndex(this.tableName, this.name, this.columnNames.map(function (name) { return name; }), this.isUnique);
                };
                // -------------------------------------------------------------------------
                // Static Methods
                // -------------------------------------------------------------------------
                /**
                 * Creates index from the index metadata object.
                 */
                TableIndex.create = function (indexMetadata) {
                    return new TableIndex(indexMetadata.entityMetadata.tableName, indexMetadata.name, indexMetadata.columns.map(function (column) { return column.databaseName; }), indexMetadata.isUnique);
                };
                return TableIndex;
            }());
            exports_21("TableIndex", TableIndex);
        }
    };
});
System.register("typeorm/schema-builder/schema/TableForeignKey", [], function (exports_22, context_22) {
    "use strict";
    var __moduleName = context_22 && context_22.id;
    var TableForeignKey;
    return {
        setters: [],
        execute: function () {
            /**
             * Foreign key from the database stored in this class.
             */
            TableForeignKey = /** @class */ (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function TableForeignKey(name, columnNames, referencedColumnNames, referencedTable, referencedTablePath, onDelete) {
                    this.name = name;
                    this.columnNames = columnNames;
                    this.referencedColumnNames = referencedColumnNames;
                    this.referencedTableName = referencedTable;
                    this.referencedTablePath = referencedTablePath;
                    this.onDelete = onDelete;
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Creates a new copy of this foreign key with exactly same properties.
                 */
                TableForeignKey.prototype.clone = function () {
                    return new TableForeignKey(this.name, this.columnNames, this.referencedColumnNames, this.referencedTableName, this.referencedTablePath);
                };
                // -------------------------------------------------------------------------
                // Static Methods
                // -------------------------------------------------------------------------
                /**
                 * Creates a new foreign schema from the given foreign key metadata.
                 */
                TableForeignKey.create = function (metadata) {
                    return new TableForeignKey(metadata.name, metadata.columnNames, metadata.referencedColumnNames, metadata.referencedTableName, metadata.referencedEntityMetadata.tablePath, metadata.onDelete);
                };
                return TableForeignKey;
            }());
            exports_22("TableForeignKey", TableForeignKey);
        }
    };
});
System.register("typeorm/schema-builder/schema/TablePrimaryKey", [], function (exports_23, context_23) {
    "use strict";
    var __moduleName = context_23 && context_23.id;
    var TablePrimaryKey;
    return {
        setters: [],
        execute: function () {
            /**
             * Primary key from the database stored in this class.
             */
            TablePrimaryKey = /** @class */ (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function TablePrimaryKey(name, columnName) {
                    this.name = name;
                    this.columnName = columnName;
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Creates a new copy of this primary key with exactly same properties.
                 */
                TablePrimaryKey.prototype.clone = function () {
                    return new TablePrimaryKey(this.name, this.columnName);
                };
                return TablePrimaryKey;
            }());
            exports_23("TablePrimaryKey", TablePrimaryKey);
        }
    };
});
System.register("typeorm/util/RandomGenerator", [], function (exports_24, context_24) {
    "use strict";
    var __moduleName = context_24 && context_24.id;
    var RandomGenerator;
    return {
        setters: [],
        execute: function () {
            RandomGenerator = /** @class */ (function () {
                function RandomGenerator() {
                }
                /**
                 *  discuss at: http://locutus.io/php/sha1/
                 * original by: Webtoolkit.info (http://www.webtoolkit.info/)
                 * improved by: Michael White (http://getsprink.com)
                 * improved by: Kevin van Zonneveld (http://kvz.io)
                 *    input by: Brett Zamir (http://brett-zamir.me)
                 *      note 1: Keep in mind that in accordance with PHP, the whole string is buffered and then
                 *      note 1: hashed. If available, we'd recommend using Node's native crypto modules directly
                 *      note 1: in a steaming fashion for faster and more efficient hashing
                 *   example 1: sha1('Kevin van Zonneveld')
                 *   returns 1: '54916d2e62f65b3afa6e192e6a601cdbe5cb5897'
                 */
                RandomGenerator.sha1 = function (str) {
                    var _rotLeft = function (n, s) {
                        var t4 = (n << s) | (n >>> (32 - s));
                        return t4;
                    };
                    var _cvtHex = function (val) {
                        var str = "";
                        var i;
                        var v;
                        for (i = 7; i >= 0; i--) {
                            v = (val >>> (i * 4)) & 0x0f;
                            str += v.toString(16);
                        }
                        return str;
                    };
                    var blockstart;
                    var i, j;
                    var W = new Array(80);
                    var H0 = 0x67452301;
                    var H1 = 0xEFCDAB89;
                    var H2 = 0x98BADCFE;
                    var H3 = 0x10325476;
                    var H4 = 0xC3D2E1F0;
                    var A, B, C, D, E;
                    var temp;
                    // utf8_encode
                    str = /*unescape*/ (encodeURIComponent(str));
                    var strLen = str.length;
                    var wordArray = [];
                    for (i = 0; i < strLen - 3; i += 4) {
                        j = str.charCodeAt(i) << 24 |
                            str.charCodeAt(i + 1) << 16 |
                            str.charCodeAt(i + 2) << 8 |
                            str.charCodeAt(i + 3);
                        wordArray.push(j);
                    }
                    switch (strLen % 4) {
                        case 0:
                            i = 0x080000000;
                            break;
                        case 1:
                            i = str.charCodeAt(strLen - 1) << 24 | 0x0800000;
                            break;
                        case 2:
                            i = str.charCodeAt(strLen - 2) << 24 | str.charCodeAt(strLen - 1) << 16 | 0x08000;
                            break;
                        case 3:
                            i = str.charCodeAt(strLen - 3) << 24 |
                                str.charCodeAt(strLen - 2) << 16 |
                                str.charCodeAt(strLen - 1) <<
                                    8 | 0x80;
                            break;
                    }
                    wordArray.push(i);
                    while ((wordArray.length % 16) !== 14) {
                        wordArray.push(0);
                    }
                    wordArray.push(strLen >>> 29);
                    wordArray.push((strLen << 3) & 0x0ffffffff);
                    for (blockstart = 0; blockstart < wordArray.length; blockstart += 16) {
                        for (i = 0; i < 16; i++) {
                            W[i] = wordArray[blockstart + i];
                        }
                        for (i = 16; i <= 79; i++) {
                            W[i] = _rotLeft(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);
                        }
                        A = H0;
                        B = H1;
                        C = H2;
                        D = H3;
                        E = H4;
                        for (i = 0; i <= 19; i++) {
                            temp = (_rotLeft(A, 5) + ((B & C) | (~B & D)) + E + W[i] + 0x5A827999) & 0x0ffffffff;
                            E = D;
                            D = C;
                            C = _rotLeft(B, 30);
                            B = A;
                            A = temp;
                        }
                        for (i = 20; i <= 39; i++) {
                            temp = (_rotLeft(A, 5) + (B ^ C ^ D) + E + W[i] + 0x6ED9EBA1) & 0x0ffffffff;
                            E = D;
                            D = C;
                            C = _rotLeft(B, 30);
                            B = A;
                            A = temp;
                        }
                        for (i = 40; i <= 59; i++) {
                            temp = (_rotLeft(A, 5) + ((B & C) | (B & D) | (C & D)) + E + W[i] + 0x8F1BBCDC) & 0x0ffffffff;
                            E = D;
                            D = C;
                            C = _rotLeft(B, 30);
                            B = A;
                            A = temp;
                        }
                        for (i = 60; i <= 79; i++) {
                            temp = (_rotLeft(A, 5) + (B ^ C ^ D) + E + W[i] + 0xCA62C1D6) & 0x0ffffffff;
                            E = D;
                            D = C;
                            C = _rotLeft(B, 30);
                            B = A;
                            A = temp;
                        }
                        H0 = (H0 + A) & 0x0ffffffff;
                        H1 = (H1 + B) & 0x0ffffffff;
                        H2 = (H2 + C) & 0x0ffffffff;
                        H3 = (H3 + D) & 0x0ffffffff;
                        H4 = (H4 + E) & 0x0ffffffff;
                    }
                    temp = _cvtHex(H0) + _cvtHex(H1) + _cvtHex(H2) + _cvtHex(H3) + _cvtHex(H4);
                    return temp.toLowerCase();
                };
                /**
                 * RFC4122 compliant UUID v4 generator.
                 */
                RandomGenerator.uuid4 = function () {
                    return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {
                        var r = Math.random() * 16 | 0, v = c === "x" ? r : (r & 0x3 | 0x8);
                        return v.toString(16);
                    });
                };
                return RandomGenerator;
            }());
            exports_24("RandomGenerator", RandomGenerator);
        }
    };
});
System.register("typeorm/platform/PlatformTools", [], function (exports_25, context_25) {
    "use strict";
    var __moduleName = context_25 && context_25.id;
    var PlatformTools, EventEmitter, Readable, Writable;
    return {
        setters: [],
        execute: function () {
            PlatformTools = /** @class */ (function () {
                /**
                 * Browser's implementation of the platform-specific tools.
                 *
                 * This file gonna replace PlatformTools for browser environment.
                 * For node.js environment this class is not getting packaged.
                 * Don't use methods of this class in the code, use PlatformTools methods instead.
                 */
                function PlatformTools() {
                }
                /**
                 * Gets global variable where global stuff can be stored.
                 */
                PlatformTools.getGlobalVariable = function () {
                    return window;
                };
                /**
                 * Loads ("require"-s) given file or package.
                 * This operation only supports on node platform
                 */
                PlatformTools.load = function (name) {
                    if (this.type === "browser")
                        throw new Error("This option/function is not supported in the browser environment. Failed operation: require(\"" + name + "\").");
                    return "";
                };
                /**
                 * Normalizes given path. Does "path.normalize".
                 */
                PlatformTools.pathNormalize = function (pathStr) {
                    if (this.type === "browser")
                        throw new Error("This option/function is not supported in the browser environment. Failed operation: path.normalize(\"" + pathStr + "\").");
                    return "";
                };
                /**
                 * Gets file extension. Does "path.extname".
                 */
                PlatformTools.pathExtname = function (pathStr) {
                    if (this.type === "browser")
                        throw new Error("This option/function is not supported in the browser environment. Failed operation: path.extname(\"" + pathStr + "\").");
                    return "";
                };
                /**
                 * Resolved given path. Does "path.resolve".
                 */
                PlatformTools.pathResolve = function (pathStr) {
                    if (this.type === "browser")
                        throw new Error("This option/function is not supported in the browser environment. Failed operation: path.resolve(\"" + pathStr + "\").");
                    return "";
                };
                /**
                 * Synchronously checks if file exist. Does "fs.existsSync".
                 */
                PlatformTools.fileExist = function (pathStr) {
                    if (this.type === "browser")
                        throw new Error("This option/function is not supported in the browser environment. Failed operation: fs.existsSync(\"" + pathStr + "\").");
                    return false;
                };
                /**
                 * Gets environment variable.
                 */
                PlatformTools.getEnvVariable = function (name) {
                    // if (this.type === "browser")
                    //     throw new Error(`This option/function is not supported in the browser environment. Failed operation: process.env["${name}"].`);
                    return undefined;
                };
                PlatformTools.readFileSync = function (filename) {
                    if (this.type === "browser")
                        throw new Error("This option/function is not supported in the browser environment. Failed operation: fs.readFileSync(\"" + filename + "\").");
                    return null;
                };
                PlatformTools.appendFileSync = function (filename, data) {
                    if (this.type === "browser")
                        throw new Error("This option/function is not supported in the browser environment. Failed operation: fs.appendFileSync(\"" + filename + "\").");
                };
                PlatformTools.writeFile = function (path, data) {
                    if (this.type === "browser")
                        throw new Error("This option/function is not supported in the browser environment. Failed operation: fs.writeFile(\"" + path + "\").");
                    return Promise.reject(null);
                };
                /**
                 * Highlights sql string to be print in the console.
                 */
                PlatformTools.highlightSql = function (sql) {
                    return sql;
                };
                /**
                 * Highlights json string to be print in the console.
                 */
                PlatformTools.highlightJson = function (json) {
                    return json;
                };
                /**
                 * Logging functions needed by AdvancedConsoleLogger (but here without chalk)
                 */
                PlatformTools.logInfo = function (prefix, info) {
                    console.info(prefix + " ", info);
                };
                PlatformTools.logError = function (prefix, error) {
                    console.error(prefix + " ", error);
                };
                PlatformTools.logWarn = function (prefix, warning) {
                    console.warn(prefix + " ", warning);
                };
                PlatformTools.log = function (message) {
                    console.log(message);
                };
                PlatformTools.warn = function (message) {
                    return message;
                };
                /**
                 * Type of the currently running platform.
                 */
                PlatformTools.type = "browser";
                return PlatformTools;
            }());
            exports_25("PlatformTools", PlatformTools);
            /**
             * These classes are needed for stream operations or
             * in the mongodb driver. both aren't supported in the browser
             */
            EventEmitter = /** @class */ (function () {
                function EventEmitter() {
                }
                return EventEmitter;
            }());
            exports_25("EventEmitter", EventEmitter);
            Readable = /** @class */ (function () {
                function Readable() {
                }
                return Readable;
            }());
            exports_25("Readable", Readable);
            Writable = /** @class */ (function () {
                function Writable() {
                }
                return Writable;
            }());
            exports_25("Writable", Writable);
        }
    };
});
System.register("typeorm/find-options/JoinOptions", [], function (exports_26, context_26) {
    "use strict";
    var __moduleName = context_26 && context_26.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/find-options/FindOneOptions", [], function (exports_27, context_27) {
    "use strict";
    var __moduleName = context_27 && context_27.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/find-options/FindManyOptions", [], function (exports_28, context_28) {
    "use strict";
    var __moduleName = context_28 && context_28.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/common/ObjectType", [], function (exports_29, context_29) {
    "use strict";
    var __moduleName = context_29 && context_29.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/error/QueryRunnerProviderAlreadyReleasedError", [], function (exports_30, context_30) {
    "use strict";
    var __moduleName = context_30 && context_30.id;
    var QueryRunnerProviderAlreadyReleasedError;
    return {
        setters: [],
        execute: function () {
            /**
             * Thrown when consumer tries to use query runner from query runner provider after it was released.
             */
            QueryRunnerProviderAlreadyReleasedError = /** @class */ (function (_super) {
                __extends(QueryRunnerProviderAlreadyReleasedError, _super);
                function QueryRunnerProviderAlreadyReleasedError() {
                    var _this = _super.call(this) || this;
                    _this.name = "QueryRunnerProviderAlreadyReleasedError";
                    _this.message = "Database connection provided by a query runner was already released, cannot continue to use its querying methods anymore.";
                    _this.stack = new Error().stack;
                    return _this;
                }
                return QueryRunnerProviderAlreadyReleasedError;
            }(Error));
            exports_30("QueryRunnerProviderAlreadyReleasedError", QueryRunnerProviderAlreadyReleasedError);
        }
    };
});
System.register("typeorm/common/DeepPartial", [], function (exports_31, context_31) {
    "use strict";
    var __moduleName = context_31 && context_31.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/repository/RemoveOptions", [], function (exports_32, context_32) {
    "use strict";
    var __moduleName = context_32 && context_32.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/repository/SaveOptions", [], function (exports_33, context_33) {
    "use strict";
    var __moduleName = context_33 && context_33.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/error/NoNeedToReleaseEntityManagerError", [], function (exports_34, context_34) {
    "use strict";
    var __moduleName = context_34 && context_34.id;
    var NoNeedToReleaseEntityManagerError;
    return {
        setters: [],
        execute: function () {
            /**
             * Thrown when consumer tries to release entity manager that does not use single database connection.
             */
            NoNeedToReleaseEntityManagerError = /** @class */ (function (_super) {
                __extends(NoNeedToReleaseEntityManagerError, _super);
                function NoNeedToReleaseEntityManagerError() {
                    var _this = _super.call(this) || this;
                    _this.name = "NoNeedToReleaseEntityManagerError";
                    _this.message = "Entity manager is not using single database connection and cannot be released. " +
                        "Only entity managers created by connection#createEntityManagerWithSingleDatabaseConnection " +
                        "methods have a single database connection and they should be released.";
                    _this.stack = new Error().stack;
                    return _this;
                }
                return NoNeedToReleaseEntityManagerError;
            }(Error));
            exports_34("NoNeedToReleaseEntityManagerError", NoNeedToReleaseEntityManagerError);
        }
    };
});
System.register("typeorm/repository/Repository", [], function (exports_35, context_35) {
    "use strict";
    var __moduleName = context_35 && context_35.id;
    var Repository;
    return {
        setters: [],
        execute: function () {
            /**
             * Repository is supposed to work with your entity objects. Find entities, insert, update, delete, etc.
             */
            Repository = /** @class */ (function () {
                function Repository() {
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Creates a new query builder that can be used to build a sql query.
                 */
                Repository.prototype.createQueryBuilder = function (alias, queryRunner) {
                    return this.manager.createQueryBuilder(this.metadata.target, alias || this.metadata.targetName, queryRunner || this.queryRunner);
                };
                Object.defineProperty(Repository.prototype, "target", {
                    /**
                     * Returns object that is managed by this repository.
                     * If this repository manages entity from schema,
                     * then it returns a name of that schema instead.
                     */
                    get: function () {
                        return this.metadata.target;
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Checks if entity has an id.
                 * If entity composite compose ids, it will check them all.
                 */
                Repository.prototype.hasId = function (entity) {
                    return this.manager.hasId(this.metadata.target, entity);
                };
                /**
                 * Gets entity mixed id.
                 */
                Repository.prototype.getId = function (entity) {
                    return this.manager.getId(this.metadata.target, entity);
                };
                /**
                 * Creates a new entity instance or instances.
                 * Can copy properties from the given object into new entities.
                 */
                Repository.prototype.create = function (plainEntityLikeOrPlainEntityLikes) {
                    return this.manager.create(this.metadata.target, plainEntityLikeOrPlainEntityLikes);
                };
                /**
                 * Merges multiple entities (or entity-like objects) into a given entity.
                 */
                Repository.prototype.merge = function (mergeIntoEntity) {
                    var entityLikes = [];
                    for (var _i = 1; _i < arguments.length; _i++) {
                        entityLikes[_i - 1] = arguments[_i];
                    }
                    return (_a = this.manager).merge.apply(_a, [this.metadata.target, mergeIntoEntity].concat(entityLikes));
                    var _a;
                };
                /**
                 * Creates a new entity from the given plan javascript object. If entity already exist in the database, then
                 * it loads it (and everything related to it), replaces all values with the new ones from the given object
                 * and returns this new entity. This new entity is actually a loaded from the db entity with all properties
                 * replaced from the new object.
                 *
                 * Note that given entity-like object must have an entity id / primary key to find entity by.
                 * Returns undefined if entity with given id was not found.
                 */
                Repository.prototype.preload = function (entityLike) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            return [2 /*return*/, this.manager.preload(this.metadata.target, entityLike)];
                        });
                    });
                };
                /**
                 * Saves one or many given entities.
                 */
                Repository.prototype.save = function (entityOrEntities, options) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            return [2 /*return*/, this.manager.save(this.metadata.target, entityOrEntities, options)];
                        });
                    });
                };
                /**
                 * Inserts a given entity into the database.
                 * Unlike save method executes a primitive operation without cascades, relations and other operations included.
                 * Does not modify source entity and does not execute listeners and subscribers.
                 * Executes fast and efficient INSERT query.
                 * Does not check if entity exist in the database, so query will fail if duplicate entity is being inserted.
                 */
                Repository.prototype.insert = function (entity, options) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            return [2 /*return*/, this.manager.insert(this.metadata.target, entity, options)];
                        });
                    });
                };
                /**
                 * Updates entity partially. Entity can be found by a given conditions.
                 */
                Repository.prototype.update = function (conditions, partialEntity, options) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            return [2 /*return*/, this.manager.update(this.metadata.target, conditions, partialEntity, options)];
                        });
                    });
                };
                /**
                 * Updates entity partially. Entity will be found by a given id.
                 */
                Repository.prototype.updateById = function (id, partialEntity, options) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            return [2 /*return*/, this.manager.updateById(this.metadata.target, id, partialEntity, options)];
                        });
                    });
                };
                /**
                 * Removes one or many given entities.
                 */
                Repository.prototype.remove = function (entityOrEntities, options) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            return [2 /*return*/, this.manager.remove(this.metadata.target, entityOrEntities, options)];
                        });
                    });
                };
                /**
                 * Deletes entities by a given conditions.
                 * Unlike save method executes a primitive operation without cascades, relations and other operations included.
                 * Does not modify source entity and does not execute listeners and subscribers.
                 * Executes fast and efficient DELETE query.
                 * Does not check if entity exist in the database.
                 */
                Repository.prototype.delete = function (conditions, options) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            return [2 /*return*/, this.manager.delete(this.metadata.target, conditions, options)];
                        });
                    });
                };
                /**
                 * Deletes entities by a given conditions.
                 * Unlike save method executes a primitive operation without cascades, relations and other operations included.
                 * Does not modify source entity and does not execute listeners and subscribers.
                 * Executes fast and efficient DELETE query.
                 * Does not check if entity exist in the database.
                 */
                Repository.prototype.deleteById = function (id, options) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            return [2 /*return*/, this.manager.deleteById(this.metadata.target, id, options)];
                        });
                    });
                };
                /**
                 * Removes entity by a given entity id.
                 *
                 * @deprecated use deleteById method instead.
                 */
                Repository.prototype.removeById = function (id, options) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            return [2 /*return*/, this.manager.deleteById(this.metadata.target, id, options)];
                        });
                    });
                };
                /**
                 * Removes entity by a given entity id.
                 *
                 * @deprecated use deleteById method instead.
                 */
                Repository.prototype.removeByIds = function (ids, options) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            return [2 /*return*/, this.manager.removeByIds(this.metadata.target, ids, options)];
                        });
                    });
                };
                /**
                 * Counts entities that match given find options or conditions.
                 */
                Repository.prototype.count = function (optionsOrConditions) {
                    return this.manager.count(this.metadata.target, optionsOrConditions);
                };
                /**
                 * Finds entities that match given find options or conditions.
                 */
                Repository.prototype.find = function (optionsOrConditions) {
                    return this.manager.find(this.metadata.target, optionsOrConditions);
                };
                /**
                 * Finds entities that match given find options or conditions.
                 * Also counts all entities that match given conditions,
                 * but ignores pagination settings (from and take options).
                 */
                Repository.prototype.findAndCount = function (optionsOrConditions) {
                    return this.manager.findAndCount(this.metadata.target, optionsOrConditions);
                };
                /**
                 * Finds entities by ids.
                 * Optionally find options can be applied.
                 */
                Repository.prototype.findByIds = function (ids, optionsOrConditions) {
                    return this.manager.findByIds(this.metadata.target, ids, optionsOrConditions);
                };
                /**
                 * Finds first entity that matches given conditions.
                 */
                Repository.prototype.findOne = function (optionsOrConditions) {
                    return this.manager.findOne(this.metadata.target, optionsOrConditions);
                };
                /**
                 * Finds entity by given id.
                 * Optionally find options or conditions can be applied.
                 */
                Repository.prototype.findOneById = function (id, optionsOrConditions) {
                    return this.manager.findOneById(this.metadata.target, id, optionsOrConditions);
                };
                /**
                 * Executes a raw SQL query and returns a raw database results.
                 * Raw query execution is supported only by relational databases (MongoDB is not supported).
                 */
                Repository.prototype.query = function (query, parameters) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            return [2 /*return*/, this.manager.query(query, parameters)];
                        });
                    });
                };
                /**
                 * Clears all the data from the given table/collection (truncates/drops it).
                 *
                 * Note: this method uses TRUNCATE and may not work as you expect in transactions on some platforms.
                 * @see https://stackoverflow.com/a/5972738/925151
                 */
                Repository.prototype.clear = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            return [2 /*return*/, this.manager.clear(this.metadata.target)];
                        });
                    });
                };
                return Repository;
            }());
            exports_35("Repository", Repository);
        }
    };
});
System.register("typeorm/driver/mongodb/typings", ["typeorm/platform/PlatformTools"], function (exports_36, context_36) {
    "use strict";
    var __moduleName = context_36 && context_36.id;
    var PlatformTools_1;
    return {
        setters: [
            function (PlatformTools_1_1) {
                PlatformTools_1 = PlatformTools_1_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/driver/mongodb/MongoQueryRunner", [], function (exports_37, context_37) {
    "use strict";
    var __moduleName = context_37 && context_37.id;
    var MongoQueryRunner;
    return {
        setters: [],
        execute: function () {
            /**
             * Runs queries on a single MongoDB connection.
             */
            MongoQueryRunner = /** @class */ (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function MongoQueryRunner(connection, databaseConnection) {
                    /**
                     * Indicates if connection for this query runner is released.
                     * Once its released, query runner cannot run queries anymore.
                     * Always false for mongodb since mongodb has a single query executor instance.
                     */
                    this.isReleased = false;
                    /**
                     * Indicates if transaction is active in this query executor.
                     * Always false for mongodb since mongodb does not support transactions.
                     */
                    this.isTransactionActive = false;
                    /**
                     * Stores temporarily user data.
                     * Useful for sharing data with subscribers.
                     */
                    this.data = {};
                    this.connection = connection;
                    this.databaseConnection = databaseConnection;
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Creates a cursor for a query that can be used to iterate over results from MongoDB.
                 */
                MongoQueryRunner.prototype.cursor = function (collectionName, query) {
                    return this.getCollection(collectionName).find(query || {});
                };
                /**
                 * Execute an aggregation framework pipeline against the collection.
                 */
                MongoQueryRunner.prototype.aggregate = function (collectionName, pipeline, options) {
                    return this.getCollection(collectionName).aggregate(pipeline, options);
                };
                /**
                 * Perform a bulkWrite operation without a fluent API.
                 */
                MongoQueryRunner.prototype.bulkWrite = function (collectionName, operations, options) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.getCollection(collectionName).bulkWrite(operations, options)];
                                case 1: return [2 /*return*/, _a.sent()];
                            }
                        });
                    });
                };
                /**
                 * Count number of matching documents in the db to a query.
                 */
                MongoQueryRunner.prototype.count = function (collectionName, query, options) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.getCollection(collectionName).count(query || {}, options)];
                                case 1: return [2 /*return*/, _a.sent()];
                            }
                        });
                    });
                };
                /**
                 * Creates an index on the db and collection.
                 */
                MongoQueryRunner.prototype.createCollectionIndex = function (collectionName, fieldOrSpec, options) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.getCollection(collectionName).createIndex(fieldOrSpec, options)];
                                case 1: return [2 /*return*/, _a.sent()];
                            }
                        });
                    });
                };
                /**
                 * Creates multiple indexes in the collection, this method is only supported for MongoDB 2.6 or higher.
                 * Earlier version of MongoDB will throw a command not supported error. Index specifications are defined at http://docs.mongodb.org/manual/reference/command/createIndexes/.
                 */
                MongoQueryRunner.prototype.createCollectionIndexes = function (collectionName, indexSpecs) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.getCollection(collectionName).createIndexes(indexSpecs)];
                                case 1: return [2 /*return*/, _a.sent()];
                            }
                        });
                    });
                };
                /**
                 * Delete multiple documents on MongoDB.
                 */
                MongoQueryRunner.prototype.deleteMany = function (collectionName, query, options) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.getCollection(collectionName).deleteMany(query, options)];
                                case 1: return [2 /*return*/, _a.sent()];
                            }
                        });
                    });
                };
                /**
                 * Delete a document on MongoDB.
                 */
                MongoQueryRunner.prototype.deleteOne = function (collectionName, query, options) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.getCollection(collectionName).deleteOne(query, options)];
                                case 1: return [2 /*return*/, _a.sent()];
                            }
                        });
                    });
                };
                /**
                 * The distinct command returns returns a list of distinct values for the given key across a collection.
                 */
                MongoQueryRunner.prototype.distinct = function (collectionName, key, query, options) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.getCollection(collectionName).distinct(key, query, options)];
                                case 1: return [2 /*return*/, _a.sent()];
                            }
                        });
                    });
                };
                /**
                 * Drops an index from this collection.
                 */
                MongoQueryRunner.prototype.dropCollectionIndex = function (collectionName, indexName, options) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.getCollection(collectionName).dropIndex(indexName, options)];
                                case 1: return [2 /*return*/, _a.sent()];
                            }
                        });
                    });
                };
                /**
                 * Drops all indexes from the collection.
                 */
                MongoQueryRunner.prototype.dropCollectionIndexes = function (collectionName) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.getCollection(collectionName).dropIndexes()];
                                case 1: return [2 /*return*/, _a.sent()];
                            }
                        });
                    });
                };
                /**
                 * Find a document and delete it in one atomic operation, requires a write lock for the duration of the operation.
                 */
                MongoQueryRunner.prototype.findOneAndDelete = function (collectionName, query, options) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.getCollection(collectionName).findOneAndDelete(query, options)];
                                case 1: return [2 /*return*/, _a.sent()];
                            }
                        });
                    });
                };
                /**
                 * Find a document and replace it in one atomic operation, requires a write lock for the duration of the operation.
                 */
                MongoQueryRunner.prototype.findOneAndReplace = function (collectionName, query, replacement, options) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.getCollection(collectionName).findOneAndReplace(query, replacement, options)];
                                case 1: return [2 /*return*/, _a.sent()];
                            }
                        });
                    });
                };
                /**
                 * Find a document and update it in one atomic operation, requires a write lock for the duration of the operation.
                 */
                MongoQueryRunner.prototype.findOneAndUpdate = function (collectionName, query, update, options) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.getCollection(collectionName).findOneAndUpdate(query, update, options)];
                                case 1: return [2 /*return*/, _a.sent()];
                            }
                        });
                    });
                };
                /**
                 * Execute a geo search using a geo haystack index on a collection.
                 */
                MongoQueryRunner.prototype.geoHaystackSearch = function (collectionName, x, y, options) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.getCollection(collectionName).geoHaystackSearch(x, y, options)];
                                case 1: return [2 /*return*/, _a.sent()];
                            }
                        });
                    });
                };
                /**
                 * Execute the geoNear command to search for items in the collection.
                 */
                MongoQueryRunner.prototype.geoNear = function (collectionName, x, y, options) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.getCollection(collectionName).geoNear(x, y, options)];
                                case 1: return [2 /*return*/, _a.sent()];
                            }
                        });
                    });
                };
                /**
                 * Run a group command across a collection.
                 */
                MongoQueryRunner.prototype.group = function (collectionName, keys, condition, initial, reduce, finalize, command, options) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.getCollection(collectionName).group(keys, condition, initial, reduce, finalize, command, options)];
                                case 1: return [2 /*return*/, _a.sent()];
                            }
                        });
                    });
                };
                /**
                 * Retrieve all the indexes on the collection.
                 */
                MongoQueryRunner.prototype.collectionIndexes = function (collectionName) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.getCollection(collectionName).indexes()];
                                case 1: return [2 /*return*/, _a.sent()];
                            }
                        });
                    });
                };
                /**
                 * Retrieve all the indexes on the collection.
                 */
                MongoQueryRunner.prototype.collectionIndexExists = function (collectionName, indexes) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.getCollection(collectionName).indexExists(indexes)];
                                case 1: return [2 /*return*/, _a.sent()];
                            }
                        });
                    });
                };
                /**
                 * Retrieves this collections index info.
                 */
                MongoQueryRunner.prototype.collectionIndexInformation = function (collectionName, options) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.getCollection(collectionName).indexInformation(options)];
                                case 1: return [2 /*return*/, _a.sent()];
                            }
                        });
                    });
                };
                /**
                 * Initiate an In order bulk write operation, operations will be serially executed in the order they are added, creating a new operation for each switch in types.
                 */
                MongoQueryRunner.prototype.initializeOrderedBulkOp = function (collectionName, options) {
                    return this.getCollection(collectionName).initializeOrderedBulkOp(options);
                };
                /**
                 * Initiate a Out of order batch write operation. All operations will be buffered into insert/update/remove commands executed out of order.
                 */
                MongoQueryRunner.prototype.initializeUnorderedBulkOp = function (collectionName, options) {
                    return this.getCollection(collectionName).initializeUnorderedBulkOp(options);
                };
                /**
                 * Inserts an array of documents into MongoDB.
                 */
                MongoQueryRunner.prototype.insertMany = function (collectionName, docs, options) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.getCollection(collectionName).insertMany(docs, options)];
                                case 1: return [2 /*return*/, _a.sent()];
                            }
                        });
                    });
                };
                /**
                 * Inserts a single document into MongoDB.
                 */
                MongoQueryRunner.prototype.insertOne = function (collectionName, doc, options) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.getCollection(collectionName).insertOne(doc, options)];
                                case 1: return [2 /*return*/, _a.sent()];
                            }
                        });
                    });
                };
                /**
                 * Returns if the collection is a capped collection.
                 */
                MongoQueryRunner.prototype.isCapped = function (collectionName) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.getCollection(collectionName).isCapped()];
                                case 1: return [2 /*return*/, _a.sent()];
                            }
                        });
                    });
                };
                /**
                 * Get the list of all indexes information for the collection.
                 */
                MongoQueryRunner.prototype.listCollectionIndexes = function (collectionName, options) {
                    return this.getCollection(collectionName).listIndexes(options);
                };
                /**
                 * Run Map Reduce across a collection. Be aware that the inline option for out will return an array of results not a collection.
                 */
                MongoQueryRunner.prototype.mapReduce = function (collectionName, map, reduce, options) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.getCollection(collectionName).mapReduce(map, reduce, options)];
                                case 1: return [2 /*return*/, _a.sent()];
                            }
                        });
                    });
                };
                /**
                 * Return N number of parallel cursors for a collection allowing parallel reading of entire collection.
                 * There are no ordering guarantees for returned results.
                 */
                MongoQueryRunner.prototype.parallelCollectionScan = function (collectionName, options) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.getCollection(collectionName).parallelCollectionScan(options)];
                                case 1: return [2 /*return*/, _a.sent()];
                            }
                        });
                    });
                };
                /**
                 * Reindex all indexes on the collection Warning: reIndex is a blocking operation (indexes are rebuilt in the foreground) and will be slow for large collections.
                 */
                MongoQueryRunner.prototype.reIndex = function (collectionName) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.getCollection(collectionName).reIndex()];
                                case 1: return [2 /*return*/, _a.sent()];
                            }
                        });
                    });
                };
                /**
                 * Reindex all indexes on the collection Warning: reIndex is a blocking operation (indexes are rebuilt in the foreground) and will be slow for large collections.
                 */
                MongoQueryRunner.prototype.rename = function (collectionName, newName, options) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.getCollection(collectionName).rename(newName, options)];
                                case 1: return [2 /*return*/, _a.sent()];
                            }
                        });
                    });
                };
                /**
                 * Replace a document on MongoDB.
                 */
                MongoQueryRunner.prototype.replaceOne = function (collectionName, query, doc, options) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.getCollection(collectionName).replaceOne(query, doc, options)];
                                case 1: return [2 /*return*/, _a.sent()];
                            }
                        });
                    });
                };
                /**
                 * Get all the collection statistics.
                 */
                MongoQueryRunner.prototype.stats = function (collectionName, options) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.getCollection(collectionName).stats(options)];
                                case 1: return [2 /*return*/, _a.sent()];
                            }
                        });
                    });
                };
                /**
                 * Update multiple documents on MongoDB.
                 */
                MongoQueryRunner.prototype.updateMany = function (collectionName, query, update, options) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.getCollection(collectionName).updateMany(query, update, options)];
                                case 1: return [2 /*return*/, _a.sent()];
                            }
                        });
                    });
                };
                /**
                 * Update a single document on MongoDB.
                 */
                MongoQueryRunner.prototype.updateOne = function (collectionName, query, update, options) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.getCollection(collectionName).updateOne(query, update, options)];
                                case 1: return [2 /*return*/, _a.sent()];
                            }
                        });
                    });
                };
                // -------------------------------------------------------------------------
                // Public Implemented Methods (from QueryRunner)
                // -------------------------------------------------------------------------
                /**
                 * Removes all collections from the currently connected database.
                 * Be careful with using this method and avoid using it in production or migrations
                 * (because it can clear all your database).
                 */
                MongoQueryRunner.prototype.clearDatabase = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.databaseConnection.dropDatabase()];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * For MongoDB database we don't create connection, because its single connection already created by a driver.
                 */
                MongoQueryRunner.prototype.connect = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            return [2 /*return*/];
                        });
                    });
                };
                /**
                 * For MongoDB database we don't release connection, because its single connection.
                 */
                MongoQueryRunner.prototype.release = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            return [2 /*return*/];
                        });
                    });
                };
                /**
                 * Starts transaction.
                 */
                MongoQueryRunner.prototype.startTransaction = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            return [2 /*return*/];
                        });
                    });
                };
                /**
                 * Commits transaction.
                 */
                MongoQueryRunner.prototype.commitTransaction = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            return [2 /*return*/];
                        });
                    });
                };
                /**
                 * Rollbacks transaction.
                 */
                MongoQueryRunner.prototype.rollbackTransaction = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            return [2 /*return*/];
                        });
                    });
                };
                /**
                 * Executes a given SQL query.
                 */
                MongoQueryRunner.prototype.query = function (query, parameters) {
                    throw new Error("Executing SQL query is not supported by MongoDB driver.");
                };
                /**
                 * Returns raw data stream.
                 */
                MongoQueryRunner.prototype.stream = function (query, parameters, onEnd, onError) {
                    throw new Error("Stream is not supported by MongoDB driver.");
                };
                /**
                 * Insert a new row with given values into the given table.
                 * Returns value of inserted object id.
                 */
                MongoQueryRunner.prototype.insert = function (collectionName, keyValues) {
                    return __awaiter(this, void 0, void 0, function () {
                        var results, generatedMap;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.databaseConnection
                                        .collection(collectionName)
                                        .insertOne(keyValues)];
                                case 1:
                                    results = _a.sent();
                                    generatedMap = this.connection.getMetadata(collectionName).objectIdColumn.createValueMap(results.insertedId);
                                    return [2 /*return*/, {
                                            result: results,
                                            generatedMap: generatedMap
                                        }];
                            }
                        });
                    });
                };
                /**
                 * Updates rows that match given conditions in the given table.
                 */
                MongoQueryRunner.prototype.update = function (collectionName, valuesMap, conditions) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.databaseConnection
                                        .collection(collectionName)
                                        .updateOne(conditions, valuesMap)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Deletes from the given table by a given conditions.
                 */
                MongoQueryRunner.prototype.delete = function (collectionName, conditions, maybeParameters) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (typeof conditions === "string")
                                        throw new Error("String condition is not supported by MongoDB driver.");
                                    return [4 /*yield*/, this.databaseConnection
                                            .collection(collectionName)
                                            .deleteOne(conditions)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Inserts rows into the closure table.
                 */
                MongoQueryRunner.prototype.insertIntoClosureTable = function (collectionName, newEntityId, parentId, hasLevel) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            throw new Error("Schema update queries are not supported by MongoDB driver.");
                        });
                    });
                };
                /**
                 * Loads given table's data from the database.
                 */
                MongoQueryRunner.prototype.getTable = function (collectionName) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            throw new Error("Schema update queries are not supported by MongoDB driver.");
                        });
                    });
                };
                /**
                 * Loads all tables (with given names) from the database and creates a Table from them.
                 */
                MongoQueryRunner.prototype.getTables = function (collectionNames) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            throw new Error("Schema update queries are not supported by MongoDB driver.");
                        });
                    });
                };
                /**
                 * Checks if database with the given name exist.
                 */
                MongoQueryRunner.prototype.hasDatabase = function (database) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            throw new Error("Check database queries are not supported by MongoDB driver.");
                        });
                    });
                };
                /**
                 * Checks if table with the given name exist in the database.
                 */
                MongoQueryRunner.prototype.hasTable = function (collectionName) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            throw new Error("Check schema queries are not supported by MongoDB driver.");
                        });
                    });
                };
                /**
                 * Creates a database if it's not created.
                 */
                MongoQueryRunner.prototype.createDatabase = function (database) {
                    throw new Error("Database create queries are not supported by MongoDB driver.");
                };
                /**
                 * Creates a schema if it's not created.
                 */
                MongoQueryRunner.prototype.createSchema = function (schemas) {
                    throw new Error("Schema create queries are not supported by MongoDB driver.");
                };
                /**
                 * Creates a new table from the given table and columns inside it.
                 */
                MongoQueryRunner.prototype.createTable = function (table) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            throw new Error("Schema update queries are not supported by MongoDB driver.");
                        });
                    });
                };
                /**
                 * Drops the table.
                 */
                MongoQueryRunner.prototype.dropTable = function (tableName) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            throw new Error("Schema update queries are not supported by MongoDB driver.");
                        });
                    });
                };
                /**
                 * Checks if column with the given name exist in the given table.
                 */
                MongoQueryRunner.prototype.hasColumn = function (collectionName, columnName) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            throw new Error("Schema update queries are not supported by MongoDB driver.");
                        });
                    });
                };
                /**
                 * Creates a new column from the column in the table.
                 */
                MongoQueryRunner.prototype.addColumn = function (tableOrName, column) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            throw new Error("Schema update queries are not supported by MongoDB driver.");
                        });
                    });
                };
                /**
                 * Creates a new columns from the column in the table.
                 */
                MongoQueryRunner.prototype.addColumns = function (tableOrName, columns) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            throw new Error("Schema update queries are not supported by MongoDB driver.");
                        });
                    });
                };
                /**
                 * Renames column in the given table.
                 */
                MongoQueryRunner.prototype.renameColumn = function (tableOrName, oldTableColumnOrName, newTableColumnOrName) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            throw new Error("Schema update queries are not supported by MongoDB driver.");
                        });
                    });
                };
                /**
                 * Changes a column in the table.
                 */
                MongoQueryRunner.prototype.changeColumn = function (tableOrName, oldTableColumnOrName, newColumn) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            throw new Error("Schema update queries are not supported by MongoDB driver.");
                        });
                    });
                };
                /**
                 * Changes a column in the table.
                 */
                MongoQueryRunner.prototype.changeColumns = function (table, changedColumns) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            throw new Error("Schema update queries are not supported by MongoDB driver.");
                        });
                    });
                };
                /**
                 * Drops column in the table.
                 */
                MongoQueryRunner.prototype.dropColumn = function (table, column) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            throw new Error("Schema update queries are not supported by MongoDB driver.");
                        });
                    });
                };
                /**
                 * Drops the columns in the table.
                 */
                MongoQueryRunner.prototype.dropColumns = function (table, columns) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            throw new Error("Schema update queries are not supported by MongoDB driver.");
                        });
                    });
                };
                /**
                 * Updates table's primary keys.
                 */
                MongoQueryRunner.prototype.updatePrimaryKeys = function (table) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            throw new Error("Schema update queries are not supported by MongoDB driver.");
                        });
                    });
                };
                /**
                 * Creates a new foreign key.
                 */
                MongoQueryRunner.prototype.createForeignKey = function (tableOrName, foreignKey) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            throw new Error("Schema update queries are not supported by MongoDB driver.");
                        });
                    });
                };
                /**
                 * Creates a new foreign keys.
                 */
                MongoQueryRunner.prototype.createForeignKeys = function (tableOrName, foreignKeys) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            throw new Error("Schema update queries are not supported by MongoDB driver.");
                        });
                    });
                };
                /**
                 * Drops a foreign key from the table.
                 */
                MongoQueryRunner.prototype.dropForeignKey = function (tableOrName, foreignKey) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            throw new Error("Schema update queries are not supported by MongoDB driver.");
                        });
                    });
                };
                /**
                 * Drops a foreign keys from the table.
                 */
                MongoQueryRunner.prototype.dropForeignKeys = function (tableOrName, foreignKeys) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            throw new Error("Schema update queries are not supported by MongoDB driver.");
                        });
                    });
                };
                /**
                 * Creates a new index.
                 */
                MongoQueryRunner.prototype.createIndex = function (collectionName, index) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            throw new Error("Schema update queries are not supported by MongoDB driver.");
                        });
                    });
                };
                /**
                 * Drops an index from the table.
                 */
                MongoQueryRunner.prototype.dropIndex = function (collectionName, indexName) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            throw new Error("Schema update queries are not supported by MongoDB driver.");
                        });
                    });
                };
                /**
                 * Drops collection.
                 */
                MongoQueryRunner.prototype.truncate = function (collectionName) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.databaseConnection
                                        .dropCollection(collectionName)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Enables special query runner mode in which sql queries won't be executed,
                 * instead they will be memorized into a special variable inside query runner.
                 * You can get memorized sql using getMemorySql() method.
                 */
                MongoQueryRunner.prototype.enableSqlMemory = function () {
                    throw new Error("This operation is not supported by MongoDB driver.");
                };
                /**
                 * Disables special query runner mode in which sql queries won't be executed
                 * started by calling enableSqlMemory() method.
                 *
                 * Previously memorized sql will be flushed.
                 */
                MongoQueryRunner.prototype.disableSqlMemory = function () {
                    throw new Error("This operation is not supported by MongoDB driver.");
                };
                /**
                 * Gets sql stored in the memory. Parameters in the sql are already replaced.
                 */
                MongoQueryRunner.prototype.getMemorySql = function () {
                    throw new Error("This operation is not supported by MongoDB driver.");
                };
                // -------------------------------------------------------------------------
                // Protected Methods
                // -------------------------------------------------------------------------
                /**
                 * Gets collection from the database with a given name.
                 */
                MongoQueryRunner.prototype.getCollection = function (collectionName) {
                    return this.databaseConnection.collection(collectionName);
                };
                return MongoQueryRunner;
            }());
            exports_37("MongoQueryRunner", MongoQueryRunner);
        }
    };
});
System.register("typeorm/metadata/types/TableTypes", [], function (exports_38, context_38) {
    "use strict";
    var __moduleName = context_38 && context_38.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/entity-schema/EntitySchemaTable", [], function (exports_39, context_39) {
    "use strict";
    var __moduleName = context_39 && context_39.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/entity-schema/EntitySchemaIndex", [], function (exports_40, context_40) {
    "use strict";
    var __moduleName = context_40 && context_40.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/entity-schema/EntitySchemaColumn", [], function (exports_41, context_41) {
    "use strict";
    var __moduleName = context_41 && context_41.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/options/JoinColumnOptions", [], function (exports_42, context_42) {
    "use strict";
    var __moduleName = context_42 && context_42.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/options/JoinTableMuplipleColumnsOptions", [], function (exports_43, context_43) {
    "use strict";
    var __moduleName = context_43 && context_43.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/entity-schema/EntitySchemaRelation", [], function (exports_44, context_44) {
    "use strict";
    var __moduleName = context_44 && context_44.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/entity-schema/EntitySchema", [], function (exports_45, context_45) {
    "use strict";
    var __moduleName = context_45 && context_45.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/logger/LoggerOptions", [], function (exports_46, context_46) {
    "use strict";
    var __moduleName = context_46 && context_46.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/driver/types/DatabaseType", [], function (exports_47, context_47) {
    "use strict";
    var __moduleName = context_47 && context_47.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/logger/Logger", [], function (exports_48, context_48) {
    "use strict";
    var __moduleName = context_48 && context_48.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/connection/BaseConnectionOptions", [], function (exports_49, context_49) {
    "use strict";
    var __moduleName = context_49 && context_49.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/driver/mongodb/MongoConnectionOptions", [], function (exports_50, context_50) {
    "use strict";
    var __moduleName = context_50 && context_50.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/driver/types/MappedColumnTypes", [], function (exports_51, context_51) {
    "use strict";
    var __moduleName = context_51 && context_51.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/schema-builder/SchemaBuilder", [], function (exports_52, context_52) {
    "use strict";
    var __moduleName = context_52 && context_52.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/schema-builder/MongoSchemaBuilder", [], function (exports_53, context_53) {
    "use strict";
    var __moduleName = context_53 && context_53.id;
    var MongoSchemaBuilder;
    return {
        setters: [],
        execute: function () {
            /**
             * Creates complete tables schemas in the database based on the entity metadatas.
             *
             * Steps how schema is being built:
             * 1. load list of all tables with complete column and keys information from the db
             * 2. drop all (old) foreign keys that exist in the table, but does not exist in the metadata
             * 3. create new tables that does not exist in the db, but exist in the metadata
             * 4. drop all columns exist (left old) in the db table, but does not exist in the metadata
             * 5. add columns from metadata which does not exist in the table
             * 6. update all exist columns which metadata has changed
             * 7. update primary keys - update old and create new primary key from changed columns
             * 8. create foreign keys which does not exist in the table yet
             * 9. create indices which are missing in db yet, and drops indices which exist in the db, but does not exist in the metadata anymore
             */
            MongoSchemaBuilder = /** @class */ (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function MongoSchemaBuilder(connection) {
                    this.connection = connection;
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Creates complete schemas for the given entity metadatas.
                 */
                MongoSchemaBuilder.prototype.build = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var queryRunner, promises;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    queryRunner = this.connection.driver.createQueryRunner();
                                    promises = [];
                                    this.connection.entityMetadatas.forEach(function (metadata) {
                                        metadata.indices.forEach(function (index) {
                                            var options = { name: index.name, unique: index.isUnique, sparse: index.isSparse };
                                            promises.push(queryRunner.createCollectionIndex(metadata.tableName, index.columnNamesWithOrderingMap, options));
                                        });
                                    });
                                    return [4 /*yield*/, Promise.all(promises)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Returns query to be executed by schema builder.
                 */
                MongoSchemaBuilder.prototype.log = function () {
                    return Promise.resolve([]);
                };
                return MongoSchemaBuilder;
            }());
            exports_53("MongoSchemaBuilder", MongoSchemaBuilder);
        }
    };
});
System.register("typeorm/driver/types/DataTypeDefaults", [], function (exports_54, context_54) {
    "use strict";
    var __moduleName = context_54 && context_54.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/driver/mysql/MysqlConnectionCredentialsOptions", [], function (exports_55, context_55) {
    "use strict";
    var __moduleName = context_55 && context_55.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/driver/mysql/MysqlConnectionOptions", [], function (exports_56, context_56) {
    "use strict";
    var __moduleName = context_56 && context_56.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/driver/postgres/PostgresConnectionCredentialsOptions", [], function (exports_57, context_57) {
    "use strict";
    var __moduleName = context_57 && context_57.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/driver/postgres/PostgresConnectionOptions", [], function (exports_58, context_58) {
    "use strict";
    var __moduleName = context_58 && context_58.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/driver/sqlite/SqliteConnectionOptions", [], function (exports_59, context_59) {
    "use strict";
    var __moduleName = context_59 && context_59.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/driver/sqlserver/SqlServerConnectionCredentialsOptions", [], function (exports_60, context_60) {
    "use strict";
    var __moduleName = context_60 && context_60.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/driver/sqlserver/SqlServerConnectionOptions", [], function (exports_61, context_61) {
    "use strict";
    var __moduleName = context_61 && context_61.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/driver/oracle/OracleConnectionCredentialsOptions", [], function (exports_62, context_62) {
    "use strict";
    var __moduleName = context_62 && context_62.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/driver/oracle/OracleConnectionOptions", [], function (exports_63, context_63) {
    "use strict";
    var __moduleName = context_63 && context_63.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/driver/websql/WebSqlConnectionOptions", [], function (exports_64, context_64) {
    "use strict";
    var __moduleName = context_64 && context_64.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/driver/cordova/CordovaConnectionOptions", [], function (exports_65, context_65) {
    "use strict";
    var __moduleName = context_65 && context_65.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/driver/sqljs/SqljsConnectionOptions", [], function (exports_66, context_66) {
    "use strict";
    var __moduleName = context_66 && context_66.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/connection/ConnectionOptions", [], function (exports_67, context_67) {
    "use strict";
    var __moduleName = context_67 && context_67.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/driver/mongodb/MongoDriver", ["typeorm/error/ConnectionIsNotSetError", "typeorm/error/DriverPackageNotInstalledError", "typeorm/driver/mongodb/MongoQueryRunner", "typeorm/platform/PlatformTools", "typeorm/schema-builder/MongoSchemaBuilder"], function (exports_68, context_68) {
    "use strict";
    var __moduleName = context_68 && context_68.id;
    var ConnectionIsNotSetError_1, DriverPackageNotInstalledError_1, MongoQueryRunner_1, PlatformTools_2, MongoSchemaBuilder_1, MongoDriver;
    return {
        setters: [
            function (ConnectionIsNotSetError_1_1) {
                ConnectionIsNotSetError_1 = ConnectionIsNotSetError_1_1;
            },
            function (DriverPackageNotInstalledError_1_1) {
                DriverPackageNotInstalledError_1 = DriverPackageNotInstalledError_1_1;
            },
            function (MongoQueryRunner_1_1) {
                MongoQueryRunner_1 = MongoQueryRunner_1_1;
            },
            function (PlatformTools_2_1) {
                PlatformTools_2 = PlatformTools_2_1;
            },
            function (MongoSchemaBuilder_1_1) {
                MongoSchemaBuilder_1 = MongoSchemaBuilder_1_1;
            }
        ],
        execute: function () {
            /**
             * Organizes communication with MongoDB.
             */
            MongoDriver = /** @class */ (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function MongoDriver(connection) {
                    this.connection = connection;
                    /**
                     * Indicates if replication is enabled.
                     */
                    this.isReplicated = false;
                    /**
                     * Indicates if tree tables are supported by this driver.
                     */
                    this.treeSupport = false;
                    /**
                     * Mongodb does not need to have column types because they are not used in schema sync.
                     */
                    this.supportedDataTypes = [];
                    /**
                     * Gets list of column data types that support length by a driver.
                     */
                    this.withLengthColumnTypes = [];
                    /**
                     * Mongodb does not need to have a strong defined mapped column types because they are not used in schema sync.
                     */
                    this.mappedDataTypes = {
                        createDate: "int",
                        createDateDefault: "",
                        updateDate: "int",
                        updateDateDefault: "",
                        version: "int",
                        treeLevel: "int",
                        migrationName: "int",
                        migrationTimestamp: "int",
                        cacheId: "int",
                        cacheIdentifier: "int",
                        cacheTime: "int",
                        cacheDuration: "int",
                        cacheQuery: "int",
                        cacheResult: "int",
                    };
                    this.options = connection.options;
                    // validate options to make sure everything is correct and driver will be able to establish connection
                    this.validateOptions(connection.options);
                    // load mongodb package
                    this.loadDependencies();
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Performs connection to the database.
                 */
                MongoDriver.prototype.connect = function () {
                    var _this = this;
                    return new Promise(function (ok, fail) {
                        _this.mongodb.MongoClient.connect(_this.buildConnectionUrl(), {
                            poolSize: _this.options.poolSize,
                            ssl: _this.options.ssl,
                            sslValidate: _this.options.sslValidate,
                            sslCA: _this.options.sslCA,
                            sslCert: _this.options.sslCert,
                            sslKey: _this.options.sslKey,
                            sslPass: _this.options.sslPass,
                            autoReconnect: _this.options.autoReconnect,
                            noDelay: _this.options.noDelay,
                            keepAlive: _this.options.keepAlive,
                            connectTimeoutMS: _this.options.connectTimeoutMS,
                            socketTimeoutMS: _this.options.socketTimeoutMS,
                            reconnectTries: _this.options.reconnectTries,
                            reconnectInterval: _this.options.reconnectInterval,
                            ha: _this.options.ha,
                            haInterval: _this.options.haInterval,
                            replicaSet: _this.options.replicaSet,
                            acceptableLatencyMS: _this.options.acceptableLatencyMS,
                            secondaryAcceptableLatencyMS: _this.options.secondaryAcceptableLatencyMS,
                            connectWithNoPrimary: _this.options.connectWithNoPrimary,
                            authSource: _this.options.authSource,
                            w: _this.options.w,
                            wtimeout: _this.options.wtimeout,
                            j: _this.options.j,
                            forceServerObjectId: _this.options.forceServerObjectId,
                            serializeFunctions: _this.options.serializeFunctions,
                            ignoreUndefined: _this.options.ignoreUndefined,
                            raw: _this.options.raw,
                            promoteLongs: _this.options.promoteLongs,
                            promoteBuffers: _this.options.promoteBuffers,
                            promoteValues: _this.options.promoteValues,
                            domainsEnabled: _this.options.domainsEnabled,
                            bufferMaxEntries: _this.options.bufferMaxEntries,
                            readPreference: _this.options.readPreference,
                            pkFactory: _this.options.pkFactory,
                            promiseLibrary: _this.options.promiseLibrary,
                            readConcern: _this.options.readConcern,
                            maxStalenessSeconds: _this.options.maxStalenessSeconds,
                            loggerLevel: _this.options.loggerLevel,
                            logger: _this.options.logger
                        }, function (err, dbConnection) {
                            if (err)
                                return fail(err);
                            _this.queryRunner = new MongoQueryRunner_1.MongoQueryRunner(_this.connection, dbConnection);
                            ok();
                        });
                    });
                };
                MongoDriver.prototype.afterConnect = function () {
                    return Promise.resolve();
                };
                /**
                 * Closes connection with the database.
                 */
                MongoDriver.prototype.disconnect = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        return __generator(this, function (_a) {
                            return [2 /*return*/, new Promise(function (ok, fail) {
                                    if (!_this.queryRunner)
                                        return fail(new ConnectionIsNotSetError_1.ConnectionIsNotSetError("mongodb"));
                                    var handler = function (err) { return err ? fail(err) : ok(); };
                                    _this.queryRunner.databaseConnection.close(handler);
                                    _this.queryRunner = undefined;
                                })];
                        });
                    });
                };
                /**
                 * Creates a schema builder used to build and sync a schema.
                 */
                MongoDriver.prototype.createSchemaBuilder = function () {
                    return new MongoSchemaBuilder_1.MongoSchemaBuilder(this.connection);
                };
                /**
                 * Creates a query runner used to execute database queries.
                 */
                MongoDriver.prototype.createQueryRunner = function (mode) {
                    if (mode === void 0) { mode = "master"; }
                    return this.queryRunner;
                };
                /**
                 * Replaces parameters in the given sql with special escaping character
                 * and an array of parameter names to be passed to a query.
                 */
                MongoDriver.prototype.escapeQueryWithParameters = function (sql, parameters) {
                    throw new Error("This operation is not supported by Mongodb driver.");
                };
                /**
                 * Escapes a column name.
                 */
                MongoDriver.prototype.escape = function (columnName) {
                    return columnName;
                };
                /**
                 * Prepares given value to a value to be persisted, based on its column type and metadata.
                 */
                MongoDriver.prototype.preparePersistentValue = function (value, columnMetadata) {
                    if (columnMetadata.transformer)
                        value = columnMetadata.transformer.to(value);
                    return value;
                };
                /**
                 * Prepares given value to a value to be persisted, based on its column type or metadata.
                 */
                MongoDriver.prototype.prepareHydratedValue = function (value, columnMetadata) {
                    if (columnMetadata.transformer)
                        value = columnMetadata.transformer.from(value);
                    return value;
                };
                /**
                 * Creates a database type from a given column metadata.
                 */
                MongoDriver.prototype.normalizeType = function (column) {
                    throw new Error("MongoDB is schema-less, not supported by this driver.");
                };
                /**
                 * Normalizes "default" value of the column.
                 */
                MongoDriver.prototype.normalizeDefault = function (column) {
                    throw new Error("MongoDB is schema-less, not supported by this driver.");
                };
                /**
                 * Normalizes "isUnique" value of the column.
                 */
                MongoDriver.prototype.normalizeIsUnique = function (column) {
                    throw new Error("MongoDB is schema-less, not supported by this driver.");
                };
                /**
                 * Calculates column length taking into account the default length values.
                 */
                MongoDriver.prototype.getColumnLength = function (column) {
                    throw new Error("MongoDB is schema-less, not supported by this driver.");
                };
                /**
                 * Normalizes "default" value of the column.
                 */
                MongoDriver.prototype.createFullType = function (column) {
                    throw new Error("MongoDB is schema-less, not supported by this driver.");
                };
                /**
                 * Obtains a new database connection to a master server.
                 * Used for replication.
                 * If replication is not setup then returns default connection's database connection.
                 */
                MongoDriver.prototype.obtainMasterConnection = function () {
                    return Promise.resolve();
                };
                /**
                 * Obtains a new database connection to a slave server.
                 * Used for replication.
                 * If replication is not setup then returns master (default) connection's database connection.
                 */
                MongoDriver.prototype.obtainSlaveConnection = function () {
                    return Promise.resolve();
                };
                // -------------------------------------------------------------------------
                // Protected Methods
                // -------------------------------------------------------------------------
                /**
                 * Validate driver options to make sure everything is correct and driver will be able to establish connection.
                 */
                MongoDriver.prototype.validateOptions = function (options) {
                    // if (!options.url) {
                    //     if (!options.database)
                    //         throw new DriverOptionNotSetError("database");
                    // }
                };
                /**
                 * Loads all driver dependencies.
                 */
                MongoDriver.prototype.loadDependencies = function () {
                    try {
                        this.mongodb = PlatformTools_2.PlatformTools.load("mongodb"); // try to load native driver dynamically
                    }
                    catch (e) {
                        throw new DriverPackageNotInstalledError_1.DriverPackageNotInstalledError("MongoDB", "mongodb");
                    }
                };
                /**
                 * Builds connection url that is passed to underlying driver to perform connection to the mongodb database.
                 */
                MongoDriver.prototype.buildConnectionUrl = function () {
                    if (this.options.url)
                        return this.options.url;
                    var credentialsUrlPart = (this.options.username && this.options.password)
                        ? this.options.username + ":" + this.options.password + "@"
                        : "";
                    return "mongodb://" + credentialsUrlPart + (this.options.host || "127.0.0.1") + ":" + (this.options.port || "27017") + "/" + this.options.database;
                };
                return MongoDriver;
            }());
            exports_68("MongoDriver", MongoDriver);
        }
    };
});
System.register("typeorm/query-builder/transformer/DocumentToEntityTransformer", [], function (exports_69, context_69) {
    "use strict";
    var __moduleName = context_69 && context_69.id;
    var DocumentToEntityTransformer;
    return {
        setters: [],
        execute: function () {
            /**
             * Transforms raw document into entity object.
             * Entity is constructed based on its entity metadata.
             */
            DocumentToEntityTransformer = /** @class */ (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function DocumentToEntityTransformer(// private selectionMap: AliasMap,
                // private joinMappings: JoinMapping[],
                // private relationCountMetas: RelationCountAttribute[],
                enableRelationIdValues) {
                    if (enableRelationIdValues === void 0) { enableRelationIdValues = false; }
                    this.enableRelationIdValues = enableRelationIdValues;
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                DocumentToEntityTransformer.prototype.transformAll = function (documents, metadata) {
                    var _this = this;
                    return documents.map(function (document) { return _this.transform(document, metadata); });
                };
                DocumentToEntityTransformer.prototype.transform = function (document, metadata) {
                    var entity = metadata.create();
                    var hasData = false;
                    // handle _id property the special way
                    if (metadata.objectIdColumn && document[metadata.objectIdColumn.databaseNameWithoutPrefixes]) {
                        // todo: we can't use driver in this class
                        // do we really need prepare hydrated value here? If no then no problem. If yes then think maybe prepareHydratedValue process should be extracted out of driver class?
                        // entity[metadata.objectIdColumn.propertyName] = this.driver.prepareHydratedValue(document[metadata.objectIdColumn.name"], metadata.objectIdColumn);
                        entity[metadata.objectIdColumn.propertyName] = document[metadata.objectIdColumn.databaseNameWithoutPrefixes];
                        hasData = true;
                    }
                    // add special columns that contains relation ids
                    if (this.enableRelationIdValues) {
                        metadata.columns.filter(function (column) { return !!column.relationMetadata; }).forEach(function (column) {
                            var valueInObject = document[column.databaseNameWithoutPrefixes];
                            if (valueInObject !== undefined && valueInObject !== null && column.propertyName) {
                                // todo: we can't use driver in this class
                                // const value = this.driver.prepareHydratedValue(valueInObject, column);
                                entity[column.propertyName] = valueInObject;
                                hasData = true;
                            }
                        });
                    }
                    /*this.joinMappings
                        .filter(joinMapping => joinMapping.parentName === alias.name && !joinMapping.alias.relationOwnerSelection && joinMapping.alias.target)
                        .map(joinMapping => {
                            const relatedEntities = this.transformRawResultsGroup(rawSqlResults, joinMapping.alias);
                            const isResultArray = joinMapping.isMany;
                            const result = !isResultArray ? relatedEntities[0] : relatedEntities;
            
                            if (result && (!isResultArray || result.length > 0)) {
                                entity[joinMapping.propertyName] = result;
                                hasData = true;
                            }
                        });*/
                    // get value from columns selections and put them into object
                    metadata.ownColumns.forEach(function (column) {
                        var valueInObject = document[column.databaseNameWithoutPrefixes];
                        if (valueInObject !== undefined &&
                            valueInObject !== null &&
                            column.propertyName &&
                            !column.isVirtual &&
                            !column.isParentId &&
                            !column.isDiscriminator) {
                            // const value = this.driver.prepareHydratedValue(valueInObject, column);
                            entity[column.propertyName] = valueInObject;
                            hasData = true;
                        }
                    });
                    var addEmbeddedValuesRecursively = function (entity, document, embeddeds) {
                        embeddeds.forEach(function (embedded) {
                            if (!document[embedded.prefix])
                                return;
                            if (embedded.isArray) {
                                entity[embedded.propertyName] = document[embedded.prefix].map(function (subValue) {
                                    var newItem = embedded.create();
                                    embedded.columns.forEach(function (column) {
                                        newItem[column.propertyName] = subValue[column.databaseNameWithoutPrefixes];
                                    });
                                    return newItem;
                                });
                            }
                            else {
                                embedded.columns.forEach(function (column) {
                                    var value = document[embedded.prefix][column.databaseNameWithoutPrefixes];
                                    if (!value)
                                        return;
                                    if (!entity[embedded.propertyName])
                                        entity[embedded.propertyName] = embedded.create();
                                    entity[embedded.propertyName][column.propertyName] = value;
                                });
                            }
                            addEmbeddedValuesRecursively(entity[embedded.propertyName], document[embedded.prefix], embedded.embeddeds);
                        });
                    };
                    addEmbeddedValuesRecursively(entity, document, metadata.embeddeds);
                    // if relation is loaded then go into it recursively and transform its values too
                    /*metadata.relations.forEach(relation => {
                        const relationAlias = this.selectionMap.findSelectionByParent(alias.name, relation.propertyName);
                        if (relationAlias) {
                            const joinMapping = this.joinMappings.find(joinMapping => joinMapping.type === "join" && joinMapping.alias === relationAlias);
                            const relatedEntities = this.transformRawResultsGroup(rawSqlResults, relationAlias);
                            const isResultArray = relation.isManyToMany || relation.isOneToMany;
                            const result = !isResultArray ? relatedEntities[0] : relatedEntities;
            
                            if (result) {
                                let propertyName = relation.propertyName;
                                if (joinMapping) {
                                    propertyName = joinMapping.propertyName;
                                }
            
                                if (relation.isLazy) {
                                    entity["__" + propertyName + "__"] = result;
                                } else {
                                    entity[propertyName] = result;
                                }
            
                                if (!isResultArray || result.length > 0)
                                    hasData = true;
                            }
                        }
            
                        // if relation has id field then relation id/ids to that field.
                        if (relation.isManyToMany) {
                            if (relationAlias) {
                                const ids: any[] = [];
                                const joinMapping = this.joinMappings.find(joinMapping => joinMapping.type === "relationId" && joinMapping.alias === relationAlias);
            
                                if (relation.idField || joinMapping) {
                                    const propertyName = joinMapping ? joinMapping.propertyName : relation.idField as string;
                                    const junctionMetadata = relation.junctionEntityMetadata;
                                    const columnName = relation.isOwning ? junctionMetadata.columns[1].name : junctionMetadata.columns[0].name;
            
                                    rawSqlResults.forEach(results => {
                                        if (relationAlias) {
                                            const resultsKey = relationAlias.name + "_" + columnName;
                                            const value = this.driver.prepareHydratedValue(results[resultsKey], relation.referencedColumn);
                                            if (value !== undefined && value !== null)
                                                ids.push(value);
                                        }
                                    });
            
                                    if (ids && ids.length)
                                        entity[propertyName] = ids;
                                }
                            }
                        } else if (relation.idField) {
                            const relationName = relation.name;
                            entity[relation.idField] = this.driver.prepareHydratedValue(rawSqlResults[0][alias.name + "_" + relationName], relation.referencedColumn);
                        }
            
                        // if relation counter
                        this.relationCountMetas.forEach(joinMeta => {
                            if (joinMeta.alias === relationAlias) {
                                // console.log("relation count was found for relation: ", relation);
                                // joinMeta.entity = entity;
                                joinMeta.entities.push({ entity: entity, metadata: metadata });
                                // console.log(joinMeta);
                                // console.log("---------------------");
                            }
                        });
                    });*/
                    return hasData ? entity : null;
                };
                return DocumentToEntityTransformer;
            }());
            exports_69("DocumentToEntityTransformer", DocumentToEntityTransformer);
        }
    };
});
System.register("typeorm/error/FindRelationsNotFoundError", [], function (exports_70, context_70) {
    "use strict";
    var __moduleName = context_70 && context_70.id;
    var FindRelationsNotFoundError;
    return {
        setters: [],
        execute: function () {
            /**
             * Thrown when relations specified in the find options were not found in the entities.
            */
            FindRelationsNotFoundError = /** @class */ (function (_super) {
                __extends(FindRelationsNotFoundError, _super);
                function FindRelationsNotFoundError(notFoundRelations) {
                    var _this = _super.call(this) || this;
                    if (notFoundRelations.length === 1) {
                        _this.message = "Relation \"" + notFoundRelations[0] + "\" was not found, please check if it is correct and really exist in your entity.";
                    }
                    else {
                        _this.message = "Relations " + notFoundRelations.map(function (relation) { return "\"" + relation + "\""; }).join(", ") + " were not found, please check if relations are correct and they exist in your entities.";
                    }
                    Object.setPrototypeOf(_this, FindRelationsNotFoundError.prototype);
                    return _this;
                }
                return FindRelationsNotFoundError;
            }(Error));
            exports_70("FindRelationsNotFoundError", FindRelationsNotFoundError);
        }
    };
});
System.register("typeorm/find-options/FindOptionsUtils", ["typeorm/error/FindRelationsNotFoundError"], function (exports_71, context_71) {
    "use strict";
    var __moduleName = context_71 && context_71.id;
    var FindRelationsNotFoundError_1, FindOptionsUtils;
    return {
        setters: [
            function (FindRelationsNotFoundError_1_1) {
                FindRelationsNotFoundError_1 = FindRelationsNotFoundError_1_1;
            }
        ],
        execute: function () {
            /**
             * Utilities to work with FindOptions.
             */
            FindOptionsUtils = /** @class */ (function () {
                function FindOptionsUtils() {
                }
                // -------------------------------------------------------------------------
                // Public Static Methods
                // -------------------------------------------------------------------------
                /**
                 * Checks if given object is really instance of FindOneOptions interface.
                 */
                FindOptionsUtils.isFindOneOptions = function (obj) {
                    var possibleOptions = obj;
                    return possibleOptions &&
                        (possibleOptions.select instanceof Array ||
                            possibleOptions.where instanceof Object ||
                            typeof possibleOptions.where === "string" ||
                            possibleOptions.relations instanceof Array ||
                            possibleOptions.join instanceof Object ||
                            possibleOptions.order instanceof Object ||
                            (possibleOptions.cache instanceof Object ||
                                typeof possibleOptions.cache === "boolean" ||
                                typeof possibleOptions.cache === "number"));
                };
                /**
                 * Checks if given object is really instance of FindManyOptions interface.
                 */
                FindOptionsUtils.isFindManyOptions = function (obj) {
                    var possibleOptions = obj;
                    return possibleOptions && (this.isFindOneOptions(possibleOptions) ||
                        typeof possibleOptions.skip === "number" ||
                        typeof possibleOptions.take === "number" ||
                        typeof possibleOptions.skip === "string" ||
                        typeof possibleOptions.take === "string");
                };
                /**
                 * Checks if given object is really instance of FindOptions interface.
                 */
                FindOptionsUtils.extractFindOneOptionsAlias = function (object) {
                    if (this.isFindOneOptions(object) && object.join)
                        return object.join.alias;
                    return undefined;
                };
                /**
                 * Checks if given object is really instance of FindOptions interface.
                 */
                FindOptionsUtils.extractFindManyOptionsAlias = function (object) {
                    if (this.isFindManyOptions(object) && object.join)
                        return object.join.alias;
                    return undefined;
                };
                /**
                 * Applies give find one options to the given query builder.
                 */
                FindOptionsUtils.applyFindOneOptionsOrConditionsToQueryBuilder = function (qb, options) {
                    if (this.isFindOneOptions(options))
                        return this.applyOptionsToQueryBuilder(qb, options);
                    if (options)
                        return qb.where(options);
                    return qb;
                };
                /**
                 * Applies give find many options to the given query builder.
                 */
                FindOptionsUtils.applyFindManyOptionsOrConditionsToQueryBuilder = function (qb, options) {
                    if (this.isFindManyOptions(options))
                        return this.applyOptionsToQueryBuilder(qb, options);
                    if (options)
                        return qb.where(options);
                    return qb;
                };
                /**
                 * Applies give find options to the given query builder.
                 */
                FindOptionsUtils.applyOptionsToQueryBuilder = function (qb, options) {
                    // if options are not set then simply return query builder. This is made for simplicity of usage.
                    if (!options || (!this.isFindOneOptions(options) && !this.isFindManyOptions(options)))
                        return qb;
                    if (!qb.expressionMap.mainAlias || !qb.expressionMap.mainAlias.hasMetadata)
                        return qb;
                    var metadata = qb.expressionMap.mainAlias.metadata;
                    // apply all options from FindOptions
                    if (options.select) {
                        qb.select([]);
                        options.select.forEach(function (select) {
                            if (!metadata.findColumnWithPropertyPath(select))
                                throw new Error(select + " column was not found in the " + metadata.name + " entity.");
                            qb.addSelect(qb.alias + "." + select);
                        });
                    }
                    if (options.where)
                        qb.where(options.where);
                    if (options.skip)
                        qb.skip(options.skip);
                    if (options.take)
                        qb.take(options.take);
                    if (options.order)
                        Object.keys(options.order).forEach(function (key) {
                            var order = options.order[key];
                            if (!metadata.findColumnWithPropertyPath(key))
                                throw new Error(key + " column was not found in the " + metadata.name + " entity.");
                            switch (order) {
                                case 1:
                                    qb.addOrderBy(qb.alias + "." + key, "ASC");
                                    break;
                                case -1:
                                    qb.addOrderBy(qb.alias + "." + key, "DESC");
                                    break;
                                case "ASC":
                                    qb.addOrderBy(qb.alias + "." + key, "ASC");
                                    break;
                                case "DESC":
                                    qb.addOrderBy(qb.alias + "." + key, "DESC");
                                    break;
                            }
                        });
                    if (options.relations) {
                        var allRelations = options.relations.map(function (relation) { return relation; });
                        this.applyRelationsRecursively(qb, allRelations, qb.expressionMap.mainAlias.name, qb.expressionMap.mainAlias.metadata, "");
                        // recursive removes found relations from allRelations array
                        // if there are relations left in this array it means those relations were not found in the entity structure
                        // so, we give an exception about not found relations
                        if (allRelations.length > 0)
                            throw new FindRelationsNotFoundError_1.FindRelationsNotFoundError(allRelations);
                    }
                    if (options.join) {
                        if (options.join.leftJoin)
                            Object.keys(options.join.leftJoin).forEach(function (key) {
                                qb.leftJoin(options.join.leftJoin[key], key);
                            });
                        if (options.join.innerJoin)
                            Object.keys(options.join.innerJoin).forEach(function (key) {
                                qb.innerJoin(options.join.innerJoin[key], key);
                            });
                        if (options.join.leftJoinAndSelect)
                            Object.keys(options.join.leftJoinAndSelect).forEach(function (key) {
                                qb.leftJoinAndSelect(options.join.leftJoinAndSelect[key], key);
                            });
                        if (options.join.innerJoinAndSelect)
                            Object.keys(options.join.innerJoinAndSelect).forEach(function (key) {
                                qb.innerJoinAndSelect(options.join.innerJoinAndSelect[key], key);
                            });
                    }
                    if (options.cache) {
                        if (options.cache instanceof Object) {
                            var cache = options.cache;
                            qb.cache(cache.id, cache.milliseconds);
                        }
                        else {
                            qb.cache(options.cache);
                        }
                    }
                    return qb;
                };
                // -------------------------------------------------------------------------
                // Protected Static Methods
                // -------------------------------------------------------------------------
                /**
                 * Adds joins for all relations and sub-relations of the given relations provided in the find options.
                 */
                FindOptionsUtils.applyRelationsRecursively = function (qb, allRelations, alias, metadata, prefix) {
                    var _this = this;
                    // find all relations that match given prefix
                    var matchedBaseRelations = [];
                    if (prefix) {
                        var regexp_1 = new RegExp("^" + prefix.replace(".", "\\.") + "\\.");
                        matchedBaseRelations = allRelations
                            .filter(function (relation) { return relation.match(regexp_1); })
                            .map(function (relation) { return relation.replace(regexp_1, ""); })
                            .filter(function (relation) { return metadata.findRelationWithPropertyPath(relation); });
                    }
                    else {
                        matchedBaseRelations = allRelations.filter(function (relation) { return metadata.findRelationWithPropertyPath(relation); });
                    }
                    // go through all matched relations and add join for them
                    matchedBaseRelations.forEach(function (relation) {
                        // add a join for the found relation
                        var selection = alias + "." + relation;
                        qb.leftJoinAndSelect(selection, alias + "_" + relation);
                        // remove added relations from the allRelations array, this is needed to find all not found relations at the end
                        allRelations.splice(allRelations.indexOf(prefix ? prefix + "." + relation : relation), 1);
                        // try to find sub-relations
                        var join = qb.expressionMap.joinAttributes.find(function (join) { return join.entityOrProperty === selection; });
                        _this.applyRelationsRecursively(qb, allRelations, join.alias.name, join.metadata, prefix ? prefix + "." + relation : relation);
                    });
                };
                return FindOptionsUtils;
            }());
            exports_71("FindOptionsUtils", FindOptionsUtils);
        }
    };
});
System.register("typeorm/entity-manager/MongoEntityManager", ["typeorm/entity-manager/EntityManager", "typeorm/query-builder/transformer/DocumentToEntityTransformer", "typeorm/find-options/FindOptionsUtils", "typeorm/platform/PlatformTools"], function (exports_72, context_72) {
    "use strict";
    var __moduleName = context_72 && context_72.id;
    var EntityManager_1, DocumentToEntityTransformer_1, FindOptionsUtils_1, PlatformTools_3, MongoEntityManager;
    return {
        setters: [
            function (EntityManager_1_1) {
                EntityManager_1 = EntityManager_1_1;
            },
            function (DocumentToEntityTransformer_1_1) {
                DocumentToEntityTransformer_1 = DocumentToEntityTransformer_1_1;
            },
            function (FindOptionsUtils_1_1) {
                FindOptionsUtils_1 = FindOptionsUtils_1_1;
            },
            function (PlatformTools_3_1) {
                PlatformTools_3 = PlatformTools_3_1;
            }
        ],
        execute: function () {
            /**
             * Entity manager supposed to work with any entity, automatically find its repository and call its methods,
             * whatever entity type are you passing.
             *
             * This implementation is used for MongoDB driver which has some specifics in its EntityManager.
             */
            MongoEntityManager = /** @class */ (function (_super) {
                __extends(MongoEntityManager, _super);
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function MongoEntityManager(connection) {
                    return _super.call(this, connection) || this;
                }
                Object.defineProperty(MongoEntityManager.prototype, "queryRunner", {
                    // -------------------------------------------------------------------------
                    // Overridden Properties
                    // -------------------------------------------------------------------------
                    /**
                     * Gets query runner used to execute queries.
                     */
                    get: function () {
                        return this.connection.driver.queryRunner;
                    },
                    enumerable: true,
                    configurable: true
                });
                // -------------------------------------------------------------------------
                // Overridden Methods
                // -------------------------------------------------------------------------
                /**
                 * Finds entities that match given find options or conditions.
                 */
                MongoEntityManager.prototype.find = function (entityClassOrName, optionsOrConditions) {
                    return __awaiter(this, void 0, void 0, function () {
                        var query, cursor;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    query = this.convertFindManyOptionsOrConditionsToMongodbQuery(optionsOrConditions);
                                    return [4 /*yield*/, this.createEntityCursor(entityClassOrName, query)];
                                case 1:
                                    cursor = _a.sent();
                                    if (FindOptionsUtils_1.FindOptionsUtils.isFindManyOptions(optionsOrConditions)) {
                                        if (optionsOrConditions.skip)
                                            cursor.skip(optionsOrConditions.skip);
                                        if (optionsOrConditions.take)
                                            cursor.limit(optionsOrConditions.take);
                                        if (optionsOrConditions.order)
                                            cursor.sort(this.convertFindOptionsOrderToOrderCriteria(optionsOrConditions.order));
                                    }
                                    return [2 /*return*/, cursor.toArray()];
                            }
                        });
                    });
                };
                /**
                 * Finds entities that match given find options or conditions.
                 * Also counts all entities that match given conditions,
                 * but ignores pagination settings (from and take options).
                 */
                MongoEntityManager.prototype.findAndCount = function (entityClassOrName, optionsOrConditions) {
                    return __awaiter(this, void 0, void 0, function () {
                        var query, cursor, _a, results, count;
                        return __generator(this, function (_b) {
                            switch (_b.label) {
                                case 0:
                                    query = this.convertFindManyOptionsOrConditionsToMongodbQuery(optionsOrConditions);
                                    return [4 /*yield*/, this.createEntityCursor(entityClassOrName, query)];
                                case 1:
                                    cursor = _b.sent();
                                    if (FindOptionsUtils_1.FindOptionsUtils.isFindManyOptions(optionsOrConditions)) {
                                        if (optionsOrConditions.skip)
                                            cursor.skip(optionsOrConditions.skip);
                                        if (optionsOrConditions.take)
                                            cursor.limit(optionsOrConditions.take);
                                        if (optionsOrConditions.order)
                                            cursor.sort(this.convertFindOptionsOrderToOrderCriteria(optionsOrConditions.order));
                                    }
                                    return [4 /*yield*/, Promise.all([
                                            cursor.toArray(),
                                            this.count(entityClassOrName, query),
                                        ])];
                                case 2:
                                    _a = _b.sent(), results = _a[0], count = _a[1];
                                    return [2 /*return*/, [results, parseInt(count)]];
                            }
                        });
                    });
                };
                /**
                 * Finds entities by ids.
                 * Optionally find options can be applied.
                 */
                MongoEntityManager.prototype.findByIds = function (entityClassOrName, ids, optionsOrConditions) {
                    return __awaiter(this, void 0, void 0, function () {
                        var metadata, query, objectIdInstance, cursor;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    metadata = this.connection.getMetadata(entityClassOrName);
                                    query = this.convertFindManyOptionsOrConditionsToMongodbQuery(optionsOrConditions) || {};
                                    objectIdInstance = PlatformTools_3.PlatformTools.load("mongodb").ObjectID;
                                    query["_id"] = { $in: ids.map(function (id) {
                                            if (id instanceof objectIdInstance)
                                                return id;
                                            return id[metadata.objectIdColumn.propertyName];
                                        }) };
                                    return [4 /*yield*/, this.createEntityCursor(entityClassOrName, query)];
                                case 1:
                                    cursor = _a.sent();
                                    if (FindOptionsUtils_1.FindOptionsUtils.isFindManyOptions(optionsOrConditions)) {
                                        if (optionsOrConditions.skip)
                                            cursor.skip(optionsOrConditions.skip);
                                        if (optionsOrConditions.take)
                                            cursor.limit(optionsOrConditions.take);
                                        if (optionsOrConditions.order)
                                            cursor.sort(this.convertFindOptionsOrderToOrderCriteria(optionsOrConditions.order));
                                    }
                                    return [4 /*yield*/, cursor.toArray()];
                                case 2: return [2 /*return*/, _a.sent()];
                            }
                        });
                    });
                };
                /**
                 * Finds first entity that matches given conditions and/or find options.
                 */
                MongoEntityManager.prototype.findOne = function (entityClassOrName, optionsOrConditions) {
                    return __awaiter(this, void 0, void 0, function () {
                        var query, cursor, result;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    query = this.convertFindOneOptionsOrConditionsToMongodbQuery(optionsOrConditions);
                                    return [4 /*yield*/, this.createEntityCursor(entityClassOrName, query)];
                                case 1:
                                    cursor = _a.sent();
                                    if (FindOptionsUtils_1.FindOptionsUtils.isFindOneOptions(optionsOrConditions)) {
                                        if (optionsOrConditions.order)
                                            cursor.sort(this.convertFindOptionsOrderToOrderCriteria(optionsOrConditions.order));
                                    }
                                    return [4 /*yield*/, cursor.limit(1).toArray()];
                                case 2:
                                    result = _a.sent();
                                    return [2 /*return*/, result.length > 0 ? result[0] : undefined];
                            }
                        });
                    });
                };
                /**
                 * Finds entity by given id.
                 * Optionally find options or conditions can be applied.
                 */
                MongoEntityManager.prototype.findOneById = function (entityClassOrName, id, optionsOrConditions) {
                    return __awaiter(this, void 0, void 0, function () {
                        var query, objectIdInstance, cursor, result;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    query = this.convertFindOneOptionsOrConditionsToMongodbQuery(optionsOrConditions) || {};
                                    objectIdInstance = PlatformTools_3.PlatformTools.load("mongodb").ObjectID;
                                    query["_id"] = (id instanceof objectIdInstance)
                                        ? id
                                        : new objectIdInstance(id);
                                    return [4 /*yield*/, this.createEntityCursor(entityClassOrName, query)];
                                case 1:
                                    cursor = _a.sent();
                                    if (FindOptionsUtils_1.FindOptionsUtils.isFindOneOptions(optionsOrConditions)) {
                                        if (optionsOrConditions.order)
                                            cursor.sort(this.convertFindOptionsOrderToOrderCriteria(optionsOrConditions.order));
                                    }
                                    return [4 /*yield*/, cursor.limit(1).toArray()];
                                case 2:
                                    result = _a.sent();
                                    return [2 /*return*/, result.length > 0 ? result[0] : undefined];
                            }
                        });
                    });
                };
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Creates a cursor for a query that can be used to iterate over results from MongoDB.
                 */
                MongoEntityManager.prototype.createCursor = function (entityClassOrName, query) {
                    var metadata = this.connection.getMetadata(entityClassOrName);
                    return this.queryRunner.cursor(metadata.tableName, query);
                };
                /**
                 * Creates a cursor for a query that can be used to iterate over results from MongoDB.
                 * This returns modified version of cursor that transforms each result into Entity model.
                 */
                MongoEntityManager.prototype.createEntityCursor = function (entityClassOrName, query) {
                    var metadata = this.connection.getMetadata(entityClassOrName);
                    var cursor = this.createCursor(entityClassOrName, query);
                    var ParentCursor = PlatformTools_3.PlatformTools.load("mongodb").Cursor;
                    cursor.toArray = function (callback) {
                        if (callback) {
                            ParentCursor.prototype.toArray.call(this, function (error, results) {
                                if (error) {
                                    callback(error, results);
                                    return;
                                }
                                var transformer = new DocumentToEntityTransformer_1.DocumentToEntityTransformer();
                                return callback(error, transformer.transformAll(results, metadata));
                            });
                        }
                        else {
                            return ParentCursor.prototype.toArray.call(this).then(function (results) {
                                var transformer = new DocumentToEntityTransformer_1.DocumentToEntityTransformer();
                                return transformer.transformAll(results, metadata);
                            });
                        }
                    };
                    cursor.next = function (callback) {
                        if (callback) {
                            ParentCursor.prototype.next.call(this, function (error, result) {
                                if (error || !result) {
                                    callback(error, result);
                                    return;
                                }
                                var transformer = new DocumentToEntityTransformer_1.DocumentToEntityTransformer();
                                return callback(error, transformer.transform(result, metadata));
                            });
                        }
                        else {
                            return ParentCursor.prototype.next.call(this).then(function (result) {
                                if (!result)
                                    return result;
                                var transformer = new DocumentToEntityTransformer_1.DocumentToEntityTransformer();
                                return transformer.transform(result, metadata);
                            });
                        }
                    };
                    return cursor;
                };
                /**
                 * Execute an aggregation framework pipeline against the collection.
                 */
                MongoEntityManager.prototype.aggregate = function (entityClassOrName, pipeline, options) {
                    var metadata = this.connection.getMetadata(entityClassOrName);
                    return this.queryRunner.aggregate(metadata.tableName, pipeline, options);
                };
                /**
                 * Perform a bulkWrite operation without a fluent API.
                 */
                MongoEntityManager.prototype.bulkWrite = function (entityClassOrName, operations, options) {
                    var metadata = this.connection.getMetadata(entityClassOrName);
                    return this.queryRunner.bulkWrite(metadata.tableName, operations, options);
                };
                /**
                 * Count number of matching documents in the db to a query.
                 */
                MongoEntityManager.prototype.count = function (entityClassOrName, query, options) {
                    var metadata = this.connection.getMetadata(entityClassOrName);
                    return this.queryRunner.count(metadata.tableName, query, options);
                };
                /**
                 * Creates an index on the db and collection.
                 */
                MongoEntityManager.prototype.createCollectionIndex = function (entityClassOrName, fieldOrSpec, options) {
                    var metadata = this.connection.getMetadata(entityClassOrName);
                    return this.queryRunner.createCollectionIndex(metadata.tableName, fieldOrSpec, options);
                };
                /**
                 * Creates multiple indexes in the collection, this method is only supported for MongoDB 2.6 or higher.
                 * Earlier version of MongoDB will throw a command not supported error.
                 * Index specifications are defined at http://docs.mongodb.org/manual/reference/command/createIndexes/.
                 */
                MongoEntityManager.prototype.createCollectionIndexes = function (entityClassOrName, indexSpecs) {
                    var metadata = this.connection.getMetadata(entityClassOrName);
                    return this.queryRunner.createCollectionIndexes(metadata.tableName, indexSpecs);
                };
                /**
                 * Delete multiple documents on MongoDB.
                 */
                MongoEntityManager.prototype.deleteMany = function (entityClassOrName, query, options) {
                    var metadata = this.connection.getMetadata(entityClassOrName);
                    return this.queryRunner.deleteMany(metadata.tableName, query, options);
                };
                /**
                 * Delete a document on MongoDB.
                 */
                MongoEntityManager.prototype.deleteOne = function (entityClassOrName, query, options) {
                    var metadata = this.connection.getMetadata(entityClassOrName);
                    return this.queryRunner.deleteOne(metadata.tableName, query, options);
                };
                /**
                 * The distinct command returns returns a list of distinct values for the given key across a collection.
                 */
                MongoEntityManager.prototype.distinct = function (entityClassOrName, key, query, options) {
                    var metadata = this.connection.getMetadata(entityClassOrName);
                    return this.queryRunner.distinct(metadata.tableName, key, query, options);
                };
                /**
                 * Drops an index from this collection.
                 */
                MongoEntityManager.prototype.dropCollectionIndex = function (entityClassOrName, indexName, options) {
                    var metadata = this.connection.getMetadata(entityClassOrName);
                    return this.queryRunner.dropCollectionIndex(metadata.tableName, indexName, options);
                };
                /**
                 * Drops all indexes from the collection.
                 */
                MongoEntityManager.prototype.dropCollectionIndexes = function (entityClassOrName) {
                    var metadata = this.connection.getMetadata(entityClassOrName);
                    return this.queryRunner.dropCollectionIndexes(metadata.tableName);
                };
                /**
                 * Find a document and delete it in one atomic operation, requires a write lock for the duration of the operation.
                 */
                MongoEntityManager.prototype.findOneAndDelete = function (entityClassOrName, query, options) {
                    var metadata = this.connection.getMetadata(entityClassOrName);
                    return this.queryRunner.findOneAndDelete(metadata.tableName, query, options);
                };
                /**
                 * Find a document and replace it in one atomic operation, requires a write lock for the duration of the operation.
                 */
                MongoEntityManager.prototype.findOneAndReplace = function (entityClassOrName, query, replacement, options) {
                    var metadata = this.connection.getMetadata(entityClassOrName);
                    return this.queryRunner.findOneAndReplace(metadata.tableName, query, replacement, options);
                };
                /**
                 * Find a document and update it in one atomic operation, requires a write lock for the duration of the operation.
                 */
                MongoEntityManager.prototype.findOneAndUpdate = function (entityClassOrName, query, update, options) {
                    var metadata = this.connection.getMetadata(entityClassOrName);
                    return this.queryRunner.findOneAndUpdate(metadata.tableName, query, update, options);
                };
                /**
                 * Execute a geo search using a geo haystack index on a collection.
                 */
                MongoEntityManager.prototype.geoHaystackSearch = function (entityClassOrName, x, y, options) {
                    var metadata = this.connection.getMetadata(entityClassOrName);
                    return this.queryRunner.geoHaystackSearch(metadata.tableName, x, y, options);
                };
                /**
                 * Execute the geoNear command to search for items in the collection.
                 */
                MongoEntityManager.prototype.geoNear = function (entityClassOrName, x, y, options) {
                    var metadata = this.connection.getMetadata(entityClassOrName);
                    return this.queryRunner.geoNear(metadata.tableName, x, y, options);
                };
                /**
                 * Run a group command across a collection.
                 */
                MongoEntityManager.prototype.group = function (entityClassOrName, keys, condition, initial, reduce, finalize, command, options) {
                    var metadata = this.connection.getMetadata(entityClassOrName);
                    return this.queryRunner.group(metadata.tableName, keys, condition, initial, reduce, finalize, command, options);
                };
                /**
                 * Retrieve all the indexes on the collection.
                 */
                MongoEntityManager.prototype.collectionIndexes = function (entityClassOrName) {
                    var metadata = this.connection.getMetadata(entityClassOrName);
                    return this.queryRunner.collectionIndexes(metadata.tableName);
                };
                /**
                 * Retrieve all the indexes on the collection.
                 */
                MongoEntityManager.prototype.collectionIndexExists = function (entityClassOrName, indexes) {
                    var metadata = this.connection.getMetadata(entityClassOrName);
                    return this.queryRunner.collectionIndexExists(metadata.tableName, indexes);
                };
                /**
                 * Retrieves this collections index info.
                 */
                MongoEntityManager.prototype.collectionIndexInformation = function (entityClassOrName, options) {
                    var metadata = this.connection.getMetadata(entityClassOrName);
                    return this.queryRunner.collectionIndexInformation(metadata.tableName, options);
                };
                /**
                 * Initiate an In order bulk write operation, operations will be serially executed in the order they are added, creating a new operation for each switch in types.
                 */
                MongoEntityManager.prototype.initializeOrderedBulkOp = function (entityClassOrName, options) {
                    var metadata = this.connection.getMetadata(entityClassOrName);
                    return this.queryRunner.initializeOrderedBulkOp(metadata.tableName, options);
                };
                /**
                 * Initiate a Out of order batch write operation. All operations will be buffered into insert/update/remove commands executed out of order.
                 */
                MongoEntityManager.prototype.initializeUnorderedBulkOp = function (entityClassOrName, options) {
                    var metadata = this.connection.getMetadata(entityClassOrName);
                    return this.queryRunner.initializeUnorderedBulkOp(metadata.tableName, options);
                };
                /**
                 * Inserts an array of documents into MongoDB.
                 */
                MongoEntityManager.prototype.insertMany = function (entityClassOrName, docs, options) {
                    var metadata = this.connection.getMetadata(entityClassOrName);
                    return this.queryRunner.insertMany(metadata.tableName, docs, options);
                };
                /**
                 * Inserts a single document into MongoDB.
                 */
                MongoEntityManager.prototype.insertOne = function (entityClassOrName, doc, options) {
                    var metadata = this.connection.getMetadata(entityClassOrName);
                    return this.queryRunner.insertOne(metadata.tableName, doc, options);
                };
                /**
                 * Returns if the collection is a capped collection.
                 */
                MongoEntityManager.prototype.isCapped = function (entityClassOrName) {
                    var metadata = this.connection.getMetadata(entityClassOrName);
                    return this.queryRunner.isCapped(metadata.tableName);
                };
                /**
                 * Get the list of all indexes information for the collection.
                 */
                MongoEntityManager.prototype.listCollectionIndexes = function (entityClassOrName, options) {
                    var metadata = this.connection.getMetadata(entityClassOrName);
                    return this.queryRunner.listCollectionIndexes(metadata.tableName, options);
                };
                /**
                 * Run Map Reduce across a collection. Be aware that the inline option for out will return an array of results not a collection.
                 */
                MongoEntityManager.prototype.mapReduce = function (entityClassOrName, map, reduce, options) {
                    var metadata = this.connection.getMetadata(entityClassOrName);
                    return this.queryRunner.mapReduce(metadata.tableName, map, reduce, options);
                };
                /**
                 * Return N number of parallel cursors for a collection allowing parallel reading of entire collection.
                 * There are no ordering guarantees for returned results.
                 */
                MongoEntityManager.prototype.parallelCollectionScan = function (entityClassOrName, options) {
                    var metadata = this.connection.getMetadata(entityClassOrName);
                    return this.queryRunner.parallelCollectionScan(metadata.tableName, options);
                };
                /**
                 * Reindex all indexes on the collection Warning: reIndex is a blocking operation (indexes are rebuilt in the foreground) and will be slow for large collections.
                 */
                MongoEntityManager.prototype.reIndex = function (entityClassOrName) {
                    var metadata = this.connection.getMetadata(entityClassOrName);
                    return this.queryRunner.reIndex(metadata.tableName);
                };
                /**
                 * Reindex all indexes on the collection Warning: reIndex is a blocking operation (indexes are rebuilt in the foreground) and will be slow for large collections.
                 */
                MongoEntityManager.prototype.rename = function (entityClassOrName, newName, options) {
                    var metadata = this.connection.getMetadata(entityClassOrName);
                    return this.queryRunner.rename(metadata.tableName, newName, options);
                };
                /**
                 * Replace a document on MongoDB.
                 */
                MongoEntityManager.prototype.replaceOne = function (entityClassOrName, query, doc, options) {
                    var metadata = this.connection.getMetadata(entityClassOrName);
                    return this.queryRunner.replaceOne(metadata.tableName, query, doc, options);
                };
                /**
                 * Get all the collection statistics.
                 */
                MongoEntityManager.prototype.stats = function (entityClassOrName, options) {
                    var metadata = this.connection.getMetadata(entityClassOrName);
                    return this.queryRunner.stats(metadata.tableName, options);
                };
                /**
                 * Update multiple documents on MongoDB.
                 */
                MongoEntityManager.prototype.updateMany = function (entityClassOrName, query, update, options) {
                    var metadata = this.connection.getMetadata(entityClassOrName);
                    return this.queryRunner.updateMany(metadata.tableName, query, update, options);
                };
                /**
                 * Update a single document on MongoDB.
                 */
                MongoEntityManager.prototype.updateOne = function (entityClassOrName, query, update, options) {
                    var metadata = this.connection.getMetadata(entityClassOrName);
                    return this.queryRunner.updateOne(metadata.tableName, query, update, options);
                };
                // -------------------------------------------------------------------------
                // Protected Methods
                // -------------------------------------------------------------------------
                /**
                 * Converts FindManyOptions to mongodb query.
                 */
                MongoEntityManager.prototype.convertFindManyOptionsOrConditionsToMongodbQuery = function (optionsOrConditions) {
                    if (!optionsOrConditions)
                        return undefined;
                    if (FindOptionsUtils_1.FindOptionsUtils.isFindManyOptions(optionsOrConditions))
                        // If where condition is passed as a string which contains sql we have to ignore
                        // as mongo is not a sql database
                        return typeof optionsOrConditions.where === "string"
                            ? {}
                            : optionsOrConditions.where;
                    return optionsOrConditions;
                };
                /**
                 * Converts FindOneOptions to mongodb query.
                 */
                MongoEntityManager.prototype.convertFindOneOptionsOrConditionsToMongodbQuery = function (optionsOrConditions) {
                    if (!optionsOrConditions)
                        return undefined;
                    if (FindOptionsUtils_1.FindOptionsUtils.isFindOneOptions(optionsOrConditions))
                        // If where condition is passed as a string which contains sql we have to ignore
                        // as mongo is not a sql database
                        return typeof optionsOrConditions.where === "string"
                            ? {}
                            : optionsOrConditions.where;
                    return optionsOrConditions;
                };
                /**
                 * Converts FindOptions into mongodb order by criteria.
                 */
                MongoEntityManager.prototype.convertFindOptionsOrderToOrderCriteria = function (order) {
                    return Object.keys(order).reduce(function (orderCriteria, key) {
                        switch (order[key]) {
                            case "DESC":
                                orderCriteria[key] = -1;
                                break;
                            case "ASC":
                                orderCriteria[key] = 1;
                                break;
                            default:
                                orderCriteria[key] = order[key];
                        }
                        return orderCriteria;
                    }, {});
                };
                return MongoEntityManager;
            }(EntityManager_1.EntityManager));
            exports_72("MongoEntityManager", MongoEntityManager);
        }
    };
});
System.register("typeorm/repository/MongoRepository", ["typeorm/repository/Repository"], function (exports_73, context_73) {
    "use strict";
    var __moduleName = context_73 && context_73.id;
    var Repository_1, MongoRepository;
    return {
        setters: [
            function (Repository_1_1) {
                Repository_1 = Repository_1_1;
            }
        ],
        execute: function () {
            /**
             * Repository used to manage mongodb documents of a single entity type.
             */
            MongoRepository = /** @class */ (function (_super) {
                __extends(MongoRepository, _super);
                function MongoRepository() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                // -------------------------------------------------------------------------
                // Overridden Methods
                // -------------------------------------------------------------------------
                /**
                 * Raw SQL query execution is not supported by MongoDB.
                 * Calling this method will return an error.
                 */
                MongoRepository.prototype.query = function (query, parameters) {
                    throw new Error("Queries aren't supported by MongoDB.");
                };
                /**
                 * Using Query Builder with MongoDB is not supported yet.
                 * Calling this method will return an error.
                 */
                MongoRepository.prototype.createQueryBuilder = function (alias, queryRunner) {
                    throw new Error("Query Builder is not supported by MongoDB.");
                };
                /**
                 * Finds entities that match given find options or conditions.
                 */
                MongoRepository.prototype.find = function (optionsOrConditions) {
                    return this.manager.find(this.metadata.target, optionsOrConditions);
                };
                /**
                 * Finds entities that match given find options or conditions.
                 * Also counts all entities that match given conditions,
                 * but ignores pagination settings (from and take options).
                 */
                MongoRepository.prototype.findAndCount = function (optionsOrConditions) {
                    return this.manager.findAndCount(this.metadata.target, optionsOrConditions);
                };
                /**
                 * Finds entities by ids.
                 * Optionally find options can be applied.
                 */
                MongoRepository.prototype.findByIds = function (ids, optionsOrConditions) {
                    return this.manager.findByIds(this.metadata.target, ids, optionsOrConditions);
                };
                /**
                 * Finds first entity that matches given conditions and/or find options.
                 */
                MongoRepository.prototype.findOne = function (optionsOrConditions) {
                    return this.manager.findOne(this.metadata.target, optionsOrConditions);
                };
                /**
                 * Finds entity by given id.
                 * Optionally find options or conditions can be applied.
                 */
                MongoRepository.prototype.findOneById = function (id, optionsOrConditions) {
                    return this.manager.findOneById(this.metadata.target, id, optionsOrConditions);
                };
                /**
                 * Creates a cursor for a query that can be used to iterate over results from MongoDB.
                 */
                MongoRepository.prototype.createCursor = function (query) {
                    return this.manager.createCursor(this.metadata.target, query);
                };
                /**
                 * Creates a cursor for a query that can be used to iterate over results from MongoDB.
                 * This returns modified version of cursor that transforms each result into Entity model.
                 */
                MongoRepository.prototype.createEntityCursor = function (query) {
                    return this.manager.createEntityCursor(this.metadata.target, query);
                };
                /**
                 * Execute an aggregation framework pipeline against the collection.
                 */
                MongoRepository.prototype.aggregate = function (pipeline, options) {
                    return this.manager.aggregate(this.metadata.target, pipeline, options);
                };
                /**
                 * Perform a bulkWrite operation without a fluent API.
                 */
                MongoRepository.prototype.bulkWrite = function (operations, options) {
                    return this.manager.bulkWrite(this.metadata.target, operations, options);
                };
                /**
                 * Count number of matching documents in the db to a query.
                 */
                MongoRepository.prototype.count = function (query, options) {
                    return this.manager.count(this.metadata.target, query || {}, options);
                };
                /**
                 * Creates an index on the db and collection.
                 */
                MongoRepository.prototype.createCollectionIndex = function (fieldOrSpec, options) {
                    return this.manager.createCollectionIndex(this.metadata.target, fieldOrSpec, options);
                };
                /**
                 * Creates multiple indexes in the collection, this method is only supported for MongoDB 2.6 or higher.
                 * Earlier version of MongoDB will throw a command not supported error.
                 * Index specifications are defined at http://docs.mongodb.org/manual/reference/command/createIndexes/.
                 */
                MongoRepository.prototype.createCollectionIndexes = function (indexSpecs) {
                    return this.manager.createCollectionIndexes(this.metadata.target, indexSpecs);
                };
                /**
                 * Delete multiple documents on MongoDB.
                 */
                MongoRepository.prototype.deleteMany = function (query, options) {
                    return this.manager.deleteMany(this.metadata.tableName, query, options);
                };
                /**
                 * Delete a document on MongoDB.
                 */
                MongoRepository.prototype.deleteOne = function (query, options) {
                    return this.manager.deleteOne(this.metadata.tableName, query, options);
                };
                /**
                 * The distinct command returns returns a list of distinct values for the given key across a collection.
                 */
                MongoRepository.prototype.distinct = function (key, query, options) {
                    return this.manager.distinct(this.metadata.tableName, key, query, options);
                };
                /**
                 * Drops an index from this collection.
                 */
                MongoRepository.prototype.dropCollectionIndex = function (indexName, options) {
                    return this.manager.dropCollectionIndex(this.metadata.tableName, indexName, options);
                };
                /**
                 * Drops all indexes from the collection.
                 */
                MongoRepository.prototype.dropCollectionIndexes = function () {
                    return this.manager.dropCollectionIndexes(this.metadata.tableName);
                };
                /**
                 * Find a document and delete it in one atomic operation, requires a write lock for the duration of the operation.
                 */
                MongoRepository.prototype.findOneAndDelete = function (query, options) {
                    return this.manager.findOneAndDelete(this.metadata.tableName, query, options);
                };
                /**
                 * Find a document and replace it in one atomic operation, requires a write lock for the duration of the operation.
                 */
                MongoRepository.prototype.findOneAndReplace = function (query, replacement, options) {
                    return this.manager.findOneAndReplace(this.metadata.tableName, query, replacement, options);
                };
                /**
                 * Find a document and update it in one atomic operation, requires a write lock for the duration of the operation.
                 */
                MongoRepository.prototype.findOneAndUpdate = function (query, update, options) {
                    return this.manager.findOneAndUpdate(this.metadata.tableName, query, update, options);
                };
                /**
                 * Execute a geo search using a geo haystack index on a collection.
                 */
                MongoRepository.prototype.geoHaystackSearch = function (x, y, options) {
                    return this.manager.geoHaystackSearch(this.metadata.tableName, x, y, options);
                };
                /**
                 * Execute the geoNear command to search for items in the collection.
                 */
                MongoRepository.prototype.geoNear = function (x, y, options) {
                    return this.manager.geoNear(this.metadata.tableName, x, y, options);
                };
                /**
                 * Run a group command across a collection.
                 */
                MongoRepository.prototype.group = function (keys, condition, initial, reduce, finalize, command, options) {
                    return this.manager.group(this.metadata.tableName, keys, condition, initial, reduce, finalize, command, options);
                };
                /**
                 * Retrieve all the indexes on the collection.
                 */
                MongoRepository.prototype.collectionIndexes = function () {
                    return this.manager.collectionIndexes(this.metadata.tableName);
                };
                /**
                 * Retrieve all the indexes on the collection.
                 */
                MongoRepository.prototype.collectionIndexExists = function (indexes) {
                    return this.manager.collectionIndexExists(this.metadata.tableName, indexes);
                };
                /**
                 * Retrieves this collections index info.
                 */
                MongoRepository.prototype.collectionIndexInformation = function (options) {
                    return this.manager.collectionIndexInformation(this.metadata.tableName, options);
                };
                /**
                 * Initiate an In order bulk write operation, operations will be serially executed in the order they are added, creating a new operation for each switch in types.
                 */
                MongoRepository.prototype.initializeOrderedBulkOp = function (options) {
                    return this.manager.initializeOrderedBulkOp(this.metadata.tableName, options);
                };
                /**
                 * Initiate a Out of order batch write operation. All operations will be buffered into insert/update/remove commands executed out of order.
                 */
                MongoRepository.prototype.initializeUnorderedBulkOp = function (options) {
                    return this.manager.initializeUnorderedBulkOp(this.metadata.tableName, options);
                };
                /**
                 * Inserts an array of documents into MongoDB.
                 */
                MongoRepository.prototype.insertMany = function (docs, options) {
                    return this.manager.insertMany(this.metadata.tableName, docs, options);
                };
                /**
                 * Inserts a single document into MongoDB.
                 */
                MongoRepository.prototype.insertOne = function (doc, options) {
                    return this.manager.insertOne(this.metadata.tableName, doc, options);
                };
                /**
                 * Returns if the collection is a capped collection.
                 */
                MongoRepository.prototype.isCapped = function () {
                    return this.manager.isCapped(this.metadata.tableName);
                };
                /**
                 * Get the list of all indexes information for the collection.
                 */
                MongoRepository.prototype.listCollectionIndexes = function (options) {
                    return this.manager.listCollectionIndexes(this.metadata.tableName, options);
                };
                /**
                 * Run Map Reduce across a collection. Be aware that the inline option for out will return an array of results not a collection.
                 */
                MongoRepository.prototype.mapReduce = function (map, reduce, options) {
                    return this.manager.mapReduce(this.metadata.tableName, map, reduce, options);
                };
                /**
                 * Return N number of parallel cursors for a collection allowing parallel reading of entire collection.
                 * There are no ordering guarantees for returned results.
                 */
                MongoRepository.prototype.parallelCollectionScan = function (options) {
                    return this.manager.parallelCollectionScan(this.metadata.tableName, options);
                };
                /**
                 * Reindex all indexes on the collection Warning: reIndex is a blocking operation (indexes are rebuilt in the foreground) and will be slow for large collections.
                 */
                MongoRepository.prototype.reIndex = function () {
                    return this.manager.reIndex(this.metadata.tableName);
                };
                /**
                 * Reindex all indexes on the collection Warning: reIndex is a blocking operation (indexes are rebuilt in the foreground) and will be slow for large collections.
                 */
                MongoRepository.prototype.rename = function (newName, options) {
                    return this.manager.rename(this.metadata.tableName, newName, options);
                };
                /**
                 * Replace a document on MongoDB.
                 */
                MongoRepository.prototype.replaceOne = function (query, doc, options) {
                    return this.manager.replaceOne(this.metadata.tableName, query, doc, options);
                };
                /**
                 * Get all the collection statistics.
                 */
                MongoRepository.prototype.stats = function (options) {
                    return this.manager.stats(this.metadata.tableName, options);
                };
                /**
                 * Update multiple documents on MongoDB.
                 */
                MongoRepository.prototype.updateMany = function (query, update, options) {
                    return this.manager.updateMany(this.metadata.tableName, query, update, options);
                };
                /**
                 * Update a single document on MongoDB.
                 */
                MongoRepository.prototype.updateOne = function (query, update, options) {
                    return this.manager.updateOne(this.metadata.tableName, query, update, options);
                };
                return MongoRepository;
            }(Repository_1.Repository));
            exports_73("MongoRepository", MongoRepository);
        }
    };
});
System.register("typeorm/repository/TreeRepository", ["typeorm/repository/Repository"], function (exports_74, context_74) {
    "use strict";
    var __moduleName = context_74 && context_74.id;
    var Repository_2, TreeRepository;
    return {
        setters: [
            function (Repository_2_1) {
                Repository_2 = Repository_2_1;
            }
        ],
        execute: function () {
            /**
             * Repository with additional functions to work with trees.
             *
             * @see Repository
             */
            TreeRepository = /** @class */ (function (_super) {
                __extends(TreeRepository, _super);
                function TreeRepository() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                // todo: implement moving
                // todo: implement removing
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Gets complete trees for all roots in the table.
                 */
                TreeRepository.prototype.findTrees = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var roots;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.findRoots()];
                                case 1:
                                    roots = _a.sent();
                                    return [4 /*yield*/, Promise.all(roots.map(function (root) { return __awaiter(_this, void 0, void 0, function () {
                                            return __generator(this, function (_a) {
                                                switch (_a.label) {
                                                    case 0: return [4 /*yield*/, this.findDescendantsTree(root)];
                                                    case 1:
                                                        _a.sent();
                                                        return [2 /*return*/];
                                                }
                                            });
                                        }); }))];
                                case 2:
                                    _a.sent();
                                    return [2 /*return*/, roots];
                            }
                        });
                    });
                };
                /**
                 * Roots are entities that have no ancestors. Finds them all.
                 */
                TreeRepository.prototype.findRoots = function () {
                    var _this = this;
                    var escapeAlias = function (alias) { return _this.manager.connection.driver.escape(alias); };
                    var escapeColumn = function (column) { return _this.manager.connection.driver.escape(column); };
                    var parentPropertyName = this.manager.connection.namingStrategy.joinColumnName(this.metadata.treeParentRelation.propertyName, "id");
                    return this.createQueryBuilder("treeEntity")
                        .where(escapeAlias("treeEntity") + "." + escapeColumn(parentPropertyName) + " IS NULL")
                        .getMany();
                };
                /**
                 * Gets all children (descendants) of the given entity. Returns them all in a flat array.
                 */
                TreeRepository.prototype.findDescendants = function (entity) {
                    return this
                        .createDescendantsQueryBuilder("treeEntity", "treeClosure", entity)
                        .getMany();
                };
                /**
                 * Gets all children (descendants) of the given entity. Returns them in a tree - nested into each other.
                 */
                TreeRepository.prototype.findDescendantsTree = function (entity) {
                    var _this = this;
                    // todo: throw exception if there is no column of this relation?
                    return this
                        .createDescendantsQueryBuilder("treeEntity", "treeClosure", entity)
                        .getRawAndEntities()
                        .then(function (entitiesAndScalars) {
                        var relationMaps = _this.createRelationMaps("treeEntity", entitiesAndScalars.raw);
                        _this.buildChildrenEntityTree(entity, entitiesAndScalars.entities, relationMaps);
                        return entity;
                    });
                };
                /**
                 * Gets number of descendants of the entity.
                 */
                TreeRepository.prototype.countDescendants = function (entity) {
                    return this
                        .createDescendantsQueryBuilder("treeEntity", "treeClosure", entity)
                        .getCount();
                };
                /**
                 * Creates a query builder used to get descendants of the entities in a tree.
                 */
                TreeRepository.prototype.createDescendantsQueryBuilder = function (alias, closureTableAlias, entity) {
                    var _this = this;
                    // create shortcuts for better readability
                    var escape = function (alias) { return _this.manager.connection.driver.escape(alias); };
                    var joinCondition = escape(alias) + "." + escape(this.metadata.primaryColumns[0].databaseName) + "=" + escape(closureTableAlias) + "." + escape("descendant");
                    return this.createQueryBuilder(alias)
                        .innerJoin(this.metadata.closureJunctionTable.tableName, closureTableAlias, joinCondition)
                        .where(escape(closureTableAlias) + "." + escape("ancestor") + "=" + this.metadata.getEntityIdMap(entity)[this.metadata.primaryColumns[0].propertyName]);
                };
                /**
                 * Gets all parents (ancestors) of the given entity. Returns them all in a flat array.
                 */
                TreeRepository.prototype.findAncestors = function (entity) {
                    return this
                        .createAncestorsQueryBuilder("treeEntity", "treeClosure", entity)
                        .getMany();
                };
                /**
                 * Gets all parents (ancestors) of the given entity. Returns them in a tree - nested into each other.
                 */
                TreeRepository.prototype.findAncestorsTree = function (entity) {
                    var _this = this;
                    // todo: throw exception if there is no column of this relation?
                    return this
                        .createAncestorsQueryBuilder("treeEntity", "treeClosure", entity)
                        .getRawAndEntities()
                        .then(function (entitiesAndScalars) {
                        var relationMaps = _this.createRelationMaps("treeEntity", entitiesAndScalars.raw);
                        _this.buildParentEntityTree(entity, entitiesAndScalars.entities, relationMaps);
                        return entity;
                    });
                };
                /**
                 * Gets number of ancestors of the entity.
                 */
                TreeRepository.prototype.countAncestors = function (entity) {
                    return this
                        .createAncestorsQueryBuilder("treeEntity", "treeClosure", entity)
                        .getCount();
                };
                /**
                 * Creates a query builder used to get ancestors of the entities in the tree.
                 */
                TreeRepository.prototype.createAncestorsQueryBuilder = function (alias, closureTableAlias, entity) {
                    var _this = this;
                    // create shortcuts for better readability
                    var escapeAlias = function (alias) { return _this.manager.connection.driver.escape(alias); };
                    var escapeColumn = function (column) { return _this.manager.connection.driver.escape(column); };
                    var joinCondition = escapeAlias(alias) + "." + escapeColumn(this.metadata.primaryColumns[0].databaseName) + "=" + escapeAlias(closureTableAlias) + "." + escapeColumn("ancestor");
                    return this.createQueryBuilder(alias)
                        .innerJoin(this.metadata.closureJunctionTable.tableName, closureTableAlias, joinCondition)
                        .where(escapeAlias(closureTableAlias) + "." + escapeColumn("descendant") + "=" + this.metadata.getEntityIdMap(entity)[this.metadata.primaryColumns[0].propertyName]);
                };
                /**
                 * Moves entity to the children of then given entity.
                 *
                move(entity: Entity, to: Entity): Promise<void> {
                    return Promise.resolve();
                } */
                // -------------------------------------------------------------------------
                // Protected Methods
                // -------------------------------------------------------------------------
                TreeRepository.prototype.createRelationMaps = function (alias, rawResults) {
                    var _this = this;
                    return rawResults.map(function (rawResult) {
                        return {
                            id: rawResult[alias + "_" + _this.metadata.primaryColumns[0].databaseName],
                            parentId: rawResult[alias + "_" + _this.metadata.treeParentRelation.joinColumns[0].givenDatabaseName]
                        };
                    });
                };
                TreeRepository.prototype.buildChildrenEntityTree = function (entity, entities, relationMaps) {
                    var _this = this;
                    var childProperty = this.metadata.treeChildrenRelation.propertyName;
                    var parentEntityId = this.metadata.primaryColumns[0].getEntityValue(entity);
                    var childRelationMaps = relationMaps.filter(function (relationMap) { return relationMap.parentId === parentEntityId; });
                    var childIds = childRelationMaps.map(function (relationMap) { return relationMap.id; });
                    entity[childProperty] = entities.filter(function (entity) { return childIds.indexOf(entity.id) !== -1; });
                    entity[childProperty].forEach(function (childEntity) {
                        _this.buildChildrenEntityTree(childEntity, entities, relationMaps);
                    });
                };
                TreeRepository.prototype.buildParentEntityTree = function (entity, entities, relationMaps) {
                    var _this = this;
                    var parentProperty = this.metadata.treeParentRelation.propertyName;
                    var entityId = this.metadata.primaryColumns[0].getEntityValue(entity);
                    var parentRelationMap = relationMaps.find(function (relationMap) { return relationMap.id === entityId; });
                    var parentEntity = entities.find(function (entity) {
                        if (!parentRelationMap)
                            return false;
                        return entity[_this.metadata.primaryColumns[0].propertyName] === parentRelationMap.parentId;
                    });
                    if (parentEntity) {
                        entity[parentProperty] = parentEntity;
                        this.buildParentEntityTree(entity[parentProperty], entities, relationMaps);
                    }
                };
                return TreeRepository;
            }(Repository_2.Repository));
            exports_74("TreeRepository", TreeRepository);
        }
    };
});
System.register("typeorm/util/DateUtils", [], function (exports_75, context_75) {
    "use strict";
    var __moduleName = context_75 && context_75.id;
    var DateUtils;
    return {
        setters: [],
        execute: function () {
            /**
             * Provides utilities to transform hydrated and persisted data.
             */
            DateUtils = /** @class */ (function () {
                function DateUtils() {
                }
                // -------------------------------------------------------------------------
                // Public Static Methods
                // -------------------------------------------------------------------------
                /**
                 * Normalizes date object hydrated from the database.
                 */
                DateUtils.normalizeHydratedDate = function (mixedDate) {
                    if (!mixedDate)
                        return mixedDate;
                    var date = typeof mixedDate === "string" ? new Date(mixedDate) : mixedDate;
                    return date;
                };
                /**
                 * Converts given value into date string in a "YYYY-MM-DD" format.
                 */
                DateUtils.mixedDateToDateString = function (value) {
                    if (value instanceof Date)
                        return this.formatZerolessValue(value.getFullYear()) + "-" + this.formatZerolessValue(value.getMonth() + 1) + "-" + this.formatZerolessValue(value.getDate());
                    return value;
                };
                /**
                 * Converts given value into date object.
                 */
                DateUtils.mixedDateToDate = function (mixedDate, toUtc, useMilliseconds) {
                    if (toUtc === void 0) { toUtc = false; }
                    if (useMilliseconds === void 0) { useMilliseconds = true; }
                    var date = typeof mixedDate === "string" ? new Date(mixedDate) : mixedDate;
                    if (toUtc)
                        date = new Date(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate(), date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds(), date.getUTCMilliseconds());
                    if (!useMilliseconds)
                        date.setUTCMilliseconds(0);
                    return date;
                };
                /**
                 * Converts given value into time string in a "HH:mm:ss" format.
                 */
                DateUtils.mixedDateToTimeString = function (value, skipSeconds) {
                    if (skipSeconds === void 0) { skipSeconds = false; }
                    if (value instanceof Date)
                        return this.formatZerolessValue(value.getHours()) +
                            ":" + this.formatZerolessValue(value.getMinutes()) +
                            (!skipSeconds ? ":" + this.formatZerolessValue(value.getSeconds()) : "");
                    return value;
                };
                /**
                 * Converts given value into time string in a "HH:mm:ss" format.
                 */
                DateUtils.mixedTimeToDate = function (value) {
                    if (typeof value === "string") {
                        var _a = value.split(":"), hours = _a[0], minutes = _a[1], seconds = _a[2];
                        var date = new Date();
                        if (hours)
                            date.setHours(parseInt(hours));
                        if (minutes)
                            date.setMinutes(parseInt(minutes));
                        if (seconds)
                            date.setSeconds(parseInt(seconds));
                        return date;
                    }
                    return value;
                };
                /**
                 * Converts given string value with "-" separator into a "HH:mm:ss" format.
                 */
                DateUtils.mixedTimeToString = function (value, skipSeconds) {
                    if (skipSeconds === void 0) { skipSeconds = false; }
                    value = value instanceof Date ? (value.getHours() + ":" + value.getMinutes() + (!skipSeconds ? ":" + value.getSeconds() : "")) : value;
                    if (typeof value === "string") {
                        return value.split(":")
                            .map(function (v) { return v.length === 1 ? "0" + v : v; }) // append zero at beginning if we have a first-zero-less number
                            .join(":");
                    }
                    return value;
                };
                /**
                 * Converts given value into datetime string in a "YYYY-MM-DD HH-mm-ss" format.
                 */
                DateUtils.mixedDateToDatetimeString = function (value) {
                    if (typeof value === "string") {
                        value = new Date(value);
                    }
                    if (value instanceof Date) {
                        return this.formatZerolessValue(value.getFullYear()) + "-" +
                            this.formatZerolessValue(value.getMonth() + 1) + "-" +
                            this.formatZerolessValue(value.getDate()) + " " +
                            this.formatZerolessValue(value.getHours()) + ":" +
                            this.formatZerolessValue(value.getMinutes()) + ":" +
                            this.formatZerolessValue(value.getSeconds()) + "." +
                            this.formatMilliseconds(value.getUTCMilliseconds());
                    }
                    return value;
                };
                /**
                 * Converts given value into utc datetime string in a "YYYY-MM-DD HH-mm-ss" format.
                 */
                DateUtils.mixedDateToUtcDatetimeString = function (value) {
                    if (typeof value === "string") {
                        value = new Date(value);
                    }
                    if (value instanceof Date) {
                        return this.formatZerolessValue(value.getUTCFullYear()) + "-" +
                            this.formatZerolessValue(value.getUTCMonth() + 1) + "-" +
                            this.formatZerolessValue(value.getUTCDate()) + " " +
                            this.formatZerolessValue(value.getUTCHours()) + ":" +
                            this.formatZerolessValue(value.getUTCMinutes()) + ":" +
                            this.formatZerolessValue(value.getUTCSeconds()) + "." +
                            this.formatMilliseconds(value.getUTCMilliseconds());
                    }
                    return value;
                };
                /**
                 * Converts each item in the given array to string joined by "," separator.
                 */
                DateUtils.simpleArrayToString = function (value) {
                    if (value instanceof Array) {
                        return value
                            .map(function (i) { return String(i); })
                            .join(",");
                    }
                    return value;
                };
                /**
                 * Converts given string to simple array split by "," separator.
                 */
                DateUtils.stringToSimpleArray = function (value) {
                    if (value instanceof String || typeof value === "string") {
                        if (value.length > 0) {
                            return value.split(",");
                        }
                        else {
                            return [];
                        }
                    }
                    return value;
                };
                DateUtils.simpleJsonToString = function (value) {
                    return JSON.stringify(value);
                };
                DateUtils.stringToSimpleJson = function (value) {
                    return JSON.parse(value);
                };
                // -------------------------------------------------------------------------
                // Private Static Methods
                // -------------------------------------------------------------------------
                /**
                 * Formats given number to "0x" format, e.g. if it is 1 then it will return "01".
                 */
                DateUtils.formatZerolessValue = function (value) {
                    if (value < 10)
                        return "0" + value;
                    return String(value);
                };
                /**
                 * Formats given number to "0x" format, e.g. if it is 1 then it will return "01".
                 */
                DateUtils.formatMilliseconds = function (value) {
                    if (value < 100)
                        return "0" + value;
                    return String(value);
                };
                return DateUtils;
            }());
            exports_75("DateUtils", DateUtils);
        }
    };
});
System.register("typeorm/persistence/Subject", ["typeorm/util/DateUtils"], function (exports_76, context_76) {
    "use strict";
    var __moduleName = context_76 && context_76.id;
    var DateUtils_1, Subject;
    return {
        setters: [
            function (DateUtils_1_1) {
                DateUtils_1 = DateUtils_1_1;
            }
        ],
        execute: function () {
            /**
             * Subject is a subject of persistence.
             * It holds information about each entity that needs to be persisted:
             * - what entity should be persisted
             * - what is database representation of the persisted entity
             * - what entity metadata of the persisted entity
             * - what is allowed to with persisted entity (insert/update/remove)
             *
             * Having this collection of subjects we can perform database queries.
             */
            Subject = /** @class */ (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function Subject(metadata, entity, databaseEntity) {
                    /**
                     * Date when this entity is persisted.
                     */
                    this.date = new Date();
                    // -------------------------------------------------------------------------
                    // Public Properties
                    // -------------------------------------------------------------------------
                    /**
                     * Indicates if this subject can be inserted into the database.
                     * This means that this subject either is newly persisted, either can be inserted by cascades.
                     */
                    this.canBeInserted = false;
                    /**
                     * Indicates if this subject can be updated in the database.
                     * This means that this subject either was persisted, either can be updated by cascades.
                     */
                    this.canBeUpdated = false;
                    /**
                     * Indicates if this subject MUST be removed from the database.
                     * This means that this subject either was removed, either was removed by cascades.
                     */
                    this.mustBeRemoved = false;
                    /**
                     * Differentiated columns between persisted and database entities.
                     */
                    this.diffColumns = [];
                    /**
                     * Differentiated relations between persisted and database entities.
                     */
                    this.diffRelations = [];
                    /**
                     * List of relations which need to be unset.
                     * This is used to update relation from inverse side.
                     */
                    this.relationUpdates = [];
                    /**
                     * Records that needs to be inserted into the junction tables of this subject.
                     */
                    this.junctionInserts = [];
                    /**
                     * Records that needs to be removed from the junction tables of this subject.
                     */
                    this.junctionRemoves = [];
                    this.metadata = metadata;
                    this._persistEntity = entity;
                    this._databaseEntity = databaseEntity;
                }
                Object.defineProperty(Subject.prototype, "entity", {
                    // -------------------------------------------------------------------------
                    // Accessors
                    // -------------------------------------------------------------------------
                    /**
                     * Gets entity sent to the persistence (e.g. changed entity).
                     * Throws error if persisted entity was not set.
                     */
                    get: function () {
                        if (!this._persistEntity)
                            throw new Error("Persistence entity is not set for the given subject.");
                        return this._persistEntity;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Subject.prototype, "hasEntity", {
                    /**
                     * Checks if subject has a persisted entity.
                     */
                    get: function () {
                        return !!this._persistEntity;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Subject.prototype, "databaseEntity", {
                    /**
                     * Gets entity from the database (e.g. original entity).
                     * THIS IS NOT RAW ENTITY DATA.
                     * Throws error if database entity was not set.
                     */
                    get: function () {
                        if (!this._databaseEntity)
                            throw new Error("Database entity is not set for the given subject.");
                        return this._databaseEntity;
                    },
                    /**
                     * Sets entity from the database (e.g. original entity).
                     * Once database entity set it calculates differentiated columns and relations
                     * between persistent entity and database entity.
                     */
                    set: function (databaseEntity) {
                        this._databaseEntity = databaseEntity;
                        this.recompute();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Subject.prototype, "hasDatabaseEntity", {
                    /**
                     * Checks if subject has a database entity.
                     */
                    get: function () {
                        return !!this._databaseEntity;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Subject.prototype, "entityTarget", {
                    /**
                     * Gets entity target from the entity metadata of this subject.
                     */
                    get: function () {
                        return this.metadata.target;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Subject.prototype, "mustBeInserted", {
                    /**
                     * Checks if this subject must be inserted into the database.
                     * Subject can be inserted into the database if it is allowed to be inserted (explicitly persisted or by cascades)
                     * and if it does not have database entity set.
                     */
                    get: function () {
                        return this.canBeInserted && !this.hasDatabaseEntity;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Subject.prototype, "mustBeUpdated", {
                    /**
                     * Checks if this subject must be updated into the database.
                     * Subject can be updated in the database if it is allowed to be updated (explicitly persisted or by cascades)
                     * and if it does have differentiated columns or relations.
                     */
                    get: function () {
                        return this.canBeUpdated && (this.diffColumns.length > 0 || this.diffRelations.length > 0);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Subject.prototype, "hasRelationUpdates", {
                    /**
                     * Checks if this subject has relations to be updated.
                     */
                    get: function () {
                        return this.relationUpdates.length > 0;
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Gets id of the persisted entity.
                 * If entity is not set then it returns undefined.
                 * If entity itself has an id then it simply returns it.
                 * If entity does not have an id then it returns newly generated id.
            
                get getPersistedEntityIdMap(): any|undefined {
                    if (!this.hasEntity)
                        return undefined;
            
                    const entityIdMap = this.metadata.getDatabaseEntityIdMap(this.entity);
                    if (entityIdMap)
                        return entityIdMap;
            
                    if (this.newlyGeneratedId)
                        return this.metadata.createSimpleDatabaseIdMap(this.newlyGeneratedId);
            
                    return undefined;
                }*/
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Validates this subject for errors.
                 * Subject cannot be at the same time inserted and updated, removed and inserted, removed and updated.
                 */
                Subject.prototype.validate = function () {
                    if (this.mustBeInserted && this.mustBeRemoved)
                        throw new Error("Removed entity " + this.metadata.name + " is also scheduled for insert operation. This looks like ORM problem. Please report a github issue.");
                    if (this.mustBeUpdated && this.mustBeRemoved)
                        throw new Error("Removed entity \"" + this.metadata.name + "\" is also scheduled for update operation. " +
                            "Make sure you are not updating and removing same object (note that update or remove may be executed by cascade operations).");
                    if (this.mustBeInserted && this.mustBeUpdated)
                        throw new Error("Inserted entity " + this.metadata.name + " is also scheduled for updated operation. This looks like ORM problem. Please report a github issue.");
                };
                /**
                 * Performs entity re-computations.
                 */
                Subject.prototype.recompute = function () {
                    if (this.hasEntity && this._databaseEntity) {
                        this.computeDiffColumns();
                        this.computeDiffRelationalColumns();
                    }
                };
                // -------------------------------------------------------------------------
                // Protected Methods
                // -------------------------------------------------------------------------
                /**
                 * Differentiate columns from the updated entity and entity stored in the database.
                 */
                Subject.prototype.computeDiffColumns = function () {
                    var _this = this;
                    this.diffColumns = this.metadata.columns.filter(function (column) {
                        // prepare both entity and database values to make comparision
                        var entityValue = column.getEntityValue(_this.entity);
                        var databaseValue = column.getEntityValue(_this.databaseEntity);
                        if (entityValue === undefined)
                            return false;
                        // normalize special values to make proper comparision (todo: arent they already normalized at this point?!)
                        if (entityValue !== null && entityValue !== undefined) {
                            if (column.type === "date") {
                                entityValue = DateUtils_1.DateUtils.mixedDateToDateString(entityValue);
                            }
                            else if (column.type === "time") {
                                entityValue = DateUtils_1.DateUtils.mixedDateToTimeString(entityValue);
                            }
                            else if (column.type === "datetime" || column.type === Date) {
                                entityValue = DateUtils_1.DateUtils.mixedDateToUtcDatetimeString(entityValue);
                                databaseValue = DateUtils_1.DateUtils.mixedDateToUtcDatetimeString(databaseValue);
                            }
                            else if (column.type === "json" || column.type === "jsonb") {
                                entityValue = JSON.stringify(entityValue);
                                if (databaseValue !== null && databaseValue !== undefined)
                                    databaseValue = JSON.stringify(databaseValue);
                            }
                            else if (column.type === "sample-array") {
                                entityValue = DateUtils_1.DateUtils.simpleArrayToString(entityValue);
                                databaseValue = DateUtils_1.DateUtils.simpleArrayToString(databaseValue);
                            }
                        }
                        // todo: this mechanism does not get in count embeddeds in embeddeds
                        // if value is not defined then no need to update it
                        // if (!column.isInEmbedded && this.entity[column.propertyName] === undefined)
                        //     return false;
                        //
                        // if value is in embedded and is not defined then no need to update it
                        // if (column.isInEmbedded && (this.entity[column.embeddedProperty] === undefined || this.entity[column.embeddedProperty][column.propertyName] === undefined))
                        //     return false;
                        // if its a special column or value is not changed - then do nothing
                        if (column.isVirtual ||
                            column.isParentId ||
                            column.isDiscriminator ||
                            column.isUpdateDate ||
                            column.isVersion ||
                            column.isCreateDate ||
                            entityValue === databaseValue)
                            return false;
                        // filter out "relational columns" only in the case if there is a relation object in entity
                        var relation = _this.metadata.findRelationWithDbName(column.databaseName);
                        if (relation) {
                            var value = relation.getEntityValue(_this.entity);
                            if (value !== null && value !== undefined)
                                return false;
                        }
                        return true;
                    });
                };
                /**
                 * Difference columns of the owning one-to-one and many-to-one columns.
                 */
                Subject.prototype.computeDiffRelationalColumns = function ( /*todo: updatesByRelations: UpdateByRelationOperation[], */) {
                    var _this = this;
                    this.diffRelations = this.metadata.relations.filter(function (relation) {
                        if (!relation.isManyToOne && !(relation.isOneToOne && relation.isOwning))
                            return false;
                        // here we cover two scenarios:
                        // 1. related entity can be another entity which is natural way
                        // 2. related entity can be entity id which is hacked way of updating entity
                        // todo: what to do if there is a column with relationId? (cover this too?)
                        var entityValue = relation.getEntityValue(_this.entity);
                        var updatedEntityRelationId = entityValue instanceof Object
                            ? relation.inverseEntityMetadata.getEntityIdMixedMap(entityValue)
                            : entityValue;
                        var dbEntityRelationId = relation.getEntityValue(_this.databaseEntity);
                        // todo: try to find if there is update by relation operation - we dont need to generate update relation operation for this
                        // todo: if (updatesByRelations.find(operation => operation.targetEntity === this && operation.updatedRelation === relation))
                        // todo:     return false;
                        // we don't perform operation over undefined properties
                        if (updatedEntityRelationId === undefined)
                            return false;
                        // if both are empty totally no need to do anything
                        if ((updatedEntityRelationId === undefined || updatedEntityRelationId === null) &&
                            (dbEntityRelationId === undefined || dbEntityRelationId === null))
                            return false;
                        // if relation ids aren't equal then we need to update them
                        return updatedEntityRelationId !== dbEntityRelationId;
                    });
                };
                return Subject;
            }());
            exports_76("Subject", Subject);
        }
    };
});
System.register("typeorm/util/OrmUtils", [], function (exports_77, context_77) {
    "use strict";
    var __moduleName = context_77 && context_77.id;
    var OrmUtils;
    return {
        setters: [],
        execute: function () {
            OrmUtils = /** @class */ (function () {
                function OrmUtils() {
                }
                OrmUtils.splitClassesAndStrings = function (clsesAndStrings) {
                    return [
                        clsesAndStrings.filter(function (cls) { return typeof cls !== "string"; }),
                        clsesAndStrings.filter(function (str) { return typeof str === "string"; }),
                    ];
                };
                OrmUtils.groupBy = function (array, propertyCallback) {
                    return array.reduce(function (groupedArray, value) {
                        var key = propertyCallback(value);
                        var grouped = groupedArray.find(function (i) { return i.id === key; });
                        if (!grouped) {
                            grouped = { id: key, items: [] };
                            groupedArray.push(grouped);
                        }
                        grouped.items.push(value);
                        return groupedArray;
                    }, []);
                };
                OrmUtils.uniq = function (array, criteriaOrProperty) {
                    return array.reduce(function (uniqueArray, item) {
                        var found = false;
                        if (criteriaOrProperty instanceof Function) {
                            var itemValue_1 = criteriaOrProperty(item);
                            found = !!uniqueArray.find(function (uniqueItem) { return criteriaOrProperty(uniqueItem) === itemValue_1; });
                        }
                        else if (typeof criteriaOrProperty === "string") {
                            found = !!uniqueArray.find(function (uniqueItem) { return uniqueItem[criteriaOrProperty] === item[criteriaOrProperty]; });
                        }
                        else {
                            found = uniqueArray.indexOf(item) !== -1;
                        }
                        if (!found)
                            uniqueArray.push(item);
                        return uniqueArray;
                    }, []);
                };
                OrmUtils.isObject = function (item) {
                    return (item && typeof item === "object" && !Array.isArray(item));
                };
                /**
                 * Deep Object.assign.
                 *
                 * @see http://stackoverflow.com/a/34749873
                 */
                OrmUtils.mergeDeep = function (target) {
                    var sources = [];
                    for (var _i = 1; _i < arguments.length; _i++) {
                        sources[_i - 1] = arguments[_i];
                    }
                    if (!sources.length)
                        return target;
                    var source = sources.shift();
                    if (this.isObject(target) && this.isObject(source)) {
                        for (var key in source) {
                            if (this.isObject(source[key])) {
                                if (!target[key])
                                    Object.assign(target, (_a = {}, _a[key] = {}, _a));
                                this.mergeDeep(target[key], source[key]);
                            }
                            else {
                                Object.assign(target, (_b = {}, _b[key] = source[key], _b));
                            }
                        }
                    }
                    return this.mergeDeep.apply(this, [target].concat(sources));
                    var _a, _b;
                };
                /**
                 * Deep compare objects.
                 *
                 * @see http://stackoverflow.com/a/1144249
                 */
                OrmUtils.deepCompare = function () {
                    var args = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        args[_i] = arguments[_i];
                    }
                    var i, l, leftChain, rightChain;
                    function compare2Objects(x, y) {
                        var p;
                        // remember that NaN === NaN returns false
                        // and isNaN(undefined) returns true
                        if (isNaN(x) && isNaN(y) && typeof x === "number" && typeof y === "number")
                            return true;
                        // Compare primitives and functions.
                        // Check if both arguments link to the same object.
                        // Especially useful on the step where we compare prototypes
                        if (x === y)
                            return true;
                        if (x.equals instanceof Function && x.equals(y))
                            return true;
                        // Works in case when functions are created in constructor.
                        // Comparing dates is a common scenario. Another built-ins?
                        // We can even handle functions passed across iframes
                        if ((typeof x === "function" && typeof y === "function") ||
                            (x instanceof Date && y instanceof Date) ||
                            (x instanceof RegExp && y instanceof RegExp) ||
                            (x instanceof String && y instanceof String) ||
                            (x instanceof Number && y instanceof Number))
                            return x.toString() === y.toString();
                        // At last checking prototypes as good as we can
                        if (!(x instanceof Object && y instanceof Object))
                            return false;
                        if (x.isPrototypeOf(y) || y.isPrototypeOf(x))
                            return false;
                        if (x.constructor !== y.constructor)
                            return false;
                        if (x.prototype !== y.prototype)
                            return false;
                        // Check for infinitive linking loops
                        if (leftChain.indexOf(x) > -1 || rightChain.indexOf(y) > -1)
                            return false;
                        // Quick checking of one object being a subset of another.
                        // todo: cache the structure of arguments[0] for performance
                        for (p in y) {
                            if (y.hasOwnProperty(p) !== x.hasOwnProperty(p)) {
                                return false;
                            }
                            else if (typeof y[p] !== typeof x[p]) {
                                return false;
                            }
                        }
                        for (p in x) {
                            if (y.hasOwnProperty(p) !== x.hasOwnProperty(p)) {
                                return false;
                            }
                            else if (typeof y[p] !== typeof x[p]) {
                                return false;
                            }
                            switch (typeof (x[p])) {
                                case "object":
                                case "function":
                                    leftChain.push(x);
                                    rightChain.push(y);
                                    if (!compare2Objects(x[p], y[p])) {
                                        return false;
                                    }
                                    leftChain.pop();
                                    rightChain.pop();
                                    break;
                                default:
                                    if (x[p] !== y[p]) {
                                        return false;
                                    }
                                    break;
                            }
                        }
                        return true;
                    }
                    if (arguments.length < 1) {
                        return true; // Die silently? Don't know how to handle such case, please help...
                        // throw "Need two or more arguments to compare";
                    }
                    for (i = 1, l = arguments.length; i < l; i++) {
                        leftChain = []; // Todo: this can be cached
                        rightChain = [];
                        if (!compare2Objects(arguments[0], arguments[i])) {
                            return false;
                        }
                    }
                    return true;
                };
                /**
                 * Transforms given value into boolean value.
                 */
                OrmUtils.toBoolean = function (value) {
                    if (typeof value === "boolean")
                        return value;
                    if (typeof value === "string")
                        return value === "true" || value === "1";
                    if (typeof value === "number")
                        return value > 0;
                    return false;
                };
                /**
                 * Composes an object from the given array of keys and values.
                 */
                OrmUtils.zipObject = function (keys, values) {
                    return keys.reduce(function (object, column, index) {
                        object[column] = values[index];
                        return object;
                    }, {});
                };
                return OrmUtils;
            }());
            exports_77("OrmUtils", OrmUtils);
        }
    };
});
System.register("typeorm/persistence/SubjectBuilder", ["typeorm/persistence/Subject", "typeorm/driver/mongodb/MongoDriver", "typeorm/util/OrmUtils"], function (exports_78, context_78) {
    "use strict";
    var __moduleName = context_78 && context_78.id;
    var Subject_1, MongoDriver_1, OrmUtils_1, SubjectBuilder;
    return {
        setters: [
            function (Subject_1_1) {
                Subject_1 = Subject_1_1;
            },
            function (MongoDriver_1_1) {
                MongoDriver_1 = MongoDriver_1_1;
            },
            function (OrmUtils_1_1) {
                OrmUtils_1 = OrmUtils_1_1;
            }
        ],
        execute: function () {
            /**
             * To be able to execute persistence operations we need to load all entities from the database we need.
             * Loading should be efficient - we need to load entities in as few queries as possible + load as less data as we can.
             * This is how we determine which entities needs to be loaded from db:
             *
             * 1. example with cascade updates and inserts:
             *
             * [Y] - means "yes, we load"
             * [N] - means "no, we don't load"
             * in {} braces we specify what cascade options are set between relations
             *
             * if Post is new, author is not set in the post
             *
             * [Y] Post -> {all} // yes because of "update" and "insert" cascades, no because of "remove"
             *   [Y] Author -> {all} // no because author is not set
             *     [Y] Photo -> {all} // no because author and its photo are not set
             *       [Y] Tag -> {all} // no because author and its photo and its tag are not set
             *
             * if Post is new, author is new (or anything else is new)
             * if Post is updated
             * if Post and/or Author are updated
             *
             * [Y] Post -> {all} // yes because of "update" and "insert" cascades, no because of "remove"
             *   [Y] Author -> {all} // yes because of "update" and "insert" cascades, no because of "remove"
             *     [Y] Photo -> {all} // yes because of "update" and "insert" cascades, no because of "remove"
             *       [Y] Tag -> {all} // yes because of "update" and "insert" cascades, no because of "remove"
             *
             * Here we load post, author, photo, tag to check if they are new or not to persist insert or update operation.
             * We load post, author, photo, tag only if they exist in the relation.
             * From these examples we can see that we always load entity relations when it has "update" or "insert" cascades.
             *
             * 2. example with cascade removes
             *
             * if entity is new its remove operations by cascades should not be executed
             * if entity is updated then values that are null or missing in array (not undefined!, undefined means skip - don't do anything) are treated as removed
             * if entity is removed then all its downside relations which has cascade remove should be removed
             *
             * Once we find removed entity - we load it, and every downside entity which has "remove" cascade set.
             *
             * At the end we have all entities we need to operate with.
             * Next step is to store all loaded entities to manipulate them efficiently.
             *
             * Rules of updating by cascades.
             * Insert operation can lead to:
             *  - insert operations
             *  - update operations
             * Update operation can lead to:
             *  - insert operations
             *  - update operations
             *  - remove operations
             * Remove operation can lead to:
             *  - remove operation
             */
            SubjectBuilder = /** @class */ (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function SubjectBuilder(connection, queryRunner) {
                    this.connection = connection;
                    this.queryRunner = queryRunner;
                    // -------------------------------------------------------------------------
                    // Protected properties
                    // -------------------------------------------------------------------------
                    /**
                     * If this gonna be reused then what to do with marked flags?
                     * One of solution can be clone this object and reset all marked states for this persistence.
                     * Or from reused just extract databaseEntities from their subjects? (looks better)
                     */
                    this.operateSubjects = [];
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Builds operations for entity that is being inserted/updated.
                 */
                SubjectBuilder.prototype.persist = function (entity, metadata) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var mainSubject, operateSubjectsWithDatabaseEntities;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    mainSubject = new Subject_1.Subject(metadata, entity);
                                    mainSubject.canBeInserted = true;
                                    mainSubject.canBeUpdated = true;
                                    this.operateSubjects.push(mainSubject);
                                    // next step we build list of subjects we will operate with
                                    // these subjects are subjects that we need to insert or update alongside with main persisted entity
                                    this.buildCascadeUpdateAndInsertOperateSubjects(mainSubject);
                                    // next step is to load database entities of all operate subjects
                                    return [4 /*yield*/, this.loadOperateSubjectsDatabaseEntities()];
                                case 1:
                                    // next step is to load database entities of all operate subjects
                                    _a.sent();
                                    operateSubjectsWithDatabaseEntities = this.operateSubjects.filter(function (subject) { return subject.hasDatabaseEntity; });
                                    return [4 /*yield*/, Promise.all(operateSubjectsWithDatabaseEntities.map(function (subject) {
                                            return _this.buildCascadeRemovedAndRelationUpdateOperateSubjects(subject);
                                        }))];
                                case 2:
                                    _a.sent();
                                    // finally find which operate subjects have insert and remove operations in their junction tables
                                    return [4 /*yield*/, this.buildJunctionOperations({ insert: true, remove: true })];
                                case 3:
                                    // finally find which operate subjects have insert and remove operations in their junction tables
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Builds only remove operations for entity that is being removed.
                 */
                SubjectBuilder.prototype.remove = function (entity, metadata) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var mainSubject, operateSubjectsWithDatabaseEntities;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    mainSubject = new Subject_1.Subject(metadata, entity);
                                    mainSubject.mustBeRemoved = true;
                                    this.operateSubjects.push(mainSubject);
                                    // next step we build list of subjects we will operate with
                                    // these subjects are subjects that we need to remove alongside with main removed entity
                                    this.buildCascadeRemoveOperateSubjects(mainSubject);
                                    // next step is to load database entities for all operate subjects
                                    return [4 /*yield*/, this.loadOperateSubjectsDatabaseEntities()];
                                case 1:
                                    // next step is to load database entities for all operate subjects
                                    _a.sent();
                                    operateSubjectsWithDatabaseEntities = this.operateSubjects.filter(function (subject) { return subject.hasDatabaseEntity; });
                                    return [4 /*yield*/, Promise.all(operateSubjectsWithDatabaseEntities.map(function (subject) {
                                            return _this.buildCascadeRemovedAndRelationUpdateOperateSubjects(subject);
                                        }))];
                                case 2:
                                    _a.sent();
                                    // finally find which operate subjects have remove operations in their junction tables
                                    return [4 /*yield*/, this.buildJunctionOperations({ insert: false, remove: true })];
                                case 3:
                                    // finally find which operate subjects have remove operations in their junction tables
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                // -------------------------------------------------------------------------
                // Protected Methods
                // -------------------------------------------------------------------------
                /**
                 * Builds and pushes to array of operate entities all entities that we will work with.
                 * These are only relational entities which has insert and update cascades.
                 * All such entities will be loaded from the database, because they can be inserted or updated.
                 * That's why we load them - to understand if they should be inserted or updated, or which columns we need to update.
                 * We can't add removed entities here, because to know which entity was removed we need first to
                 * load original entity (particularly its id) from the database.
                 * That's why we first need to load all changed entities, then extract ids of the removed entities from them,
                 * and only then load removed entities by extracted ids.
                 */
                SubjectBuilder.prototype.buildCascadeUpdateAndInsertOperateSubjects = function (subject) {
                    var _this = this;
                    subject.metadata
                        .extractRelationValuesFromEntity(subject.entity, subject.metadata.relations)
                        .filter(function (_a) {
                        var relation = _a[0], relationEntity = _a[1], relationEntityMetadata = _a[2];
                        // we need only defined values and insert or update cascades of the relation should be set
                        return relationEntity !== undefined &&
                            relationEntity !== null &&
                            (relation.isCascadeInsert || relation.isCascadeUpdate);
                    })
                        .forEach(function (_a) {
                        var relation = _a[0], relationEntity = _a[1], relationEntityMetadata = _a[2];
                        // if we already has this entity in list of operated subjects then skip it to avoid recursion
                        var alreadyExistRelationEntitySubject = _this.findByEntityLike(relationEntityMetadata.target, relationEntity);
                        if (alreadyExistRelationEntitySubject) {
                            if (alreadyExistRelationEntitySubject.canBeInserted === false) // if its not marked for insertion yet
                                alreadyExistRelationEntitySubject.canBeInserted = relation.isCascadeInsert === true;
                            if (alreadyExistRelationEntitySubject.canBeUpdated === false) // if its not marked for update yet
                                alreadyExistRelationEntitySubject.canBeUpdated = relation.isCascadeUpdate === true;
                            return;
                        }
                        // mark subject with what we can do with it
                        // and add to the array of subjects to load only if there is no same entity there already
                        var relationEntitySubject = new Subject_1.Subject(relationEntityMetadata, relationEntity);
                        relationEntitySubject.canBeInserted = relation.isCascadeInsert === true;
                        relationEntitySubject.canBeUpdated = relation.isCascadeUpdate === true;
                        _this.operateSubjects.push(relationEntitySubject);
                        // go recursively and find other entities we need to insert/update
                        _this.buildCascadeUpdateAndInsertOperateSubjects(relationEntitySubject);
                    });
                };
                /**
                 * Builds and pushes to array of operate entities all entities that must be removed.
                 */
                SubjectBuilder.prototype.buildCascadeRemoveOperateSubjects = function (subject) {
                    var _this = this;
                    subject.metadata
                        .extractRelationValuesFromEntity(subject.entity, subject.metadata.relations)
                        .filter(function (_a) {
                        var relation = _a[0], relationEntity = _a[1], relationEntityMetadata = _a[2];
                        // we need only defined values and insert cascades of the relation should be set
                        return relationEntity !== undefined && relationEntity !== null && relation.isCascadeRemove;
                    })
                        .forEach(function (_a) {
                        var relation = _a[0], relationEntity = _a[1], relationEntityMetadata = _a[2];
                        // if we already has this entity in list of operated subjects then skip it to avoid recursion
                        var alreadyExistValueSubject = _this.findByEntityLike(relationEntityMetadata.target, relationEntity);
                        if (alreadyExistValueSubject) {
                            alreadyExistValueSubject.mustBeRemoved = true;
                            return;
                        }
                        // add to the array of subjects to load only if there is no same entity there already
                        var valueSubject = new Subject_1.Subject(relationEntityMetadata, relationEntity);
                        valueSubject.mustBeRemoved = true;
                        _this.operateSubjects.push(valueSubject);
                        // go recursively and find other entities we need to remove
                        _this.buildCascadeRemoveOperateSubjects(valueSubject);
                    });
                };
                /**
                 * Loads database entities for all operate subjects which do not have database entity set.
                 * All entities that we load database entities for are marked as updated or inserted.
                 * To understand which of them really needs to be inserted or updated we need to load
                 * their original representations from the database.
                 */
                SubjectBuilder.prototype.loadOperateSubjectsDatabaseEntities = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var promises;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    promises = this.groupByEntityTargets().map(function (subjectGroup) { return __awaiter(_this, void 0, void 0, function () {
                                        var _this = this;
                                        var allIds, entities;
                                        return __generator(this, function (_a) {
                                            switch (_a.label) {
                                                case 0:
                                                    allIds = subjectGroup.subjects
                                                        .filter(function (subject) { return !subject.hasDatabaseEntity; }) // we don't load if subject already has a database entity loaded
                                                        .filter(function (subject) {
                                                        return !subject.metadata.isEntityMapEmpty(subject.entity);
                                                    }) // we only need entity id
                                                        .map(function (subject) {
                                                        // console.log(subject.entity);
                                                        return subject.metadata.getEntityIdMap(subject.entity);
                                                        // if (mixedId instanceof Object)
                                                        //     return Object.keys(mixedId).every(key => mixedId[key] !== undefined && mixedId[key] !== null && mixedId[key] !== "");
                                                        //
                                                        // return mixedId !== undefined && mixedId !== null && mixedId !== "";
                                                    });
                                                    // if there no ids found (which means all entities are new and have generated ids) - then nothing to load there
                                                    // console.log("allIds: ", allIds);
                                                    // console.log("subject.entity: ", subjectGroup.subjects);
                                                    // console.log("allIds: ", allIds);
                                                    if (!allIds.length)
                                                        return [2 /*return*/];
                                                    if (!(this.connection.driver instanceof MongoDriver_1.MongoDriver)) return [3 /*break*/, 2];
                                                    return [4 /*yield*/, this.connection
                                                            .getMongoRepository(subjectGroup.target)
                                                            .findByIds(allIds)];
                                                case 1:
                                                    entities = _a.sent();
                                                    return [3 /*break*/, 4];
                                                case 2: return [4 /*yield*/, this.connection
                                                        .getRepository(subjectGroup.target)
                                                        .createQueryBuilder("subject", this.queryRunner)
                                                        .whereInIds(allIds)
                                                        .loadAllRelationIds()
                                                        .getMany()];
                                                case 3:
                                                    entities = _a.sent();
                                                    _a.label = 4;
                                                case 4:
                                                    // now when we have entities we need to find subject of each entity
                                                    // and insert that entity into database entity of the found subject
                                                    entities.forEach(function (entity) {
                                                        // console.log(1);
                                                        var subject = _this.findByEntityLike(subjectGroup.target, entity);
                                                        if (subject)
                                                            subject.databaseEntity = entity;
                                                    });
                                                    return [2 /*return*/];
                                            }
                                        });
                                    }); });
                                    return [4 /*yield*/, Promise.all(promises)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * We need to load removed entity when:
                 *  - entity with relations is not new (this can be determined only after entity is loaded from db)
                 *      (note: simple "id" check will not work because id can be not generated)
                 *  - entity missing relation. When relation is simple
                 *      - in the case of one-to-one owner (with join column) relation we need to load owner entity
                 *      - in the case of one-to-one (without join column) relation we need to load inverse side entity
                 *      - in the case of many-to-one relations we need to load entity itself
                 *      - in the case of one-to-many relations we need to load entities by relation from inverse side
                 *
                 *  Before loading each entity we need to check in the loaded subjects - maybe it was already loaded.
                 *
                 *  BIG NOTE: objects are being removed by cascades not only when relation is removed, but also when
                 *  relation is replaced (e.g. changed with different object).
                 */
                SubjectBuilder.prototype.buildCascadeRemovedAndRelationUpdateOperateSubjects = function (subject) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var promises;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    promises = subject.metadata.relations.map(function (relation) { return __awaiter(_this, void 0, void 0, function () {
                                        var _this = this;
                                        var valueMetadata, qbAlias, relationIdInDatabaseEntity_1, persistValueRelationId, persistValue_1, alreadyLoadedRelatedDatabaseSubject, qb, condition, parameters, databaseEntity, persistValueRelationId, persistValue, relationIdInDatabaseEntity_2, alreadyLoadedRelatedDatabaseSubject, databaseEntity, inverseEntityRelationId, persistValue_2, databaseEntities_1, escape_1, joinAlias_1, joinColumnConditions, inverseJoinColumnConditions, conditions, parameters, joinAlias_2, joinColumnConditions, inverseJoinColumnConditions, conditions, parameters, relationIdInDatabaseEntity, promises_1, promises_2;
                                        return __generator(this, function (_a) {
                                            switch (_a.label) {
                                                case 0:
                                                    valueMetadata = relation.inverseEntityMetadata;
                                                    qbAlias = valueMetadata.tableName;
                                                    // added for type-safety, but subject without databaseEntity cant come here anyway because of checks on upper levels
                                                    if (!subject.hasDatabaseEntity)
                                                        return [2 /*return*/];
                                                    if (!(relation.isOneToOneOwner || relation.isManyToOne)) return [3 /*break*/, 4];
                                                    // we only work with cascade removes here
                                                    if (!relation.isCascadeRemove)
                                                        return [2 /*return*/];
                                                    relationIdInDatabaseEntity_1 = relation.getEntityValue(subject.databaseEntity);
                                                    // if database relation id does not exist in the database object then nothing to remove
                                                    if (relationIdInDatabaseEntity_1 === null || relationIdInDatabaseEntity_1 === undefined)
                                                        return [2 /*return*/];
                                                    persistValueRelationId = undefined, persistValue_1 = undefined;
                                                    if (subject.hasEntity) {
                                                        persistValue_1 = relation.getEntityValue(subject.entity);
                                                        if (persistValue_1 === null)
                                                            persistValueRelationId = null;
                                                        if (persistValue_1)
                                                            persistValueRelationId = relation.joinColumns.reduce(function (map, column) { return column.referencedColumn.getEntityValueMap(persistValue_1); }, {});
                                                        if (persistValueRelationId === undefined)
                                                            return [2 /*return*/]; // skip undefined properties
                                                    }
                                                    // object is removed only if relation id in the persisted entity is empty or is changed
                                                    // if (persistValueRelationId !== null && persistValueRelationId === relationIdInDatabaseEntity)
                                                    //     return;
                                                    // console.log("relationIdInDatabaseEntity:", relationIdInDatabaseEntity);
                                                    // console.log("persistValue:", persistValue);
                                                    // console.log("compareEntities:", relation.entityMetadata.compareEntities(relationIdInDatabaseEntity, persistValue));
                                                    // console.log("compareIds:", relation.entityMetadata.compareIds(relationIdInDatabaseEntity, persistValue));
                                                    if (persistValueRelationId !== null && relation.entityMetadata.compareIds(relationIdInDatabaseEntity_1, persistValue_1))
                                                        return [2 /*return*/];
                                                    alreadyLoadedRelatedDatabaseSubject = this.operateSubjects.find(function (relatedSubject) {
                                                        // (example) filter only subject that has database entity loaded and its target is Details
                                                        if (!relatedSubject.hasDatabaseEntity || relatedSubject.entityTarget !== valueMetadata.target)
                                                            return false;
                                                        // (example) here we seek a Details loaded from the database in the subjects
                                                        // (example) here relatedSubject.databaseEntity is a Details
                                                        // (example) and we need to compare details.id === post.detailsId
                                                        return relation.entityMetadata.compareIds(relationIdInDatabaseEntity_1, relation.getEntityValue(relatedSubject.databaseEntity));
                                                    });
                                                    if (!!alreadyLoadedRelatedDatabaseSubject) return [3 /*break*/, 2];
                                                    qb = this.connection
                                                        .getRepository(valueMetadata.target)
                                                        .createQueryBuilder(qbAlias, this.queryRunner) // todo: this wont work for mongodb. implement this in some method and call it here instead?
                                                        .loadAllRelationIds();
                                                    condition = relation.joinColumns.map(function (joinColumn) {
                                                        return qbAlias + "." + joinColumn.referencedColumn.propertyPath + " = :" + joinColumn.databaseName;
                                                    }).join(" AND ");
                                                    parameters = relation.joinColumns.reduce(function (parameters, joinColumn) {
                                                        parameters[joinColumn.databaseName] = joinColumn.referencedColumn.getEntityValue(relationIdInDatabaseEntity_1);
                                                        return parameters;
                                                    }, {});
                                                    qb.where(condition)
                                                        .setParameters(parameters);
                                                    return [4 /*yield*/, qb.getOne()];
                                                case 1:
                                                    databaseEntity = _a.sent();
                                                    if (databaseEntity) {
                                                        alreadyLoadedRelatedDatabaseSubject = new Subject_1.Subject(valueMetadata, undefined, databaseEntity);
                                                        this.operateSubjects.push(alreadyLoadedRelatedDatabaseSubject);
                                                    }
                                                    _a.label = 2;
                                                case 2:
                                                    if (!alreadyLoadedRelatedDatabaseSubject) return [3 /*break*/, 4];
                                                    // if object is already marked as removed then no need to proceed because it already was proceed
                                                    // if we remove this it will cause a recursion
                                                    if (alreadyLoadedRelatedDatabaseSubject.mustBeRemoved)
                                                        return [2 /*return*/];
                                                    alreadyLoadedRelatedDatabaseSubject.mustBeRemoved = true;
                                                    return [4 /*yield*/, this.buildCascadeRemovedAndRelationUpdateOperateSubjects(alreadyLoadedRelatedDatabaseSubject)];
                                                case 3:
                                                    _a.sent();
                                                    _a.label = 4;
                                                case 4:
                                                    if (!relation.isOneToOneNotOwner) return [3 /*break*/, 8];
                                                    // we only work with cascade removes here
                                                    if (!relation.isCascadeRemove)
                                                        return [2 /*return*/]; // todo: no
                                                    persistValueRelationId = undefined;
                                                    if (subject.hasEntity && !subject.mustBeRemoved) {
                                                        persistValue = relation.getEntityValue(subject.entity);
                                                        if (persistValue)
                                                            persistValueRelationId = relation.inverseRelation.getEntityValue(persistValue);
                                                        if (persistValueRelationId === undefined)
                                                            return [2 /*return*/]; // skip undefined properties
                                                    }
                                                    relationIdInDatabaseEntity_2 = relation.inverseRelation.joinColumns[0].referencedColumn.getEntityValue(subject.databaseEntity);
                                                    // if database relation id does not exist then nothing to remove (but can this be possible?)
                                                    if (relationIdInDatabaseEntity_2 === null || relationIdInDatabaseEntity_2 === undefined)
                                                        return [2 /*return*/];
                                                    alreadyLoadedRelatedDatabaseSubject = this.operateSubjects.find(function (relatedSubject) {
                                                        // (example) filter only subject that has database entity loaded and its target is Post
                                                        if (!relatedSubject.hasDatabaseEntity || relatedSubject.entityTarget !== valueMetadata.target)
                                                            return false;
                                                        // (example) here we seek a Post loaded from the database in the subjects
                                                        // (example) here relatedSubject.databaseEntity is a Post
                                                        // (example) and we need to compare post.detailsId === details.id
                                                        return relation.inverseRelation.getEntityValue(relatedSubject.databaseEntity) === relationIdInDatabaseEntity_2;
                                                    });
                                                    if (!!alreadyLoadedRelatedDatabaseSubject) return [3 /*break*/, 6];
                                                    return [4 /*yield*/, this.connection
                                                            .getRepository(valueMetadata.target)
                                                            .createQueryBuilder(qbAlias, this.queryRunner) // todo: this wont work for mongodb. implement this in some method and call it here instead?
                                                            .where(qbAlias + "." + relation.inverseSidePropertyPath + "=:id") // TODO relation.inverseRelation.joinColumns
                                                            .setParameter("id", relationIdInDatabaseEntity_2) // (example) subject.entity is a details here, and the value is details.id
                                                            .loadAllRelationIds()
                                                            .getOne()];
                                                case 5:
                                                    databaseEntity = _a.sent();
                                                    // add only if database entity exist - because in the case of inverse side of the one-to-one relation
                                                    // we cannot check if it was removed or not until we query the database
                                                    // and it can be a situation that relation wasn't exist at all. This is particular that case
                                                    alreadyLoadedRelatedDatabaseSubject = new Subject_1.Subject(valueMetadata, undefined, databaseEntity);
                                                    this.operateSubjects.push(alreadyLoadedRelatedDatabaseSubject);
                                                    _a.label = 6;
                                                case 6:
                                                    if (!(alreadyLoadedRelatedDatabaseSubject && alreadyLoadedRelatedDatabaseSubject.hasDatabaseEntity)) return [3 /*break*/, 8];
                                                    inverseEntityRelationId = relation.inverseRelation.getEntityValue(alreadyLoadedRelatedDatabaseSubject.databaseEntity);
                                                    if (persistValueRelationId && persistValueRelationId === inverseEntityRelationId)
                                                        return [2 /*return*/];
                                                    // if object is already marked as removed then no need to proceed because it already was proceed
                                                    // if we remove this it will cause a recursion
                                                    if (alreadyLoadedRelatedDatabaseSubject.mustBeRemoved)
                                                        return [2 /*return*/];
                                                    alreadyLoadedRelatedDatabaseSubject.mustBeRemoved = true;
                                                    return [4 /*yield*/, this.buildCascadeRemovedAndRelationUpdateOperateSubjects(alreadyLoadedRelatedDatabaseSubject)];
                                                case 7:
                                                    _a.sent();
                                                    _a.label = 8;
                                                case 8:
                                                    if (!(relation.isOneToMany || relation.isManyToMany)) return [3 /*break*/, 18];
                                                    persistValue_2 = undefined;
                                                    if (subject.hasEntity) {
                                                        persistValue_2 = relation.getEntityValue(subject.entity);
                                                        if (persistValue_2 === undefined)
                                                            return [2 /*return*/]; // skip undefined properties
                                                    }
                                                    databaseEntities_1 = [];
                                                    escape_1 = function (name) { return _this.connection.driver.escape(name); };
                                                    if (!relation.isManyToManyOwner) return [3 /*break*/, 10];
                                                    // we only need to load inverse entities if cascade removes are set
                                                    // because remove by cascades is the only reason we need relational entities here
                                                    if (!relation.isCascadeRemove)
                                                        return [2 /*return*/];
                                                    joinAlias_1 = escape_1("persistenceJoinedRelation");
                                                    joinColumnConditions = relation.joinColumns.map(function (joinColumn) {
                                                        return joinAlias_1 + "." + joinColumn.propertyName + " = :" + joinColumn.propertyName;
                                                    });
                                                    inverseJoinColumnConditions = relation.inverseJoinColumns.map(function (inverseJoinColumn) {
                                                        return joinAlias_1 + "." + inverseJoinColumn.propertyName + " = " + escape_1(qbAlias) + "." + escape_1(inverseJoinColumn.referencedColumn.propertyName);
                                                    });
                                                    conditions = joinColumnConditions.concat(inverseJoinColumnConditions).join(" AND ");
                                                    parameters = relation.joinColumns.reduce(function (parameters, joinColumn) {
                                                        parameters[joinColumn.propertyName] = joinColumn.referencedColumn.getEntityValue(subject.databaseEntity);
                                                        return parameters;
                                                    }, {});
                                                    return [4 /*yield*/, this.connection
                                                            .getRepository(valueMetadata.target)
                                                            .createQueryBuilder(qbAlias, this.queryRunner) // todo: this wont work for mongodb. implement this in some method and call it here instead?
                                                            .innerJoin(relation.junctionEntityMetadata.tableName, joinAlias_1, conditions)
                                                            .setParameters(parameters)
                                                            .loadAllRelationIds()
                                                            .getMany()];
                                                case 9:
                                                    databaseEntities_1 = _a.sent();
                                                    return [3 /*break*/, 14];
                                                case 10:
                                                    if (!relation.isManyToManyNotOwner) return [3 /*break*/, 12];
                                                    // we only need to load inverse entities if cascade removes are set
                                                    // because remove by cascades is the only reason we need relational entities here
                                                    if (!relation.isCascadeRemove)
                                                        return [2 /*return*/];
                                                    joinAlias_2 = escape_1("persistenceJoinedRelation");
                                                    joinColumnConditions = relation.joinColumns.map(function (joinColumn) {
                                                        return joinAlias_2 + "." + joinColumn.propertyName + " = " + escape_1(qbAlias) + "." + escape_1(joinColumn.referencedColumn.propertyName);
                                                    });
                                                    inverseJoinColumnConditions = relation.inverseJoinColumns.map(function (inverseJoinColumn) {
                                                        return joinAlias_2 + "." + inverseJoinColumn.propertyName + " = :" + inverseJoinColumn.propertyName;
                                                    });
                                                    conditions = joinColumnConditions.concat(inverseJoinColumnConditions).join(" AND ");
                                                    parameters = relation.inverseRelation.inverseJoinColumns.reduce(function (parameters, joinColumn) {
                                                        parameters[joinColumn.propertyName] = joinColumn.referencedColumn.getEntityValue(subject.databaseEntity);
                                                        return parameters;
                                                    }, {});
                                                    return [4 /*yield*/, this.connection
                                                            .getRepository(valueMetadata.target)
                                                            .createQueryBuilder(qbAlias, this.queryRunner) // todo: this wont work for mongodb. implement this in some method and call it here instead?
                                                            .innerJoin(relation.junctionEntityMetadata.tableName, joinAlias_2, conditions)
                                                            .setParameters(parameters)
                                                            .loadAllRelationIds()
                                                            .getMany()];
                                                case 11:
                                                    databaseEntities_1 = _a.sent();
                                                    return [3 /*break*/, 14];
                                                case 12:
                                                    relationIdInDatabaseEntity = relation.inverseRelation.joinColumns[0].referencedColumn.getEntityValue(subject.databaseEntity);
                                                    return [4 /*yield*/, this.connection
                                                            .getRepository(valueMetadata.target)
                                                            .createQueryBuilder(qbAlias, this.queryRunner) // todo: this wont work for mongodb. implement this in some method and call it here instead?
                                                            .where(qbAlias + "." + relation.inverseSidePropertyPath + "=:id")
                                                            .setParameter("id", relationIdInDatabaseEntity)
                                                            .loadAllRelationIds()
                                                            .getMany()];
                                                case 13:
                                                    // in this case we need inverse entities not only because of cascade removes
                                                    // because we also need inverse entities to be able to perform update of entities
                                                    // in the inverse side when entities is detached from one-to-many relation
                                                    databaseEntities_1 = _a.sent();
                                                    _a.label = 14;
                                                case 14:
                                                    // add to loadMap loaded entities if some of them are missing
                                                    databaseEntities_1.forEach(function (databaseEntity) {
                                                        var subjectInLoadMap = _this.findByEntityLike(valueMetadata.target, databaseEntity);
                                                        if (subjectInLoadMap && !subjectInLoadMap.hasDatabaseEntity) {
                                                            subjectInLoadMap.databaseEntity = databaseEntity;
                                                        }
                                                        else if (!subjectInLoadMap) {
                                                            var subject_1 = new Subject_1.Subject(valueMetadata, undefined, databaseEntity);
                                                            _this.operateSubjects.push(subject_1);
                                                        }
                                                    });
                                                    if (!(relation.isOneToMany && persistValue_2)) return [3 /*break*/, 16];
                                                    promises_1 = persistValue_2.map(function (persistValue) { return __awaiter(_this, void 0, void 0, function () {
                                                        var persistedValueInDatabaseEntity, loadedSubject, id, databaseEntity;
                                                        return __generator(this, function (_a) {
                                                            switch (_a.label) {
                                                                case 0:
                                                                    persistedValueInDatabaseEntity = databaseEntities_1.find(function (databaseEntity) {
                                                                        return valueMetadata.compareEntities(persistValue, databaseEntity);
                                                                    });
                                                                    if (!!persistedValueInDatabaseEntity) return [3 /*break*/, 3];
                                                                    loadedSubject = this.findByDatabaseEntityLike(valueMetadata.target, persistValue);
                                                                    if (!!loadedSubject) return [3 /*break*/, 2];
                                                                    id = valueMetadata.getEntityIdMap(persistValue);
                                                                    if (!id) return [3 /*break*/, 2];
                                                                    return [4 /*yield*/, this.connection
                                                                            .getRepository(valueMetadata.target)
                                                                            .createQueryBuilder(qbAlias, this.queryRunner) // todo: this wont work for mongodb. implement this in some method and call it here instead?
                                                                            .whereInIds([id])
                                                                            .loadAllRelationIds()
                                                                            .getOne()];
                                                                case 1:
                                                                    databaseEntity = _a.sent();
                                                                    if (databaseEntity) {
                                                                        loadedSubject = new Subject_1.Subject(valueMetadata, undefined, databaseEntity); // todo: what if entity like object exist in the loaded subjects but without databaseEntity?
                                                                        this.operateSubjects.push(loadedSubject);
                                                                    }
                                                                    _a.label = 2;
                                                                case 2:
                                                                    if (loadedSubject) {
                                                                        loadedSubject.relationUpdates.push({
                                                                            relation: relation.inverseRelation,
                                                                            value: subject.entity
                                                                        });
                                                                    }
                                                                    _a.label = 3;
                                                                case 3: return [2 /*return*/];
                                                            }
                                                        });
                                                    }); });
                                                    return [4 /*yield*/, Promise.all(promises_1)];
                                                case 15:
                                                    _a.sent();
                                                    _a.label = 16;
                                                case 16:
                                                    promises_2 = databaseEntities_1.map(function (databaseEntity) { return __awaiter(_this, void 0, void 0, function () {
                                                        var relatedEntitySubject, relatedValue;
                                                        return __generator(this, function (_a) {
                                                            switch (_a.label) {
                                                                case 0:
                                                                    relatedEntitySubject = this.findByDatabaseEntityLike(valueMetadata.target, databaseEntity);
                                                                    if (!relatedEntitySubject)
                                                                        return [2 /*return*/]; // should not be possible, anyway add it for type-safety
                                                                    // if object is already marked as removed then no need to proceed because it already was proceed
                                                                    // if we remove this check it will cause a recursion
                                                                    if (relatedEntitySubject.mustBeRemoved)
                                                                        return [2 /*return*/]; // todo: add another check for entity in unsetRelations?
                                                                    relatedValue = (persistValue_2 || []).find(function (persistValueItem) {
                                                                        return valueMetadata.compareEntities(relatedEntitySubject.databaseEntity, persistValueItem);
                                                                    });
                                                                    if (!(persistValue_2 === null || !relatedValue)) return [3 /*break*/, 3];
                                                                    if (!relation.isCascadeRemove) return [3 /*break*/, 2];
                                                                    relatedEntitySubject.mustBeRemoved = true;
                                                                    // mark as removed all underlying entities that has cascade remove
                                                                    return [4 /*yield*/, this.buildCascadeRemovedAndRelationUpdateOperateSubjects(relatedEntitySubject)];
                                                                case 1:
                                                                    // mark as removed all underlying entities that has cascade remove
                                                                    _a.sent();
                                                                    return [3 /*break*/, 3];
                                                                case 2:
                                                                    if (relation.isOneToMany && relation.inverseRelation) {
                                                                        relatedEntitySubject.relationUpdates.push({
                                                                            relation: relation.inverseRelation,
                                                                            value: null
                                                                        }); // todo: implement same for one-to-one
                                                                    }
                                                                    _a.label = 3;
                                                                case 3: return [2 /*return*/];
                                                            }
                                                        });
                                                    }); });
                                                    return [4 /*yield*/, Promise.all(promises_2)];
                                                case 17:
                                                    _a.sent();
                                                    _a.label = 18;
                                                case 18: return [2 /*return*/];
                                            }
                                        });
                                    }); });
                                    return [4 /*yield*/, Promise.all(promises)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Builds all junction insert and remove operations used to insert new bind data into junction tables,
                 * or remove old junction records.
                 * Options specifies which junction operations should be built - insert, remove or both.
                 */
                SubjectBuilder.prototype.buildJunctionOperations = function (options) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var promises;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    promises = this.operateSubjects.filter(function (subject) { return subject.hasEntity; }).map(function (subject) {
                                        var metadata = subject.metadata.parentEntityMetadata ? subject.metadata.parentEntityMetadata : subject.metadata;
                                        var promises = metadata.manyToManyRelations.map(function (relation) { return __awaiter(_this, void 0, void 0, function () {
                                            var existInverseEntityRelationIds_1, relatedValue, existInverseEntityRelationIds, changedInverseEntityRelationIds, removedJunctionEntityIds, newJunctionEntities;
                                            return __generator(this, function (_a) {
                                                // if subject marked to be removed then all its junctions must be removed
                                                if (subject.mustBeRemoved && options.remove) {
                                                    existInverseEntityRelationIds_1 = relation.getEntityValue(subject.databaseEntity);
                                                    // finally create a new junction remove operation and push it to the array of such operations
                                                    if (existInverseEntityRelationIds_1.length > 0) {
                                                        subject.junctionRemoves.push({
                                                            relation: relation,
                                                            junctionRelationIds: existInverseEntityRelationIds_1
                                                        });
                                                    }
                                                    return [2 /*return*/];
                                                }
                                                // if entity don't have entity then no need to find something that should be inserted or removed
                                                if (!subject.hasEntity)
                                                    return [2 /*return*/];
                                                relatedValue = relation.getEntityValue(subject.entity);
                                                if (!(relatedValue instanceof Array))
                                                    return [2 /*return*/];
                                                existInverseEntityRelationIds = [];
                                                // if subject don't have database entity it means its new and we don't need to remove something that is not exist
                                                if (subject.hasDatabaseEntity) {
                                                    existInverseEntityRelationIds = relation.getEntityValue(subject.databaseEntity);
                                                    // console.log("existInverseEntityRelationIds:", existInverseEntityRelationIds[0]);
                                                }
                                                changedInverseEntityRelationIds = relatedValue
                                                    .map(function (subRelationValue) {
                                                    var joinColumns = relation.isOwning ? relation.inverseJoinColumns : relation.inverseRelation.joinColumns;
                                                    return joinColumns.reduce(function (ids, joinColumn) {
                                                        return OrmUtils_1.OrmUtils.mergeDeep(ids, joinColumn.referencedColumn.createValueMap(joinColumn.referencedColumn.getEntityValue(subRelationValue))); // todo: duplicate. relation.createJoinColumnsIdMap(entity) ?
                                                    }, {});
                                                })
                                                    .filter(function (subRelationValue) { return subRelationValue !== undefined && subRelationValue !== null; });
                                                removedJunctionEntityIds = existInverseEntityRelationIds.filter(function (existRelationId) {
                                                    return !changedInverseEntityRelationIds.find(function (changedRelationId) {
                                                        return relation.inverseEntityMetadata.compareIds(changedRelationId, existRelationId);
                                                    });
                                                });
                                                newJunctionEntities = relatedValue.filter(function (subRelatedValue) {
                                                    // console.log(subRelatedValue);
                                                    var joinColumns = relation.isOwning ? relation.inverseJoinColumns : relation.inverseRelation.joinColumns;
                                                    var ids = joinColumns.reduce(function (ids, joinColumn) {
                                                        return OrmUtils_1.OrmUtils.mergeDeep(ids, joinColumn.referencedColumn.createValueMap(joinColumn.referencedColumn.getEntityValue(subRelatedValue))); // todo: duplicate. relation.createJoinColumnsIdMap(entity) ?
                                                    }, {});
                                                    // console.log("ids:", ids);
                                                    return !existInverseEntityRelationIds.find(function (relationId) {
                                                        return relation.inverseEntityMetadata.compareIds(relationId, ids);
                                                    });
                                                });
                                                // console.log("newJunctionEntities: ", newJunctionEntities);
                                                // finally create a new junction insert operation and push it to the array of such operations
                                                if (newJunctionEntities.length > 0 && options.insert) {
                                                    subject.junctionInserts.push({
                                                        relation: relation,
                                                        junctionEntities: newJunctionEntities
                                                    });
                                                }
                                                // finally create a new junction remove operation and push it to the array of such operations
                                                if (removedJunctionEntityIds.length > 0 && options.remove) {
                                                    subject.junctionRemoves.push({
                                                        relation: relation,
                                                        junctionRelationIds: removedJunctionEntityIds
                                                    });
                                                }
                                                return [2 /*return*/];
                                            });
                                        }); });
                                        return Promise.all(promises);
                                    });
                                    return [4 /*yield*/, Promise.all(promises)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Finds subject where entity like given subject's entity.
                 * Comparision made by entity id.
                 */
                SubjectBuilder.prototype.findByEntityLike = function (entityTarget, entity) {
                    return this.operateSubjects.find(function (subject) {
                        if (!subject.hasEntity)
                            return false;
                        if (subject.entity === entity)
                            return true;
                        return subject.entityTarget === entityTarget && subject.metadata.compareEntities(subject.entity, entity);
                    });
                };
                /**
                 * Finds subject where entity like given subject's database entity.
                 * Comparision made by entity id.
                 */
                SubjectBuilder.prototype.findByDatabaseEntityLike = function (entityTarget, entity) {
                    return this.operateSubjects.find(function (subject) {
                        if (!subject.hasDatabaseEntity)
                            return false;
                        return subject.entityTarget === entityTarget && subject.metadata.compareEntities(subject.databaseEntity, entity);
                    });
                };
                /**
                 * Groups given Subject objects into groups separated by entity targets.
                 */
                SubjectBuilder.prototype.groupByEntityTargets = function () {
                    return this.operateSubjects.reduce(function (groups, operatedEntity) {
                        var group = groups.find(function (group) { return group.target === operatedEntity.entityTarget; });
                        if (!group) {
                            group = { target: operatedEntity.entityTarget, subjects: [] };
                            groups.push(group);
                        }
                        group.subjects.push(operatedEntity);
                        return groups;
                    }, []);
                };
                return SubjectBuilder;
            }());
            exports_78("SubjectBuilder", SubjectBuilder);
        }
    };
});
System.register("typeorm/util/PromiseUtils", [], function (exports_79, context_79) {
    "use strict";
    var __moduleName = context_79 && context_79.id;
    var PromiseUtils;
    return {
        setters: [],
        execute: function () {
            /**
             * Utils to help to work with Promise objects.
             */
            PromiseUtils = /** @class */ (function () {
                function PromiseUtils() {
                }
                /**
                 * Runs given callback that returns promise for each item in the given collection in order.
                 * Operations executed after each other, right after previous promise being resolved.
                 */
                PromiseUtils.runInSequence = function (collection, callback) {
                    var results = [];
                    return collection.reduce(function (promise, item) {
                        return promise.then(function () {
                            return callback(item);
                        }).then(function (result) {
                            results.push(result);
                        });
                    }, Promise.resolve()).then(function () {
                        return results;
                    });
                };
                /**
                 * Returns a promise that is fulfilled with an array of promise state snapshots,
                 * but only after all the original promises have settled, i.e. become either fulfilled or rejected.
                 */
                PromiseUtils.settle = function (promises) {
                    return Promise.all(promises.map(function (p) { return Promise.resolve(p).then(function (v) { return ({
                        state: "fulfilled",
                        value: v,
                    }); }, function (r) { return ({
                        state: "rejected",
                        reason: r,
                    }); }); })).then(function (results) {
                        var rejected = results.find(function (result) { return result.state === "rejected"; });
                        if (rejected)
                            return Promise.reject(rejected.reason);
                        return results.map(function (result) { return result.value; });
                    });
                };
                return PromiseUtils;
            }());
            exports_79("PromiseUtils", PromiseUtils);
        }
    };
});
System.register("typeorm/subscriber/event/UpdateEvent", [], function (exports_80, context_80) {
    "use strict";
    var __moduleName = context_80 && context_80.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/subscriber/event/RemoveEvent", [], function (exports_81, context_81) {
    "use strict";
    var __moduleName = context_81 && context_81.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/subscriber/event/InsertEvent", [], function (exports_82, context_82) {
    "use strict";
    var __moduleName = context_82 && context_82.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/subscriber/EntitySubscriberInterface", [], function (exports_83, context_83) {
    "use strict";
    var __moduleName = context_83 && context_83.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/metadata/types/EventListenerTypes", [], function (exports_84, context_84) {
    "use strict";
    var __moduleName = context_84 && context_84.id;
    var EventListenerTypes;
    return {
        setters: [],
        execute: function () {
            EventListenerTypes = /** @class */ (function () {
                /**
                 * Provides a constants for each entity listener type.
                 */
                function EventListenerTypes() {
                }
                EventListenerTypes.AFTER_LOAD = "after-load";
                EventListenerTypes.BEFORE_INSERT = "before-insert";
                EventListenerTypes.AFTER_INSERT = "after-insert";
                EventListenerTypes.BEFORE_UPDATE = "before-update";
                EventListenerTypes.AFTER_UPDATE = "after-update";
                EventListenerTypes.BEFORE_REMOVE = "before-remove";
                EventListenerTypes.AFTER_REMOVE = "after-remove";
                return EventListenerTypes;
            }());
            exports_84("EventListenerTypes", EventListenerTypes);
        }
    };
});
System.register("typeorm/subscriber/Broadcaster", ["typeorm/metadata/types/EventListenerTypes"], function (exports_85, context_85) {
    "use strict";
    var __moduleName = context_85 && context_85.id;
    var EventListenerTypes_1, Broadcaster;
    return {
        setters: [
            function (EventListenerTypes_1_1) {
                EventListenerTypes_1 = EventListenerTypes_1_1;
            }
        ],
        execute: function () {
            /**
             * Broadcaster provides a helper methods to broadcast events to the subscribers.
             */
            Broadcaster = /** @class */ (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function Broadcaster(connection) {
                    this.connection = connection;
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Broadcasts "BEFORE_INSERT", "BEFORE_UPDATE", "BEFORE_REMOVE" events for all given subjects.
                 */
                Broadcaster.prototype.broadcastBeforeEventsForAll = function (entityManager, insertSubjects, updateSubjects, removeSubjects) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var insertPromises, updatePromises, removePromises, allPromises;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    insertPromises = insertSubjects.map(function (subject) { return _this.broadcastBeforeInsertEvent(entityManager, subject); });
                                    updatePromises = updateSubjects.map(function (subject) { return _this.broadcastBeforeUpdateEvent(entityManager, subject); });
                                    removePromises = removeSubjects.map(function (subject) { return _this.broadcastBeforeRemoveEvent(entityManager, subject); });
                                    allPromises = insertPromises.concat(updatePromises).concat(removePromises);
                                    return [4 /*yield*/, Promise.all(allPromises)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Broadcasts "AFTER_INSERT", "AFTER_UPDATE", "AFTER_REMOVE" events for all given subjects.
                 */
                Broadcaster.prototype.broadcastAfterEventsForAll = function (entityManager, insertSubjects, updateSubjects, removeSubjects) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var insertPromises, updatePromises, removePromises, allPromises;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    insertPromises = insertSubjects.map(function (subject) { return _this.broadcastAfterInsertEvent(entityManager, subject); });
                                    updatePromises = updateSubjects.map(function (subject) { return _this.broadcastAfterUpdateEvent(entityManager, subject); });
                                    removePromises = removeSubjects.map(function (subject) { return _this.broadcastAfterRemoveEvent(entityManager, subject); });
                                    allPromises = insertPromises.concat(updatePromises).concat(removePromises);
                                    return [4 /*yield*/, Promise.all(allPromises)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Broadcasts "BEFORE_INSERT" event.
                 * Before insert event is executed before entity is being inserted to the database for the first time.
                 * All subscribers and entity listeners who listened to this event will be executed at this point.
                 * Subscribers and entity listeners can return promises, it will wait until they are resolved.
                 */
                Broadcaster.prototype.broadcastBeforeInsertEvent = function (manager, subject) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var listeners, subscribers;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    listeners = subject.metadata.listeners
                                        .filter(function (listener) { return listener.type === EventListenerTypes_1.EventListenerTypes.BEFORE_INSERT && listener.isAllowed(subject.entity); })
                                        .map(function (entityListener) { return entityListener.execute(subject.entity); });
                                    subscribers = this.connection.subscribers
                                        .filter(function (subscriber) { return _this.isAllowedSubscriber(subscriber, subject.entityTarget) && subscriber.beforeInsert; })
                                        .map(function (subscriber) { return subscriber.beforeInsert({
                                        manager: manager,
                                        entity: subject.entity
                                    }); });
                                    return [4 /*yield*/, Promise.all(listeners.concat(subscribers))];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Broadcasts "BEFORE_UPDATE" event.
                 * Before update event is executed before entity is being updated in the database.
                 * All subscribers and entity listeners who listened to this event will be executed at this point.
                 * Subscribers and entity listeners can return promises, it will wait until they are resolved.
                 */
                Broadcaster.prototype.broadcastBeforeUpdateEvent = function (manager, subject) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var listeners, subscribers;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    listeners = subject.metadata.listeners
                                        .filter(function (listener) { return listener.type === EventListenerTypes_1.EventListenerTypes.BEFORE_UPDATE && listener.isAllowed(subject.entity); })
                                        .map(function (entityListener) { return entityListener.execute(subject.entity); });
                                    subscribers = this.connection.subscribers
                                        .filter(function (subscriber) { return _this.isAllowedSubscriber(subscriber, subject.entityTarget) && subscriber.beforeUpdate; })
                                        .map(function (subscriber) { return subscriber.beforeUpdate({
                                        manager: manager,
                                        entity: subject.entity,
                                        databaseEntity: subject.databaseEntity,
                                        updatedColumns: subject.diffColumns,
                                        updatedRelations: subject.diffRelations,
                                    }); });
                                    return [4 /*yield*/, Promise.all(listeners.concat(subscribers))];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Broadcasts "BEFORE_REMOVE" event.
                 * Before remove event is executed before entity is being removed from the database.
                 * All subscribers and entity listeners who listened to this event will be executed at this point.
                 * Subscribers and entity listeners can return promises, it will wait until they are resolved.
                 */
                Broadcaster.prototype.broadcastBeforeRemoveEvent = function (manager, subject) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var listeners, subscribers;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    listeners = subject.metadata.listeners
                                        .filter(function (listener) { return listener.type === EventListenerTypes_1.EventListenerTypes.BEFORE_REMOVE && listener.isAllowed(subject.entity); })
                                        .map(function (entityListener) { return entityListener.execute(subject.databaseEntity); });
                                    subscribers = this.connection.subscribers
                                        .filter(function (subscriber) { return _this.isAllowedSubscriber(subscriber, subject.entityTarget) && subscriber.beforeRemove; })
                                        .map(function (subscriber) { return subscriber.beforeRemove({
                                        manager: manager,
                                        entity: subject.hasEntity ? subject.entity : undefined,
                                        databaseEntity: subject.databaseEntity,
                                        entityId: subject.metadata.getEntityIdMixedMap(subject.databaseEntity)
                                    }); });
                                    return [4 /*yield*/, Promise.all(listeners.concat(subscribers))];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Broadcasts "AFTER_INSERT" event.
                 * After insert event is executed after entity is being persisted to the database for the first time.
                 * All subscribers and entity listeners who listened to this event will be executed at this point.
                 * Subscribers and entity listeners can return promises, it will wait until they are resolved.
                 */
                Broadcaster.prototype.broadcastAfterInsertEvent = function (manager, subject) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var listeners, subscribers;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    listeners = subject.metadata.listeners
                                        .filter(function (listener) { return listener.type === EventListenerTypes_1.EventListenerTypes.AFTER_INSERT && listener.isAllowed(subject.entity); })
                                        .map(function (entityListener) { return entityListener.execute(subject.entity); });
                                    subscribers = this.connection.subscribers
                                        .filter(function (subscriber) { return _this.isAllowedSubscriber(subscriber, subject.entityTarget) && subscriber.afterInsert; })
                                        .map(function (subscriber) { return subscriber.afterInsert({
                                        manager: manager,
                                        entity: subject.entity
                                    }); });
                                    return [4 /*yield*/, Promise.all(listeners.concat(subscribers))];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Broadcasts "AFTER_UPDATE" event.
                 * After update event is executed after entity is being updated in the database.
                 * All subscribers and entity listeners who listened to this event will be executed at this point.
                 * Subscribers and entity listeners can return promises, it will wait until they are resolved.
                 */
                Broadcaster.prototype.broadcastAfterUpdateEvent = function (manager, subject) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var listeners, subscribers;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    listeners = subject.metadata.listeners
                                        .filter(function (listener) { return listener.type === EventListenerTypes_1.EventListenerTypes.AFTER_UPDATE && listener.isAllowed(subject.entity); })
                                        .map(function (entityListener) { return entityListener.execute(subject.entity); });
                                    subscribers = this.connection.subscribers
                                        .filter(function (subscriber) { return _this.isAllowedSubscriber(subscriber, subject.entityTarget) && subscriber.afterUpdate; })
                                        .map(function (subscriber) { return subscriber.afterUpdate({
                                        manager: manager,
                                        entity: subject.entity,
                                        databaseEntity: subject.databaseEntity,
                                        updatedColumns: subject.diffColumns,
                                        updatedRelations: subject.diffRelations,
                                    }); });
                                    return [4 /*yield*/, Promise.all(listeners.concat(subscribers))];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Broadcasts "AFTER_REMOVE" event.
                 * After remove event is executed after entity is being removed from the database.
                 * All subscribers and entity listeners who listened to this event will be executed at this point.
                 * Subscribers and entity listeners can return promises, it will wait until they are resolved.
                 */
                Broadcaster.prototype.broadcastAfterRemoveEvent = function (manager, subject) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var listeners, subscribers;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    listeners = subject.metadata.listeners
                                        .filter(function (listener) { return listener.type === EventListenerTypes_1.EventListenerTypes.AFTER_REMOVE && listener.isAllowed(subject.entity); })
                                        .map(function (entityListener) { return entityListener.execute(subject.entity); });
                                    subscribers = this.connection.subscribers
                                        .filter(function (subscriber) { return _this.isAllowedSubscriber(subscriber, subject.entityTarget) && subscriber.afterRemove; })
                                        .map(function (subscriber) { return subscriber.afterRemove({
                                        manager: manager,
                                        entity: subject.hasEntity ? subject.entity : undefined,
                                        databaseEntity: subject.databaseEntity,
                                        entityId: subject.metadata.getEntityIdMixedMap(subject.databaseEntity)
                                    }); });
                                    return [4 /*yield*/, Promise.all(listeners.concat(subscribers))];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Broadcasts "AFTER_LOAD" event for all given entities, and their sub-entities.
                 * After load event is executed after entity has been loaded from the database.
                 * All subscribers and entity listeners who listened to this event will be executed at this point.
                 * Subscribers and entity listeners can return promises, it will wait until they are resolved.
                 */
                Broadcaster.prototype.broadcastLoadEventsForAll = function (target, entities) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, Promise.all(entities.map(function (entity) { return _this.broadcastLoadEvents(target, entity); }))];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Broadcasts "AFTER_LOAD" event for the given entity and all its sub-entities.
                 * After load event is executed after entity has been loaded from the database.
                 * All subscribers and entity listeners who listened to this event will be executed at this point.
                 * Subscribers and entity listeners can return promises, it will wait until they are resolved.
                 */
                Broadcaster.prototype.broadcastLoadEvents = function (target, entity) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var children, listeners, subscribers;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (entity instanceof Promise) // todo: check why need this?
                                        return [2 /*return*/];
                                    children = this.connection.getMetadata(target).relations.reduce(function (promises, relation) {
                                        // in lazy relations we cannot simply access to entity property because it will cause a getter and a database query
                                        if (relation.isLazy) {
                                            if (!entity.hasOwnProperty(relation.propertyName))
                                                return promises;
                                        }
                                        else {
                                            if (entity[relation.propertyName] === null || entity[relation.propertyName] === undefined)
                                                return promises;
                                        }
                                        var value = relation.getEntityValue(entity);
                                        if (value instanceof Array) {
                                            promises = promises.concat(_this.broadcastLoadEventsForAll(relation.inverseEntityMetadata.target, value));
                                        }
                                        else if (value) {
                                            promises.push(_this.broadcastLoadEvents(relation.inverseEntityMetadata.target, value));
                                        }
                                        return promises;
                                    }, []);
                                    listeners = this.connection.getMetadata(target).listeners
                                        .filter(function (listener) { return listener.type === EventListenerTypes_1.EventListenerTypes.AFTER_LOAD && listener.isAllowed(entity); })
                                        .map(function (listener) { return entity[listener.propertyName](); });
                                    subscribers = this.connection.subscribers
                                        .filter(function (subscriber) { return _this.isAllowedSubscriber(subscriber, target) && subscriber.afterLoad; })
                                        .map(function (subscriber) { return subscriber.afterLoad(entity); });
                                    return [4 /*yield*/, Promise.all(children.concat(listeners.concat(subscribers)))];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                // -------------------------------------------------------------------------
                // Protected Methods
                // -------------------------------------------------------------------------
                /**
                 * Checks if subscriber's methods can be executed by checking if its don't listen to the particular entity,
                 * or listens our entity.
                 */
                Broadcaster.prototype.isAllowedSubscriber = function (subscriber, target) {
                    return !subscriber.listenTo ||
                        !subscriber.listenTo() ||
                        subscriber.listenTo() === Object ||
                        subscriber.listenTo() === target ||
                        subscriber.listenTo().isPrototypeOf(target);
                };
                return Broadcaster;
            }());
            exports_85("Broadcaster", Broadcaster);
        }
    };
});
System.register("typeorm/persistence/SubjectOperationExecutor", ["typeorm/util/OrmUtils", "typeorm/util/PromiseUtils", "typeorm/driver/mongodb/MongoDriver", "typeorm/subscriber/Broadcaster"], function (exports_86, context_86) {
    "use strict";
    var __moduleName = context_86 && context_86.id;
    var OrmUtils_2, PromiseUtils_1, MongoDriver_2, Broadcaster_1, SubjectOperationExecutor;
    return {
        setters: [
            function (OrmUtils_2_1) {
                OrmUtils_2 = OrmUtils_2_1;
            },
            function (PromiseUtils_1_1) {
                PromiseUtils_1 = PromiseUtils_1_1;
            },
            function (MongoDriver_2_1) {
                MongoDriver_2 = MongoDriver_2_1;
            },
            function (Broadcaster_1_1) {
                Broadcaster_1 = Broadcaster_1_1;
            }
        ],
        execute: function () {
            /**
             * Executes all database operations (inserts, updated, deletes) that must be executed
             * with given persistence subjects.
             */
            SubjectOperationExecutor = /** @class */ (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function SubjectOperationExecutor(connection, transactionEntityManager, queryRunner, subjects) {
                    /*subjects.forEach(subject => {
                     console.log(subject.entity);
                     console.log("mustBeInserted: ", subject.mustBeInserted);
                     console.log("mustBeUpdated: ", subject.mustBeUpdated);
                     console.log("mustBeRemoved: ", subject.mustBeRemoved);
                     });*/
                    this.connection = connection;
                    this.transactionEntityManager = transactionEntityManager;
                    this.queryRunner = queryRunner;
                    // validate all subjects first
                    subjects.forEach(function (subject) { return subject.validate(); });
                    // set class properties for easy use
                    this.allSubjects = subjects;
                    this.insertSubjects = subjects.filter(function (subject) { return subject.mustBeInserted; });
                    this.updateSubjects = subjects.filter(function (subject) { return subject.mustBeUpdated; });
                    this.removeSubjects = subjects.filter(function (subject) { return subject.mustBeRemoved; });
                    this.relationUpdateSubjects = subjects.filter(function (subject) { return subject.hasRelationUpdates; });
                    this.broadcaster = new Broadcaster_1.Broadcaster(this.connection);
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                SubjectOperationExecutor.prototype.areExecutableOperations = function () {
                    return this.insertSubjects.length > 0 ||
                        this.updateSubjects.length > 0 ||
                        this.removeSubjects.length > 0 ||
                        this.relationUpdateSubjects.length > 0 ||
                        this.allSubjects.some(function (subject) { return subject.junctionInserts.length > 0; }) ||
                        this.allSubjects.some(function (subject) { return subject.junctionRemoves.length > 0; });
                };
                /**
                 * Executes all operations over given array of subjects.
                 * Executes queries using given query runner.
                 */
                SubjectOperationExecutor.prototype.execute = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: 
                                // broadcast "before" events before we start updating
                                return [4 /*yield*/, this.broadcaster.broadcastBeforeEventsForAll(this.transactionEntityManager, this.insertSubjects, this.updateSubjects, this.removeSubjects)];
                                case 1:
                                    // broadcast "before" events before we start updating
                                    _a.sent();
                                    // since events can trigger some internal changes (for example update depend property) we need to perform some re-computations here
                                    this.updateSubjects.forEach(function (subject) { return subject.recompute(); });
                                    return [4 /*yield*/, this.executeInsertOperations()];
                                case 2:
                                    _a.sent();
                                    return [4 /*yield*/, this.executeInsertClosureTableOperations()];
                                case 3:
                                    _a.sent();
                                    return [4 /*yield*/, this.executeInsertJunctionsOperations()];
                                case 4:
                                    _a.sent();
                                    return [4 /*yield*/, this.executeRemoveJunctionsOperations()];
                                case 5:
                                    _a.sent();
                                    return [4 /*yield*/, this.executeUpdateOperations()];
                                case 6:
                                    _a.sent();
                                    return [4 /*yield*/, this.executeUpdateRelations()];
                                case 7:
                                    _a.sent();
                                    return [4 /*yield*/, this.executeRemoveOperations()];
                                case 8:
                                    _a.sent();
                                    // update all special columns in persisted entities, like inserted id or remove ids from the removed entities
                                    return [4 /*yield*/, this.updateSpecialColumnsInPersistedEntities()];
                                case 9:
                                    // update all special columns in persisted entities, like inserted id or remove ids from the removed entities
                                    _a.sent();
                                    // finally broadcast "after" events
                                    // todo: THIS SHOULD NOT BE TRUTH: note that we are broadcasting events after commit because we want to have ids of the entities inside them to be available in subscribers
                                    return [4 /*yield*/, this.broadcaster.broadcastAfterEventsForAll(this.transactionEntityManager, this.insertSubjects, this.updateSubjects, this.removeSubjects)];
                                case 10:
                                    // finally broadcast "after" events
                                    // todo: THIS SHOULD NOT BE TRUTH: note that we are broadcasting events after commit because we want to have ids of the entities inside them to be available in subscribers
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                // -------------------------------------------------------------------------
                // Private Methods: Insertion
                // -------------------------------------------------------------------------
                /**
                 * Executes insert operations.
                 *
                 * For insertion we separate two groups of entities:
                 * - first group of entities are entities which do not have any relations
                 *      or entities which do not have any non-nullable relation
                 * - second group of entities are entities which does have non-nullable relations
                 *
                 * Insert process of the entities from the first group which can only have nullable relations are actually a two-step process:
                 * - first we insert entities without their relations, explicitly left them NULL
                 * - later we update inserted entity once again with id of the object inserted with it
                 *
                 * Yes, two queries are being executed, but this is by design.
                 * There is no better way to solve this problem and others at the same time.
                 *
                 * Insert process of the entities from the second group which can have only non nullable relations is a single-step process:
                 * - we simply insert all entities and get into attention all its dependencies which were inserted in the first group
                 */
                SubjectOperationExecutor.prototype.executeInsertOperations = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var firstInsertSubjects, secondInsertSubjects, updatePromises;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    firstInsertSubjects = this.insertSubjects.filter(function (subject) { return !subject.metadata.hasNonNullableRelations; });
                                    secondInsertSubjects = this.insertSubjects.filter(function (subject) { return subject.metadata.hasNonNullableRelations; });
                                    // note: these operations should be executed in sequence, not in parallel
                                    // because second group depend of obtained data from the first group
                                    return [4 /*yield*/, Promise.all(firstInsertSubjects.map(function (subject) { return _this.insert(subject, []); }))];
                                case 1:
                                    // note: these operations should be executed in sequence, not in parallel
                                    // because second group depend of obtained data from the first group
                                    _a.sent();
                                    return [4 /*yield*/, Promise.all(secondInsertSubjects.map(function (subject) { return _this.insert(subject, firstInsertSubjects); }))];
                                case 2:
                                    _a.sent();
                                    updatePromises = [];
                                    firstInsertSubjects.forEach(function (subject) {
                                        // first update relations with join columns (one-to-one owner and many-to-one relations)
                                        var updateOptions = {};
                                        subject.metadata.relationsWithJoinColumns.forEach(function (relation) {
                                            relation.joinColumns.forEach(function (joinColumn) {
                                                var referencedColumn = joinColumn.referencedColumn;
                                                var relatedEntity = relation.getEntityValue(subject.entity);
                                                // if relation value is not set then nothing to do here
                                                if (!relatedEntity)
                                                    return;
                                                // check if relation reference column is a relation
                                                var relationId;
                                                var columnRelation = relation.inverseEntityMetadata.findRelationWithPropertyPath(joinColumn.referencedColumn.propertyPath);
                                                if (columnRelation) { // if referenced column is a relation
                                                    var insertSubject = _this.insertSubjects.find(function (insertedSubject) { return insertedSubject.entity === referencedColumn.getEntityValue(relatedEntity); });
                                                    // if this relation was just inserted
                                                    if (insertSubject) {
                                                        // check if we have this relation id already
                                                        relationId = columnRelation.getEntityValue(referencedColumn.getEntityValue(relatedEntity));
                                                        if (!relationId) {
                                                            // if we don't have relation id then use special values
                                                            if (referencedColumn.isGenerated && insertSubject.generatedMap)
                                                                relationId = referencedColumn.getEntityValue(insertSubject.generatedMap);
                                                            // todo: handle other special types too
                                                        }
                                                    }
                                                }
                                                else { // if referenced column is a simple non relational column
                                                    var insertSubject = _this.insertSubjects.find(function (insertedSubject) { return insertedSubject.entity === relatedEntity; });
                                                    // if this relation was just inserted
                                                    if (insertSubject) {
                                                        // check if we have this relation id already
                                                        relationId = referencedColumn.getEntityValue(relatedEntity);
                                                        if (!relationId) {
                                                            // if we don't have relation id then use special values
                                                            if (referencedColumn.isGenerated && insertSubject.generatedMap)
                                                                relationId = referencedColumn.getEntityValue(insertSubject.generatedMap);
                                                            // todo: handle other special types too
                                                        }
                                                    }
                                                }
                                                if (relationId) {
                                                    updateOptions[joinColumn.databaseName] = relationId;
                                                }
                                            });
                                        });
                                        // if we found relations which we can update - then update them
                                        if (Object.keys(updateOptions).length > 0 /*&& subject.hasEntity*/) {
                                            // const relatedEntityIdMap = subject.getPersistedEntityIdMap; // todo: this works incorrectly
                                            var columns = subject.metadata.parentEntityMetadata ? subject.metadata.primaryColumns : subject.metadata.primaryColumns;
                                            var conditions_1 = {};
                                            columns.forEach(function (column) {
                                                var entityValue = column.getEntityValue(subject.entity);
                                                // if entity id is a relation, then extract referenced column from that relation
                                                var columnRelation = subject.metadata.relations.find(function (relation) { return relation.propertyName === column.propertyName; });
                                                if (entityValue && columnRelation) { // not sure if we need handle join column from inverse side
                                                    columnRelation.joinColumns.forEach(function (joinColumn) {
                                                        var relationIdOfEntityValue = entityValue[joinColumn.referencedColumn.propertyName];
                                                        if (!relationIdOfEntityValue) {
                                                            var entityValueInsertSubject = _this.insertSubjects.find(function (subject) { return subject.entity === entityValue; });
                                                            if (entityValueInsertSubject) {
                                                                if (joinColumn.referencedColumn.isGenerated && entityValueInsertSubject.generatedMap)
                                                                    relationIdOfEntityValue = joinColumn.referencedColumn.getEntityValue(entityValueInsertSubject.generatedMap);
                                                            }
                                                        }
                                                        if (relationIdOfEntityValue) {
                                                            conditions_1[column.databaseName] = relationIdOfEntityValue;
                                                        }
                                                    });
                                                }
                                                else {
                                                    if (entityValue) {
                                                        conditions_1[column.databaseName] = entityValue;
                                                    }
                                                    else {
                                                        if (subject.generatedMap)
                                                            conditions_1[column.databaseName] = column.getEntityValue(subject.generatedMap);
                                                    }
                                                }
                                            });
                                            if (!Object.keys(conditions_1).length)
                                                return;
                                            var updatePromise = _this.queryRunner.update(subject.metadata.tablePath, updateOptions, conditions_1);
                                            updatePromises.push(updatePromise);
                                        }
                                        // we need to update relation ids if newly inserted objects are used from inverse side in one-to-many inverse relation
                                        // we also need to update relation ids if newly inserted objects are used from inverse side in one-to-one inverse relation
                                        var oneToManyAndOneToOneNonOwnerRelations = subject.metadata.oneToManyRelations.concat(subject.metadata.oneToOneRelations.filter(function (relation) { return !relation.isOwning; }));
                                        // console.log(oneToManyAndOneToOneNonOwnerRelations);
                                        subject.metadata.extractRelationValuesFromEntity(subject.entity, oneToManyAndOneToOneNonOwnerRelations)
                                            .forEach(function (_a) {
                                            var relation = _a[0], subRelatedEntity = _a[1], inverseEntityMetadata = _a[2];
                                            relation.inverseRelation.joinColumns.forEach(function (joinColumn) {
                                                var referencedColumn = joinColumn.referencedColumn;
                                                var columns = inverseEntityMetadata.parentEntityMetadata ? inverseEntityMetadata.primaryColumns : inverseEntityMetadata.primaryColumns;
                                                var conditions = {};
                                                columns.forEach(function (column) {
                                                    var entityValue = column.getEntityValue(subRelatedEntity);
                                                    // if entity id is a relation, then extract referenced column from that relation
                                                    var columnRelation = inverseEntityMetadata.relations.find(function (relation) { return relation.propertyName === column.propertyName; });
                                                    if (entityValue && columnRelation) { // not sure if we need handle join column from inverse side
                                                        columnRelation.joinColumns.forEach(function (columnRelationJoinColumn) {
                                                            var relationIdOfEntityValue = entityValue[columnRelationJoinColumn.referencedColumn.propertyName];
                                                            if (!relationIdOfEntityValue) {
                                                                var entityValueInsertSubject = _this.insertSubjects.find(function (subject) { return subject.entity === entityValue; });
                                                                if (entityValueInsertSubject) {
                                                                    if (columnRelationJoinColumn.referencedColumn.isGenerated && entityValueInsertSubject.generatedMap) {
                                                                        relationIdOfEntityValue = columnRelationJoinColumn.referencedColumn.getEntityValue(entityValueInsertSubject.generatedMap);
                                                                    }
                                                                }
                                                            }
                                                            if (relationIdOfEntityValue) {
                                                                conditions[column.databaseName] = relationIdOfEntityValue;
                                                            }
                                                        });
                                                    }
                                                    else {
                                                        var entityValueInsertSubject = _this.insertSubjects.find(function (subject) { return subject.entity === subRelatedEntity; });
                                                        if (entityValue) {
                                                            conditions[column.databaseName] = entityValue;
                                                        }
                                                        else {
                                                            if (entityValueInsertSubject && entityValueInsertSubject.generatedMap)
                                                                conditions[column.databaseName] = column.getEntityValue(entityValueInsertSubject.generatedMap);
                                                        }
                                                    }
                                                });
                                                if (!Object.keys(conditions).length)
                                                    return;
                                                var updateOptions = {};
                                                var columnRelation = relation.inverseEntityMetadata.relations.find(function (rel) { return rel.propertyName === referencedColumn.propertyName; });
                                                var columnValue = referencedColumn.getEntityValue(subject.entity);
                                                if (columnRelation) {
                                                    var id = columnRelation.getEntityValue(columnValue);
                                                    if (!id) {
                                                        var insertSubject = _this.insertSubjects.find(function (subject) { return subject.entity === columnValue; });
                                                        if (insertSubject) {
                                                            if (insertSubject.generatedMap)
                                                                id = referencedColumn.getEntityValue(insertSubject.generatedMap);
                                                        }
                                                    }
                                                    updateOptions[joinColumn.databaseName] = id;
                                                }
                                                else {
                                                    var generatedColumnValue = subject.generatedMap ? referencedColumn.getEntityValue(subject.generatedMap) : undefined;
                                                    updateOptions[joinColumn.databaseName] = columnValue || generatedColumnValue;
                                                }
                                                var updatePromise = _this.queryRunner.update(relation.inverseEntityMetadata.tablePath, updateOptions, conditions);
                                                updatePromises.push(updatePromise);
                                            });
                                        });
                                    });
                                    return [4 /*yield*/, Promise.all(updatePromises)];
                                case 3:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Inserts an entity from the given insert operation into the database.
                 * If entity has an generated column, then after saving new generated value will be stored to the InsertOperation.
                 * If entity uses class-table-inheritance, then multiple inserts may by performed to save all entities.
                 */
                SubjectOperationExecutor.prototype.insert = function (subject, alreadyInsertedSubjects) {
                    return __awaiter(this, void 0, void 0, function () {
                        var parentEntityMetadata, metadata, entity, insertResult, parentGeneratedId, parentValuesMap, childValuesMap, secondGeneratedId, valuesMap;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    parentEntityMetadata = subject.metadata.parentEntityMetadata;
                                    metadata = subject.metadata;
                                    entity = subject.entity;
                                    if (!metadata.isClassTableChild) return [3 /*break*/, 3];
                                    parentValuesMap = this.collectColumnsAndValues(parentEntityMetadata, entity, subject.date, undefined, metadata.discriminatorValue, alreadyInsertedSubjects, "insert");
                                    return [4 /*yield*/, this.queryRunner.insert(parentEntityMetadata.tablePath, parentValuesMap)];
                                case 1:
                                    insertResult = parentGeneratedId = _a.sent();
                                    childValuesMap = this.collectColumnsAndValues(metadata, entity, subject.date, insertResult.generatedMap[parentEntityMetadata.primaryColumns[0].propertyName], undefined, alreadyInsertedSubjects, "insert");
                                    return [4 /*yield*/, this.queryRunner.insert(metadata.tablePath, childValuesMap)];
                                case 2:
                                    secondGeneratedId = _a.sent();
                                    if (!insertResult && secondGeneratedId)
                                        insertResult = secondGeneratedId;
                                    return [3 /*break*/, 5];
                                case 3:
                                    valuesMap = this.collectColumnsAndValues(metadata, entity, subject.date, undefined, undefined, alreadyInsertedSubjects, "insert");
                                    return [4 /*yield*/, this.queryRunner.insert(metadata.tablePath, valuesMap)];
                                case 4:
                                    // console.log("valuesMap", valuesMap);
                                    insertResult = _a.sent();
                                    _a.label = 5;
                                case 5:
                                    if (parentGeneratedId)
                                        subject.parentGeneratedId = parentGeneratedId.generatedMap[parentEntityMetadata.primaryColumns[0].propertyName];
                                    // todo: better if insert method will return object with all generated ids, object id, etc.
                                    if (insertResult.generatedMap)
                                        subject.generatedMap = insertResult.generatedMap;
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                SubjectOperationExecutor.prototype.collectColumns = function (columns, entity, object, operation) {
                    var _this = this;
                    columns.forEach(function (column) {
                        if (column.isVirtual || column.isParentId || column.isDiscriminator)
                            return;
                        if (operation === "update" && column.isReadonly)
                            return;
                        var value = entity[column.propertyName];
                        if (value === undefined)
                            return;
                        object[column.databaseNameWithoutPrefixes] = _this.connection.driver.preparePersistentValue(value, column); // todo: maybe preparePersistentValue is not responsibility of this class
                    });
                };
                SubjectOperationExecutor.prototype.collectEmbeds = function (embed, entity, object, operation) {
                    var _this = this;
                    if (embed.isArray) {
                        if (entity[embed.propertyName] instanceof Array) {
                            if (!object[embed.prefix])
                                object[embed.prefix] = [];
                            entity[embed.propertyName].forEach(function (subEntity, index) {
                                if (!object[embed.prefix][index])
                                    object[embed.prefix][index] = {};
                                _this.collectColumns(embed.columns, subEntity, object[embed.prefix][index], operation);
                                embed.embeddeds.forEach(function (childEmbed) { return _this.collectEmbeds(childEmbed, subEntity, object[embed.prefix][index], operation); });
                            });
                        }
                    }
                    else {
                        if (entity[embed.propertyName] !== undefined) {
                            if (!object[embed.prefix])
                                object[embed.prefix] = {};
                            this.collectColumns(embed.columns, entity[embed.propertyName], object[embed.prefix], operation);
                            embed.embeddeds.forEach(function (childEmbed) { return _this.collectEmbeds(childEmbed, entity[embed.propertyName], object[embed.prefix], operation); });
                        }
                    }
                };
                /**
                 * Collects columns and values for the insert operation.
                 */
                SubjectOperationExecutor.prototype.collectColumnsAndValues = function (metadata, entity, date, parentIdColumnValue, discriminatorValue, alreadyInsertedSubjects, operation) {
                    var _this = this;
                    var values = {};
                    if (this.connection.driver instanceof MongoDriver_2.MongoDriver) {
                        this.collectColumns(metadata.ownColumns, entity, values, operation);
                        metadata.embeddeds.forEach(function (embed) { return _this.collectEmbeds(embed, entity, values, operation); });
                    }
                    else {
                        metadata.columns.forEach(function (column) {
                            if (column.isVirtual || column.isParentId || column.isDiscriminator)
                                return;
                            var value = column.getEntityValue(entity);
                            if (value === undefined)
                                return;
                            values[column.databaseName] = _this.connection.driver.preparePersistentValue(value, column); // todo: maybe preparePersistentValue is not responsibility of this class
                        });
                    }
                    metadata.relationsWithJoinColumns.forEach(function (relation) {
                        relation.joinColumns.forEach(function (joinColumn) {
                            var relationValue;
                            var value = relation.getEntityValue(entity);
                            if (value) {
                                // if relation value is stored in the entity itself then use it from there
                                var relationId = joinColumn.referencedColumn.getEntityValue(value); // relation.getInverseEntityRelationId(value); // todo: check it
                                if (relationId) {
                                    relationValue = relationId;
                                }
                                // otherwise try to find relational value from just inserted subjects
                                var alreadyInsertedSubject = alreadyInsertedSubjects.find(function (insertedSubject) {
                                    return insertedSubject.entity === value;
                                });
                                if (alreadyInsertedSubject) {
                                    var referencedColumn = joinColumn.referencedColumn;
                                    // if join column references to the primary generated column then seek in the newEntityId of the insertedSubject
                                    if (referencedColumn.referencedColumn && referencedColumn.referencedColumn.isGenerated) {
                                        if (referencedColumn.isParentId) {
                                            relationValue = alreadyInsertedSubject.parentGeneratedId;
                                        }
                                        // todo: what if reference column is not generated?
                                        // todo: what if reference column is not related to table inheritance?
                                    }
                                    if (referencedColumn.isGenerated && alreadyInsertedSubject.generatedMap)
                                        relationValue = referencedColumn.getEntityValue(alreadyInsertedSubject.generatedMap);
                                    // if it references to create or update date columns
                                    if (referencedColumn.isCreateDate || referencedColumn.isUpdateDate)
                                        relationValue = _this.connection.driver.preparePersistentValue(alreadyInsertedSubject.date, referencedColumn);
                                    // if it references to version column
                                    if (referencedColumn.isVersion)
                                        relationValue = _this.connection.driver.preparePersistentValue(1, referencedColumn);
                                }
                            }
                            else if (relation.inverseRelation) {
                                var inverseSubject = _this.allSubjects.find(function (subject) {
                                    if (!subject.hasEntity || subject.entityTarget !== relation.inverseRelation.target)
                                        return false;
                                    var inverseRelationValue = relation.inverseRelation.getEntityValue(subject.entity);
                                    if (inverseRelationValue) {
                                        if (inverseRelationValue instanceof Array) {
                                            return inverseRelationValue.find(function (subValue) { return subValue === subValue; });
                                        }
                                        else {
                                            return inverseRelationValue === entity;
                                        }
                                    }
                                });
                                if (inverseSubject && joinColumn.referencedColumn.getEntityValue(inverseSubject.entity)) {
                                    relationValue = joinColumn.referencedColumn.getEntityValue(inverseSubject.entity);
                                }
                            }
                            if (relationValue) {
                                values[joinColumn.databaseName] = relationValue;
                            }
                        });
                    });
                    // add special column and value - date of creation
                    if (metadata.createDateColumn) {
                        var value = this.connection.driver.preparePersistentValue(date, metadata.createDateColumn);
                        values[metadata.createDateColumn.databaseName] = value;
                    }
                    // add special column and value - date of updating
                    if (metadata.updateDateColumn) {
                        var value = this.connection.driver.preparePersistentValue(date, metadata.updateDateColumn);
                        values[metadata.updateDateColumn.databaseName] = value;
                    }
                    // add special column and value - version column
                    if (metadata.versionColumn) {
                        var value = this.connection.driver.preparePersistentValue(1, metadata.versionColumn);
                        values[metadata.versionColumn.databaseName] = value;
                    }
                    // add special column and value - discriminator value (for tables using table inheritance)
                    if (metadata.discriminatorColumn) {
                        var value = this.connection.driver.preparePersistentValue(discriminatorValue || metadata.discriminatorValue, metadata.discriminatorColumn);
                        values[metadata.discriminatorColumn.databaseName] = value;
                    }
                    metadata.generatedColumns
                        .filter(function (column) { return column.generationStrategy === "uuid"; })
                        .forEach(function (column) {
                        if (column.isNullable && values[column.databaseName] === null)
                            return;
                        var uuid = _this.connection.driver.preparePersistentValue("", column);
                        if (uuid && !values[column.databaseName])
                            values[column.databaseName] = uuid;
                    });
                    // add special column and value - tree level and tree parents (for tree-type tables)
                    if (metadata.treeLevelColumn && metadata.treeParentRelation) {
                        var parentEntity = metadata.treeParentRelation.getEntityValue(entity);
                        var parentLevel = parentEntity ? (metadata.treeLevelColumn.getEntityValue(parentEntity) || 0) : 0;
                        values[metadata.treeLevelColumn.databaseName] = parentLevel + 1;
                    }
                    // add special column and value - parent id column (for tables using table inheritance)
                    if (metadata.parentEntityMetadata && metadata.parentIdColumns.length) { // todo: should be array of primary keys
                        values[metadata.parentIdColumns[0].databaseName] = parentIdColumnValue || metadata.parentEntityMetadata.primaryColumns[0].getEntityValue(entity);
                    }
                    return values;
                };
                // -------------------------------------------------------------------------
                // Private Methods: Insertion into closure tables
                // -------------------------------------------------------------------------
                /**
                 * Inserts all given subjects into closure table.
                 */
                SubjectOperationExecutor.prototype.executeInsertClosureTableOperations = function ( /*, updatesByRelations: Subject[]*/) {
                    var _this = this;
                    var promises = this.insertSubjects
                        .filter(function (subject) { return subject.metadata.isClosure; })
                        .map(function (subject) { return __awaiter(_this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: 
                                // const relationsUpdateMap = this.findUpdateOperationForEntity(updatesByRelations, insertSubjects, subject.entity);
                                // subject.treeLevel = await this.insertIntoClosureTable(subject, relationsUpdateMap);
                                return [4 /*yield*/, this.insertClosureTableValues(subject)];
                                case 1:
                                    // const relationsUpdateMap = this.findUpdateOperationForEntity(updatesByRelations, insertSubjects, subject.entity);
                                    // subject.treeLevel = await this.insertIntoClosureTable(subject, relationsUpdateMap);
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    }); });
                    return Promise.all(promises);
                };
                /**
                 * Inserts given subject into closure table.
                 */
                SubjectOperationExecutor.prototype.insertClosureTableValues = function (subject) {
                    return __awaiter(this, void 0, void 0, function () {
                        var tablePath, referencedColumn, newEntityId, parentEntity, parentEntityId, parentInsertedSubject, parentSubject, _a, values, _b, _c;
                        return __generator(this, function (_d) {
                            switch (_d.label) {
                                case 0:
                                    tablePath = subject.metadata.closureJunctionTable.tablePath;
                                    referencedColumn = subject.metadata.treeParentRelation.joinColumns[0].referencedColumn;
                                    newEntityId = referencedColumn.getEntityValue(subject.entity);
                                    if (!newEntityId && referencedColumn.isGenerated && subject.generatedMap) {
                                        newEntityId = referencedColumn.getEntityValue(subject.generatedMap);
                                        // we should not handle object id here because closure tables are not supported by mongodb driver.
                                    } // todo: implement other special column types too
                                    parentEntity = subject.metadata.treeParentRelation.getEntityValue(subject.entity);
                                    parentEntityId = 0;
                                    if (parentEntity) {
                                        parentEntityId = referencedColumn.getEntityValue(parentEntity);
                                        if (!parentEntityId && referencedColumn.isGenerated) {
                                            parentInsertedSubject = this.insertSubjects.find(function (subject) { return subject.entity === parentEntity; });
                                            // todo: throw exception if parentInsertedSubject is not set
                                            if (parentInsertedSubject.generatedMap)
                                                parentEntityId = referencedColumn.getEntityValue(parentInsertedSubject.generatedMap);
                                        } // todo: implement other special column types too
                                    }
                                    // try to find parent entity id in some other entity that has this entity in its children
                                    if (!parentEntityId) {
                                        parentSubject = this.allSubjects.find(function (allSubject) {
                                            if (!allSubject.hasEntity || !allSubject.metadata.isClosure || !allSubject.metadata.treeChildrenRelation)
                                                return false;
                                            var children = subject.metadata.treeChildrenRelation.getEntityValue(allSubject.entity);
                                            return children instanceof Array ? children.indexOf(subject.entity) !== -1 : false;
                                        });
                                        if (parentSubject) {
                                            parentEntityId = referencedColumn.getEntityValue(parentSubject.entity);
                                            if (!parentEntityId && parentSubject.generatedMap) { // if still not found then it means parent just inserted with generated column
                                                parentEntityId = referencedColumn.getEntityValue(parentSubject.generatedMap);
                                            }
                                        }
                                    }
                                    // if parent entity exist then insert a new row into closure table
                                    _a = subject;
                                    return [4 /*yield*/, this.queryRunner.insertIntoClosureTable(tablePath, newEntityId, parentEntityId, !!subject.metadata.treeLevelColumn)];
                                case 1:
                                    // if parent entity exist then insert a new row into closure table
                                    _a.treeLevel = _d.sent();
                                    if (!subject.metadata.treeLevelColumn) return [3 /*break*/, 3];
                                    values = (_b = {}, _b[subject.metadata.treeLevelColumn.databaseName] = subject.treeLevel, _b);
                                    return [4 /*yield*/, this.queryRunner.update(subject.metadata.tablePath, values, (_c = {}, _c[referencedColumn.databaseName] = newEntityId, _c))];
                                case 2:
                                    _d.sent();
                                    _d.label = 3;
                                case 3: return [2 /*return*/];
                            }
                        });
                    });
                };
                // -------------------------------------------------------------------------
                // Private Methods: Update
                // -------------------------------------------------------------------------
                /**
                 * Updates all given subjects in the database.
                 */
                SubjectOperationExecutor.prototype.executeUpdateOperations = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, Promise.all(this.updateSubjects.map(function (subject) { return _this.update(subject); }))];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Updates given subject in the database.
                 */
                SubjectOperationExecutor.prototype.update = function (subject) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var entity, idMap, value_1, valueMaps, valueMap, valueMap, valueMap, valueMap;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    entity = subject.entity;
                                    if (this.connection.driver instanceof MongoDriver_2.MongoDriver) {
                                        idMap = subject.metadata.getDatabaseEntityIdMap(entity);
                                        if (!idMap)
                                            throw new Error("Internal error. Cannot get id of the updating entity.");
                                        value_1 = {};
                                        this.collectColumns(subject.metadata.ownColumns, entity, value_1, "update");
                                        subject.metadata.embeddeds.forEach(function (embed) { return _this.collectEmbeds(embed, entity, value_1, "update"); });
                                        // if number of updated columns = 0 no need to update updated date and version columns
                                        if (Object.keys(value_1).length === 0)
                                            return [2 /*return*/];
                                        if (subject.metadata.updateDateColumn)
                                            value_1[subject.metadata.updateDateColumn.databaseName] = this.connection.driver.preparePersistentValue(new Date(), subject.metadata.updateDateColumn);
                                        if (subject.metadata.versionColumn)
                                            value_1[subject.metadata.versionColumn.databaseName] = this.connection.driver.preparePersistentValue(subject.metadata.versionColumn.getEntityValue(entity) + 1, subject.metadata.versionColumn);
                                        return [2 /*return*/, this.queryRunner.update(subject.metadata.tablePath, value_1, idMap)];
                                    }
                                    valueMaps = [];
                                    // console.log(subject.diffColumns);
                                    subject.diffColumns.forEach(function (column) {
                                        // if (!column.entityTarget) return; // todo: how this can be possible?
                                        var metadata = _this.connection.getMetadata(column.entityMetadata.target);
                                        var valueMap = valueMaps.find(function (valueMap) { return valueMap.tablePath === metadata.tablePath; });
                                        if (!valueMap) {
                                            valueMap = { tablePath: metadata.tablePath, metadata: metadata, values: {} };
                                            valueMaps.push(valueMap);
                                        }
                                        valueMap.values[column.databaseName] = _this.connection.driver.preparePersistentValue(column.getEntityValue(entity), column);
                                    });
                                    subject.diffRelations.forEach(function (relation) {
                                        var valueMap = valueMaps.find(function (valueMap) { return valueMap.tablePath === relation.entityMetadata.tablePath; });
                                        if (!valueMap) {
                                            valueMap = { tablePath: relation.entityMetadata.tablePath, metadata: relation.entityMetadata, values: {} };
                                            valueMaps.push(valueMap);
                                        }
                                        var value = relation.getEntityValue(entity);
                                        relation.joinColumns.forEach(function (joinColumn) {
                                            valueMap.values[joinColumn.databaseName] = value !== null && value !== undefined ? value[joinColumn.referencedColumn.propertyName] : null; // todo: should not have a call to primaryColumn, instead join column metadata should be used
                                        });
                                    });
                                    // if number of updated columns = 0 no need to update updated date and version columns
                                    if (Object.keys(valueMaps).length === 0)
                                        return [2 /*return*/];
                                    if (subject.metadata.updateDateColumn) {
                                        valueMap = valueMaps.find(function (valueMap) { return valueMap.tablePath === subject.metadata.tablePath; });
                                        if (!valueMap) {
                                            valueMap = { tablePath: subject.metadata.tablePath, metadata: subject.metadata, values: {} };
                                            valueMaps.push(valueMap);
                                        }
                                        valueMap.values[subject.metadata.updateDateColumn.databaseName] = this.connection.driver.preparePersistentValue(new Date(), subject.metadata.updateDateColumn);
                                    }
                                    if (subject.metadata.versionColumn) {
                                        valueMap = valueMaps.find(function (valueMap) { return valueMap.tablePath === subject.metadata.tablePath; });
                                        if (!valueMap) {
                                            valueMap = { tablePath: subject.metadata.tablePath, metadata: subject.metadata, values: {} };
                                            valueMaps.push(valueMap);
                                        }
                                        valueMap.values[subject.metadata.versionColumn.databaseName] = this.connection.driver.preparePersistentValue(subject.metadata.versionColumn.getEntityValue(entity) + 1, subject.metadata.versionColumn);
                                    }
                                    if (subject.metadata.parentEntityMetadata) {
                                        if (subject.metadata.parentEntityMetadata.updateDateColumn) {
                                            valueMap = valueMaps.find(function (valueMap) { return valueMap.tablePath === subject.metadata.parentEntityMetadata.tablePath; });
                                            if (!valueMap) {
                                                valueMap = {
                                                    tablePath: subject.metadata.parentEntityMetadata.tablePath,
                                                    metadata: subject.metadata.parentEntityMetadata,
                                                    values: {}
                                                };
                                                valueMaps.push(valueMap);
                                            }
                                            valueMap.values[subject.metadata.parentEntityMetadata.updateDateColumn.databaseName] = this.connection.driver.preparePersistentValue(new Date(), subject.metadata.parentEntityMetadata.updateDateColumn);
                                        }
                                        if (subject.metadata.parentEntityMetadata.versionColumn) {
                                            valueMap = valueMaps.find(function (valueMap) { return valueMap.tablePath === subject.metadata.parentEntityMetadata.tablePath; });
                                            if (!valueMap) {
                                                valueMap = {
                                                    tablePath: subject.metadata.parentEntityMetadata.tablePath,
                                                    metadata: subject.metadata.parentEntityMetadata,
                                                    values: {}
                                                };
                                                valueMaps.push(valueMap);
                                            }
                                            valueMap.values[subject.metadata.parentEntityMetadata.versionColumn.databaseName] = this.connection.driver.preparePersistentValue(subject.metadata.parentEntityMetadata.versionColumn.getEntityValue(entity) + 1, subject.metadata.parentEntityMetadata.versionColumn);
                                        }
                                    }
                                    return [4 /*yield*/, Promise.all(valueMaps.map(function (valueMap) {
                                            var idMap = valueMap.metadata.getDatabaseEntityIdMap(entity);
                                            if (!idMap)
                                                throw new Error("Internal error. Cannot get id of the updating entity.");
                                            return _this.queryRunner.update(valueMap.tablePath, valueMap.values, idMap);
                                        }))];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                // -------------------------------------------------------------------------
                // Private Methods: Update only relations
                // -------------------------------------------------------------------------
                /**
                 * Updates relations of all given subjects in the database.
                 */
                SubjectOperationExecutor.prototype.executeUpdateRelations = function () {
                    var _this = this;
                    return Promise.all(this.relationUpdateSubjects.map(function (subject) { return _this.updateRelations(subject); }));
                };
                /**
                 * Updates relations of the given subject in the database.
                 */
                SubjectOperationExecutor.prototype.updateRelations = function (subject) {
                    return __awaiter(this, void 0, void 0, function () {
                        var values, idMap;
                        return __generator(this, function (_a) {
                            values = {};
                            subject.relationUpdates.forEach(function (setRelation) {
                                setRelation.relation.joinColumns.forEach(function (joinColumn) {
                                    var value = setRelation.value ? setRelation.value[joinColumn.referencedColumn.propertyName] : null;
                                    values[joinColumn.databaseName] = value; // todo: || fromInsertedSubjects ??
                                });
                            });
                            idMap = subject.metadata.getDatabaseEntityIdMap(subject.databaseEntity);
                            if (!idMap)
                                throw new Error("Internal error. Cannot get id of the updating entity.");
                            return [2 /*return*/, this.queryRunner.update(subject.metadata.tablePath, values, idMap)];
                        });
                    });
                };
                // -------------------------------------------------------------------------
                // Private Methods: Remove
                // -------------------------------------------------------------------------
                /**
                 * Removes all given subjects from the database.
                 */
                SubjectOperationExecutor.prototype.executeRemoveOperations = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, PromiseUtils_1.PromiseUtils.runInSequence(this.removeSubjects, function (subject) { return __awaiter(_this, void 0, void 0, function () { return __generator(this, function (_a) {
                                        switch (_a.label) {
                                            case 0: return [4 /*yield*/, this.remove(subject)];
                                            case 1: return [2 /*return*/, _a.sent()];
                                        }
                                    }); }); })];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Updates given subject from the database.
                 */
                SubjectOperationExecutor.prototype.remove = function (subject) {
                    return __awaiter(this, void 0, void 0, function () {
                        var parentConditions_1, childConditions_1;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (!subject.metadata.parentEntityMetadata) return [3 /*break*/, 3];
                                    parentConditions_1 = {};
                                    subject.metadata.primaryColumns.forEach(function (column) {
                                        parentConditions_1[column.databaseName] = column.getEntityValue(subject.databaseEntity);
                                    });
                                    return [4 /*yield*/, this.queryRunner.delete(subject.metadata.parentEntityMetadata.tablePath, parentConditions_1)];
                                case 1:
                                    _a.sent();
                                    childConditions_1 = {};
                                    subject.metadata.primaryColumns.forEach(function (column) {
                                        childConditions_1[column.databaseName] = column.getEntityValue(subject.databaseEntity);
                                    });
                                    return [4 /*yield*/, this.queryRunner.delete(subject.metadata.tablePath, childConditions_1)];
                                case 2:
                                    _a.sent();
                                    return [3 /*break*/, 5];
                                case 3: return [4 /*yield*/, this.queryRunner.delete(subject.metadata.tablePath, subject.metadata.getDatabaseEntityIdMap(subject.databaseEntity))];
                                case 4:
                                    _a.sent();
                                    _a.label = 5;
                                case 5: return [2 /*return*/];
                            }
                        });
                    });
                };
                // -------------------------------------------------------------------------
                // Private Methods: Insertion into junction tables
                // -------------------------------------------------------------------------
                /**
                 * Inserts into database junction tables all given array of subjects junction data.
                 */
                SubjectOperationExecutor.prototype.executeInsertJunctionsOperations = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var promises;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    promises = [];
                                    this.allSubjects.forEach(function (subject) {
                                        subject.junctionInserts.forEach(function (junctionInsert) {
                                            promises.push(_this.insertJunctions(subject, junctionInsert));
                                        });
                                    });
                                    return [4 /*yield*/, Promise.all(promises)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Inserts into database junction table given subject's junction insert data.
                 */
                SubjectOperationExecutor.prototype.insertJunctions = function (subject, junctionInsert) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var getRelationId, relation, joinColumns, ownId, promises;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    getRelationId = function (entity, joinColumns) {
                                        return joinColumns.map(function (joinColumn) {
                                            var id = joinColumn.referencedColumn.getEntityValue(entity);
                                            if (!id && joinColumn.referencedColumn.isGenerated) {
                                                var insertSubject = _this.insertSubjects.find(function (subject) { return subject.entity === entity; });
                                                if (insertSubject && insertSubject.generatedMap)
                                                    return joinColumn.referencedColumn.getEntityValue(insertSubject.generatedMap);
                                            }
                                            // todo: implement other special referenced column types (update date, create date, version, discriminator column, etc.)
                                            return id;
                                        });
                                    };
                                    relation = junctionInsert.relation;
                                    joinColumns = relation.isManyToManyOwner ? relation.joinColumns : relation.inverseRelation.inverseJoinColumns;
                                    ownId = getRelationId(subject.entity, joinColumns);
                                    if (!ownId.length)
                                        throw new Error("Cannot insert object of " + subject.entityTarget + " type. Looks like its not persisted yet, or cascades are not set on the relation."); // todo: better error message
                                    promises = junctionInsert.junctionEntities.map(function (newBindEntity) {
                                        // get relation id from the newly bind entity
                                        var joinColumns = relation.isManyToManyOwner ? relation.inverseJoinColumns : relation.inverseRelation.joinColumns;
                                        var relationId = getRelationId(newBindEntity, joinColumns);
                                        // if relation id still does not exist - we arise an error
                                        if (!relationId)
                                            throw new Error("Cannot insert object of " + newBindEntity.constructor.name + " type. Looks like its not persisted yet, or cascades are not set on the relation."); // todo: better error message
                                        var columns = relation.junctionEntityMetadata.columns.map(function (column) { return column.databaseName; });
                                        var values = relation.isOwning ? ownId.concat(relationId) : relationId.concat(ownId);
                                        return _this.queryRunner.insert(relation.junctionEntityMetadata.tablePath, OrmUtils_2.OrmUtils.zipObject(columns, values));
                                    });
                                    return [4 /*yield*/, Promise.all(promises)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                // -------------------------------------------------------------------------
                // Private Methods: Remove from junction tables
                // -------------------------------------------------------------------------
                /**
                 * Removes from database junction tables all given array of subjects removal junction data.
                 */
                SubjectOperationExecutor.prototype.executeRemoveJunctionsOperations = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var promises;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    promises = [];
                                    this.allSubjects.forEach(function (subject) {
                                        subject.junctionRemoves.forEach(function (junctionRemove) {
                                            promises.push(_this.removeJunctions(subject, junctionRemove));
                                        });
                                    });
                                    return [4 /*yield*/, Promise.all(promises)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Removes from database junction table all given subject's removal junction data.
                 */
                SubjectOperationExecutor.prototype.removeJunctions = function (subject, junctionRemove) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var junctionMetadata, entity, firstJoinColumns, secondJoinColumns, conditions, removePromises;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    junctionMetadata = junctionRemove.relation.junctionEntityMetadata;
                                    entity = subject.hasEntity ? subject.entity : subject.databaseEntity;
                                    firstJoinColumns = junctionRemove.relation.isOwning ? junctionRemove.relation.joinColumns : junctionRemove.relation.inverseRelation.inverseJoinColumns;
                                    secondJoinColumns = junctionRemove.relation.isOwning ? junctionRemove.relation.inverseJoinColumns : junctionRemove.relation.inverseRelation.joinColumns;
                                    conditions = {};
                                    firstJoinColumns.forEach(function (joinColumn) {
                                        conditions[joinColumn.databaseName] = joinColumn.referencedColumn.getEntityValue(entity);
                                    });
                                    removePromises = junctionRemove.junctionRelationIds.map(function (relationIds) {
                                        var inverseConditions = {};
                                        secondJoinColumns.forEach(function (joinColumn) {
                                            inverseConditions[joinColumn.databaseName] = joinColumn.referencedColumn.getEntityValue(relationIds);
                                        });
                                        return _this.queryRunner.delete(junctionMetadata.tableName, Object.assign({}, inverseConditions, conditions));
                                    });
                                    return [4 /*yield*/, Promise.all(removePromises)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                // -------------------------------------------------------------------------
                // Private Methods: Refresh entity values after persistence
                // -------------------------------------------------------------------------
                /**
                 * Updates all special columns of the saving entities (create date, update date, versioning).
                 */
                SubjectOperationExecutor.prototype.updateSpecialColumnsInPersistedEntities = function () {
                    // update entity columns that gets updated on each entity insert
                    this.insertSubjects.forEach(function (subject) {
                        // if (subject.generatedObjectId && subject.metadata.objectIdColumn)
                        //     subject.metadata.objectIdColumn.setEntityValue(subject.entity, subject.generatedObjectId);
                        if (subject.generatedMap) {
                            subject.metadata.generatedColumns.forEach(function (generatedColumn) {
                                var generatedValue = generatedColumn.getEntityValue(subject.generatedMap);
                                if (!generatedValue)
                                    return;
                                generatedColumn.setEntityValue(subject.entity, generatedValue);
                            });
                        }
                        subject.metadata.primaryColumns.forEach(function (primaryColumn) {
                            if (subject.parentGeneratedId)
                                primaryColumn.setEntityValue(subject.entity, subject.parentGeneratedId);
                        });
                        if (subject.metadata.updateDateColumn)
                            subject.metadata.updateDateColumn.setEntityValue(subject.entity, subject.date);
                        if (subject.metadata.createDateColumn)
                            subject.metadata.createDateColumn.setEntityValue(subject.entity, subject.date);
                        if (subject.metadata.versionColumn)
                            subject.metadata.versionColumn.setEntityValue(subject.entity, 1);
                        if (subject.metadata.treeLevelColumn) {
                            // const parentEntity = insertOperation.entity[metadata.treeParentMetadata.propertyName];
                            // const parentLevel = parentEntity ? (parentEntity[metadata.treeLevelColumn.propertyName] || 0) : 0;
                            subject.metadata.treeLevelColumn.setEntityValue(subject.entity, subject.treeLevel);
                        }
                        /*if (subject.metadata.hasTreeChildrenCountColumn) {
                             subject.entity[subject.metadata.treeChildrenCountColumn.propertyName] = 0;
                        }*/
                        // set values to "null" for nullable columns that did not have values
                        subject.metadata.columns
                            .filter(function (column) { return column.isNullable && !column.isVirtual; })
                            .forEach(function (column) {
                            var columnValue = column.getEntityValue(subject.entity);
                            if (columnValue === undefined)
                                column.setEntityValue(subject.entity, null);
                        });
                    });
                    // update special columns that gets updated on each entity update
                    this.updateSubjects.forEach(function (subject) {
                        if (subject.metadata.updateDateColumn)
                            subject.metadata.updateDateColumn.setEntityValue(subject.entity, subject.date);
                        if (subject.metadata.versionColumn)
                            subject.metadata.versionColumn.setEntityValue(subject.entity, subject.metadata.versionColumn.getEntityValue(subject.entity) + 1);
                    });
                    // remove ids from the entities that were removed
                    this.removeSubjects
                        .filter(function (subject) { return subject.hasEntity; })
                        .forEach(function (subject) {
                        subject.metadata.primaryColumns.forEach(function (primaryColumn) {
                            primaryColumn.setEntityValue(subject.entity, undefined);
                        });
                    });
                    this.allSubjects
                        .filter(function (subject) { return subject.hasEntity; })
                        .forEach(function (subject) {
                        subject.metadata.relationIds.forEach(function (relationId) {
                            relationId.setValue(subject.entity);
                        });
                    });
                };
                return SubjectOperationExecutor;
            }());
            exports_86("SubjectOperationExecutor", SubjectOperationExecutor);
        }
    };
});
System.register("typeorm/query-builder/transformer/PlainObjectToNewEntityTransformer", [], function (exports_87, context_87) {
    "use strict";
    var __moduleName = context_87 && context_87.id;
    var PlainObjectToNewEntityTransformer;
    return {
        setters: [],
        execute: function () {
            /**
             * Transforms plain old javascript object
             * Entity is constructed based on its entity metadata.
             */
            PlainObjectToNewEntityTransformer = /** @class */ (function () {
                function PlainObjectToNewEntityTransformer() {
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                PlainObjectToNewEntityTransformer.prototype.transform = function (newEntity, object, metadata) {
                    this.groupAndTransform(newEntity, object, metadata);
                    return newEntity;
                };
                // -------------------------------------------------------------------------
                // Private Methods
                // -------------------------------------------------------------------------
                /**
                 * Since db returns a duplicated rows of the data where accuracies of the same object can be duplicated
                 * we need to group our result and we must have some unique id (primary key in our case)
                 */
                PlainObjectToNewEntityTransformer.prototype.groupAndTransform = function (entity, object, metadata) {
                    var _this = this;
                    // copy regular column properties from the given object
                    metadata.columns
                        .filter(function (column) { return object.hasOwnProperty(column.propertyName); })
                        .forEach(function (column) { return entity[column.propertyName] = object[column.propertyName]; }); // todo: also need to be sure that type is correct
                    // if relation is loaded then go into it recursively and transform its values too
                    metadata.relations
                        .filter(function (relation) { return object.hasOwnProperty(relation.propertyName); })
                        .forEach(function (relation) {
                        var relationMetadata = relation.inverseEntityMetadata;
                        if (!relationMetadata)
                            throw new Error("Relation metadata for the relation " + metadata.name + "#" + relation.propertyName + " is missing");
                        if (relation.isManyToMany || relation.isOneToMany) {
                            if (object[relation.propertyName] instanceof Array) {
                                entity[relation.propertyName] = object[relation.propertyName].map(function (subObject) {
                                    var subEntity = relationMetadata.create();
                                    // todo: support custom initial fields here
                                    if (entity[relation.propertyName] instanceof Array) {
                                        var existRelation = entity[relation.propertyName].find(function (subEntity) {
                                            return subEntity[relation.propertyName] === subObject[relation.propertyName];
                                        });
                                        if (existRelation)
                                            _this.groupAndTransform(subEntity, existRelation, relationMetadata);
                                    }
                                    _this.groupAndTransform(subEntity, subObject, relationMetadata);
                                    return subEntity;
                                });
                            }
                            else {
                                entity[relation.propertyName] = object[relation.propertyName];
                            }
                        }
                        else {
                            if (object[relation.propertyName]) {
                                var subEntity = relationMetadata.create();
                                if (entity[relation.propertyName])
                                    _this.groupAndTransform(subEntity, entity[relation.propertyName], relationMetadata);
                                _this.groupAndTransform(subEntity, object[relation.propertyName], relationMetadata);
                                entity[relation.propertyName] = subEntity;
                            }
                            else {
                                entity[relation.propertyName] = object[relation.propertyName];
                            }
                        }
                    });
                };
                return PlainObjectToNewEntityTransformer;
            }());
            exports_87("PlainObjectToNewEntityTransformer", PlainObjectToNewEntityTransformer);
        }
    };
});
System.register("typeorm/query-builder/transformer/PlainObjectToDatabaseEntityTransformer", [], function (exports_88, context_88) {
    "use strict";
    var __moduleName = context_88 && context_88.id;
    var LoadMapItem, LoadMap, PlainObjectToDatabaseEntityTransformer;
    return {
        setters: [],
        execute: function () {
            /**
             */
            LoadMapItem = /** @class */ (function () {
                function LoadMapItem(plainEntity, metadata, parentLoadMapItem, relation) {
                    this.plainEntity = plainEntity;
                    this.metadata = metadata;
                    this.parentLoadMapItem = parentLoadMapItem;
                    this.relation = relation;
                }
                Object.defineProperty(LoadMapItem.prototype, "target", {
                    get: function () {
                        return this.metadata.target;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(LoadMapItem.prototype, "id", {
                    get: function () {
                        return this.metadata.getEntityIdMixedMap(this.plainEntity);
                    },
                    enumerable: true,
                    configurable: true
                });
                LoadMapItem.prototype.compareEntities = function (entity1, entity2) {
                    return this.metadata.compareEntities(entity1, entity2);
                };
                return LoadMapItem;
            }());
            LoadMap = /** @class */ (function () {
                function LoadMap() {
                    this.loadMapItems = [];
                }
                Object.defineProperty(LoadMap.prototype, "mainLoadMapItem", {
                    get: function () {
                        return this.loadMapItems.find(function (item) { return !item.relation && !item.parentLoadMapItem; });
                    },
                    enumerable: true,
                    configurable: true
                });
                LoadMap.prototype.addLoadMap = function (newLoadMap) {
                    var item = this.loadMapItems.find(function (item) { return item.target === newLoadMap.target && item.id === newLoadMap.id; });
                    if (!item)
                        this.loadMapItems.push(newLoadMap);
                };
                LoadMap.prototype.fillEntities = function (target, entities) {
                    var _this = this;
                    entities.forEach(function (entity) {
                        var item = _this.loadMapItems.find(function (loadMapItem) {
                            return loadMapItem.target === target && loadMapItem.compareEntities(entity, loadMapItem.plainEntity);
                        });
                        if (item)
                            item.entity = entity;
                    });
                };
                LoadMap.prototype.groupByTargetIds = function () {
                    var groups = [];
                    this.loadMapItems.forEach(function (loadMapItem) {
                        var group = groups.find(function (group) { return group.target === loadMapItem.target; });
                        if (!group) {
                            group = { target: loadMapItem.target, ids: [] };
                            groups.push(group);
                        }
                        group.ids.push(loadMapItem.id);
                    });
                    return groups;
                };
                return LoadMap;
            }());
            /**
             * Transforms plain old javascript object
             * Entity is constructed based on its entity metadata.
             */
            PlainObjectToDatabaseEntityTransformer = /** @class */ (function () {
                function PlainObjectToDatabaseEntityTransformer(manager) {
                    this.manager = manager;
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                PlainObjectToDatabaseEntityTransformer.prototype.transform = function (plainObject, metadata) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var loadMap, fillLoadMap;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    // if plain object does not have id then nothing to load really
                                    if (!metadata.checkIfObjectContainsAllPrimaryKeys(plainObject))
                                        return [2 /*return*/, Promise.reject("Given object does not have a primary column, cannot transform it to database entity.")];
                                    loadMap = new LoadMap();
                                    fillLoadMap = function (entity, entityMetadata, parentLoadMapItem, relation) {
                                        var item = new LoadMapItem(entity, entityMetadata, parentLoadMapItem, relation);
                                        loadMap.addLoadMap(item);
                                        entityMetadata
                                            .extractRelationValuesFromEntity(entity, metadata.relations)
                                            .filter(function (value) { return value !== null && value !== undefined; })
                                            .forEach(function (_a) {
                                            var relation = _a[0], value = _a[1], inverseEntityMetadata = _a[2];
                                            return fillLoadMap(value, inverseEntityMetadata, item, relation);
                                        });
                                    };
                                    fillLoadMap(plainObject, metadata);
                                    // load all entities and store them in the load map
                                    return [4 /*yield*/, Promise.all(loadMap.groupByTargetIds().map(function (targetWithIds) {
                                            return _this.manager
                                                .findByIds(targetWithIds.target, targetWithIds.ids)
                                                .then(function (entities) { return loadMap.fillEntities(targetWithIds.target, entities); });
                                        }))];
                                case 1:
                                    // load all entities and store them in the load map
                                    _a.sent();
                                    // go through each item in the load map and set their entity relationship using metadata stored in load map
                                    loadMap.loadMapItems.forEach(function (loadMapItem) {
                                        if (!loadMapItem.relation ||
                                            !loadMapItem.entity ||
                                            !loadMapItem.parentLoadMapItem ||
                                            !loadMapItem.parentLoadMapItem.entity)
                                            return;
                                        if (loadMapItem.relation.isManyToMany || loadMapItem.relation.isOneToMany) {
                                            if (!loadMapItem.parentLoadMapItem.entity[loadMapItem.relation.propertyName])
                                                loadMapItem.parentLoadMapItem.entity[loadMapItem.relation.propertyName] = [];
                                            loadMapItem.parentLoadMapItem.entity[loadMapItem.relation.propertyName].push(loadMapItem.entity);
                                        }
                                        else {
                                            loadMapItem.parentLoadMapItem.entity[loadMapItem.relation.propertyName] = loadMapItem.entity;
                                        }
                                    });
                                    return [2 /*return*/, loadMap.mainLoadMapItem ? loadMap.mainLoadMapItem.entity : undefined];
                            }
                        });
                    });
                };
                return PlainObjectToDatabaseEntityTransformer;
            }());
            exports_88("PlainObjectToDatabaseEntityTransformer", PlainObjectToDatabaseEntityTransformer);
        }
    };
});
System.register("typeorm/error/CustomRepositoryNotFoundError", [], function (exports_89, context_89) {
    "use strict";
    var __moduleName = context_89 && context_89.id;
    var CustomRepositoryNotFoundError;
    return {
        setters: [],
        execute: function () {
            /**
             * Thrown if custom repository was not found.
             */
            CustomRepositoryNotFoundError = /** @class */ (function (_super) {
                __extends(CustomRepositoryNotFoundError, _super);
                function CustomRepositoryNotFoundError(repository) {
                    var _this = _super.call(this) || this;
                    _this.name = "CustomRepositoryNotFoundError";
                    _this.message = "Custom repository " + (repository instanceof Function ? repository.name : repository.constructor.name) + " was not found. " +
                        "Did you forgot to put @EntityRepository decorator on it?";
                    return _this;
                }
                return CustomRepositoryNotFoundError;
            }(Error));
            exports_89("CustomRepositoryNotFoundError", CustomRepositoryNotFoundError);
        }
    };
});
System.register("typeorm/error/CustomRepositoryDoesNotHaveEntityError", [], function (exports_90, context_90) {
    "use strict";
    var __moduleName = context_90 && context_90.id;
    var CustomRepositoryDoesNotHaveEntityError;
    return {
        setters: [],
        execute: function () {
            /**
             * Thrown if custom repositories that extend AbstractRepository classes does not have managed entity.
             */
            CustomRepositoryDoesNotHaveEntityError = /** @class */ (function (_super) {
                __extends(CustomRepositoryDoesNotHaveEntityError, _super);
                function CustomRepositoryDoesNotHaveEntityError(repository) {
                    var _this = _super.call(this, "Custom repository " + (repository instanceof Function ? repository.name : repository.constructor.name) + " does not have managed entity. " +
                        "Did you forget to specify entity for it @EntityRepository(MyEntity)? ") || this;
                    _this.name = "CustomRepositoryDoesNotHaveEntityError";
                    return _this;
                }
                return CustomRepositoryDoesNotHaveEntityError;
            }(Error));
            exports_90("CustomRepositoryDoesNotHaveEntityError", CustomRepositoryDoesNotHaveEntityError);
        }
    };
});
System.register("typeorm/repository/AbstractRepository", ["typeorm/error/CustomRepositoryDoesNotHaveEntityError", "typeorm/index", "typeorm/error/CustomRepositoryNotFoundError"], function (exports_91, context_91) {
    "use strict";
    var __moduleName = context_91 && context_91.id;
    var CustomRepositoryDoesNotHaveEntityError_1, index_1, CustomRepositoryNotFoundError_1, AbstractRepository;
    return {
        setters: [
            function (CustomRepositoryDoesNotHaveEntityError_1_1) {
                CustomRepositoryDoesNotHaveEntityError_1 = CustomRepositoryDoesNotHaveEntityError_1_1;
            },
            function (index_1_1) {
                index_1 = index_1_1;
            },
            function (CustomRepositoryNotFoundError_1_1) {
                CustomRepositoryNotFoundError_1 = CustomRepositoryNotFoundError_1_1;
            }
        ],
        execute: function () {
            /**
             * Provides abstract class for custom repositories that do not inherit from original orm Repository.
             * Contains all most-necessary methods to simplify code in the custom repository.
             * All methods are protected thus not exposed and it allows to create encapsulated custom repository.
             *
             * @experimental
             */
            AbstractRepository = /** @class */ (function () {
                function AbstractRepository() {
                }
                Object.defineProperty(AbstractRepository.prototype, "repository", {
                    // -------------------------------------------------------------------------
                    // Protected Accessors
                    // -------------------------------------------------------------------------
                    /**
                     * Gets the original ORM repository for the entity that is managed by this repository.
                     * If current repository does not manage any entity, then exception will be thrown.
                     */
                    get: function () {
                        var target = this.getCustomRepositoryTarget(this);
                        if (!target)
                            throw new CustomRepositoryDoesNotHaveEntityError_1.CustomRepositoryDoesNotHaveEntityError(this.constructor);
                        return this.manager.getRepository(target);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(AbstractRepository.prototype, "treeRepository", {
                    /**
                     * Gets the original ORM tree repository for the entity that is managed by this repository.
                     * If current repository does not manage any entity, then exception will be thrown.
                     */
                    get: function () {
                        var target = this.getCustomRepositoryTarget(this);
                        if (!target)
                            throw new CustomRepositoryDoesNotHaveEntityError_1.CustomRepositoryDoesNotHaveEntityError(this.constructor);
                        return this.manager.getTreeRepository(target);
                    },
                    enumerable: true,
                    configurable: true
                });
                // -------------------------------------------------------------------------
                // Protected Methods
                // -------------------------------------------------------------------------
                /**
                 * Creates a new query builder for the repository's entity that can be used to build a sql query.
                 * If current repository does not manage any entity, then exception will be thrown.
                 */
                AbstractRepository.prototype.createQueryBuilder = function (alias) {
                    var target = this.getCustomRepositoryTarget(this.constructor);
                    if (!target)
                        throw new CustomRepositoryDoesNotHaveEntityError_1.CustomRepositoryDoesNotHaveEntityError(this.constructor);
                    return this.manager.getRepository(target).createQueryBuilder(alias);
                };
                /**
                 * Creates a new query builder for the given entity that can be used to build a sql query.
                 */
                AbstractRepository.prototype.createQueryBuilderFor = function (entity, alias) {
                    return this.getRepositoryFor(entity).createQueryBuilder(alias);
                };
                /**
                 * Gets the original ORM repository for the given entity class.
                 */
                AbstractRepository.prototype.getRepositoryFor = function (entity) {
                    return this.manager.getRepository(entity);
                };
                /**
                 * Gets the original ORM tree repository for the given entity class.
                 */
                AbstractRepository.prototype.getTreeRepositoryFor = function (entity) {
                    return this.manager.getTreeRepository(entity);
                };
                // -------------------------------------------------------------------------
                // Private Methods
                // -------------------------------------------------------------------------
                /**
                 * Gets custom repository's managed entity.
                 * If given custom repository does not manage any entity then undefined will be returned.
                 */
                AbstractRepository.prototype.getCustomRepositoryTarget = function (customRepository) {
                    var entityRepositoryMetadataArgs = index_1.getMetadataArgsStorage().entityRepositories.find(function (repository) {
                        return repository.target === (customRepository instanceof Function ? customRepository : customRepository.constructor);
                    });
                    if (!entityRepositoryMetadataArgs)
                        throw new CustomRepositoryNotFoundError_1.CustomRepositoryNotFoundError(customRepository);
                    return entityRepositoryMetadataArgs.entity;
                };
                return AbstractRepository;
            }());
            exports_91("AbstractRepository", AbstractRepository);
        }
    };
});
System.register("typeorm/error/CustomRepositoryCannotInheritRepositoryError", [], function (exports_92, context_92) {
    "use strict";
    var __moduleName = context_92 && context_92.id;
    var CustomRepositoryCannotInheritRepositoryError;
    return {
        setters: [],
        execute: function () {
            /**
             * Thrown if custom repository inherits Repository class however entity is not set in @EntityRepository decorator.
             */
            CustomRepositoryCannotInheritRepositoryError = /** @class */ (function (_super) {
                __extends(CustomRepositoryCannotInheritRepositoryError, _super);
                function CustomRepositoryCannotInheritRepositoryError(repository) {
                    var _this = _super.call(this, "Custom entity repository " + (repository instanceof Function ? repository.name : repository.constructor.name) + " " +
                        " cannot inherit Repository class without entity being set in the @EntityRepository decorator.") || this;
                    _this.name = "CustomRepositoryCannotInheritRepositoryError";
                    return _this;
                }
                return CustomRepositoryCannotInheritRepositoryError;
            }(Error));
            exports_92("CustomRepositoryCannotInheritRepositoryError", CustomRepositoryCannotInheritRepositoryError);
        }
    };
});
System.register("typeorm/error/RepositoryNotFoundError", [], function (exports_93, context_93) {
    "use strict";
    var __moduleName = context_93 && context_93.id;
    var RepositoryNotFoundError;
    return {
        setters: [],
        execute: function () {
            /**
             * Thrown when repository for the given class is not found.
             */
            RepositoryNotFoundError = /** @class */ (function (_super) {
                __extends(RepositoryNotFoundError, _super);
                function RepositoryNotFoundError(connectionName, entityClass) {
                    var _this = _super.call(this) || this;
                    _this.name = "RepositoryNotFoundError";
                    var targetName = typeof entityClass === "function" && entityClass.name ? entityClass.name : entityClass;
                    _this.message = "No repository for \"" + targetName + "\" was found. Looks like this entity is not registered in " +
                        ("current \"" + connectionName + "\" connection?");
                    _this.stack = new Error().stack;
                    return _this;
                }
                return RepositoryNotFoundError;
            }(Error));
            exports_93("RepositoryNotFoundError", RepositoryNotFoundError);
        }
    };
});
System.register("typeorm/error/RepositoryNotTreeError", [], function (exports_94, context_94) {
    "use strict";
    var __moduleName = context_94 && context_94.id;
    var RepositoryNotTreeError;
    return {
        setters: [],
        execute: function () {
            /**
             * Thrown when repository for the given class is not found.
             */
            RepositoryNotTreeError = /** @class */ (function (_super) {
                __extends(RepositoryNotTreeError, _super);
                function RepositoryNotTreeError(entityClass) {
                    var _this = _super.call(this) || this;
                    _this.name = "RepositoryNotTreeError";
                    var targetName = typeof entityClass === "function" && entityClass.name ? entityClass.name : entityClass;
                    _this.message = "Repository of the \"" + targetName + "\" class is not a TreeRepository. Try to use @ClosureEntity decorator instead of @Entity.";
                    _this.stack = new Error().stack;
                    return _this;
                }
                return RepositoryNotTreeError;
            }(Error));
            exports_94("RepositoryNotTreeError", RepositoryNotTreeError);
        }
    };
});
System.register("typeorm/repository/RepositoryFactory", ["typeorm/repository/TreeRepository", "typeorm/repository/Repository", "typeorm/driver/mongodb/MongoDriver", "typeorm/repository/MongoRepository"], function (exports_95, context_95) {
    "use strict";
    var __moduleName = context_95 && context_95.id;
    var TreeRepository_1, Repository_3, MongoDriver_3, MongoRepository_1, RepositoryFactory;
    return {
        setters: [
            function (TreeRepository_1_1) {
                TreeRepository_1 = TreeRepository_1_1;
            },
            function (Repository_3_1) {
                Repository_3 = Repository_3_1;
            },
            function (MongoDriver_3_1) {
                MongoDriver_3 = MongoDriver_3_1;
            },
            function (MongoRepository_1_1) {
                MongoRepository_1 = MongoRepository_1_1;
            }
        ],
        execute: function () {
            /**
             * Factory used to create different types of repositories.
             */
            RepositoryFactory = /** @class */ (function () {
                function RepositoryFactory() {
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Creates a repository.
                 */
                RepositoryFactory.prototype.create = function (manager, metadata, queryRunner) {
                    if (metadata.isClosure) {
                        // NOTE: dynamic access to protected properties. We need this to prevent unwanted properties in those classes to be exposed,
                        // however we need these properties for internal work of the class
                        var repository = new TreeRepository_1.TreeRepository();
                        Object.assign(repository, {
                            manager: manager,
                            metadata: metadata,
                            queryRunner: queryRunner,
                        });
                        return repository;
                    }
                    else {
                        // NOTE: dynamic access to protected properties. We need this to prevent unwanted properties in those classes to be exposed,
                        // however we need these properties for internal work of the class
                        var repository = void 0;
                        if (manager.connection.driver instanceof MongoDriver_3.MongoDriver) {
                            repository = new MongoRepository_1.MongoRepository();
                        }
                        else {
                            repository = new Repository_3.Repository();
                        }
                        Object.assign(repository, {
                            manager: manager,
                            metadata: metadata,
                            queryRunner: queryRunner,
                        });
                        return repository;
                    }
                };
                return RepositoryFactory;
            }());
            exports_95("RepositoryFactory", RepositoryFactory);
        }
    };
});
System.register("typeorm/error/TreeRepositoryNotSupportedError", [], function (exports_96, context_96) {
    "use strict";
    var __moduleName = context_96 && context_96.id;
    var TreeRepositoryNotSupportedError;
    return {
        setters: [],
        execute: function () {
            TreeRepositoryNotSupportedError = /** @class */ (function (_super) {
                __extends(TreeRepositoryNotSupportedError, _super);
                function TreeRepositoryNotSupportedError(driver) {
                    var _this = _super.call(this) || this;
                    _this.name = "TreeRepositoryNotSupportedError";
                    _this.message = "Tree repositories are not supported in " + driver.options.type + " driver.";
                    return _this;
                }
                return TreeRepositoryNotSupportedError;
            }(Error));
            exports_96("TreeRepositoryNotSupportedError", TreeRepositoryNotSupportedError);
        }
    };
});
System.register("typeorm/query-builder/QueryPartialEntity", [], function (exports_97, context_97) {
    "use strict";
    var __moduleName = context_97 && context_97.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/entity-manager/EntityManager", ["typeorm/error/QueryRunnerProviderAlreadyReleasedError", "typeorm/error/NoNeedToReleaseEntityManagerError", "typeorm/repository/TreeRepository", "typeorm/repository/Repository", "typeorm/find-options/FindOptionsUtils", "typeorm/persistence/SubjectBuilder", "typeorm/persistence/SubjectOperationExecutor", "typeorm/query-builder/transformer/PlainObjectToNewEntityTransformer", "typeorm/query-builder/transformer/PlainObjectToDatabaseEntityTransformer", "typeorm/error/CustomRepositoryNotFoundError", "typeorm/index", "typeorm/repository/AbstractRepository", "typeorm/error/CustomRepositoryCannotInheritRepositoryError", "typeorm/driver/mongodb/MongoDriver", "typeorm/error/RepositoryNotFoundError", "typeorm/error/RepositoryNotTreeError", "typeorm/repository/RepositoryFactory", "typeorm/error/TreeRepositoryNotSupportedError"], function (exports_98, context_98) {
    "use strict";
    var __moduleName = context_98 && context_98.id;
    var QueryRunnerProviderAlreadyReleasedError_1, NoNeedToReleaseEntityManagerError_1, TreeRepository_2, Repository_4, FindOptionsUtils_2, SubjectBuilder_1, SubjectOperationExecutor_1, PlainObjectToNewEntityTransformer_1, PlainObjectToDatabaseEntityTransformer_1, CustomRepositoryNotFoundError_2, index_2, AbstractRepository_1, CustomRepositoryCannotInheritRepositoryError_1, MongoDriver_4, RepositoryNotFoundError_1, RepositoryNotTreeError_1, RepositoryFactory_1, TreeRepositoryNotSupportedError_1, EntityManager;
    return {
        setters: [
            function (QueryRunnerProviderAlreadyReleasedError_1_1) {
                QueryRunnerProviderAlreadyReleasedError_1 = QueryRunnerProviderAlreadyReleasedError_1_1;
            },
            function (NoNeedToReleaseEntityManagerError_1_1) {
                NoNeedToReleaseEntityManagerError_1 = NoNeedToReleaseEntityManagerError_1_1;
            },
            function (TreeRepository_2_1) {
                TreeRepository_2 = TreeRepository_2_1;
            },
            function (Repository_4_1) {
                Repository_4 = Repository_4_1;
            },
            function (FindOptionsUtils_2_1) {
                FindOptionsUtils_2 = FindOptionsUtils_2_1;
            },
            function (SubjectBuilder_1_1) {
                SubjectBuilder_1 = SubjectBuilder_1_1;
            },
            function (SubjectOperationExecutor_1_1) {
                SubjectOperationExecutor_1 = SubjectOperationExecutor_1_1;
            },
            function (PlainObjectToNewEntityTransformer_1_1) {
                PlainObjectToNewEntityTransformer_1 = PlainObjectToNewEntityTransformer_1_1;
            },
            function (PlainObjectToDatabaseEntityTransformer_1_1) {
                PlainObjectToDatabaseEntityTransformer_1 = PlainObjectToDatabaseEntityTransformer_1_1;
            },
            function (CustomRepositoryNotFoundError_2_1) {
                CustomRepositoryNotFoundError_2 = CustomRepositoryNotFoundError_2_1;
            },
            function (index_2_1) {
                index_2 = index_2_1;
            },
            function (AbstractRepository_1_1) {
                AbstractRepository_1 = AbstractRepository_1_1;
            },
            function (CustomRepositoryCannotInheritRepositoryError_1_1) {
                CustomRepositoryCannotInheritRepositoryError_1 = CustomRepositoryCannotInheritRepositoryError_1_1;
            },
            function (MongoDriver_4_1) {
                MongoDriver_4 = MongoDriver_4_1;
            },
            function (RepositoryNotFoundError_1_1) {
                RepositoryNotFoundError_1 = RepositoryNotFoundError_1_1;
            },
            function (RepositoryNotTreeError_1_1) {
                RepositoryNotTreeError_1 = RepositoryNotTreeError_1_1;
            },
            function (RepositoryFactory_1_1) {
                RepositoryFactory_1 = RepositoryFactory_1_1;
            },
            function (TreeRepositoryNotSupportedError_1_1) {
                TreeRepositoryNotSupportedError_1 = TreeRepositoryNotSupportedError_1_1;
            }
        ],
        execute: function () {
            /**
             * Entity manager supposed to work with any entity, automatically find its repository and call its methods,
             * whatever entity type are you passing.
             */
            EntityManager = /** @class */ (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function EntityManager(connection, queryRunner) {
                    // -------------------------------------------------------------------------
                    // Protected Properties
                    // -------------------------------------------------------------------------
                    /**
                     * Once created and then reused by en repositories.
                     */
                    this.repositories = [];
                    this.connection = connection;
                    if (queryRunner) {
                        this.queryRunner = queryRunner;
                        // dynamic: this.queryRunner = manager;
                        Object.assign(this.queryRunner, { manager: this });
                    }
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Wraps given function execution (and all operations made there) in a transaction.
                 * All database operations must be executed using provided entity manager.
                 */
                EntityManager.prototype.transaction = function (runInTransaction) {
                    return __awaiter(this, void 0, void 0, function () {
                        var usedQueryRunner, transactionEntityManager, result, err_1, rollbackError_1;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.connection.driver instanceof MongoDriver_4.MongoDriver)
                                        throw new Error("Transactions aren't supported by MongoDB.");
                                    if (this.queryRunner && this.queryRunner.isReleased)
                                        throw new QueryRunnerProviderAlreadyReleasedError_1.QueryRunnerProviderAlreadyReleasedError();
                                    if (this.queryRunner && this.queryRunner.isTransactionActive)
                                        throw new Error("Cannot start transaction because its already started");
                                    usedQueryRunner = this.queryRunner || this.connection.createQueryRunner("master");
                                    transactionEntityManager = this.connection.createEntityManager(usedQueryRunner);
                                    _a.label = 1;
                                case 1:
                                    _a.trys.push([1, 5, 10, 13]);
                                    return [4 /*yield*/, usedQueryRunner.startTransaction()];
                                case 2:
                                    _a.sent();
                                    return [4 /*yield*/, runInTransaction(transactionEntityManager)];
                                case 3:
                                    result = _a.sent();
                                    return [4 /*yield*/, usedQueryRunner.commitTransaction()];
                                case 4:
                                    _a.sent();
                                    return [2 /*return*/, result];
                                case 5:
                                    err_1 = _a.sent();
                                    _a.label = 6;
                                case 6:
                                    _a.trys.push([6, 8, , 9]);
                                    return [4 /*yield*/, usedQueryRunner.rollbackTransaction()];
                                case 7:
                                    _a.sent();
                                    return [3 /*break*/, 9];
                                case 8:
                                    rollbackError_1 = _a.sent();
                                    return [3 /*break*/, 9];
                                case 9: throw err_1;
                                case 10:
                                    if (!!this.queryRunner) return [3 /*break*/, 12];
                                    return [4 /*yield*/, usedQueryRunner.release()];
                                case 11:
                                    _a.sent();
                                    _a.label = 12;
                                case 12: return [7 /*endfinally*/];
                                case 13: return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Executes raw SQL query and returns raw database results.
                 */
                EntityManager.prototype.query = function (query, parameters) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            return [2 /*return*/, this.connection.query(query, parameters, this.queryRunner)];
                        });
                    });
                };
                /**
                 * Creates a new query builder that can be used to build a sql query.
                 */
                EntityManager.prototype.createQueryBuilder = function (entityClass, alias, queryRunner) {
                    if (alias) {
                        return this.connection.createQueryBuilder(entityClass, alias, queryRunner || this.queryRunner);
                    }
                    else {
                        return this.connection.createQueryBuilder(entityClass || this.queryRunner);
                    }
                };
                /**
                 * Checks if entity has an id by its Function type or schema name.
                 */
                EntityManager.prototype.hasId = function (targetOrEntity, maybeEntity) {
                    var target = arguments.length === 2 ? targetOrEntity : targetOrEntity.constructor;
                    var entity = arguments.length === 2 ? maybeEntity : targetOrEntity;
                    var metadata = this.connection.getMetadata(target);
                    return metadata.hasId(entity);
                };
                /**
                 * Gets entity mixed id.
                 */
                EntityManager.prototype.getId = function (targetOrEntity, maybeEntity) {
                    var target = arguments.length === 2 ? targetOrEntity : targetOrEntity.constructor;
                    var entity = arguments.length === 2 ? maybeEntity : targetOrEntity;
                    var metadata = this.connection.getMetadata(target);
                    return metadata.getEntityIdMixedMap(entity);
                };
                /**
                 * Creates a new entity instance or instances.
                 * Can copy properties from the given object into new entities.
                 */
                EntityManager.prototype.create = function (entityClass, plainObjectOrObjects) {
                    var _this = this;
                    var metadata = this.connection.getMetadata(entityClass);
                    if (!plainObjectOrObjects)
                        return metadata.create();
                    if (plainObjectOrObjects instanceof Array)
                        return plainObjectOrObjects.map(function (plainEntityLike) { return _this.create(entityClass, plainEntityLike); });
                    return this.merge(entityClass, metadata.create(), plainObjectOrObjects);
                };
                /**
                 * Merges two entities into one new entity.
                 */
                EntityManager.prototype.merge = function (entityClass, mergeIntoEntity) {
                    var entityLikes = [];
                    for (var _i = 2; _i < arguments.length; _i++) {
                        entityLikes[_i - 2] = arguments[_i];
                    }
                    var metadata = this.connection.getMetadata(entityClass);
                    var plainObjectToEntityTransformer = new PlainObjectToNewEntityTransformer_1.PlainObjectToNewEntityTransformer();
                    entityLikes.forEach(function (object) { return plainObjectToEntityTransformer.transform(mergeIntoEntity, object, metadata); });
                    return mergeIntoEntity;
                };
                /**
                 * Creates a new entity from the given plan javascript object. If entity already exist in the database, then
                 * it loads it (and everything related to it), replaces all values with the new ones from the given object
                 * and returns this new entity. This new entity is actually a loaded from the db entity with all properties
                 * replaced from the new object.
                 */
                EntityManager.prototype.preload = function (entityClass, entityLike) {
                    return __awaiter(this, void 0, void 0, function () {
                        var metadata, plainObjectToDatabaseEntityTransformer, transformedEntity;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    metadata = this.connection.getMetadata(entityClass);
                                    plainObjectToDatabaseEntityTransformer = new PlainObjectToDatabaseEntityTransformer_1.PlainObjectToDatabaseEntityTransformer(this.connection.manager);
                                    return [4 /*yield*/, plainObjectToDatabaseEntityTransformer.transform(entityLike, metadata)];
                                case 1:
                                    transformedEntity = _a.sent();
                                    if (transformedEntity)
                                        return [2 /*return*/, this.merge(entityClass, transformedEntity, entityLike)];
                                    return [2 /*return*/, undefined];
                            }
                        });
                    });
                };
                /**
                 * Saves a given entity in the database.
                 */
                EntityManager.prototype.save = function (targetOrEntity, maybeEntityOrOptions, maybeOptions) {
                    var _this = this;
                    var target = (arguments.length > 1 && (targetOrEntity instanceof Function || typeof targetOrEntity === "string")) ? targetOrEntity : undefined;
                    var entity = target ? maybeEntityOrOptions : targetOrEntity;
                    var options = target ? maybeOptions : maybeEntityOrOptions;
                    // if user passed empty array of entities then we don't need to do anything
                    if (entity instanceof Array && entity.length === 0)
                        return Promise.resolve(entity);
                    return Promise.resolve().then(function () { return __awaiter(_this, void 0, void 0, function () {
                        var _this = this;
                        var queryRunner, transactionEntityManager, executors_1, finalTarget, metadata, databaseEntityLoader, executor, executorsNeedsToBeExecuted, isTransactionStartedByItself, error_1, rollbackError_2;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    queryRunner = this.queryRunner || this.connection.createQueryRunner("master");
                                    transactionEntityManager = this.connection.createEntityManager(queryRunner);
                                    if (options && options.data)
                                        Object.assign(queryRunner.data, options.data);
                                    _a.label = 1;
                                case 1:
                                    _a.trys.push([1, , 18, 21]);
                                    executors_1 = [];
                                    if (!(entity instanceof Array)) return [3 /*break*/, 3];
                                    return [4 /*yield*/, Promise.all(entity.map(function (entity) { return __awaiter(_this, void 0, void 0, function () {
                                            var entityTarget, metadata, databaseEntityLoader, executor;
                                            return __generator(this, function (_a) {
                                                switch (_a.label) {
                                                    case 0:
                                                        entityTarget = target ? target : entity.constructor;
                                                        metadata = this.connection.getMetadata(entityTarget);
                                                        databaseEntityLoader = new SubjectBuilder_1.SubjectBuilder(this.connection, queryRunner);
                                                        return [4 /*yield*/, databaseEntityLoader.persist(entity, metadata)];
                                                    case 1:
                                                        _a.sent();
                                                        executor = new SubjectOperationExecutor_1.SubjectOperationExecutor(this.connection, transactionEntityManager, queryRunner, databaseEntityLoader.operateSubjects);
                                                        executors_1.push(executor);
                                                        return [2 /*return*/];
                                                }
                                            });
                                        }); }))];
                                case 2:
                                    _a.sent();
                                    return [3 /*break*/, 5];
                                case 3:
                                    finalTarget = target ? target : entity.constructor;
                                    metadata = this.connection.getMetadata(finalTarget);
                                    databaseEntityLoader = new SubjectBuilder_1.SubjectBuilder(this.connection, queryRunner);
                                    return [4 /*yield*/, databaseEntityLoader.persist(entity, metadata)];
                                case 4:
                                    _a.sent();
                                    executor = new SubjectOperationExecutor_1.SubjectOperationExecutor(this.connection, transactionEntityManager, queryRunner, databaseEntityLoader.operateSubjects);
                                    executors_1.push(executor);
                                    _a.label = 5;
                                case 5:
                                    executorsNeedsToBeExecuted = executors_1.filter(function (executor) { return executor.areExecutableOperations(); });
                                    if (!executorsNeedsToBeExecuted.length) return [3 /*break*/, 17];
                                    isTransactionStartedByItself = false;
                                    _a.label = 6;
                                case 6:
                                    _a.trys.push([6, 12, , 17]);
                                    if (!!queryRunner.isTransactionActive) return [3 /*break*/, 8];
                                    isTransactionStartedByItself = true;
                                    return [4 /*yield*/, queryRunner.startTransaction()];
                                case 7:
                                    _a.sent();
                                    _a.label = 8;
                                case 8: return [4 /*yield*/, Promise.all(executorsNeedsToBeExecuted.map(function (executor) {
                                        return executor.execute();
                                    }))];
                                case 9:
                                    _a.sent();
                                    if (!(isTransactionStartedByItself === true)) return [3 /*break*/, 11];
                                    return [4 /*yield*/, queryRunner.commitTransaction()];
                                case 10:
                                    _a.sent();
                                    _a.label = 11;
                                case 11: return [3 /*break*/, 17];
                                case 12:
                                    error_1 = _a.sent();
                                    if (!isTransactionStartedByItself) return [3 /*break*/, 16];
                                    _a.label = 13;
                                case 13:
                                    _a.trys.push([13, 15, , 16]);
                                    return [4 /*yield*/, queryRunner.rollbackTransaction()];
                                case 14:
                                    _a.sent();
                                    return [3 /*break*/, 16];
                                case 15:
                                    rollbackError_2 = _a.sent();
                                    return [3 /*break*/, 16];
                                case 16: throw error_1;
                                case 17: return [3 /*break*/, 21];
                                case 18:
                                    if (!!this.queryRunner) return [3 /*break*/, 20];
                                    return [4 /*yield*/, queryRunner.release()];
                                case 19:
                                    _a.sent();
                                    _a.label = 20;
                                case 20: return [7 /*endfinally*/];
                                case 21: return [2 /*return*/, entity];
                            }
                        });
                    }); });
                };
                /**
                 * Inserts a given entity into the database.
                 * Unlike save method executes a primitive operation without cascades, relations and other operations included.
                 * Does not modify source entity and does not execute listeners and subscribers.
                 * Executes fast and efficient INSERT query.
                 * Does not check if entity exist in the database, so query will fail if duplicate entity is being inserted.
                 * You can execute bulk inserts using this method.
                 */
                EntityManager.prototype.insert = function (target, entity, options) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: 
                                // todo: in the future create InsertResult with query result information
                                // todo: think if subscribers and listeners can be executed here as well
                                return [4 /*yield*/, this.createQueryBuilder()
                                        .insert()
                                        .into(target)
                                        .values(entity)
                                        .execute()];
                                case 1:
                                    // todo: in the future create InsertResult with query result information
                                    // todo: think if subscribers and listeners can be executed here as well
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Updates entity partially. Entity can be found by a given conditions.
                 * Unlike save method executes a primitive operation without cascades, relations and other operations included.
                 * Does not modify source entity and does not execute listeners and subscribers.
                 * Executes fast and efficient UPDATE query.
                 * Does not check if entity exist in the database.
                 */
                EntityManager.prototype.update = function (target, conditions, partialEntity, options) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: 
                                // todo: in the future create UpdateResult with query result information
                                // todo: think if subscribers and listeners can be executed here as well
                                return [4 /*yield*/, this.createQueryBuilder()
                                        .update(target)
                                        .set(partialEntity)
                                        .where(conditions)
                                        .execute()];
                                case 1:
                                    // todo: in the future create UpdateResult with query result information
                                    // todo: think if subscribers and listeners can be executed here as well
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Updates entity partially. Entity will be found by a given id.
                 * Unlike save method executes a primitive operation without cascades, relations and other operations included.
                 * Does not modify source entity and does not execute listeners and subscribers.
                 * Executes fast and efficient UPDATE query.
                 * Does not check if entity exist in the database.
                 */
                EntityManager.prototype.updateById = function (target, id, partialEntity, options) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: 
                                // todo: in the future create UpdateResult with query result information
                                // todo: think if subscribers and listeners can be executed here as well
                                return [4 /*yield*/, this.createQueryBuilder()
                                        .update(target)
                                        .set(partialEntity)
                                        .whereInIds(id)
                                        .execute()];
                                case 1:
                                    // todo: in the future create UpdateResult with query result information
                                    // todo: think if subscribers and listeners can be executed here as well
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Removes a given entity from the database.
                 */
                EntityManager.prototype.remove = function (targetOrEntity, maybeEntityOrOptions, maybeOptions) {
                    var _this = this;
                    var target = (arguments.length > 1 && (targetOrEntity instanceof Function || typeof targetOrEntity === "string")) ? targetOrEntity : undefined;
                    var entity = target ? maybeEntityOrOptions : targetOrEntity;
                    var options = target ? maybeOptions : maybeEntityOrOptions;
                    // if user passed empty array of entities then we don't need to do anything
                    if (entity instanceof Array && entity.length === 0)
                        return Promise.resolve(entity);
                    return Promise.resolve().then(function () { return __awaiter(_this, void 0, void 0, function () {
                        var _this = this;
                        var queryRunner, transactionEntityManager, executors_2, finalTarget, metadata, databaseEntityLoader, executor, executorsNeedsToBeExecuted, isTransactionStartedByItself, error_2, rollbackError_3;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    queryRunner = this.queryRunner || this.connection.createQueryRunner("master");
                                    transactionEntityManager = this.connection.createEntityManager(queryRunner);
                                    if (options && options.data)
                                        Object.assign(queryRunner.data, options.data);
                                    _a.label = 1;
                                case 1:
                                    _a.trys.push([1, , 18, 21]);
                                    executors_2 = [];
                                    if (!(entity instanceof Array)) return [3 /*break*/, 3];
                                    return [4 /*yield*/, Promise.all(entity.map(function (entity) { return __awaiter(_this, void 0, void 0, function () {
                                            var entityTarget, metadata, databaseEntityLoader, executor;
                                            return __generator(this, function (_a) {
                                                switch (_a.label) {
                                                    case 0:
                                                        entityTarget = target ? target : entity.constructor;
                                                        metadata = this.connection.getMetadata(entityTarget);
                                                        databaseEntityLoader = new SubjectBuilder_1.SubjectBuilder(this.connection, queryRunner);
                                                        return [4 /*yield*/, databaseEntityLoader.remove(entity, metadata)];
                                                    case 1:
                                                        _a.sent();
                                                        executor = new SubjectOperationExecutor_1.SubjectOperationExecutor(this.connection, transactionEntityManager, queryRunner, databaseEntityLoader.operateSubjects);
                                                        executors_2.push(executor);
                                                        return [2 /*return*/];
                                                }
                                            });
                                        }); }))];
                                case 2:
                                    _a.sent();
                                    return [3 /*break*/, 5];
                                case 3:
                                    finalTarget = target ? target : entity.constructor;
                                    metadata = this.connection.getMetadata(finalTarget);
                                    databaseEntityLoader = new SubjectBuilder_1.SubjectBuilder(this.connection, queryRunner);
                                    return [4 /*yield*/, databaseEntityLoader.remove(entity, metadata)];
                                case 4:
                                    _a.sent();
                                    executor = new SubjectOperationExecutor_1.SubjectOperationExecutor(this.connection, transactionEntityManager, queryRunner, databaseEntityLoader.operateSubjects);
                                    executors_2.push(executor);
                                    _a.label = 5;
                                case 5:
                                    executorsNeedsToBeExecuted = executors_2.filter(function (executor) { return executor.areExecutableOperations(); });
                                    if (!executorsNeedsToBeExecuted.length) return [3 /*break*/, 17];
                                    isTransactionStartedByItself = false;
                                    _a.label = 6;
                                case 6:
                                    _a.trys.push([6, 12, , 17]);
                                    if (!!queryRunner.isTransactionActive) return [3 /*break*/, 8];
                                    isTransactionStartedByItself = true;
                                    return [4 /*yield*/, queryRunner.startTransaction()];
                                case 7:
                                    _a.sent();
                                    _a.label = 8;
                                case 8: return [4 /*yield*/, Promise.all(executorsNeedsToBeExecuted.map(function (executor) {
                                        return executor.execute();
                                    }))];
                                case 9:
                                    _a.sent();
                                    if (!(isTransactionStartedByItself === true)) return [3 /*break*/, 11];
                                    return [4 /*yield*/, queryRunner.commitTransaction()];
                                case 10:
                                    _a.sent();
                                    _a.label = 11;
                                case 11: return [3 /*break*/, 17];
                                case 12:
                                    error_2 = _a.sent();
                                    if (!isTransactionStartedByItself) return [3 /*break*/, 16];
                                    _a.label = 13;
                                case 13:
                                    _a.trys.push([13, 15, , 16]);
                                    return [4 /*yield*/, queryRunner.rollbackTransaction()];
                                case 14:
                                    _a.sent();
                                    return [3 /*break*/, 16];
                                case 15:
                                    rollbackError_3 = _a.sent();
                                    return [3 /*break*/, 16];
                                case 16: throw error_2;
                                case 17: return [3 /*break*/, 21];
                                case 18:
                                    if (!!this.queryRunner) return [3 /*break*/, 20];
                                    return [4 /*yield*/, queryRunner.release()];
                                case 19:
                                    _a.sent();
                                    _a.label = 20;
                                case 20: return [7 /*endfinally*/];
                                case 21: return [2 /*return*/, entity];
                            }
                        });
                    }); });
                };
                /**
                 * Deletes entities by a given conditions.
                 * Unlike save method executes a primitive operation without cascades, relations and other operations included.
                 * Does not modify source entity and does not execute listeners and subscribers.
                 * Executes fast and efficient DELETE query.
                 * Does not check if entity exist in the database.
                 */
                EntityManager.prototype.delete = function (targetOrEntity, conditions, options) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: 
                                // todo: in the future create DeleteResult with query result information
                                // todo: think if subscribers and listeners can be executed here as well
                                return [4 /*yield*/, this.createQueryBuilder()
                                        .delete()
                                        .from(targetOrEntity)
                                        .where(conditions)
                                        .execute()];
                                case 1:
                                    // todo: in the future create DeleteResult with query result information
                                    // todo: think if subscribers and listeners can be executed here as well
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Deletes entities by a given entity id or ids.
                 * Unlike save method executes a primitive operation without cascades, relations and other operations included.
                 * Does not modify source entity and does not execute listeners and subscribers.
                 * Executes fast and efficient DELETE query.
                 * Does not check if entity exist in the database.
                 */
                EntityManager.prototype.deleteById = function (targetOrEntity, id, options) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: 
                                // todo: in the future create DeleteResult with query result information
                                // todo: think if subscribers and listeners can be executed here as well
                                return [4 /*yield*/, this.createQueryBuilder()
                                        .delete()
                                        .from(targetOrEntity)
                                        .whereInIds(id)
                                        .execute()];
                                case 1:
                                    // todo: in the future create DeleteResult with query result information
                                    // todo: think if subscribers and listeners can be executed here as well
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Deletes entity by a given entity id.
                 *
                 * @deprecated use deleteById method instead.
                 */
                EntityManager.prototype.removeById = function (targetOrEntity, id, options) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            return [2 /*return*/, this.deleteById(targetOrEntity, id, options)];
                        });
                    });
                };
                /**
                 * Deletes entity by a given entity ids.
                 *
                 * @deprecated use deleteById method instead.
                 */
                EntityManager.prototype.removeByIds = function (targetOrEntity, ids, options) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            return [2 /*return*/, this.deleteById(targetOrEntity, ids, options)];
                        });
                    });
                };
                /**
                 * Counts entities that match given find options or conditions.
                 * Useful for pagination.
                 */
                EntityManager.prototype.count = function (entityClass, optionsOrConditions) {
                    return __awaiter(this, void 0, void 0, function () {
                        var metadata, qb;
                        return __generator(this, function (_a) {
                            metadata = this.connection.getMetadata(entityClass);
                            qb = this.createQueryBuilder(entityClass, FindOptionsUtils_2.FindOptionsUtils.extractFindManyOptionsAlias(optionsOrConditions) || metadata.name);
                            return [2 /*return*/, FindOptionsUtils_2.FindOptionsUtils.applyFindManyOptionsOrConditionsToQueryBuilder(qb, optionsOrConditions).getCount()];
                        });
                    });
                };
                /**
                 * Finds entities that match given find options or conditions.
                 */
                EntityManager.prototype.find = function (entityClass, optionsOrConditions) {
                    return __awaiter(this, void 0, void 0, function () {
                        var metadata, qb;
                        return __generator(this, function (_a) {
                            metadata = this.connection.getMetadata(entityClass);
                            qb = this.createQueryBuilder(entityClass, FindOptionsUtils_2.FindOptionsUtils.extractFindManyOptionsAlias(optionsOrConditions) || metadata.name);
                            this.joinEagerRelations(qb, qb.alias, metadata);
                            return [2 /*return*/, FindOptionsUtils_2.FindOptionsUtils.applyFindManyOptionsOrConditionsToQueryBuilder(qb, optionsOrConditions).getMany()];
                        });
                    });
                };
                /**
                 * Finds entities that match given find options and conditions.
                 * Also counts all entities that match given conditions,
                 * but ignores pagination settings (from and take options).
                 */
                EntityManager.prototype.findAndCount = function (entityClass, optionsOrConditions) {
                    return __awaiter(this, void 0, void 0, function () {
                        var metadata, qb;
                        return __generator(this, function (_a) {
                            metadata = this.connection.getMetadata(entityClass);
                            qb = this.createQueryBuilder(entityClass, FindOptionsUtils_2.FindOptionsUtils.extractFindManyOptionsAlias(optionsOrConditions) || metadata.name);
                            this.joinEagerRelations(qb, qb.alias, metadata);
                            return [2 /*return*/, FindOptionsUtils_2.FindOptionsUtils.applyFindManyOptionsOrConditionsToQueryBuilder(qb, optionsOrConditions).getManyAndCount()];
                        });
                    });
                };
                /**
                 * Finds entities with ids.
                 * Optionally find options or conditions can be applied.
                 */
                EntityManager.prototype.findByIds = function (entityClass, ids, optionsOrConditions) {
                    return __awaiter(this, void 0, void 0, function () {
                        var metadata, qb;
                        return __generator(this, function (_a) {
                            // if no ids passed, no need to execute a query - just return an empty array of values
                            if (!ids.length)
                                return [2 /*return*/, Promise.resolve([])];
                            metadata = this.connection.getMetadata(entityClass);
                            qb = this.createQueryBuilder(entityClass, FindOptionsUtils_2.FindOptionsUtils.extractFindManyOptionsAlias(optionsOrConditions) || metadata.name);
                            FindOptionsUtils_2.FindOptionsUtils.applyFindManyOptionsOrConditionsToQueryBuilder(qb, optionsOrConditions);
                            ids = ids.map(function (id) {
                                if (!metadata.hasMultiplePrimaryKeys && !(id instanceof Object)) {
                                    return metadata.createEntityIdMap([id]);
                                }
                                return id;
                            });
                            this.joinEagerRelations(qb, qb.alias, metadata);
                            return [2 /*return*/, qb.andWhereInIds(ids).getMany()];
                        });
                    });
                };
                /**
                 * Finds first entity that matches given conditions.
                 */
                EntityManager.prototype.findOne = function (entityClass, optionsOrConditions) {
                    return __awaiter(this, void 0, void 0, function () {
                        var metadata, qb;
                        return __generator(this, function (_a) {
                            metadata = this.connection.getMetadata(entityClass);
                            qb = this.createQueryBuilder(entityClass, FindOptionsUtils_2.FindOptionsUtils.extractFindOneOptionsAlias(optionsOrConditions) || metadata.name);
                            this.joinEagerRelations(qb, qb.alias, metadata);
                            return [2 /*return*/, FindOptionsUtils_2.FindOptionsUtils.applyFindOneOptionsOrConditionsToQueryBuilder(qb, optionsOrConditions).getOne()];
                        });
                    });
                };
                /**
                 * Finds entity with given id.
                 * Optionally find options or conditions can be applied.
                 */
                EntityManager.prototype.findOneById = function (entityClass, id, optionsOrConditions) {
                    return __awaiter(this, void 0, void 0, function () {
                        var metadata, qb;
                        return __generator(this, function (_a) {
                            metadata = this.connection.getMetadata(entityClass);
                            qb = this.createQueryBuilder(entityClass, FindOptionsUtils_2.FindOptionsUtils.extractFindOneOptionsAlias(optionsOrConditions) || metadata.name);
                            if (metadata.hasMultiplePrimaryKeys && !(id instanceof Object)) {
                                // const columnNames = this.metadata.getEntityIdMap({  });
                                throw new Error("You have multiple primary keys in your entity, to use findOneById with multiple primary keys please provide " +
                                    "complete object with all entity ids, like this: { firstKey: value, secondKey: value }");
                            }
                            if (!metadata.hasMultiplePrimaryKeys && !(id instanceof Object)) {
                                id = metadata.createEntityIdMap([id]);
                            }
                            this.joinEagerRelations(qb, qb.alias, metadata);
                            FindOptionsUtils_2.FindOptionsUtils.applyFindOneOptionsOrConditionsToQueryBuilder(qb, optionsOrConditions);
                            return [2 /*return*/, qb.andWhereInIds([id]).getOne()];
                        });
                    });
                };
                /**
                 * Clears all the data from the given table (truncates/drops it).
                 *
                 * Note: this method uses TRUNCATE and may not work as you expect in transactions on some platforms.
                 * @see https://stackoverflow.com/a/5972738/925151
                 */
                EntityManager.prototype.clear = function (entityClass) {
                    return __awaiter(this, void 0, void 0, function () {
                        var metadata, queryRunner;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    metadata = this.connection.getMetadata(entityClass);
                                    queryRunner = this.queryRunner || this.connection.createQueryRunner("master");
                                    _a.label = 1;
                                case 1:
                                    _a.trys.push([1, , 3, 6]);
                                    return [4 /*yield*/, queryRunner.truncate(metadata.tablePath)];
                                case 2: return [2 /*return*/, _a.sent()]; // await is needed here because we are using finally
                                case 3:
                                    if (!!this.queryRunner) return [3 /*break*/, 5];
                                    return [4 /*yield*/, queryRunner.release()];
                                case 4:
                                    _a.sent();
                                    _a.label = 5;
                                case 5: return [7 /*endfinally*/];
                                case 6: return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Gets repository for the given entity class or name.
                 * If single database connection mode is used, then repository is obtained from the
                 * repository aggregator, where each repository is individually created for this entity manager.
                 * When single database connection is not used, repository is being obtained from the connection.
                 */
                EntityManager.prototype.getRepository = function (target) {
                    // throw exception if there is no repository with this target registered
                    if (!this.connection.hasMetadata(target))
                        throw new RepositoryNotFoundError_1.RepositoryNotFoundError(this.connection.name, target);
                    // find already created repository instance and return it if found
                    var metadata = this.connection.getMetadata(target);
                    var repository = this.repositories.find(function (repository) { return repository.metadata === metadata; });
                    if (repository)
                        return repository;
                    // if repository was not found then create it, store its instance and return it
                    var newRepository = new RepositoryFactory_1.RepositoryFactory().create(this, metadata, this.queryRunner);
                    this.repositories.push(newRepository);
                    return newRepository;
                };
                /**
                 * Gets tree repository for the given entity class or name.
                 * If single database connection mode is used, then repository is obtained from the
                 * repository aggregator, where each repository is individually created for this entity manager.
                 * When single database connection is not used, repository is being obtained from the connection.
                 */
                EntityManager.prototype.getTreeRepository = function (target) {
                    // tree tables aren't supported by some drivers (mongodb)
                    if (this.connection.driver.treeSupport === false)
                        throw new TreeRepositoryNotSupportedError_1.TreeRepositoryNotSupportedError(this.connection.driver);
                    // check if repository is real tree repository
                    var repository = this.getRepository(target);
                    if (!(repository instanceof TreeRepository_2.TreeRepository))
                        throw new RepositoryNotTreeError_1.RepositoryNotTreeError(target);
                    return repository;
                };
                /**
                 * Gets mongodb repository for the given entity class or name.
                 */
                EntityManager.prototype.getMongoRepository = function (entityClassOrName) {
                    return this.connection.getMongoRepository(entityClassOrName);
                };
                /**
                 * Gets custom entity repository marked with @EntityRepository decorator.
                 */
                EntityManager.prototype.getCustomRepository = function (customRepository) {
                    var entityRepositoryMetadataArgs = index_2.getMetadataArgsStorage().entityRepositories.find(function (repository) {
                        return repository.target === (customRepository instanceof Function ? customRepository : customRepository.constructor);
                    });
                    if (!entityRepositoryMetadataArgs)
                        throw new CustomRepositoryNotFoundError_2.CustomRepositoryNotFoundError(customRepository);
                    var entityMetadata = entityRepositoryMetadataArgs.entity ? this.connection.getMetadata(entityRepositoryMetadataArgs.entity) : undefined;
                    var entityRepositoryInstance = new entityRepositoryMetadataArgs.target(this, entityMetadata);
                    // NOTE: dynamic access to protected properties. We need this to prevent unwanted properties in those classes to be exposed,
                    // however we need these properties for internal work of the class
                    if (entityRepositoryInstance instanceof AbstractRepository_1.AbstractRepository) {
                        if (!entityRepositoryInstance["manager"])
                            entityRepositoryInstance["manager"] = this;
                    }
                    if (entityRepositoryInstance instanceof Repository_4.Repository) {
                        if (!entityMetadata)
                            throw new CustomRepositoryCannotInheritRepositoryError_1.CustomRepositoryCannotInheritRepositoryError(customRepository);
                        entityRepositoryInstance["manager"] = this;
                        entityRepositoryInstance["metadata"] = entityMetadata;
                    }
                    return entityRepositoryInstance;
                };
                /**
                 * Releases all resources used by entity manager.
                 * This is used when entity manager is created with a single query runner,
                 * and this single query runner needs to be released after job with entity manager is done.
                 */
                EntityManager.prototype.release = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            if (!this.queryRunner)
                                throw new NoNeedToReleaseEntityManagerError_1.NoNeedToReleaseEntityManagerError();
                            return [2 /*return*/, this.queryRunner.release()];
                        });
                    });
                };
                // -------------------------------------------------------------------------
                // Protected Methods
                // -------------------------------------------------------------------------
                /**
                 * Joins all eager relations recursively.
                 */
                EntityManager.prototype.joinEagerRelations = function (qb, alias, metadata) {
                    var _this = this;
                    metadata.eagerRelations.forEach(function (relation) {
                        var relationAlias = alias + "_" + relation.propertyPath.replace(".", "_");
                        qb.leftJoinAndSelect(alias + "." + relation.propertyPath, relationAlias);
                        _this.joinEagerRelations(qb, relationAlias, relation.inverseEntityMetadata);
                    });
                };
                return EntityManager;
            }());
            exports_98("EntityManager", EntityManager);
        }
    };
});
System.register("typeorm/driver/InsertResult", [], function (exports_99, context_99) {
    "use strict";
    var __moduleName = context_99 && context_99.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/driver/sqlite-abstract/AbstractSqliteQueryRunner", ["typeorm/error/TransactionAlreadyStartedError", "typeorm/error/TransactionNotStartedError", "typeorm/schema-builder/schema/TableColumn", "typeorm/metadata/ColumnMetadata", "typeorm/schema-builder/schema/Table", "typeorm/schema-builder/schema/TableIndex", "typeorm/schema-builder/schema/TableForeignKey", "typeorm/schema-builder/schema/TablePrimaryKey", "typeorm/util/RandomGenerator"], function (exports_100, context_100) {
    "use strict";
    var __moduleName = context_100 && context_100.id;
    var TransactionAlreadyStartedError_1, TransactionNotStartedError_1, TableColumn_1, ColumnMetadata_1, Table_1, TableIndex_1, TableForeignKey_1, TablePrimaryKey_1, RandomGenerator_1, AbstractSqliteQueryRunner;
    return {
        setters: [
            function (TransactionAlreadyStartedError_1_1) {
                TransactionAlreadyStartedError_1 = TransactionAlreadyStartedError_1_1;
            },
            function (TransactionNotStartedError_1_1) {
                TransactionNotStartedError_1 = TransactionNotStartedError_1_1;
            },
            function (TableColumn_1_1) {
                TableColumn_1 = TableColumn_1_1;
            },
            function (ColumnMetadata_1_1) {
                ColumnMetadata_1 = ColumnMetadata_1_1;
            },
            function (Table_1_1) {
                Table_1 = Table_1_1;
            },
            function (TableIndex_1_1) {
                TableIndex_1 = TableIndex_1_1;
            },
            function (TableForeignKey_1_1) {
                TableForeignKey_1 = TableForeignKey_1_1;
            },
            function (TablePrimaryKey_1_1) {
                TablePrimaryKey_1 = TablePrimaryKey_1_1;
            },
            function (RandomGenerator_1_1) {
                RandomGenerator_1 = RandomGenerator_1_1;
            }
        ],
        execute: function () {
            /**
             * Runs queries on a single sqlite database connection.
             *
             * Does not support compose primary keys with autoincrement field.
             * todo: need to throw exception for this case.
             */
            AbstractSqliteQueryRunner = /** @class */ (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function AbstractSqliteQueryRunner(driver) {
                    /**
                     * Indicates if connection for this query runner is released.
                     * Once its released, query runner cannot run queries anymore.
                     */
                    this.isReleased = false;
                    /**
                     * Indicates if transaction is in progress.
                     */
                    this.isTransactionActive = false;
                    /**
                     * Stores temporarily user data.
                     * Useful for sharing data with subscribers.
                     */
                    this.data = {};
                    // -------------------------------------------------------------------------
                    // Protected Properties
                    // -------------------------------------------------------------------------
                    /**
                     * Indicates if special query runner mode in which sql queries won't be executed is enabled.
                     */
                    this.sqlMemoryMode = false;
                    /**
                     * Sql-s stored if "sql in memory" mode is enabled.
                     */
                    this.sqlsInMemory = [];
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Creates/uses database connection from the connection pool to perform further operations.
                 * Returns obtained database connection.
                 */
                AbstractSqliteQueryRunner.prototype.connect = function () {
                    return Promise.resolve(this.driver.databaseConnection);
                };
                /**
                 * Releases used database connection.
                 * We don't do anything here because sqlite do not support multiple connections thus query runners.
                 */
                AbstractSqliteQueryRunner.prototype.release = function () {
                    return Promise.resolve();
                };
                /**
                 * Starts transaction.
                 */
                AbstractSqliteQueryRunner.prototype.startTransaction = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isTransactionActive)
                                        throw new TransactionAlreadyStartedError_1.TransactionAlreadyStartedError();
                                    this.isTransactionActive = true;
                                    return [4 /*yield*/, this.query("BEGIN TRANSACTION")];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Commits transaction.
                 * Error will be thrown if transaction was not started.
                 */
                AbstractSqliteQueryRunner.prototype.commitTransaction = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (!this.isTransactionActive)
                                        throw new TransactionNotStartedError_1.TransactionNotStartedError();
                                    return [4 /*yield*/, this.query("COMMIT")];
                                case 1:
                                    _a.sent();
                                    this.isTransactionActive = false;
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Rollbacks transaction.
                 * Error will be thrown if transaction was not started.
                 */
                AbstractSqliteQueryRunner.prototype.rollbackTransaction = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (!this.isTransactionActive)
                                        throw new TransactionNotStartedError_1.TransactionNotStartedError();
                                    return [4 /*yield*/, this.query("ROLLBACK")];
                                case 1:
                                    _a.sent();
                                    this.isTransactionActive = false;
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Executes a given SQL query.
                 */
                AbstractSqliteQueryRunner.prototype.query = function (query, parameters) {
                    throw new Error("Do not use AbstractSqlite directly, it has to be used with one of the sqlite drivers");
                };
                /**
                 * Returns raw data stream.
                 */
                AbstractSqliteQueryRunner.prototype.stream = function (query, parameters, onEnd, onError) {
                    throw new Error("Stream is not supported by sqlite driver.");
                };
                /**
                 * Insert a new row with given values into the given table.
                 * Returns value of the generated column if given and generate column exist in the table.
                 */
                AbstractSqliteQueryRunner.prototype.insert = function (tableName, keyValues) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            throw new Error("Do not use AbstractSqlite directly, it has to be used with one of the sqlite drivers");
                        });
                    });
                };
                /**
                 * Updates rows that match given conditions in the given table.
                 */
                AbstractSqliteQueryRunner.prototype.update = function (tableName, valuesMap, conditions) {
                    return __awaiter(this, void 0, void 0, function () {
                        var updateValues, conditionString, query, updateParams, conditionParams, allParameters;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    updateValues = this.parametrize(valuesMap).join(", ");
                                    conditionString = this.parametrize(conditions, Object.keys(valuesMap).length).join(" AND ");
                                    query = "UPDATE \"" + tableName + "\" SET " + updateValues + " " + (conditionString ? (" WHERE " + conditionString) : "");
                                    updateParams = Object.keys(valuesMap).map(function (key) { return valuesMap[key]; });
                                    conditionParams = Object.keys(conditions).map(function (key) { return conditions[key]; });
                                    allParameters = updateParams.concat(conditionParams);
                                    return [4 /*yield*/, this.query(query, allParameters)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Deletes from the given table by a given conditions.
                 */
                AbstractSqliteQueryRunner.prototype.delete = function (tableName, conditions, maybeParameters) {
                    return __awaiter(this, void 0, void 0, function () {
                        var conditionString, parameters, sql;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    conditionString = typeof conditions === "string" ? conditions : this.parametrize(conditions).join(" AND ");
                                    parameters = conditions instanceof Object ? Object.keys(conditions).map(function (key) { return conditions[key]; }) : maybeParameters;
                                    sql = "DELETE FROM \"" + tableName + "\" WHERE " + conditionString;
                                    return [4 /*yield*/, this.query(sql, parameters)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Inserts rows into closure table.
                 */
                AbstractSqliteQueryRunner.prototype.insertIntoClosureTable = function (tableName, newEntityId, parentId, hasLevel) {
                    return __awaiter(this, void 0, void 0, function () {
                        var sql, results;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    sql = "";
                                    if (hasLevel) {
                                        sql = "INSERT INTO \"" + tableName + "\"(\"ancestor\", \"descendant\", \"level\") " +
                                            ("SELECT \"ancestor\", " + newEntityId + ", \"level\" + 1 FROM \"" + tableName + "\" WHERE \"descendant\" = " + parentId + " ") +
                                            ("UNION ALL SELECT " + newEntityId + ", " + newEntityId + ", 1");
                                    }
                                    else {
                                        sql = "INSERT INTO \"" + tableName + "\"(\"ancestor\", \"descendant\") " +
                                            ("SELECT \"ancestor\", " + newEntityId + " FROM \"" + tableName + "\" WHERE \"descendant\" = " + parentId + " ") +
                                            ("UNION ALL SELECT " + newEntityId + ", " + newEntityId);
                                    }
                                    return [4 /*yield*/, this.query(sql)];
                                case 1:
                                    _a.sent();
                                    if (!hasLevel) return [3 /*break*/, 3];
                                    return [4 /*yield*/, this.query("SELECT MAX(level) as level FROM " + tableName + " WHERE descendant = " + parentId)];
                                case 2:
                                    results = _a.sent();
                                    return [2 /*return*/, results && results[0] && results[0]["level"] ? parseInt(results[0]["level"]) + 1 : 1];
                                case 3: return [2 /*return*/, -1];
                            }
                        });
                    });
                };
                /**
                 * Loads given table's data from the database.
                 */
                AbstractSqliteQueryRunner.prototype.getTable = function (tableName) {
                    return __awaiter(this, void 0, void 0, function () {
                        var tables;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.getTables([tableName])];
                                case 1:
                                    tables = _a.sent();
                                    return [2 /*return*/, tables.length > 0 ? tables[0] : undefined];
                            }
                        });
                    });
                };
                /**
                 * Loads all tables (with given names) from the database and creates a Table from them.
                 */
                AbstractSqliteQueryRunner.prototype.getTables = function (tableNames) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var tableNamesString, dbTables;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    // if no tables given then no need to proceed
                                    if (!tableNames || !tableNames.length)
                                        return [2 /*return*/, []];
                                    tableNamesString = tableNames.map(function (tableName) { return "'" + tableName + "'"; }).join(", ");
                                    return [4 /*yield*/, this.query("SELECT * FROM sqlite_master WHERE type = 'table' AND name IN (" + tableNamesString + ")")];
                                case 1:
                                    dbTables = _a.sent();
                                    // if tables were not found in the db, no need to proceed
                                    if (!dbTables || !dbTables.length)
                                        return [2 /*return*/, []];
                                    // create table schemas for loaded tables
                                    return [2 /*return*/, Promise.all(dbTables.map(function (dbTable) { return __awaiter(_this, void 0, void 0, function () {
                                            var _this = this;
                                            var table, _a, dbColumns, dbIndices, dbForeignKeys, autoIncrementColumnName, tableSql, comma, bracket, indicesPromises, indices;
                                            return __generator(this, function (_b) {
                                                switch (_b.label) {
                                                    case 0:
                                                        table = new Table_1.Table(dbTable["name"]);
                                                        return [4 /*yield*/, Promise.all([
                                                                this.query("PRAGMA table_info(\"" + dbTable["name"] + "\")"),
                                                                this.query("PRAGMA index_list(\"" + dbTable["name"] + "\")"),
                                                                this.query("PRAGMA foreign_key_list(\"" + dbTable["name"] + "\")"),
                                                            ])];
                                                    case 1:
                                                        _a = _b.sent(), dbColumns = _a[0], dbIndices = _a[1], dbForeignKeys = _a[2];
                                                        autoIncrementColumnName = undefined;
                                                        tableSql = dbTable["sql"];
                                                        if (tableSql.indexOf("AUTOINCREMENT") !== -1) {
                                                            autoIncrementColumnName = tableSql.substr(0, tableSql.indexOf("AUTOINCREMENT"));
                                                            comma = autoIncrementColumnName.lastIndexOf(",");
                                                            bracket = autoIncrementColumnName.lastIndexOf("(");
                                                            if (comma !== -1) {
                                                                autoIncrementColumnName = autoIncrementColumnName.substr(comma);
                                                                autoIncrementColumnName = autoIncrementColumnName.substr(0, autoIncrementColumnName.lastIndexOf("\""));
                                                                autoIncrementColumnName = autoIncrementColumnName.substr(autoIncrementColumnName.indexOf("\"") + 1);
                                                            }
                                                            else if (bracket !== -1) {
                                                                autoIncrementColumnName = autoIncrementColumnName.substr(bracket);
                                                                autoIncrementColumnName = autoIncrementColumnName.substr(0, autoIncrementColumnName.lastIndexOf("\""));
                                                                autoIncrementColumnName = autoIncrementColumnName.substr(autoIncrementColumnName.indexOf("\"") + 1);
                                                            }
                                                        }
                                                        // create columns from the loaded columns
                                                        table.columns = dbColumns.map(function (dbColumn) {
                                                            var tableColumn = new TableColumn_1.TableColumn();
                                                            tableColumn.name = dbColumn["name"];
                                                            tableColumn.type = dbColumn["type"].toLowerCase();
                                                            tableColumn.default = dbColumn["dflt_value"] !== null && dbColumn["dflt_value"] !== undefined ? dbColumn["dflt_value"] : undefined;
                                                            tableColumn.isNullable = dbColumn["notnull"] === 0;
                                                            // primary keys are numbered starting with 1, columns that aren't primary keys are marked with 0
                                                            tableColumn.isPrimary = dbColumn["pk"] > 0;
                                                            tableColumn.comment = ""; // todo later
                                                            tableColumn.isGenerated = autoIncrementColumnName === dbColumn["name"];
                                                            if (tableColumn.isGenerated) {
                                                                tableColumn.generationStrategy = "increment";
                                                            }
                                                            // parse datatype and attempt to retrieve length
                                                            var pos = tableColumn.type.indexOf("(");
                                                            if (pos !== -1) {
                                                                var dataType_1 = tableColumn.type.substr(0, pos);
                                                                if (!!_this.driver.withLengthColumnTypes.find(function (col) { return col === dataType_1; })) {
                                                                    var len = parseInt(tableColumn.type.substring(pos + 1, tableColumn.type.length - 1));
                                                                    if (len) {
                                                                        tableColumn.length = len.toString();
                                                                        tableColumn.type = dataType_1; // remove the length part from the datatype
                                                                    }
                                                                }
                                                            }
                                                            var columnForeignKeys = dbForeignKeys
                                                                .filter(function (foreignKey) { return foreignKey["from"] === dbColumn["name"]; })
                                                                .map(function (foreignKey) {
                                                                // const keyName = this.driver.namingStrategy.foreignKeyName(dbTable["name"], [foreignKey["from"]], foreignKey["table"], [foreignKey["to"]]);
                                                                // todo: figure out solution here, name should be same as naming strategy generates!
                                                                var key = dbTable["name"] + "_" + [foreignKey["from"]].join("_") + "_" + foreignKey["table"] + "_" + [foreignKey["to"]].join("_");
                                                                var keyName = "fk_" + RandomGenerator_1.RandomGenerator.sha1(key).substr(0, 27);
                                                                return new TableForeignKey_1.TableForeignKey(keyName, [foreignKey["from"]], [foreignKey["to"]], foreignKey["table"], foreignKey["on_delete"]); // todo: how sqlite return from and to when they are arrays? (multiple column foreign keys)
                                                            });
                                                            table.addForeignKeys(columnForeignKeys);
                                                            return tableColumn;
                                                        });
                                                        // create primary key schema
                                                        return [4 /*yield*/, Promise.all(dbIndices
                                                                .filter(function (index) { return index["origin"] === "pk"; })
                                                                .map(function (index) { return __awaiter(_this, void 0, void 0, function () {
                                                                var indexInfos, indexColumns;
                                                                return __generator(this, function (_a) {
                                                                    switch (_a.label) {
                                                                        case 0: return [4 /*yield*/, this.query("PRAGMA index_info(\"" + index["name"] + "\")")];
                                                                        case 1:
                                                                            indexInfos = _a.sent();
                                                                            indexColumns = indexInfos.map(function (indexInfo) { return indexInfo["name"]; });
                                                                            indexColumns.forEach(function (indexColumn) {
                                                                                table.primaryKeys.push(new TablePrimaryKey_1.TablePrimaryKey(index["name"], indexColumn));
                                                                            });
                                                                            return [2 /*return*/];
                                                                    }
                                                                });
                                                            }); }))];
                                                    case 2:
                                                        // create primary key schema
                                                        _b.sent();
                                                        indicesPromises = dbIndices
                                                            .filter(function (dbIndex) {
                                                            return dbIndex["origin"] !== "pk" &&
                                                                (!table.foreignKeys.find(function (foreignKey) { return foreignKey.name === dbIndex["name"]; })) &&
                                                                (!table.primaryKeys.find(function (primaryKey) { return primaryKey.name === dbIndex["name"]; }));
                                                        })
                                                            .map(function (dbIndex) { return dbIndex["name"]; })
                                                            .filter(function (value, index, self) { return self.indexOf(value) === index; }) // unqiue
                                                            .map(function (dbIndexName) { return __awaiter(_this, void 0, void 0, function () {
                                                            var dbIndex, indexInfos, indexColumns, isUnique;
                                                            return __generator(this, function (_a) {
                                                                switch (_a.label) {
                                                                    case 0:
                                                                        dbIndex = dbIndices.find(function (dbIndex) { return dbIndex["name"] === dbIndexName; });
                                                                        return [4 /*yield*/, this.query("PRAGMA index_info(\"" + dbIndex["name"] + "\")")];
                                                                    case 1:
                                                                        indexInfos = _a.sent();
                                                                        indexColumns = indexInfos
                                                                            .sort(function (indexInfo1, indexInfo2) { return parseInt(indexInfo1["seqno"]) - parseInt(indexInfo2["seqno"]); })
                                                                            .map(function (indexInfo) { return indexInfo["name"]; });
                                                                        // check if db index is generated by sqlite itself and has special use case
                                                                        if (dbIndex["name"].substr(0, "sqlite_autoindex".length) === "sqlite_autoindex") {
                                                                            if (dbIndex["unique"] === 1) { // this means we have a special index generated for a column
                                                                                // so we find and update the column
                                                                                indexColumns.forEach(function (columnName) {
                                                                                    var column = table.columns.find(function (column) { return column.name === columnName; });
                                                                                    if (column)
                                                                                        column.isUnique = true;
                                                                                });
                                                                            }
                                                                            return [2 /*return*/, Promise.resolve(undefined)];
                                                                        }
                                                                        else {
                                                                            isUnique = dbIndex["unique"] === "1" || dbIndex["unique"] === 1;
                                                                            return [2 /*return*/, new TableIndex_1.TableIndex(dbTable["name"], dbIndex["name"], indexColumns, isUnique)];
                                                                        }
                                                                        return [2 /*return*/];
                                                                }
                                                            });
                                                        }); });
                                                        return [4 /*yield*/, Promise.all(indicesPromises)];
                                                    case 3:
                                                        indices = _b.sent();
                                                        table.indices = indices.filter(function (index) { return !!index; });
                                                        return [2 /*return*/, table];
                                                }
                                            });
                                        }); }))];
                            }
                        });
                    });
                };
                /**
                 * Checks if database with the given name exist.
                 */
                AbstractSqliteQueryRunner.prototype.hasDatabase = function (database) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            return [2 /*return*/, Promise.resolve(false)];
                        });
                    });
                };
                /**
                 * Checks if table with the given name exist in the database.
                 */
                AbstractSqliteQueryRunner.prototype.hasTable = function (tableName) {
                    return __awaiter(this, void 0, void 0, function () {
                        var sql, result;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    sql = "SELECT * FROM sqlite_master WHERE type = 'table' AND name = '" + tableName + "'";
                                    return [4 /*yield*/, this.query(sql)];
                                case 1:
                                    result = _a.sent();
                                    return [2 /*return*/, result.length ? true : false];
                            }
                        });
                    });
                };
                /**
                 * Creates a database if it's not created.
                 */
                AbstractSqliteQueryRunner.prototype.createDatabase = function (database) {
                    return Promise.resolve([]);
                };
                /**
                 * Creates a schema if it's not created.
                 */
                AbstractSqliteQueryRunner.prototype.createSchema = function (schemas) {
                    return Promise.resolve([]);
                };
                /**
                 * Creates a new table from the given table metadata and column metadatas.
                 */
                AbstractSqliteQueryRunner.prototype.createTable = function (table) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var columnDefinitions, sql, primaryKeyColumns;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    columnDefinitions = table.columns.map(function (column) { return _this.buildCreateColumnSql(column); }).join(", ");
                                    sql = "CREATE TABLE \"" + table.name + "\" (" + columnDefinitions;
                                    primaryKeyColumns = table.columns.filter(function (column) { return column.isPrimary && !column.isGenerated; });
                                    if (primaryKeyColumns.length > 0)
                                        sql += ", PRIMARY KEY(" + primaryKeyColumns.map(function (column) { return "" + column.name; }).join(", ") + ")"; // for some reason column escaping here generates a wrong schema
                                    sql += ")";
                                    return [4 /*yield*/, this.query(sql)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Drops the table.
                 */
                AbstractSqliteQueryRunner.prototype.dropTable = function (tableName) {
                    return __awaiter(this, void 0, void 0, function () {
                        var sql;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    sql = "DROP TABLE \"" + tableName + "\"";
                                    return [4 /*yield*/, this.query(sql)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Checks if column with the given name exist in the given table.
                 */
                AbstractSqliteQueryRunner.prototype.hasColumn = function (tableName, columnName) {
                    return __awaiter(this, void 0, void 0, function () {
                        var sql, columns;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    sql = "PRAGMA table_info(\"" + tableName + "\")";
                                    return [4 /*yield*/, this.query(sql)];
                                case 1:
                                    columns = _a.sent();
                                    return [2 /*return*/, !!columns.find(function (column) { return column["name"] === columnName; })];
                            }
                        });
                    });
                };
                /**
                 * Creates a new column from the column in the table.
                 */
                AbstractSqliteQueryRunner.prototype.addColumn = function (tableOrName, column) {
                    return __awaiter(this, void 0, void 0, function () {
                        var table, newTableSchema;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.getTableSchema(tableOrName)];
                                case 1:
                                    table = _a.sent();
                                    newTableSchema = table.clone();
                                    newTableSchema.addColumns([column]);
                                    return [4 /*yield*/, this.recreateTable(newTableSchema, table)];
                                case 2:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Creates a new columns from the column in the table.
                 */
                AbstractSqliteQueryRunner.prototype.addColumns = function (tableOrName, columns) {
                    return __awaiter(this, void 0, void 0, function () {
                        var table, newTableSchema;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.getTableSchema(tableOrName)];
                                case 1:
                                    table = _a.sent();
                                    newTableSchema = table.clone();
                                    newTableSchema.addColumns(columns);
                                    return [4 /*yield*/, this.recreateTable(newTableSchema, table)];
                                case 2:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Renames column in the given table.
                 */
                AbstractSqliteQueryRunner.prototype.renameColumn = function (tableOrName, oldTableColumnOrName, newTableColumnOrName) {
                    return __awaiter(this, void 0, void 0, function () {
                        var table, oldColumn, newColumn;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    table = undefined;
                                    if (!(tableOrName instanceof Table_1.Table)) return [3 /*break*/, 1];
                                    table = tableOrName;
                                    return [3 /*break*/, 3];
                                case 1: return [4 /*yield*/, this.getTable(tableOrName)];
                                case 2:
                                    table = _a.sent();
                                    _a.label = 3;
                                case 3:
                                    if (!table)
                                        throw new Error("Table " + tableOrName + " was not found.");
                                    oldColumn = undefined;
                                    if (oldTableColumnOrName instanceof TableColumn_1.TableColumn) {
                                        oldColumn = oldTableColumnOrName;
                                    }
                                    else {
                                        oldColumn = table.columns.find(function (column) { return column.name === oldTableColumnOrName; });
                                    }
                                    if (!oldColumn)
                                        throw new Error("Column \"" + oldTableColumnOrName + "\" was not found in the \"" + tableOrName + "\" table.");
                                    newColumn = undefined;
                                    if (newTableColumnOrName instanceof TableColumn_1.TableColumn) {
                                        newColumn = newTableColumnOrName;
                                    }
                                    else {
                                        newColumn = oldColumn.clone();
                                        newColumn.name = newTableColumnOrName;
                                    }
                                    return [2 /*return*/, this.changeColumn(table, oldColumn, newColumn)];
                            }
                        });
                    });
                };
                /**
                 * Changes a column in the table.
                 */
                AbstractSqliteQueryRunner.prototype.changeColumn = function (tableOrName, oldTableColumnOrName, newColumn) {
                    return __awaiter(this, void 0, void 0, function () {
                        var table, oldColumn;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    table = undefined;
                                    if (!(tableOrName instanceof Table_1.Table)) return [3 /*break*/, 1];
                                    table = tableOrName;
                                    return [3 /*break*/, 3];
                                case 1: return [4 /*yield*/, this.getTable(tableOrName)];
                                case 2:
                                    table = _a.sent();
                                    _a.label = 3;
                                case 3:
                                    if (!table)
                                        throw new Error("Table " + tableOrName + " was not found.");
                                    oldColumn = undefined;
                                    if (oldTableColumnOrName instanceof TableColumn_1.TableColumn) {
                                        oldColumn = oldTableColumnOrName;
                                    }
                                    else {
                                        oldColumn = table.columns.find(function (column) { return column.name === oldTableColumnOrName; });
                                    }
                                    if (!oldColumn)
                                        throw new Error("Column \"" + oldTableColumnOrName + "\" was not found in the \"" + tableOrName + "\" table.");
                                    // todo: fix it. it should not depend on table
                                    return [2 /*return*/, this.recreateTable(table)];
                            }
                        });
                    });
                };
                /**
                 * Changes a column in the table.
                 * Changed column looses all its keys in the db.
                 */
                AbstractSqliteQueryRunner.prototype.changeColumns = function (table, changedColumns) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            // todo: fix it. it should not depend on table
                            return [2 /*return*/, this.recreateTable(table)];
                        });
                    });
                };
                /**
                 * Drops column in the table.
                 */
                AbstractSqliteQueryRunner.prototype.dropColumn = function (table, column) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            return [2 /*return*/, this.dropColumns(table, [column])];
                        });
                    });
                };
                /**
                 * Drops the columns in the table.
                 */
                AbstractSqliteQueryRunner.prototype.dropColumns = function (table, columns) {
                    return __awaiter(this, void 0, void 0, function () {
                        var updatingTableSchema;
                        return __generator(this, function (_a) {
                            updatingTableSchema = table.clone();
                            updatingTableSchema.removeColumns(columns);
                            return [2 /*return*/, this.recreateTable(updatingTableSchema)];
                        });
                    });
                };
                /**
                 * Updates table's primary keys.
                 */
                AbstractSqliteQueryRunner.prototype.updatePrimaryKeys = function (dbTable) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            return [2 /*return*/, this.recreateTable(dbTable)];
                        });
                    });
                };
                /**
                 * Creates a new foreign key.
                 */
                AbstractSqliteQueryRunner.prototype.createForeignKey = function (tableOrName, foreignKey) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            return [2 /*return*/, this.createForeignKeys(tableOrName, [foreignKey])];
                        });
                    });
                };
                /**
                 * Creates a new foreign keys.
                 */
                AbstractSqliteQueryRunner.prototype.createForeignKeys = function (tableOrName, foreignKeys) {
                    return __awaiter(this, void 0, void 0, function () {
                        var table, changedTableSchema;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.getTableSchema(tableOrName)];
                                case 1:
                                    table = _a.sent();
                                    changedTableSchema = table.clone();
                                    changedTableSchema.addForeignKeys(foreignKeys);
                                    return [2 /*return*/, this.recreateTable(changedTableSchema)];
                            }
                        });
                    });
                };
                /**
                 * Drops a foreign key from the table.
                 */
                AbstractSqliteQueryRunner.prototype.dropForeignKey = function (tableOrName, foreignKey) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            return [2 /*return*/, this.dropForeignKeys(tableOrName, [foreignKey])];
                        });
                    });
                };
                /**
                 * Drops a foreign keys from the table.
                 */
                AbstractSqliteQueryRunner.prototype.dropForeignKeys = function (tableOrName, foreignKeys) {
                    return __awaiter(this, void 0, void 0, function () {
                        var table, changedTableSchema;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.getTableSchema(tableOrName)];
                                case 1:
                                    table = _a.sent();
                                    changedTableSchema = table.clone();
                                    changedTableSchema.removeForeignKeys(foreignKeys);
                                    return [2 /*return*/, this.recreateTable(changedTableSchema)];
                            }
                        });
                    });
                };
                /**
                 * Creates a new index.
                 */
                AbstractSqliteQueryRunner.prototype.createIndex = function (table, index) {
                    return __awaiter(this, void 0, void 0, function () {
                        var columnNames, sql;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    columnNames = index.columnNames.map(function (columnName) { return "\"" + columnName + "\""; }).join(",");
                                    sql = "CREATE " + (index.isUnique ? "UNIQUE " : "") + "INDEX \"" + index.name + "\" ON \"" + (table instanceof Table_1.Table ? table.name : table) + "\"(" + columnNames + ")";
                                    return [4 /*yield*/, this.query(sql)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Drops an index from the table.
                 */
                AbstractSqliteQueryRunner.prototype.dropIndex = function (tableSchemeOrName, indexName) {
                    return __awaiter(this, void 0, void 0, function () {
                        var sql;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    sql = "DROP INDEX \"" + indexName + "\"";
                                    return [4 /*yield*/, this.query(sql)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Truncates table.
                 */
                AbstractSqliteQueryRunner.prototype.truncate = function (tableName) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.query("DELETE FROM \"" + tableName + "\"")];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Removes all tables from the currently connected database.
                 */
                AbstractSqliteQueryRunner.prototype.clearDatabase = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var selectDropsQuery, dropQueries, error_3, rollbackError_4;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.query("PRAGMA foreign_keys = OFF;")];
                                case 1:
                                    _a.sent();
                                    return [4 /*yield*/, this.startTransaction()];
                                case 2:
                                    _a.sent();
                                    _a.label = 3;
                                case 3:
                                    _a.trys.push([3, 7, 12, 14]);
                                    selectDropsQuery = "select 'drop table \"' || name || '\";' as query from sqlite_master where type = 'table' and name != 'sqlite_sequence'";
                                    return [4 /*yield*/, this.query(selectDropsQuery)];
                                case 4:
                                    dropQueries = _a.sent();
                                    return [4 /*yield*/, Promise.all(dropQueries.map(function (q) { return _this.query(q["query"]); }))];
                                case 5:
                                    _a.sent();
                                    return [4 /*yield*/, this.commitTransaction()];
                                case 6:
                                    _a.sent();
                                    return [3 /*break*/, 14];
                                case 7:
                                    error_3 = _a.sent();
                                    _a.label = 8;
                                case 8:
                                    _a.trys.push([8, 10, , 11]);
                                    return [4 /*yield*/, this.rollbackTransaction()];
                                case 9:
                                    _a.sent();
                                    return [3 /*break*/, 11];
                                case 10:
                                    rollbackError_4 = _a.sent();
                                    return [3 /*break*/, 11];
                                case 11: throw error_3;
                                case 12: return [4 /*yield*/, this.query("PRAGMA foreign_keys = ON;")];
                                case 13:
                                    _a.sent();
                                    return [7 /*endfinally*/];
                                case 14: return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Enables special query runner mode in which sql queries won't be executed,
                 * instead they will be memorized into a special variable inside query runner.
                 * You can get memorized sql using getMemorySql() method.
                 */
                AbstractSqliteQueryRunner.prototype.enableSqlMemory = function () {
                    this.sqlMemoryMode = true;
                };
                /**
                 * Disables special query runner mode in which sql queries won't be executed
                 * started by calling enableSqlMemory() method.
                 *
                 * Previously memorized sql will be flushed.
                 */
                AbstractSqliteQueryRunner.prototype.disableSqlMemory = function () {
                    this.sqlsInMemory = [];
                    this.sqlMemoryMode = false;
                };
                /**
                 * Gets sql stored in the memory. Parameters in the sql are already replaced.
                 */
                AbstractSqliteQueryRunner.prototype.getMemorySql = function () {
                    return this.sqlsInMemory;
                };
                // -------------------------------------------------------------------------
                // Protected Methods
                // -------------------------------------------------------------------------
                /**
                 * Parametrizes given object of values. Used to create column=value queries.
                 */
                AbstractSqliteQueryRunner.prototype.parametrize = function (objectLiteral, startIndex) {
                    if (startIndex === void 0) { startIndex = 0; }
                    return Object.keys(objectLiteral).map(function (key, index) { return "\"" + key + "\"" + "=$" + (startIndex + index + 1); });
                };
                /**
                 * Builds a query for create column.
                 */
                AbstractSqliteQueryRunner.prototype.buildCreateColumnSql = function (column) {
                    var c = "\"" + column.name + "\"";
                    if (column instanceof ColumnMetadata_1.ColumnMetadata) {
                        c += " " + this.driver.normalizeType(column);
                    }
                    else {
                        c += " " + this.connection.driver.createFullType(column);
                    }
                    if (column.collation)
                        c += " COLLATE " + column.collation;
                    if (column.isNullable !== true)
                        c += " NOT NULL";
                    if (column.isUnique === true)
                        c += " UNIQUE";
                    if (column.isGenerated === true && column.generationStrategy === "increment") { // don't use skipPrimary here since updates can update already exist primary without auto inc.
                        c += " PRIMARY KEY AUTOINCREMENT";
                    }
                    else if (column.isPrimary === true && column.isGenerated === true) {
                        c += " PRIMARY KEY";
                    }
                    if (column.default !== undefined && column.default !== null) { // todo: same code in all drivers. make it DRY
                        c += " DEFAULT (" + column.default + ")";
                    }
                    return c;
                };
                AbstractSqliteQueryRunner.prototype.recreateTable = function (table, oldTableSchema, migrateData) {
                    if (migrateData === void 0) { migrateData = true; }
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var columnDefinitions, columnNames, sql1, primaryKeyColumns, oldColumnNames, sql2, sql3, sql4, indexPromises;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    columnDefinitions = table.columns.map(function (dbColumn) { return _this.buildCreateColumnSql(dbColumn); }).join(", ");
                                    columnNames = table.columns.map(function (column) { return "\"" + column.name + "\""; }).join(", ");
                                    sql1 = "CREATE TABLE \"temporary_" + table.name + "\" (" + columnDefinitions;
                                    // if (options && options.createForeignKeys) {
                                    table.foreignKeys.forEach(function (foreignKey) {
                                        var columnNames = foreignKey.columnNames.map(function (name) { return "\"" + name + "\""; }).join(", ");
                                        var referencedColumnNames = foreignKey.referencedColumnNames.map(function (name) { return "\"" + name + "\""; }).join(", ");
                                        sql1 += ", FOREIGN KEY(" + columnNames + ") REFERENCES \"" + foreignKey.referencedTableName + "\"(" + referencedColumnNames + ")";
                                        if (foreignKey.onDelete)
                                            sql1 += " ON DELETE " + foreignKey.onDelete;
                                    });
                                    primaryKeyColumns = table.columns.filter(function (column) { return column.isPrimary && !column.isGenerated; });
                                    if (primaryKeyColumns.length > 0)
                                        sql1 += ", PRIMARY KEY(" + primaryKeyColumns.map(function (column) { return "" + column.name; }).join(", ") + ")"; // for some reason column escaping here generate a wrong schema
                                    sql1 += ")";
                                    // todo: need also create uniques and indices?
                                    // recreate a table with a temporary name
                                    return [4 /*yield*/, this.query(sql1)];
                                case 1:
                                    // todo: need also create uniques and indices?
                                    // recreate a table with a temporary name
                                    _a.sent();
                                    oldColumnNames = oldTableSchema ? oldTableSchema.columns.map(function (column) { return "\"" + column.name + "\""; }).join(", ") : columnNames;
                                    if (!migrateData) return [3 /*break*/, 3];
                                    sql2 = "INSERT INTO \"temporary_" + table.name + "\"(" + oldColumnNames + ") SELECT " + oldColumnNames + " FROM \"" + table.name + "\"";
                                    return [4 /*yield*/, this.query(sql2)];
                                case 2:
                                    _a.sent();
                                    _a.label = 3;
                                case 3:
                                    sql3 = "DROP TABLE \"" + table.name + "\"";
                                    return [4 /*yield*/, this.query(sql3)];
                                case 4:
                                    _a.sent();
                                    sql4 = "ALTER TABLE \"temporary_" + table.name + "\" RENAME TO \"" + table.name + "\"";
                                    return [4 /*yield*/, this.query(sql4)];
                                case 5:
                                    _a.sent();
                                    indexPromises = table.indices.map(function (index) { return _this.createIndex(table.name, index); });
                                    // const uniquePromises = table.uniqueKeys.map(key => this.createIndex(key));
                                    return [4 /*yield*/, Promise.all(indexPromises /*.concat(uniquePromises)*/)];
                                case 6:
                                    // const uniquePromises = table.uniqueKeys.map(key => this.createIndex(key));
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * If given value is a table name then it loads its table schema representation from the database.
                 */
                AbstractSqliteQueryRunner.prototype.getTableSchema = function (tableOrName) {
                    return __awaiter(this, void 0, void 0, function () {
                        var table;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (!(tableOrName instanceof Table_1.Table)) return [3 /*break*/, 1];
                                    return [2 /*return*/, tableOrName];
                                case 1: return [4 /*yield*/, this.getTable(tableOrName)];
                                case 2:
                                    table = _a.sent();
                                    if (!table)
                                        throw new Error("Table named " + tableOrName + " was not found in the database.");
                                    return [2 /*return*/, table];
                            }
                        });
                    });
                };
                return AbstractSqliteQueryRunner;
            }());
            exports_100("AbstractSqliteQueryRunner", AbstractSqliteQueryRunner);
        }
    };
});
System.register("typeorm/schema-builder/RdbmsSchemaBuilder", ["typeorm/schema-builder/schema/Table", "typeorm/schema-builder/schema/TableColumn", "typeorm/schema-builder/schema/TableForeignKey", "typeorm/schema-builder/schema/TableIndex", "typeorm/schema-builder/schema/TablePrimaryKey", "typeorm/util/PromiseUtils"], function (exports_101, context_101) {
    "use strict";
    var __moduleName = context_101 && context_101.id;
    var Table_2, TableColumn_2, TableForeignKey_2, TableIndex_2, TablePrimaryKey_2, PromiseUtils_2, RdbmsSchemaBuilder;
    return {
        setters: [
            function (Table_2_1) {
                Table_2 = Table_2_1;
            },
            function (TableColumn_2_1) {
                TableColumn_2 = TableColumn_2_1;
            },
            function (TableForeignKey_2_1) {
                TableForeignKey_2 = TableForeignKey_2_1;
            },
            function (TableIndex_2_1) {
                TableIndex_2 = TableIndex_2_1;
            },
            function (TablePrimaryKey_2_1) {
                TablePrimaryKey_2 = TablePrimaryKey_2_1;
            },
            function (PromiseUtils_2_1) {
                PromiseUtils_2 = PromiseUtils_2_1;
            }
        ],
        execute: function () {
            /**
             * Creates complete tables schemas in the database based on the entity metadatas.
             *
             * Steps how schema is being built:
             * 1. load list of all tables with complete column and keys information from the db
             * 2. drop all (old) foreign keys that exist in the table, but does not exist in the metadata
             * 3. create new tables that does not exist in the db, but exist in the metadata
             * 4. drop all columns exist (left old) in the db table, but does not exist in the metadata
             * 5. add columns from metadata which does not exist in the table
             * 6. update all exist columns which metadata has changed
             * 7. update primary keys - update old and create new primary key from changed columns
             * 8. create foreign keys which does not exist in the table yet
             * 9. create indices which are missing in db yet, and drops indices which exist in the db, but does not exist in the metadata anymore
             */
            RdbmsSchemaBuilder = /** @class */ (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function RdbmsSchemaBuilder(connection) {
                    this.connection = connection;
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Creates complete schemas for the given entity metadatas.
                 */
                RdbmsSchemaBuilder.prototype.build = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var _a, _b, error_4, rollbackError_5;
                        return __generator(this, function (_c) {
                            switch (_c.label) {
                                case 0:
                                    _a = this;
                                    return [4 /*yield*/, this.connection.createQueryRunner("master")];
                                case 1:
                                    _a.queryRunner = _c.sent();
                                    return [4 /*yield*/, this.createNewDatabases()];
                                case 2:
                                    _c.sent();
                                    return [4 /*yield*/, this.queryRunner.startTransaction()];
                                case 3:
                                    _c.sent();
                                    _c.label = 4;
                                case 4:
                                    _c.trys.push([4, 10, 15, 17]);
                                    _b = this;
                                    return [4 /*yield*/, this.loadTableSchemas()];
                                case 5:
                                    _b.tables = _c.sent();
                                    return [4 /*yield*/, this.executeSchemaSyncOperationsInProperOrder()];
                                case 6:
                                    _c.sent();
                                    if (!this.connection.queryResultCache) return [3 /*break*/, 8];
                                    return [4 /*yield*/, this.connection.queryResultCache.synchronize(this.queryRunner)];
                                case 7:
                                    _c.sent();
                                    _c.label = 8;
                                case 8: return [4 /*yield*/, this.queryRunner.commitTransaction()];
                                case 9:
                                    _c.sent();
                                    return [3 /*break*/, 17];
                                case 10:
                                    error_4 = _c.sent();
                                    _c.label = 11;
                                case 11:
                                    _c.trys.push([11, 13, , 14]);
                                    return [4 /*yield*/, this.queryRunner.rollbackTransaction()];
                                case 12:
                                    _c.sent();
                                    return [3 /*break*/, 14];
                                case 13:
                                    rollbackError_5 = _c.sent();
                                    return [3 /*break*/, 14];
                                case 14: throw error_4;
                                case 15: return [4 /*yield*/, this.queryRunner.release()];
                                case 16:
                                    _c.sent();
                                    return [7 /*endfinally*/];
                                case 17: return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Returns sql queries to be executed by schema builder.
                 */
                RdbmsSchemaBuilder.prototype.log = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var _a, _b;
                        return __generator(this, function (_c) {
                            switch (_c.label) {
                                case 0:
                                    _a = this;
                                    return [4 /*yield*/, this.connection.createQueryRunner("master")];
                                case 1:
                                    _a.queryRunner = _c.sent();
                                    _c.label = 2;
                                case 2:
                                    _c.trys.push([2, , 8, 10]);
                                    return [4 /*yield*/, this.createNewDatabases()];
                                case 3:
                                    _c.sent();
                                    _b = this;
                                    return [4 /*yield*/, this.loadTableSchemas()];
                                case 4:
                                    _b.tables = _c.sent();
                                    this.queryRunner.enableSqlMemory();
                                    return [4 /*yield*/, this.executeSchemaSyncOperationsInProperOrder()];
                                case 5:
                                    _c.sent();
                                    if (!this.connection.queryResultCache) return [3 /*break*/, 7];
                                    return [4 /*yield*/, this.connection.queryResultCache.synchronize(this.queryRunner)];
                                case 6:
                                    _c.sent();
                                    _c.label = 7;
                                case 7: return [2 /*return*/, this.queryRunner.getMemorySql()];
                                case 8:
                                    // its important to disable this mode despite the fact we are release query builder
                                    // because there exist drivers which reuse same query runner. Also its important to disable
                                    // sql memory after call of getMemorySql() method because last one flushes sql memory.
                                    this.queryRunner.disableSqlMemory();
                                    return [4 /*yield*/, this.queryRunner.release()];
                                case 9:
                                    _c.sent();
                                    return [7 /*endfinally*/];
                                case 10: return [2 /*return*/];
                            }
                        });
                    });
                };
                // -------------------------------------------------------------------------
                // Protected Methods
                // -------------------------------------------------------------------------
                /**
                 * Loads all tables from the database.
                 */
                RdbmsSchemaBuilder.prototype.loadTableSchemas = function () {
                    var tablePaths = this.entityToSyncMetadatas.map(function (metadata) { return metadata.tablePath; });
                    return this.queryRunner.getTables(tablePaths);
                };
                Object.defineProperty(RdbmsSchemaBuilder.prototype, "entityToSyncMetadatas", {
                    /**
                     * Returns only entities that should be synced in the database.
                     */
                    get: function () {
                        return this.connection.entityMetadatas.filter(function (metadata) { return !metadata.skipSync && metadata.tableType !== "single-table-child"; });
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Creates new databases if they are not exists.
                 */
                RdbmsSchemaBuilder.prototype.createNewDatabases = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var databases;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    databases = [];
                                    this.connection.entityMetadatas.forEach(function (metadata) {
                                        if (metadata.database && databases.indexOf(metadata.database) === -1)
                                            databases.push(metadata.database);
                                    });
                                    return [4 /*yield*/, Promise.all(databases.map(function (database) { return _this.queryRunner.createDatabase(database); }))];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Executes schema sync operations in a proper order.
                 * Order of operations matter here.
                 */
                RdbmsSchemaBuilder.prototype.executeSchemaSyncOperationsInProperOrder = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var schemaPaths;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    schemaPaths = [];
                                    this.connection.entityMetadatas
                                        .filter(function (entityMetadata) { return !!entityMetadata.schemaPath; })
                                        .forEach(function (entityMetadata) {
                                        var existSchemaPath = schemaPaths.find(function (path) { return path === entityMetadata.schemaPath; });
                                        if (!existSchemaPath)
                                            schemaPaths.push(entityMetadata.schemaPath);
                                    });
                                    return [4 /*yield*/, this.queryRunner.createSchema(schemaPaths)];
                                case 1:
                                    _a.sent();
                                    return [4 /*yield*/, this.dropOldForeignKeys()];
                                case 2:
                                    _a.sent();
                                    // await this.dropOldPrimaryKeys(); // todo: need to drop primary column because column updates are not possible
                                    return [4 /*yield*/, this.createNewTables()];
                                case 3:
                                    // await this.dropOldPrimaryKeys(); // todo: need to drop primary column because column updates are not possible
                                    _a.sent();
                                    return [4 /*yield*/, this.dropRemovedColumns()];
                                case 4:
                                    _a.sent();
                                    return [4 /*yield*/, this.addNewColumns()];
                                case 5:
                                    _a.sent();
                                    return [4 /*yield*/, this.updateExistColumns()];
                                case 6:
                                    _a.sent();
                                    return [4 /*yield*/, this.updatePrimaryKeys()];
                                case 7:
                                    _a.sent();
                                    return [4 /*yield*/, this.createIndices()];
                                case 8:
                                    _a.sent(); // we need to create indices before foreign keys because foreign keys rely on unique indices
                                    return [4 /*yield*/, this.createForeignKeys()];
                                case 9:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Drops all (old) foreign keys that exist in the tables, but do not exist in the entity metadata.
                 */
                RdbmsSchemaBuilder.prototype.dropOldForeignKeys = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, PromiseUtils_2.PromiseUtils.runInSequence(this.entityToSyncMetadatas, function (metadata) { return __awaiter(_this, void 0, void 0, function () {
                                        var table, tableForeignKeysToDrop;
                                        return __generator(this, function (_a) {
                                            switch (_a.label) {
                                                case 0:
                                                    table = this.tables.find(function (table) { return table.name === metadata.tableName; });
                                                    if (!table)
                                                        return [2 /*return*/];
                                                    tableForeignKeysToDrop = table.foreignKeys.filter(function (tableForeignKey) {
                                                        return !metadata.foreignKeys.find(function (metadataForeignKey) { return metadataForeignKey.name === tableForeignKey.name; });
                                                    });
                                                    if (tableForeignKeysToDrop.length === 0)
                                                        return [2 /*return*/];
                                                    this.connection.logger.logSchemaBuild("dropping old foreign keys of " + table.name + ": " + tableForeignKeysToDrop.map(function (dbForeignKey) { return dbForeignKey.name; }).join(", "));
                                                    // remove foreign keys from the table
                                                    table.removeForeignKeys(tableForeignKeysToDrop);
                                                    // drop foreign keys from the database
                                                    return [4 /*yield*/, this.queryRunner.dropForeignKeys(table, tableForeignKeysToDrop)];
                                                case 1:
                                                    // drop foreign keys from the database
                                                    _a.sent();
                                                    return [2 /*return*/];
                                            }
                                        });
                                    }); })];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Creates tables that do not exist in the database yet.
                 * New tables are created without foreign and primary keys.
                 * Primary key only can be created in conclusion with auto generated column.
                 */
                RdbmsSchemaBuilder.prototype.createNewTables = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, PromiseUtils_2.PromiseUtils.runInSequence(this.entityToSyncMetadatas, function (metadata) { return __awaiter(_this, void 0, void 0, function () {
                                        var existTableSchema, table;
                                        return __generator(this, function (_a) {
                                            switch (_a.label) {
                                                case 0:
                                                    existTableSchema = this.tables.find(function (table) {
                                                        if (table.name !== metadata.tableName)
                                                            return false;
                                                        if (metadata.schema && table.schema !== metadata.schema)
                                                            return false;
                                                        if (metadata.database && table.database !== metadata.database)
                                                            return false;
                                                        return true;
                                                    });
                                                    if (existTableSchema)
                                                        return [2 /*return*/];
                                                    this.connection.logger.logSchemaBuild("creating a new table: " + metadata.tableName);
                                                    table = new Table_2.Table(metadata.tableName, this.metadataColumnsToTableColumns(metadata.columns), true, metadata.engine, metadata.database, metadata.schema);
                                                    this.tables.push(table);
                                                    return [4 /*yield*/, this.queryRunner.createTable(table)];
                                                case 1:
                                                    _a.sent();
                                                    return [2 /*return*/];
                                            }
                                        });
                                    }); })];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Drops all columns that exist in the table, but does not exist in the metadata (left old).
                 * We drop their keys too, since it should be safe.
                 */
                RdbmsSchemaBuilder.prototype.dropRemovedColumns = function () {
                    var _this = this;
                    return PromiseUtils_2.PromiseUtils.runInSequence(this.entityToSyncMetadatas, function (metadata) { return __awaiter(_this, void 0, void 0, function () {
                        var _this = this;
                        var table, droppedTableColumns;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    table = this.tables.find(function (table) { return table.name === metadata.tableName; });
                                    if (!table)
                                        return [2 /*return*/];
                                    droppedTableColumns = table.columns.filter(function (tableColumn) {
                                        return !metadata.columns.find(function (columnMetadata) { return columnMetadata.databaseName === tableColumn.name; });
                                    });
                                    if (droppedTableColumns.length === 0)
                                        return [2 /*return*/];
                                    // drop all foreign keys that has column to be removed in its columns
                                    return [4 /*yield*/, Promise.all(droppedTableColumns.map(function (droppedTableColumn) {
                                            return _this.dropColumnReferencedForeignKeys(metadata.tableName, droppedTableColumn.name);
                                        }))];
                                case 1:
                                    // drop all foreign keys that has column to be removed in its columns
                                    _a.sent();
                                    // drop all indices that point to this column
                                    return [4 /*yield*/, Promise.all(droppedTableColumns.map(function (droppedTableColumn) {
                                            return _this.dropColumnReferencedIndices(metadata.tableName, droppedTableColumn.name);
                                        }))];
                                case 2:
                                    // drop all indices that point to this column
                                    _a.sent();
                                    this.connection.logger.logSchemaBuild("columns dropped in " + table.name + ": " + droppedTableColumns.map(function (column) { return column.name; }).join(", "));
                                    // remove columns from the table and primary keys of it if its used in the primary keys
                                    table.removeColumns(droppedTableColumns);
                                    table.removePrimaryKeysOfColumns(droppedTableColumns);
                                    // drop columns from the database
                                    return [4 /*yield*/, this.queryRunner.dropColumns(table, droppedTableColumns)];
                                case 3:
                                    // drop columns from the database
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    }); });
                };
                /**
                 * Adds columns from metadata which does not exist in the table.
                 * Columns are created without keys.
                 */
                RdbmsSchemaBuilder.prototype.addNewColumns = function () {
                    var _this = this;
                    return PromiseUtils_2.PromiseUtils.runInSequence(this.entityToSyncMetadatas, function (metadata) { return __awaiter(_this, void 0, void 0, function () {
                        var table, newColumnMetadatas, newTableColumns;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    table = this.tables.find(function (table) { return table.name === metadata.tableName; });
                                    if (!table)
                                        return [2 /*return*/];
                                    newColumnMetadatas = metadata.columns.filter(function (columnMetadata) {
                                        return !table.columns.find(function (tableColumn) { return tableColumn.name === columnMetadata.databaseName; });
                                    });
                                    if (newColumnMetadatas.length === 0)
                                        return [2 /*return*/];
                                    this.connection.logger.logSchemaBuild("new columns added: " + newColumnMetadatas.map(function (column) { return column.databaseName; }).join(", "));
                                    newTableColumns = this.metadataColumnsToTableColumns(newColumnMetadatas);
                                    return [4 /*yield*/, this.queryRunner.addColumns(table, newTableColumns)];
                                case 1:
                                    _a.sent();
                                    table.addColumns(newTableColumns);
                                    return [2 /*return*/];
                            }
                        });
                    }); });
                };
                /**
                 * Update all exist columns which metadata has changed.
                 * Still don't create keys. Also we don't touch foreign keys of the changed columns.
                 */
                RdbmsSchemaBuilder.prototype.updateExistColumns = function () {
                    var _this = this;
                    return PromiseUtils_2.PromiseUtils.runInSequence(this.entityToSyncMetadatas, function (metadata) { return __awaiter(_this, void 0, void 0, function () {
                        var _this = this;
                        var table, updatedTableColumns, dropRelatedForeignKeysPromises, dropRelatedIndicesPromises, newAndOldTableColumns;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    table = this.tables.find(function (table) { return table.name === metadata.tableName; });
                                    if (!table)
                                        return [2 /*return*/];
                                    updatedTableColumns = table.findChangedColumns(this.connection.driver, metadata.columns);
                                    if (updatedTableColumns.length === 0)
                                        return [2 /*return*/];
                                    this.connection.logger.logSchemaBuild("columns changed in " + table.name + ". updating: " + updatedTableColumns.map(function (column) { return column.name; }).join(", "));
                                    dropRelatedForeignKeysPromises = updatedTableColumns
                                        .filter(function (changedTableColumn) { return !!metadata.columns.find(function (columnMetadata) { return columnMetadata.databaseName === changedTableColumn.name; }); })
                                        .map(function (changedTableColumn) { return _this.dropColumnReferencedForeignKeys(metadata.tableName, changedTableColumn.name); });
                                    // wait until all related foreign keys are dropped
                                    return [4 /*yield*/, Promise.all(dropRelatedForeignKeysPromises)];
                                case 1:
                                    // wait until all related foreign keys are dropped
                                    _a.sent();
                                    dropRelatedIndicesPromises = updatedTableColumns
                                        .filter(function (changedTableColumn) { return !!metadata.columns.find(function (columnMetadata) { return columnMetadata.databaseName === changedTableColumn.name; }); })
                                        .map(function (changedTableColumn) { return _this.dropColumnReferencedIndices(metadata.tableName, changedTableColumn.name); });
                                    // wait until all related indices are dropped
                                    return [4 /*yield*/, Promise.all(dropRelatedIndicesPromises)];
                                case 2:
                                    // wait until all related indices are dropped
                                    _a.sent();
                                    newAndOldTableColumns = updatedTableColumns.map(function (changedTableColumn) {
                                        var columnMetadata = metadata.columns.find(function (column) { return column.databaseName === changedTableColumn.name; });
                                        var newTableColumn = TableColumn_2.TableColumn.create(columnMetadata, _this.connection.driver.normalizeType(columnMetadata), _this.connection.driver.normalizeDefault(columnMetadata), _this.connection.driver.getColumnLength(columnMetadata));
                                        table.replaceColumn(changedTableColumn, newTableColumn);
                                        return {
                                            newColumn: newTableColumn,
                                            oldColumn: changedTableColumn
                                        };
                                    });
                                    return [2 /*return*/, this.queryRunner.changeColumns(table, newAndOldTableColumns)];
                            }
                        });
                    }); });
                };
                /**
                 * Creates primary keys which does not exist in the table yet.
                 */
                RdbmsSchemaBuilder.prototype.updatePrimaryKeys = function () {
                    var _this = this;
                    return PromiseUtils_2.PromiseUtils.runInSequence(this.entityToSyncMetadatas, function (metadata) { return __awaiter(_this, void 0, void 0, function () {
                        var table, metadataPrimaryColumns, addedKeys, droppedKeys;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    table = this.tables.find(function (table) { return table.name === metadata.tableName && !table.justCreated; });
                                    if (!table)
                                        return [2 /*return*/];
                                    metadataPrimaryColumns = metadata.columns.filter(function (column) { return column.isPrimary; });
                                    addedKeys = metadataPrimaryColumns
                                        .filter(function (primaryKey) {
                                        return !table.primaryKeys.find(function (dbPrimaryKey) { return dbPrimaryKey.columnName === primaryKey.databaseName; });
                                    })
                                        .map(function (primaryKey) { return new TablePrimaryKey_2.TablePrimaryKey("", primaryKey.databaseName); });
                                    droppedKeys = table.primaryKeys.filter(function (primaryKeySchema) {
                                        return !metadataPrimaryColumns.find(function (primaryKeyMetadata) { return primaryKeyMetadata.databaseName === primaryKeySchema.columnName; });
                                    });
                                    if (addedKeys.length === 0 && droppedKeys.length === 0)
                                        return [2 /*return*/];
                                    this.connection.logger.logSchemaBuild("primary keys of " + table.name + " has changed: dropped - " + (droppedKeys.map(function (key) { return key.columnName; }).join(", ") || "nothing") + "; added - " + (addedKeys.map(function (key) { return key.columnName; }).join(", ") || "nothing"));
                                    table.addPrimaryKeys(addedKeys);
                                    table.removePrimaryKeys(droppedKeys);
                                    return [4 /*yield*/, this.queryRunner.updatePrimaryKeys(table)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    }); });
                };
                /**
                 * Creates foreign keys which does not exist in the table yet.
                 */
                RdbmsSchemaBuilder.prototype.createForeignKeys = function () {
                    var _this = this;
                    return PromiseUtils_2.PromiseUtils.runInSequence(this.entityToSyncMetadatas, function (metadata) { return __awaiter(_this, void 0, void 0, function () {
                        var table, newKeys, dbForeignKeys;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    table = this.tables.find(function (table) { return table.name === metadata.tableName; });
                                    if (!table)
                                        return [2 /*return*/];
                                    newKeys = metadata.foreignKeys.filter(function (foreignKey) {
                                        return !table.foreignKeys.find(function (dbForeignKey) { return dbForeignKey.name === foreignKey.name; });
                                    });
                                    if (newKeys.length === 0)
                                        return [2 /*return*/];
                                    dbForeignKeys = newKeys.map(function (foreignKeyMetadata) { return TableForeignKey_2.TableForeignKey.create(foreignKeyMetadata); });
                                    this.connection.logger.logSchemaBuild("creating a foreign keys: " + newKeys.map(function (key) { return key.name; }).join(", "));
                                    return [4 /*yield*/, this.queryRunner.createForeignKeys(table, dbForeignKeys)];
                                case 1:
                                    _a.sent();
                                    table.addForeignKeys(dbForeignKeys);
                                    return [2 /*return*/];
                            }
                        });
                    }); });
                };
                /**
                 * Creates indices which are missing in db yet, and drops indices which exist in the db,
                 * but does not exist in the metadata anymore.
                 */
                RdbmsSchemaBuilder.prototype.createIndices = function () {
                    var _this = this;
                    // return Promise.all(this.connection.entityMetadatas.map(metadata => this.createIndices(metadata.table, metadata.indices)));
                    return PromiseUtils_2.PromiseUtils.runInSequence(this.entityToSyncMetadatas, function (metadata) { return __awaiter(_this, void 0, void 0, function () {
                        var _this = this;
                        var table, dropQueries, addQueries;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    table = this.tables.find(function (table) { return table.name === metadata.tableName; });
                                    if (!table)
                                        return [2 /*return*/];
                                    dropQueries = table.indices
                                        .filter(function (tableIndex) {
                                        var metadataIndex = metadata.indices.find(function (indexMetadata) { return indexMetadata.name === tableIndex.name; });
                                        if (!metadataIndex)
                                            return true;
                                        if (metadataIndex.isUnique !== tableIndex.isUnique)
                                            return true;
                                        if (metadataIndex.columns.length !== tableIndex.columnNames.length)
                                            return true;
                                        if (metadataIndex.columns.findIndex(function (col, i) { return col.databaseName !== tableIndex.columnNames[i]; }) !== -1)
                                            return true;
                                        return false;
                                    })
                                        .map(function (tableIndex) { return __awaiter(_this, void 0, void 0, function () {
                                        return __generator(this, function (_a) {
                                            switch (_a.label) {
                                                case 0:
                                                    this.connection.logger.logSchemaBuild("dropping an index: " + tableIndex.name);
                                                    table.removeIndex(tableIndex);
                                                    return [4 /*yield*/, this.queryRunner.dropIndex(metadata.tablePath, tableIndex.name)];
                                                case 1:
                                                    _a.sent();
                                                    return [2 /*return*/];
                                            }
                                        });
                                    }); });
                                    return [4 /*yield*/, Promise.all(dropQueries)];
                                case 1:
                                    _a.sent();
                                    addQueries = metadata.indices
                                        .filter(function (indexMetadata) { return !table.indices.find(function (tableIndex) { return tableIndex.name === indexMetadata.name; }); })
                                        .map(function (indexMetadata) { return __awaiter(_this, void 0, void 0, function () {
                                        var tableIndex;
                                        return __generator(this, function (_a) {
                                            switch (_a.label) {
                                                case 0:
                                                    tableIndex = TableIndex_2.TableIndex.create(indexMetadata);
                                                    table.indices.push(tableIndex);
                                                    this.connection.logger.logSchemaBuild("adding new index: " + tableIndex.name);
                                                    return [4 /*yield*/, this.queryRunner.createIndex(table, tableIndex)];
                                                case 1:
                                                    _a.sent();
                                                    return [2 /*return*/];
                                            }
                                        });
                                    }); });
                                    return [4 /*yield*/, Promise.all(addQueries)];
                                case 2:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    }); });
                };
                /**
                 * Drops all indices where given column of the given table is being used.
                 */
                RdbmsSchemaBuilder.prototype.dropColumnReferencedIndices = function (tableName, columnName) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var table, dependIndicesInTable, dropPromises;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    table = this.tables.find(function (table) { return table.name === tableName; });
                                    if (!table)
                                        return [2 /*return*/];
                                    dependIndicesInTable = table.indices.filter(function (tableIndex) {
                                        return tableIndex.tableName === tableName && !!tableIndex.columnNames.find(function (columnDatabaseName) { return columnDatabaseName === columnName; });
                                    });
                                    if (dependIndicesInTable.length === 0)
                                        return [2 /*return*/];
                                    this.connection.logger.logSchemaBuild("dropping related indices of " + tableName + "#" + columnName + ": " + dependIndicesInTable.map(function (index) { return index.name; }).join(", "));
                                    dropPromises = dependIndicesInTable.map(function (index) {
                                        table.removeIndex(index);
                                        return _this.queryRunner.dropIndex(table, index.name);
                                    });
                                    return [4 /*yield*/, Promise.all(dropPromises)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Drops all foreign keys where given column of the given table is being used.
                 */
                RdbmsSchemaBuilder.prototype.dropColumnReferencedForeignKeys = function (tableName, columnName) {
                    return __awaiter(this, void 0, void 0, function () {
                        var allForeignKeyMetadatas, table, dependForeignKeys, dependForeignKeyInTable, tableForeignKeys;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    allForeignKeyMetadatas = this.connection.entityMetadatas.reduce(function (all, metadata) { return all.concat(metadata.foreignKeys); }, []);
                                    table = this.tables.find(function (table) { return table.name === tableName; });
                                    if (!table)
                                        return [2 /*return*/];
                                    dependForeignKeys = allForeignKeyMetadatas.filter(function (foreignKey) {
                                        if (foreignKey.tableName === tableName) {
                                            return !!foreignKey.columns.find(function (fkColumn) {
                                                return fkColumn.databaseName === columnName;
                                            });
                                        }
                                        else if (foreignKey.referencedTableName === tableName) {
                                            return !!foreignKey.referencedColumns.find(function (fkColumn) {
                                                return fkColumn.databaseName === columnName;
                                            });
                                        }
                                        return false;
                                    });
                                    if (!dependForeignKeys.length)
                                        return [2 /*return*/];
                                    dependForeignKeyInTable = dependForeignKeys.filter(function (fk) {
                                        return !!table.foreignKeys.find(function (dbForeignKey) { return dbForeignKey.name === fk.name; });
                                    });
                                    if (dependForeignKeyInTable.length === 0)
                                        return [2 /*return*/];
                                    this.connection.logger.logSchemaBuild("dropping related foreign keys of " + tableName + "#" + columnName + ": " + dependForeignKeyInTable.map(function (foreignKey) { return foreignKey.name; }).join(", "));
                                    tableForeignKeys = dependForeignKeyInTable.map(function (foreignKeyMetadata) { return TableForeignKey_2.TableForeignKey.create(foreignKeyMetadata); });
                                    table.removeForeignKeys(tableForeignKeys);
                                    return [4 /*yield*/, this.queryRunner.dropForeignKeys(table, tableForeignKeys)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Creates new columns from the given column metadatas.
                 */
                RdbmsSchemaBuilder.prototype.metadataColumnsToTableColumns = function (columns) {
                    var _this = this;
                    return columns.map(function (columnMetadata) {
                        return TableColumn_2.TableColumn.create(columnMetadata, _this.connection.driver.normalizeType(columnMetadata), _this.connection.driver.normalizeDefault(columnMetadata), _this.connection.driver.getColumnLength(columnMetadata));
                    });
                };
                return RdbmsSchemaBuilder;
            }());
            exports_101("RdbmsSchemaBuilder", RdbmsSchemaBuilder);
        }
    };
});
System.register("typeorm/driver/sqlite-abstract/AbstractSqliteDriver", ["typeorm/driver/sqlite-abstract/AbstractSqliteQueryRunner", "typeorm/util/DateUtils", "typeorm/schema-builder/RdbmsSchemaBuilder", "typeorm/util/RandomGenerator"], function (exports_102, context_102) {
    "use strict";
    var __moduleName = context_102 && context_102.id;
    var AbstractSqliteQueryRunner_1, DateUtils_2, RdbmsSchemaBuilder_1, RandomGenerator_2, AbstractSqliteDriver;
    return {
        setters: [
            function (AbstractSqliteQueryRunner_1_1) {
                AbstractSqliteQueryRunner_1 = AbstractSqliteQueryRunner_1_1;
            },
            function (DateUtils_2_1) {
                DateUtils_2 = DateUtils_2_1;
            },
            function (RdbmsSchemaBuilder_1_1) {
                RdbmsSchemaBuilder_1 = RdbmsSchemaBuilder_1_1;
            },
            function (RandomGenerator_2_1) {
                RandomGenerator_2 = RandomGenerator_2_1;
            }
        ],
        execute: function () {
            /**
             * Organizes communication with sqlite DBMS.
             */
            AbstractSqliteDriver = /** @class */ (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function AbstractSqliteDriver(connection) {
                    /**
                     * Indicates if replication is enabled.
                     */
                    this.isReplicated = false;
                    /**
                     * Indicates if tree tables are supported by this driver.
                     */
                    this.treeSupport = true;
                    /**
                     * Gets list of supported column data types by a driver.
                     *
                     * @see https://www.tutorialspoint.com/sqlite/sqlite_data_types.htm
                     * @see https://sqlite.org/datatype3.html
                     */
                    this.supportedDataTypes = [
                        "int",
                        "integer",
                        "tinyint",
                        "smallint",
                        "mediumint",
                        "bigint",
                        "unsigned big int",
                        "int2",
                        "int8",
                        "integer",
                        "character",
                        "varchar",
                        "varying character",
                        "nchar",
                        "native character",
                        "nvarchar",
                        "text",
                        "clob",
                        "text",
                        "blob",
                        "real",
                        "double",
                        "double precision",
                        "float",
                        "real",
                        "numeric",
                        "decimal",
                        "boolean",
                        "date",
                        "time",
                        "datetime"
                    ];
                    /**
                     * Gets list of column data types that support length by a driver.
                     */
                    this.withLengthColumnTypes = [
                        "character",
                        "varchar",
                        "varying character",
                        "nchar",
                        "native character",
                        "nvarchar",
                        "text",
                        "blob",
                        "clob"
                    ];
                    /**
                     * Orm has special columns and we need to know what database column types should be for those types.
                     * Column types are driver dependant.
                     */
                    this.mappedDataTypes = {
                        createDate: "datetime",
                        createDateDefault: "datetime('now')",
                        updateDate: "datetime",
                        updateDateDefault: "datetime('now')",
                        version: "integer",
                        treeLevel: "integer",
                        migrationName: "varchar",
                        migrationTimestamp: "bigint",
                        cacheId: "int",
                        cacheIdentifier: "varchar",
                        cacheTime: "bigint",
                        cacheDuration: "int",
                        cacheQuery: "text",
                        cacheResult: "text",
                    };
                    this.connection = connection;
                    this.options = connection.options;
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Performs connection to the database.
                 */
                AbstractSqliteDriver.prototype.connect = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var _a;
                        return __generator(this, function (_b) {
                            switch (_b.label) {
                                case 0:
                                    _a = this;
                                    return [4 /*yield*/, this.createDatabaseConnection()];
                                case 1:
                                    _a.databaseConnection = _b.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Makes any action after connection (e.g. create extensions in Postgres driver).
                 */
                AbstractSqliteDriver.prototype.afterConnect = function () {
                    return Promise.resolve();
                };
                /**
                 * Closes connection with database.
                 */
                AbstractSqliteDriver.prototype.disconnect = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        return __generator(this, function (_a) {
                            return [2 /*return*/, new Promise(function (ok, fail) {
                                    _this.queryRunner = undefined;
                                    _this.databaseConnection.close(function (err) { return err ? fail(err) : ok(); });
                                })];
                        });
                    });
                };
                /**
                 * Creates a schema builder used to build and sync a schema.
                 */
                AbstractSqliteDriver.prototype.createSchemaBuilder = function () {
                    return new RdbmsSchemaBuilder_1.RdbmsSchemaBuilder(this.connection);
                };
                /**
                 * Creates a query runner used to execute database queries.
                 */
                AbstractSqliteDriver.prototype.createQueryRunner = function (mode) {
                    if (mode === void 0) { mode = "master"; }
                    if (!this.queryRunner)
                        this.queryRunner = new AbstractSqliteQueryRunner_1.AbstractSqliteQueryRunner(this);
                    return this.queryRunner;
                };
                /**
                 * Prepares given value to a value to be persisted, based on its column type and metadata.
                 */
                AbstractSqliteDriver.prototype.preparePersistentValue = function (value, columnMetadata) {
                    if (columnMetadata.transformer)
                        value = columnMetadata.transformer.to(value);
                    if (value === null || value === undefined)
                        return value;
                    if (columnMetadata.type === Boolean || columnMetadata.type === "boolean") {
                        return value === true ? 1 : 0;
                    }
                    else if (columnMetadata.type === "date") {
                        return DateUtils_2.DateUtils.mixedDateToDateString(value);
                    }
                    else if (columnMetadata.type === "time") {
                        return DateUtils_2.DateUtils.mixedDateToTimeString(value);
                    }
                    else if (columnMetadata.type === "datetime" || columnMetadata.type === Date) {
                        return DateUtils_2.DateUtils.mixedDateToDatetimeString(value); // to string conversation needs because SQLite stores fate as integer number, when date came as Object
                    }
                    else if (columnMetadata.isGenerated && columnMetadata.generationStrategy === "uuid" && !value) {
                        return RandomGenerator_2.RandomGenerator.uuid4();
                    }
                    else if (columnMetadata.type === "simple-array") {
                        return DateUtils_2.DateUtils.simpleArrayToString(value);
                    }
                    else if (columnMetadata.type === "simple-json") {
                        return DateUtils_2.DateUtils.simpleJsonToString(value);
                    }
                    return value;
                };
                /**
                 * Prepares given value to a value to be hydrated, based on its column type or metadata.
                 */
                AbstractSqliteDriver.prototype.prepareHydratedValue = function (value, columnMetadata) {
                    if (value === null || value === undefined)
                        return value;
                    if (columnMetadata.type === Boolean || columnMetadata.type === "boolean") {
                        value = value ? true : false;
                    }
                    else if (columnMetadata.type === "datetime" || columnMetadata.type === Date) {
                        value = DateUtils_2.DateUtils.normalizeHydratedDate(value);
                    }
                    else if (columnMetadata.type === "date") {
                        value = DateUtils_2.DateUtils.mixedDateToDateString(value);
                    }
                    else if (columnMetadata.type === "time") {
                        value = DateUtils_2.DateUtils.mixedTimeToString(value);
                    }
                    else if (columnMetadata.type === "simple-array") {
                        value = DateUtils_2.DateUtils.stringToSimpleArray(value);
                    }
                    else if (columnMetadata.type === "simple-json") {
                        value = DateUtils_2.DateUtils.stringToSimpleJson(value);
                    }
                    if (columnMetadata.transformer)
                        value = columnMetadata.transformer.from(value);
                    return value;
                };
                /**
                 * Replaces parameters in the given sql with special escaping character
                 * and an array of parameter names to be passed to a query.
                 */
                AbstractSqliteDriver.prototype.escapeQueryWithParameters = function (sql, parameters) {
                    if (!parameters || !Object.keys(parameters).length)
                        return [sql, []];
                    var builtParameters = [];
                    var keys = Object.keys(parameters).map(function (parameter) { return "(:" + parameter + "\\b)"; }).join("|");
                    sql = sql.replace(new RegExp(keys, "g"), function (key) {
                        var value = parameters[key.substr(1)];
                        if (value instanceof Array) {
                            return value.map(function (v) {
                                builtParameters.push(v);
                                return "$" + builtParameters.length;
                            }).join(", ");
                        }
                        else if (value instanceof Function) {
                            return value();
                        }
                        else {
                            builtParameters.push(value);
                            return "$" + builtParameters.length;
                        }
                    }); // todo: make replace only in value statements, otherwise problems
                    return [sql, builtParameters];
                };
                /**
                 * Escapes a column name.
                 */
                AbstractSqliteDriver.prototype.escape = function (columnName) {
                    return "\"" + columnName + "\"";
                };
                /**
                 * Creates a database type from a given column metadata.
                 */
                AbstractSqliteDriver.prototype.normalizeType = function (column) {
                    if (column.type === Number || column.type === "int") {
                        return "integer";
                    }
                    else if (column.type === String) {
                        return "varchar";
                    }
                    else if (column.type === Date) {
                        return "datetime";
                    }
                    else if (column.type === Boolean) {
                        return "boolean";
                    }
                    else if (column.type === "uuid") {
                        return "varchar";
                    }
                    else if (column.type === "simple-array") {
                        return "text";
                    }
                    else if (column.type === "simple-json") {
                        return "text";
                    }
                    else {
                        return column.type || "";
                    }
                };
                /**
                 * Normalizes "default" value of the column.
                 */
                AbstractSqliteDriver.prototype.normalizeDefault = function (column) {
                    if (typeof column.default === "number") {
                        return "" + column.default;
                    }
                    else if (typeof column.default === "boolean") {
                        return column.default === true ? "1" : "0";
                    }
                    else if (typeof column.default === "function") {
                        return column.default();
                    }
                    else if (typeof column.default === "string") {
                        return "'" + column.default + "'";
                    }
                    else {
                        return column.default;
                    }
                };
                /**
                 * Normalizes "isUnique" value of the column.
                 */
                AbstractSqliteDriver.prototype.normalizeIsUnique = function (column) {
                    return column.isUnique;
                };
                /**
                 * Calculates column length taking into account the default length values.
                 */
                AbstractSqliteDriver.prototype.getColumnLength = function (column) {
                    if (column.length)
                        return column.length;
                    var normalizedType = this.normalizeType(column);
                    if (this.dataTypeDefaults && this.dataTypeDefaults[normalizedType] && this.dataTypeDefaults[normalizedType].length)
                        return this.dataTypeDefaults[normalizedType].length.toString();
                    return "";
                };
                /**
                 * Normalizes "default" value of the column.
                 */
                AbstractSqliteDriver.prototype.createFullType = function (column) {
                    var type = column.type;
                    if (column.length) {
                        type += "(" + column.length + ")";
                    }
                    else if (column.precision && column.scale) {
                        type += "(" + column.precision + "," + column.scale + ")";
                    }
                    else if (column.precision) {
                        type += "(" + column.precision + ")";
                    }
                    else if (column.scale) {
                        type += "(" + column.scale + ")";
                    }
                    else if (this.dataTypeDefaults && this.dataTypeDefaults[column.type] && this.dataTypeDefaults[column.type].length) {
                        type += "(" + this.dataTypeDefaults[column.type].length.toString() + ")";
                    }
                    if (column.isArray)
                        type += " array";
                    return type;
                };
                /**
                 * Obtains a new database connection to a master server.
                 * Used for replication.
                 * If replication is not setup then returns default connection's database connection.
                 */
                AbstractSqliteDriver.prototype.obtainMasterConnection = function () {
                    return Promise.resolve();
                };
                /**
                 * Obtains a new database connection to a slave server.
                 * Used for replication.
                 * If replication is not setup then returns master (default) connection's database connection.
                 */
                AbstractSqliteDriver.prototype.obtainSlaveConnection = function () {
                    return Promise.resolve();
                };
                // -------------------------------------------------------------------------
                // Protected Methods
                // -------------------------------------------------------------------------
                /**
                 * Creates connection with the database.
                 */
                AbstractSqliteDriver.prototype.createDatabaseConnection = function () {
                    throw new Error("Do not use AbstractSqlite directly, it has to be used with one of the sqlite drivers");
                };
                /**
                 * If driver dependency is not given explicitly, then try to load it via "require".
                 */
                AbstractSqliteDriver.prototype.loadDependencies = function () {
                    // dependencies have to be loaded in the specific driver
                };
                return AbstractSqliteDriver;
            }());
            exports_102("AbstractSqliteDriver", AbstractSqliteDriver);
        }
    };
});
System.register("typeorm/error/QueryRunnerAlreadyReleasedError", [], function (exports_103, context_103) {
    "use strict";
    var __moduleName = context_103 && context_103.id;
    var QueryRunnerAlreadyReleasedError;
    return {
        setters: [],
        execute: function () {
            /**
             */
            QueryRunnerAlreadyReleasedError = /** @class */ (function (_super) {
                __extends(QueryRunnerAlreadyReleasedError, _super);
                function QueryRunnerAlreadyReleasedError() {
                    var _this = _super.call(this) || this;
                    _this.name = "QueryRunnerAlreadyReleasedError";
                    _this.message = "Query runner already released. Cannot run queries anymore.";
                    return _this;
                }
                return QueryRunnerAlreadyReleasedError;
            }(Error));
            exports_103("QueryRunnerAlreadyReleasedError", QueryRunnerAlreadyReleasedError);
        }
    };
});
System.register("typeorm/error/QueryFailedError", [], function (exports_104, context_104) {
    "use strict";
    var __moduleName = context_104 && context_104.id;
    var QueryFailedError;
    return {
        setters: [],
        execute: function () {
            /**
             * Thrown when query execution has failed.
            */
            QueryFailedError = /** @class */ (function (_super) {
                __extends(QueryFailedError, _super);
                function QueryFailedError(query, parameters, driverError) {
                    var _this = _super.call(this) || this;
                    _this.message = driverError.toString()
                        .replace(/^error: /, "")
                        .replace(/^Error: /, "")
                        .replace(/^Request/, "");
                    Object.setPrototypeOf(_this, QueryFailedError.prototype);
                    Object.assign(_this, __assign({}, driverError, { name: "QueryFailedError", query: query, parameters: parameters || [] }));
                    return _this;
                }
                return QueryFailedError;
            }(Error));
            exports_104("QueryFailedError", QueryFailedError);
        }
    };
});
System.register("typeorm/driver/oracle/OracleQueryRunner", ["typeorm/error/TransactionAlreadyStartedError", "typeorm/error/TransactionNotStartedError", "typeorm/schema-builder/schema/TableColumn", "typeorm/schema-builder/schema/Table", "typeorm/schema-builder/schema/TableForeignKey", "typeorm/schema-builder/schema/TablePrimaryKey", "typeorm/schema-builder/schema/TableIndex", "typeorm/error/QueryRunnerAlreadyReleasedError", "typeorm/error/QueryFailedError"], function (exports_105, context_105) {
    "use strict";
    var __moduleName = context_105 && context_105.id;
    var TransactionAlreadyStartedError_2, TransactionNotStartedError_2, TableColumn_3, Table_3, TableForeignKey_3, TablePrimaryKey_3, TableIndex_3, QueryRunnerAlreadyReleasedError_1, QueryFailedError_1, OracleQueryRunner;
    return {
        setters: [
            function (TransactionAlreadyStartedError_2_1) {
                TransactionAlreadyStartedError_2 = TransactionAlreadyStartedError_2_1;
            },
            function (TransactionNotStartedError_2_1) {
                TransactionNotStartedError_2 = TransactionNotStartedError_2_1;
            },
            function (TableColumn_3_1) {
                TableColumn_3 = TableColumn_3_1;
            },
            function (Table_3_1) {
                Table_3 = Table_3_1;
            },
            function (TableForeignKey_3_1) {
                TableForeignKey_3 = TableForeignKey_3_1;
            },
            function (TablePrimaryKey_3_1) {
                TablePrimaryKey_3 = TablePrimaryKey_3_1;
            },
            function (TableIndex_3_1) {
                TableIndex_3 = TableIndex_3_1;
            },
            function (QueryRunnerAlreadyReleasedError_1_1) {
                QueryRunnerAlreadyReleasedError_1 = QueryRunnerAlreadyReleasedError_1_1;
            },
            function (QueryFailedError_1_1) {
                QueryFailedError_1 = QueryFailedError_1_1;
            }
        ],
        execute: function () {
            /**
             * Runs queries on a single oracle database connection.
             *
             * todo: this driver is not 100% finished yet, need to fix all issues that are left
             */
            OracleQueryRunner = /** @class */ (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function OracleQueryRunner(driver, mode) {
                    if (mode === void 0) { mode = "master"; }
                    /**
                     * Indicates if connection for this query runner is released.
                     * Once its released, query runner cannot run queries anymore.
                     */
                    this.isReleased = false;
                    /**
                     * Indicates if transaction is in progress.
                     */
                    this.isTransactionActive = false;
                    /**
                     * Stores temporarily user data.
                     * Useful for sharing data with subscribers.
                     */
                    this.data = {};
                    /**
                     * Indicates if special query runner mode in which sql queries won't be executed is enabled.
                     */
                    this.sqlMemoryMode = false;
                    /**
                     * Sql-s stored if "sql in memory" mode is enabled.
                     */
                    this.sqlsInMemory = [];
                    this.driver = driver;
                    this.connection = driver.connection;
                    this.mode = mode;
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Creates/uses database connection from the connection pool to perform further operations.
                 * Returns obtained database connection.
                 */
                OracleQueryRunner.prototype.connect = function () {
                    var _this = this;
                    if (this.databaseConnection)
                        return Promise.resolve(this.databaseConnection);
                    if (this.databaseConnectionPromise)
                        return this.databaseConnectionPromise;
                    if (this.mode === "slave" && this.driver.isReplicated) {
                        this.databaseConnectionPromise = this.driver.obtainSlaveConnection().then(function (connection) {
                            _this.databaseConnection = connection;
                            return _this.databaseConnection;
                        });
                    }
                    else { // master
                        this.databaseConnectionPromise = this.driver.obtainMasterConnection().then(function (connection) {
                            _this.databaseConnection = connection;
                            return _this.databaseConnection;
                        });
                    }
                    return this.databaseConnectionPromise;
                };
                /**
                 * Releases used database connection.
                 * You cannot use query runner methods once its released.
                 */
                OracleQueryRunner.prototype.release = function () {
                    var _this = this;
                    return new Promise(function (ok, fail) {
                        _this.isReleased = true;
                        if (_this.databaseConnection) {
                            _this.databaseConnection.close(function (err) {
                                if (err)
                                    return fail(err);
                                ok();
                            });
                        }
                    });
                };
                /**
                 * Starts transaction.
                 */
                OracleQueryRunner.prototype.startTransaction = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            if (this.isReleased)
                                throw new QueryRunnerAlreadyReleasedError_1.QueryRunnerAlreadyReleasedError();
                            if (this.isTransactionActive)
                                throw new TransactionAlreadyStartedError_2.TransactionAlreadyStartedError();
                            // await this.query("START TRANSACTION");
                            this.isTransactionActive = true;
                            return [2 /*return*/];
                        });
                    });
                };
                /**
                 * Commits transaction.
                 * Error will be thrown if transaction was not started.
                 */
                OracleQueryRunner.prototype.commitTransaction = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (!this.isTransactionActive)
                                        throw new TransactionNotStartedError_2.TransactionNotStartedError();
                                    return [4 /*yield*/, this.query("COMMIT")];
                                case 1:
                                    _a.sent();
                                    this.isTransactionActive = false;
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Rollbacks transaction.
                 * Error will be thrown if transaction was not started.
                 */
                OracleQueryRunner.prototype.rollbackTransaction = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (!this.isTransactionActive)
                                        throw new TransactionNotStartedError_2.TransactionNotStartedError();
                                    return [4 /*yield*/, this.query("ROLLBACK")];
                                case 1:
                                    _a.sent();
                                    this.isTransactionActive = false;
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Executes a given SQL query.
                 */
                OracleQueryRunner.prototype.query = function (query, parameters) {
                    var _this = this;
                    if (this.isReleased)
                        throw new QueryRunnerAlreadyReleasedError_1.QueryRunnerAlreadyReleasedError();
                    return new Promise(function (ok, fail) { return __awaiter(_this, void 0, void 0, function () {
                        var _this = this;
                        var queryStartTime_1, handler, executionOptions, databaseConnection, err_2;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    _a.trys.push([0, 2, , 3]);
                                    this.driver.connection.logger.logQuery(query, parameters, this);
                                    queryStartTime_1 = +new Date();
                                    handler = function (err, result) {
                                        // log slow queries if maxQueryExecution time is set
                                        var maxQueryExecutionTime = _this.driver.connection.options.maxQueryExecutionTime;
                                        var queryEndTime = +new Date();
                                        var queryExecutionTime = queryEndTime - queryStartTime_1;
                                        if (maxQueryExecutionTime && queryExecutionTime > maxQueryExecutionTime)
                                            _this.driver.connection.logger.logQuerySlow(queryExecutionTime, query, parameters, _this);
                                        if (err) {
                                            _this.driver.connection.logger.logQueryError(err, query, parameters, _this);
                                            return fail(new QueryFailedError_1.QueryFailedError(query, parameters, err));
                                        }
                                        ok(result.rows || result.outBinds);
                                    };
                                    executionOptions = {
                                        autoCommit: this.isTransactionActive ? false : true
                                    };
                                    return [4 /*yield*/, this.connect()];
                                case 1:
                                    databaseConnection = _a.sent();
                                    databaseConnection.execute(query, parameters || {}, executionOptions, handler);
                                    return [3 /*break*/, 3];
                                case 2:
                                    err_2 = _a.sent();
                                    fail(err_2);
                                    return [3 /*break*/, 3];
                                case 3: return [2 /*return*/];
                            }
                        });
                    }); });
                };
                /**
                 * Returns raw data stream.
                 */
                OracleQueryRunner.prototype.stream = function (query, parameters, onEnd, onError) {
                    throw new Error("Stream is not supported by Oracle driver.");
                };
                /**
                 * Insert a new row with given values into the given table.
                 * Returns value of the generated column if given and generate column exist in the table.
                 */
                OracleQueryRunner.prototype.insert = function (tableName, keyValues) {
                    return __awaiter(this, void 0, void 0, function () {
                        var generatedColumn, keys, columns, values, parameters, generatedColumns, insertSql, sql2, saveResult;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    keys = Object.keys(keyValues);
                                    columns = keys.map(function (key) { return "\"" + key + "\""; }).join(", ");
                                    values = keys.map(function (key) { return ":" + key; }).join(", ");
                                    parameters = keys.map(function (key) { return keyValues[key]; });
                                    generatedColumns = this.connection.hasMetadata(tableName) ? this.connection.getMetadata(tableName).generatedColumns : [];
                                    if (generatedColumns.length > 0)
                                        generatedColumn = generatedColumns.find(function (column) { return column.isPrimary && column.isGenerated; });
                                    insertSql = columns.length > 0
                                        ? "INSERT INTO \"" + tableName + "\" (" + columns + ") VALUES (" + values + ")"
                                        : "INSERT INTO \"" + tableName + "\" DEFAULT VALUES";
                                    if (!generatedColumn) return [3 /*break*/, 2];
                                    sql2 = "declare lastId number; begin " + insertSql + " returning \"" + generatedColumn.databaseName + "\" into lastId; dbms_output.enable; dbms_output.put_line(lastId); dbms_output.get_line(:ln, :st); end;";
                                    return [4 /*yield*/, this.query(sql2, parameters.concat([
                                            { dir: this.driver.oracle.BIND_OUT, type: this.driver.oracle.STRING, maxSize: 32767 },
                                            { dir: this.driver.oracle.BIND_OUT, type: this.driver.oracle.NUMBER }
                                        ]))];
                                case 1:
                                    saveResult = _a.sent();
                                    return [2 /*return*/, parseInt(saveResult[0])];
                                case 2: return [2 /*return*/, this.query(insertSql, parameters)];
                            }
                        });
                    });
                };
                /**
                 * Updates rows that match given conditions in the given table.
                 */
                OracleQueryRunner.prototype.update = function (tableName, valuesMap, conditions) {
                    return __awaiter(this, void 0, void 0, function () {
                        var updateValues, conditionString, sql, conditionParams, updateParams, allParameters;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    updateValues = this.parametrize(valuesMap).join(", ");
                                    conditionString = this.parametrize(conditions).join(" AND ");
                                    sql = "UPDATE \"" + tableName + "\" SET " + updateValues + " " + (conditionString ? (" WHERE " + conditionString) : "");
                                    conditionParams = Object.keys(conditions).map(function (key) { return conditions[key]; });
                                    updateParams = Object.keys(valuesMap).map(function (key) { return valuesMap[key]; });
                                    allParameters = updateParams.concat(conditionParams);
                                    return [4 /*yield*/, this.query(sql, allParameters)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Deletes from the given table by a given conditions.
                 */
                OracleQueryRunner.prototype.delete = function (tableName, conditions, maybeParameters) {
                    return __awaiter(this, void 0, void 0, function () {
                        var conditionString, parameters, sql;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    conditionString = typeof conditions === "string" ? conditions : this.parametrize(conditions).join(" AND ");
                                    parameters = conditions instanceof Object ? Object.keys(conditions).map(function (key) { return conditions[key]; }) : maybeParameters;
                                    sql = "DELETE FROM \"" + tableName + "\" WHERE " + conditionString;
                                    return [4 /*yield*/, this.query(sql, parameters)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Inserts rows into the closure table.
                 */
                OracleQueryRunner.prototype.insertIntoClosureTable = function (tableName, newEntityId, parentId, hasLevel) {
                    return __awaiter(this, void 0, void 0, function () {
                        var sql, results;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    sql = "";
                                    if (hasLevel) {
                                        sql = "INSERT INTO \"" + tableName + "\"(\"ancestor\", \"descendant\", \"level\") " +
                                            ("SELECT \"ancestor\", " + newEntityId + ", \"level\" + 1 FROM \"" + tableName + "\" WHERE \"descendant\" = " + parentId + " ") +
                                            ("UNION ALL SELECT " + newEntityId + ", " + newEntityId + ", 1");
                                    }
                                    else {
                                        sql = "INSERT INTO \"" + tableName + "\" (\"ancestor\", \"descendant\") " +
                                            ("SELECT \"ancestor\", " + newEntityId + " FROM \"" + tableName + "\" WHERE \"descendant\" = " + parentId + " ") +
                                            ("UNION ALL SELECT " + newEntityId + ", " + newEntityId);
                                    }
                                    return [4 /*yield*/, this.query(sql)];
                                case 1:
                                    _a.sent();
                                    return [4 /*yield*/, this.query("SELECT MAX(\"level\") as \"level\" FROM \"" + tableName + "\" WHERE \"descendant\" = " + parentId)];
                                case 2:
                                    results = _a.sent();
                                    return [2 /*return*/, results && results[0] && results[0]["level"] ? parseInt(results[0]["level"]) + 1 : 1];
                            }
                        });
                    });
                };
                /**
                 * Loads given table's data from the database.
                 */
                OracleQueryRunner.prototype.getTable = function (tableName) {
                    return __awaiter(this, void 0, void 0, function () {
                        var tables;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.getTables([tableName])];
                                case 1:
                                    tables = _a.sent();
                                    return [2 /*return*/, tables.length > 0 ? tables[0] : undefined];
                            }
                        });
                    });
                };
                /**
                 * Loads all tables (with given names) from the database and creates a Table from them.
                 */
                OracleQueryRunner.prototype.getTables = function (tableNames) {
                    return __awaiter(this, void 0, void 0, function () {
                        var tableNamesString, tablesSql, columnsSql, indicesSql, constraintsSql, _a, dbTables, dbColumns, dbIndices, constraints;
                        return __generator(this, function (_b) {
                            switch (_b.label) {
                                case 0:
                                    // if no tables given then no need to proceed
                                    if (!tableNames || !tableNames.length)
                                        return [2 /*return*/, []];
                                    tableNamesString = tableNames.map(function (name) { return "'" + name + "'"; }).join(", ");
                                    tablesSql = "SELECT TABLE_NAME FROM user_tables WHERE TABLE_NAME IN (" + tableNamesString + ")";
                                    columnsSql = "SELECT TABLE_NAME, COLUMN_NAME, DATA_TYPE, DATA_LENGTH, DATA_PRECISION, DATA_SCALE, NULLABLE, IDENTITY_COLUMN FROM all_tab_cols WHERE TABLE_NAME IN (" + tableNamesString + ")";
                                    indicesSql = "SELECT ind.INDEX_NAME, ind.TABLE_NAME, ind.UNIQUENESS, LISTAGG(cols.COLUMN_NAME, ',') WITHIN GROUP (ORDER BY cols.COLUMN_NAME) AS COLUMN_NAMES\n                                FROM USER_INDEXES ind, USER_IND_COLUMNS cols \n                                WHERE ind.INDEX_NAME = cols.INDEX_NAME AND ind.TABLE_NAME IN (" + tableNamesString + ")\n                                GROUP BY ind.INDEX_NAME, ind.TABLE_NAME, ind.UNIQUENESS";
                                    constraintsSql = "SELECT cols.table_name, cols.column_name, cols.position, cons.constraint_type, cons.constraint_name\nFROM all_constraints cons, all_cons_columns cols WHERE cols.table_name IN (" + tableNamesString + ") \nAND cons.constraint_name = cols.constraint_name AND cons.owner = cols.owner ORDER BY cols.table_name, cols.position";
                                    return [4 /*yield*/, Promise.all([
                                            this.query(tablesSql),
                                            this.query(columnsSql),
                                            this.query(indicesSql),
                                            // this.query(foreignKeysSql),
                                            // this.query(uniqueKeysSql),
                                            this.query(constraintsSql),
                                        ])];
                                case 1:
                                    _a = _b.sent(), dbTables = _a[0], dbColumns = _a[1], dbIndices = _a[2], constraints = _a[3];
                                    // if tables were not found in the db, no need to proceed
                                    if (!dbTables.length)
                                        return [2 /*return*/, []];
                                    // create tables for loaded tables
                                    return [2 /*return*/, dbTables.map(function (dbTable) {
                                            var table = new Table_3.Table(dbTable["TABLE_NAME"]);
                                            // create columns from the loaded columns
                                            table.columns = dbColumns
                                                .filter(function (dbColumn) { return dbColumn["TABLE_NAME"] === table.name; })
                                                .map(function (dbColumn) {
                                                var isPrimary = !!constraints
                                                    .find(function (constraint) {
                                                    return constraint["TABLE_NAME"] === table.name &&
                                                        constraint["CONSTRAINT_TYPE"] === "P" &&
                                                        constraint["COLUMN_NAME"] === dbColumn["COLUMN_NAME"];
                                                });
                                                // TODO fix
                                                var columnType = dbColumn["DATA_TYPE"].toLowerCase();
                                                if (dbColumn["DATA_TYPE"].toLowerCase() === "varchar2" && dbColumn["DATA_LENGTH"] !== null) {
                                                    columnType += "(" + dbColumn["DATA_LENGTH"] + ")";
                                                }
                                                else if (dbColumn["DATA_PRECISION"] !== null && dbColumn["DATA_SCALE"] !== null) {
                                                    columnType += "(" + dbColumn["DATA_PRECISION"] + "," + dbColumn["DATA_SCALE"] + ")";
                                                }
                                                else if (dbColumn["DATA_SCALE"] !== null) {
                                                    columnType += "(0," + dbColumn["DATA_SCALE"] + ")";
                                                }
                                                else if (dbColumn["DATA_PRECISION"] !== null) {
                                                    columnType += "(" + dbColumn["DATA_PRECISION"] + ")";
                                                }
                                                var tableColumn = new TableColumn_3.TableColumn();
                                                tableColumn.name = dbColumn["COLUMN_NAME"];
                                                tableColumn.type = columnType;
                                                tableColumn.default = dbColumn["COLUMN_DEFAULT"] !== null && dbColumn["COLUMN_DEFAULT"] !== undefined ? dbColumn["COLUMN_DEFAULT"] : undefined;
                                                tableColumn.isNullable = dbColumn["NULLABLE"] !== "N";
                                                tableColumn.isPrimary = isPrimary;
                                                tableColumn.isGenerated = dbColumn["IDENTITY_COLUMN"] === "YES"; // todo
                                                tableColumn.comment = ""; // todo
                                                return tableColumn;
                                            });
                                            // create primary key schema
                                            table.primaryKeys = constraints
                                                .filter(function (constraint) {
                                                return constraint["TABLE_NAME"] === table.name && constraint["CONSTRAINT_TYPE"] === "P";
                                            })
                                                .map(function (constraint) {
                                                return new TablePrimaryKey_3.TablePrimaryKey(constraint["CONSTRAINT_NAME"], constraint["COLUMN_NAME"]);
                                            });
                                            // create foreign key schemas from the loaded indices
                                            table.foreignKeys = constraints
                                                .filter(function (constraint) { return constraint["TABLE_NAME"] === table.name && constraint["CONSTRAINT_TYPE"] === "R"; })
                                                .map(function (constraint) { return new TableForeignKey_3.TableForeignKey(constraint["CONSTRAINT_NAME"], [], [], "", ""); }); // todo: fix missing params
                                            // create index schemas from the loaded indices
                                            table.indices = dbIndices
                                                .filter(function (dbIndex) {
                                                return dbIndex["TABLE_NAME"] === table.name &&
                                                    (!table.foreignKeys.find(function (foreignKey) { return foreignKey.name === dbIndex["INDEX_NAME"]; })) &&
                                                    (!table.primaryKeys.find(function (primaryKey) { return primaryKey.name === dbIndex["INDEX_NAME"]; }));
                                            })
                                                .map(function (dbIndex) {
                                                return new TableIndex_3.TableIndex(dbTable["TABLE_NAME"], dbIndex["INDEX_NAME"], dbIndex["COLUMN_NAMES"], !!(dbIndex["COLUMN_NAMES"] === "UNIQUE"));
                                            });
                                            return table;
                                        })];
                            }
                        });
                    });
                };
                /**
                 * Checks if database with the given name exist.
                 */
                OracleQueryRunner.prototype.hasDatabase = function (database) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            return [2 /*return*/, Promise.resolve(false)];
                        });
                    });
                };
                /**
                 * Checks if table with the given name exist in the database.
                 */
                OracleQueryRunner.prototype.hasTable = function (tableName) {
                    return __awaiter(this, void 0, void 0, function () {
                        var sql, result;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    sql = "SELECT TABLE_NAME FROM user_tables WHERE TABLE_NAME = '" + tableName + "'";
                                    return [4 /*yield*/, this.query(sql)];
                                case 1:
                                    result = _a.sent();
                                    return [2 /*return*/, result.length ? true : false];
                            }
                        });
                    });
                };
                /**
                 * Creates a database if it's not created.
                 */
                OracleQueryRunner.prototype.createDatabase = function (database) {
                    return this.query("CREATE DATABASE IF NOT EXISTS " + database);
                };
                /**
                 * Creates a schema if it's not created.
                 */
                OracleQueryRunner.prototype.createSchema = function (schemas) {
                    return Promise.resolve([]);
                };
                /**
                 * Creates a new table from the given table metadata and column metadatas.
                 */
                OracleQueryRunner.prototype.createTable = function (table) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var columnDefinitions, sql, primaryKeyColumns;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    columnDefinitions = table.columns.map(function (column) { return _this.buildCreateColumnSql(column); }).join(", ");
                                    sql = "CREATE TABLE \"" + table.name + "\" (" + columnDefinitions;
                                    primaryKeyColumns = table.columns.filter(function (column) { return column.isPrimary; });
                                    if (primaryKeyColumns.length > 0)
                                        sql += ", PRIMARY KEY(" + primaryKeyColumns.map(function (column) { return "\"" + column.name + "\""; }).join(", ") + ")";
                                    sql += ")";
                                    return [4 /*yield*/, this.query(sql)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Drops the table.
                 */
                OracleQueryRunner.prototype.dropTable = function (tableName) {
                    return __awaiter(this, void 0, void 0, function () {
                        var sql;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    sql = "DROP TABLE \"" + tableName + "\"";
                                    return [4 /*yield*/, this.query(sql)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Checks if column with the given name exist in the given table.
                 */
                OracleQueryRunner.prototype.hasColumn = function (tableName, columnName) {
                    return __awaiter(this, void 0, void 0, function () {
                        var sql, result;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    sql = "SELECT COLUMN_NAME FROM all_tab_cols WHERE TABLE_NAME = '" + tableName + "' AND COLUMN_NAME = '" + columnName + "'";
                                    return [4 /*yield*/, this.query(sql)];
                                case 1:
                                    result = _a.sent();
                                    return [2 /*return*/, result.length ? true : false];
                            }
                        });
                    });
                };
                /**
                 * Creates a new column from the column in the table.
                 */
                OracleQueryRunner.prototype.addColumn = function (tableOrName, column) {
                    return __awaiter(this, void 0, void 0, function () {
                        var tableName, sql;
                        return __generator(this, function (_a) {
                            tableName = tableOrName instanceof Table_3.Table ? tableOrName.name : tableOrName;
                            sql = "ALTER TABLE \"" + tableName + "\" ADD " + this.buildCreateColumnSql(column);
                            return [2 /*return*/, this.query(sql)];
                        });
                    });
                };
                /**
                 * Creates a new columns from the column in the table.
                 */
                OracleQueryRunner.prototype.addColumns = function (tableOrName, columns) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var queries;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    queries = columns.map(function (column) { return _this.addColumn(tableOrName, column); });
                                    return [4 /*yield*/, Promise.all(queries)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Renames column in the given table.
                 */
                OracleQueryRunner.prototype.renameColumn = function (tableOrName, oldTableColumnOrName, newTableColumnOrName) {
                    return __awaiter(this, void 0, void 0, function () {
                        var table, oldColumn, newColumn;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    table = undefined;
                                    if (!(tableOrName instanceof Table_3.Table)) return [3 /*break*/, 1];
                                    table = tableOrName;
                                    return [3 /*break*/, 3];
                                case 1: return [4 /*yield*/, this.getTable(tableOrName)];
                                case 2:
                                    table = _a.sent();
                                    _a.label = 3;
                                case 3:
                                    if (!table)
                                        throw new Error("Table " + tableOrName + " was not found.");
                                    oldColumn = undefined;
                                    if (oldTableColumnOrName instanceof TableColumn_3.TableColumn) {
                                        oldColumn = oldTableColumnOrName;
                                    }
                                    else {
                                        oldColumn = table.columns.find(function (column) { return column.name === oldTableColumnOrName; });
                                    }
                                    if (!oldColumn)
                                        throw new Error("Column \"" + oldTableColumnOrName + "\" was not found in the \"" + tableOrName + "\" table.");
                                    newColumn = undefined;
                                    if (newTableColumnOrName instanceof TableColumn_3.TableColumn) {
                                        newColumn = newTableColumnOrName;
                                    }
                                    else {
                                        newColumn = oldColumn.clone();
                                        newColumn.name = newTableColumnOrName;
                                    }
                                    return [2 /*return*/, this.changeColumn(table, oldColumn, newColumn)];
                            }
                        });
                    });
                };
                /**
                 * Changes a column in the table.
                 */
                OracleQueryRunner.prototype.changeColumn = function (tableOrName, oldTableColumnOrName, newColumn) {
                    return __awaiter(this, void 0, void 0, function () {
                        var table, oldColumn, dropPrimarySql, dropSql, createSql, sql, sql, sql;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    table = undefined;
                                    if (!(tableOrName instanceof Table_3.Table)) return [3 /*break*/, 1];
                                    table = tableOrName;
                                    return [3 /*break*/, 3];
                                case 1: return [4 /*yield*/, this.getTable(tableOrName)];
                                case 2:
                                    table = _a.sent();
                                    _a.label = 3;
                                case 3:
                                    if (!table)
                                        throw new Error("Table " + tableOrName + " was not found.");
                                    oldColumn = undefined;
                                    if (oldTableColumnOrName instanceof TableColumn_3.TableColumn) {
                                        oldColumn = oldTableColumnOrName;
                                    }
                                    else {
                                        oldColumn = table.columns.find(function (column) { return column.name === oldTableColumnOrName; });
                                    }
                                    if (!oldColumn)
                                        throw new Error("Column \"" + oldTableColumnOrName + "\" was not found in the \"" + tableOrName + "\" table.");
                                    if (!(newColumn.isGenerated !== oldColumn.isGenerated)) return [3 /*break*/, 10];
                                    if (!newColumn.isGenerated) return [3 /*break*/, 8];
                                    if (!(table.primaryKeys.length > 0 && oldColumn.isPrimary)) return [3 /*break*/, 5];
                                    dropPrimarySql = "ALTER TABLE \"" + table.name + "\" DROP CONSTRAINT \"" + table.primaryKeys[0].name + "\"";
                                    return [4 /*yield*/, this.query(dropPrimarySql)];
                                case 4:
                                    _a.sent();
                                    _a.label = 5;
                                case 5:
                                    dropSql = "ALTER TABLE \"" + table.name + "\" DROP COLUMN \"" + newColumn.name + "\"";
                                    return [4 /*yield*/, this.query(dropSql)];
                                case 6:
                                    _a.sent();
                                    createSql = "ALTER TABLE \"" + table.name + "\" ADD " + this.buildCreateColumnSql(newColumn);
                                    return [4 /*yield*/, this.query(createSql)];
                                case 7:
                                    _a.sent();
                                    return [3 /*break*/, 10];
                                case 8:
                                    sql = "ALTER TABLE \"" + table.name + "\" MODIFY \"" + newColumn.name + "\" DROP IDENTITY";
                                    return [4 /*yield*/, this.query(sql)];
                                case 9:
                                    _a.sent();
                                    _a.label = 10;
                                case 10:
                                    if (!(newColumn.isNullable !== oldColumn.isNullable)) return [3 /*break*/, 12];
                                    sql = "ALTER TABLE \"" + table.name + "\" MODIFY \"" + newColumn.name + "\" " + this.connection.driver.createFullType(newColumn) + " " + (newColumn.isNullable ? "NULL" : "NOT NULL");
                                    return [4 /*yield*/, this.query(sql)];
                                case 11:
                                    _a.sent();
                                    return [3 /*break*/, 14];
                                case 12:
                                    if (!(this.connection.driver.createFullType(newColumn) !== this.connection.driver.createFullType(oldColumn))) return [3 /*break*/, 14];
                                    sql = "ALTER TABLE \"" + table.name + "\" MODIFY \"" + newColumn.name + "\" " + this.connection.driver.createFullType(newColumn);
                                    return [4 /*yield*/, this.query(sql)];
                                case 13:
                                    _a.sent();
                                    _a.label = 14;
                                case 14: return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Changes a column in the table.
                 */
                OracleQueryRunner.prototype.changeColumns = function (table, changedColumns) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var updatePromises;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    updatePromises = changedColumns.map(function (changedColumn) { return __awaiter(_this, void 0, void 0, function () {
                                        return __generator(this, function (_a) {
                                            return [2 /*return*/, this.changeColumn(table, changedColumn.oldColumn, changedColumn.newColumn)];
                                        });
                                    }); });
                                    return [4 /*yield*/, Promise.all(updatePromises)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Drops column in the table.
                 */
                OracleQueryRunner.prototype.dropColumn = function (table, column) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            return [2 /*return*/, this.query("ALTER TABLE \"" + table.name + "\" DROP COLUMN \"" + column.name + "\"")];
                        });
                    });
                };
                /**
                 * Drops the columns in the table.
                 */
                OracleQueryRunner.prototype.dropColumns = function (table, columns) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var dropPromises;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    dropPromises = columns.map(function (column) { return _this.dropColumn(table, column); });
                                    return [4 /*yield*/, Promise.all(dropPromises)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Updates table's primary keys.
                 */
                OracleQueryRunner.prototype.updatePrimaryKeys = function (dbTable) {
                    return __awaiter(this, void 0, void 0, function () {
                        var primaryColumnNames;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    primaryColumnNames = dbTable.primaryKeys.map(function (primaryKey) { return "\"" + primaryKey.columnName + "\""; });
                                    if (!(dbTable.primaryKeys.length > 0 && dbTable.primaryKeys[0].name)) return [3 /*break*/, 2];
                                    return [4 /*yield*/, this.query("ALTER TABLE \"" + dbTable.name + "\" DROP CONSTRAINT \"" + dbTable.primaryKeys[0].name + "\"")];
                                case 1:
                                    _a.sent();
                                    _a.label = 2;
                                case 2:
                                    if (!(primaryColumnNames.length > 0)) return [3 /*break*/, 4];
                                    return [4 /*yield*/, this.query("ALTER TABLE \"" + dbTable.name + "\" ADD PRIMARY KEY (" + primaryColumnNames.join(", ") + ")")];
                                case 3:
                                    _a.sent();
                                    _a.label = 4;
                                case 4: return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Creates a new foreign key.
                 */
                OracleQueryRunner.prototype.createForeignKey = function (tableOrName, foreignKey) {
                    return __awaiter(this, void 0, void 0, function () {
                        var tableName, columnNames, referencedColumnNames, sql;
                        return __generator(this, function (_a) {
                            tableName = tableOrName instanceof Table_3.Table ? tableOrName.name : tableOrName;
                            columnNames = foreignKey.columnNames.map(function (column) { return "\"" + column + "\""; }).join(", ");
                            referencedColumnNames = foreignKey.referencedColumnNames.map(function (column) { return "\"" + column + "\""; }).join(",");
                            sql = "ALTER TABLE \"" + tableName + "\" ADD CONSTRAINT \"" + foreignKey.name + "\" " +
                                ("FOREIGN KEY (" + columnNames + ") ") +
                                ("REFERENCES \"" + foreignKey.referencedTableName + "\"(" + referencedColumnNames + ")");
                            if (foreignKey.onDelete)
                                sql += " ON DELETE " + foreignKey.onDelete;
                            return [2 /*return*/, this.query(sql)];
                        });
                    });
                };
                /**
                 * Creates a new foreign keys.
                 */
                OracleQueryRunner.prototype.createForeignKeys = function (tableOrName, foreignKeys) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var promises;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    promises = foreignKeys.map(function (foreignKey) { return _this.createForeignKey(tableOrName, foreignKey); });
                                    return [4 /*yield*/, Promise.all(promises)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Drops a foreign key from the table.
                 */
                OracleQueryRunner.prototype.dropForeignKey = function (tableOrName, foreignKey) {
                    return __awaiter(this, void 0, void 0, function () {
                        var tableName, sql;
                        return __generator(this, function (_a) {
                            tableName = tableOrName instanceof Table_3.Table ? tableOrName.name : tableOrName;
                            sql = "ALTER TABLE \"" + tableName + "\" DROP CONSTRAINT \"" + foreignKey.name + "\"";
                            return [2 /*return*/, this.query(sql)];
                        });
                    });
                };
                /**
                 * Drops a foreign keys from the table.
                 */
                OracleQueryRunner.prototype.dropForeignKeys = function (tableOrName, foreignKeys) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var promises;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    promises = foreignKeys.map(function (foreignKey) { return _this.dropForeignKey(tableOrName, foreignKey); });
                                    return [4 /*yield*/, Promise.all(promises)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Creates a new index.
                 */
                OracleQueryRunner.prototype.createIndex = function (table, index) {
                    return __awaiter(this, void 0, void 0, function () {
                        var columns, sql;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    columns = index.columnNames.map(function (columnName) { return "\"" + columnName + "\""; }).join(", ");
                                    sql = "CREATE " + (index.isUnique ? "UNIQUE" : "") + " INDEX \"" + index.name + "\" ON \"" + (table instanceof Table_3.Table ? table.name : table) + "\"(" + columns + ")";
                                    return [4 /*yield*/, this.query(sql)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Drops an index from the table.
                 */
                OracleQueryRunner.prototype.dropIndex = function (tableSchemeOrName, indexName) {
                    return __awaiter(this, void 0, void 0, function () {
                        var tableName, sql;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    tableName = tableSchemeOrName instanceof Table_3.Table ? tableSchemeOrName.name : tableSchemeOrName;
                                    sql = "ALTER TABLE \"" + tableName + "\" DROP INDEX \"" + indexName + "\"";
                                    return [4 /*yield*/, this.query(sql)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Truncates table.
                 */
                OracleQueryRunner.prototype.truncate = function (tableName) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.query("TRUNCATE TABLE \"" + tableName + "\"")];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Removes all tables from the currently connected database.
                 */
                OracleQueryRunner.prototype.clearDatabase = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var disableForeignKeysCheckQuery, dropTablesQuery, enableForeignKeysCheckQuery, dropQueries, error_5, rollbackError_6;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.startTransaction()];
                                case 1:
                                    _a.sent();
                                    _a.label = 2;
                                case 2:
                                    _a.trys.push([2, 8, , 13]);
                                    disableForeignKeysCheckQuery = "SET FOREIGN_KEY_CHECKS = 0;";
                                    dropTablesQuery = "SELECT concat('DROP TABLE IF EXISTS \"', table_name, '\";') AS query FROM information_schema.tables WHERE table_schema = '" + this.dbName + "'";
                                    enableForeignKeysCheckQuery = "SET FOREIGN_KEY_CHECKS = 1;";
                                    return [4 /*yield*/, this.query(disableForeignKeysCheckQuery)];
                                case 3:
                                    _a.sent();
                                    return [4 /*yield*/, this.query(dropTablesQuery)];
                                case 4:
                                    dropQueries = _a.sent();
                                    return [4 /*yield*/, Promise.all(dropQueries.map(function (query) { return _this.query(query["query"]); }))];
                                case 5:
                                    _a.sent();
                                    return [4 /*yield*/, this.query(enableForeignKeysCheckQuery)];
                                case 6:
                                    _a.sent();
                                    return [4 /*yield*/, this.commitTransaction()];
                                case 7:
                                    _a.sent();
                                    return [3 /*break*/, 13];
                                case 8:
                                    error_5 = _a.sent();
                                    _a.label = 9;
                                case 9:
                                    _a.trys.push([9, 11, , 12]);
                                    return [4 /*yield*/, this.rollbackTransaction()];
                                case 10:
                                    _a.sent();
                                    return [3 /*break*/, 12];
                                case 11:
                                    rollbackError_6 = _a.sent();
                                    return [3 /*break*/, 12];
                                case 12: throw error_5;
                                case 13: return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Enables special query runner mode in which sql queries won't be executed,
                 * instead they will be memorized into a special variable inside query runner.
                 * You can get memorized sql using getMemorySql() method.
                 */
                OracleQueryRunner.prototype.enableSqlMemory = function () {
                    this.sqlMemoryMode = true;
                };
                /**
                 * Disables special query runner mode in which sql queries won't be executed
                 * started by calling enableSqlMemory() method.
                 *
                 * Previously memorized sql will be flushed.
                 */
                OracleQueryRunner.prototype.disableSqlMemory = function () {
                    this.sqlsInMemory = [];
                    this.sqlMemoryMode = false;
                };
                /**
                 * Gets sql stored in the memory. Parameters in the sql are already replaced.
                 */
                OracleQueryRunner.prototype.getMemorySql = function () {
                    return this.sqlsInMemory;
                };
                Object.defineProperty(OracleQueryRunner.prototype, "dbName", {
                    // -------------------------------------------------------------------------
                    // Protected Methods
                    // -------------------------------------------------------------------------
                    /**
                     * Database name shortcut.
                     */
                    get: function () {
                        return this.driver.options.schema;
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Parametrizes given object of values. Used to create column=value queries.
                 */
                OracleQueryRunner.prototype.parametrize = function (objectLiteral) {
                    return Object.keys(objectLiteral).map(function (key) { return "\"" + key + "\"=:" + key; });
                };
                /**
                 * Builds a query for create column.
                 */
                OracleQueryRunner.prototype.buildCreateColumnSql = function (column) {
                    var c = "\"" + column.name + "\" " + this.connection.driver.createFullType(column);
                    if (column.charset)
                        c += " CHARACTER SET " + column.charset;
                    if (column.collation)
                        c += " COLLATE " + column.collation;
                    if (column.isNullable !== true && !column.isGenerated) // NOT NULL is not supported with GENERATED
                        c += " NOT NULL";
                    // if (column.isPrimary === true && addPrimary)
                    //     c += " PRIMARY KEY";
                    if (column.isGenerated === true) // don't use skipPrimary here since updates can update already exist primary without auto inc.
                        c += " GENERATED BY DEFAULT ON NULL AS IDENTITY";
                    // if (column.comment) // todo: less priority, fix it later
                    //     c += " COMMENT '" + column.comment + "'";
                    if (column.default !== undefined && column.default !== null) { // todo: same code in all drivers. make it DRY
                        c += " DEFAULT " + column.default;
                    }
                    return c;
                };
                return OracleQueryRunner;
            }());
            exports_105("OracleQueryRunner", OracleQueryRunner);
        }
    };
});
System.register("typeorm/driver/oracle/OracleDriver", ["typeorm/error/ConnectionIsNotSetError", "typeorm/error/DriverPackageNotInstalledError", "typeorm/driver/oracle/OracleQueryRunner", "typeorm/util/DateUtils", "typeorm/platform/PlatformTools", "typeorm/schema-builder/RdbmsSchemaBuilder", "typeorm/driver/DriverUtils"], function (exports_106, context_106) {
    "use strict";
    var __moduleName = context_106 && context_106.id;
    var ConnectionIsNotSetError_2, DriverPackageNotInstalledError_2, OracleQueryRunner_1, DateUtils_3, PlatformTools_4, RdbmsSchemaBuilder_2, DriverUtils_1, OracleDriver;
    return {
        setters: [
            function (ConnectionIsNotSetError_2_1) {
                ConnectionIsNotSetError_2 = ConnectionIsNotSetError_2_1;
            },
            function (DriverPackageNotInstalledError_2_1) {
                DriverPackageNotInstalledError_2 = DriverPackageNotInstalledError_2_1;
            },
            function (OracleQueryRunner_1_1) {
                OracleQueryRunner_1 = OracleQueryRunner_1_1;
            },
            function (DateUtils_3_1) {
                DateUtils_3 = DateUtils_3_1;
            },
            function (PlatformTools_4_1) {
                PlatformTools_4 = PlatformTools_4_1;
            },
            function (RdbmsSchemaBuilder_2_1) {
                RdbmsSchemaBuilder_2 = RdbmsSchemaBuilder_2_1;
            },
            function (DriverUtils_1_1) {
                DriverUtils_1 = DriverUtils_1_1;
            }
        ],
        execute: function () {
            /**
             * Organizes communication with Oracle RDBMS.
             *
             * todo: this driver is not 100% finished yet, need to fix all issues that are left
             */
            OracleDriver = /** @class */ (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function OracleDriver(connection) {
                    /**
                     * Pool for slave databases.
                     * Used in replication.
                     */
                    this.slaves = [];
                    /**
                     * Indicates if replication is enabled.
                     */
                    this.isReplicated = false;
                    /**
                     * Indicates if tree tables are supported by this driver.
                     */
                    this.treeSupport = true;
                    /**
                     * Gets list of supported column data types by a driver.
                     *
                     * @see https://www.techonthenet.com/oracle/datatypes.php
                     * @see https://docs.oracle.com/cd/B28359_01/server.111/b28318/datatype.htm#CNCPT012
                     */
                    this.supportedDataTypes = [
                        "char",
                        "nchar",
                        "nvarchar2",
                        "varchar2",
                        "long",
                        "raw",
                        "long raw",
                        "number",
                        "numeric",
                        "dec",
                        "decimal",
                        "integer",
                        "int",
                        "smallint",
                        "real",
                        "double precision",
                        "date",
                        "timestamp",
                        "timestamp with time zone",
                        "timestamp with local time zone",
                        "interval year",
                        "interval day",
                        "bfile",
                        "blob",
                        "clob",
                        "nclob",
                        "rowid",
                        "urowid"
                    ];
                    /**
                     * Gets list of column data types that support length by a driver.
                     */
                    this.withLengthColumnTypes = [
                        "char",
                        "nchar",
                        "nvarchar2",
                        "varchar2"
                    ];
                    /**
                     * Orm has special columns and we need to know what database column types should be for those types.
                     * Column types are driver dependant.
                     */
                    this.mappedDataTypes = {
                        createDate: "datetime",
                        createDateDefault: "CURRENT_TIMESTAMP",
                        updateDate: "datetime",
                        updateDateDefault: "CURRENT_TIMESTAMP",
                        version: "number",
                        treeLevel: "number",
                        migrationName: "nvarchar",
                        migrationTimestamp: "timestamp",
                        cacheId: "int",
                        cacheIdentifier: "nvarchar",
                        cacheTime: "timestamp",
                        cacheDuration: "int",
                        cacheQuery: "text",
                        cacheResult: "text",
                    };
                    this.connection = connection;
                    this.options = connection.options;
                    // load oracle package
                    this.loadDependencies();
                    // extra oracle setup
                    this.oracle.outFormat = this.oracle.OBJECT;
                    // Object.assign(connection.options, DriverUtils.buildDriverOptions(connection.options)); // todo: do it better way
                    // validate options to make sure everything is set
                    // if (!this.options.host)
                    //     throw new DriverOptionNotSetError("host");
                    // if (!this.options.username)
                    //     throw new DriverOptionNotSetError("username");
                    // if (!this.options.sid)
                    //     throw new DriverOptionNotSetError("sid");
                    //
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Performs connection to the database.
                 * Based on pooling options, it can either create connection immediately,
                 * either create a pool and create connection when needed.
                 */
                OracleDriver.prototype.connect = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var _a, _b, _c;
                        return __generator(this, function (_d) {
                            switch (_d.label) {
                                case 0:
                                    if (!this.options.replication) return [3 /*break*/, 3];
                                    _a = this;
                                    return [4 /*yield*/, Promise.all(this.options.replication.slaves.map(function (slave) {
                                            return _this.createPool(_this.options, slave);
                                        }))];
                                case 1:
                                    _a.slaves = _d.sent();
                                    _b = this;
                                    return [4 /*yield*/, this.createPool(this.options, this.options.replication.master)];
                                case 2:
                                    _b.master = _d.sent();
                                    this.database = this.options.replication.master.database;
                                    return [3 /*break*/, 5];
                                case 3:
                                    _c = this;
                                    return [4 /*yield*/, this.createPool(this.options, this.options)];
                                case 4:
                                    _c.master = _d.sent();
                                    this.database = this.options.database;
                                    _d.label = 5;
                                case 5: return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Makes any action after connection (e.g. create extensions in Postgres driver).
                 */
                OracleDriver.prototype.afterConnect = function () {
                    return Promise.resolve();
                };
                /**
                 * Closes connection with the database.
                 */
                OracleDriver.prototype.disconnect = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (!this.master)
                                        return [2 /*return*/, Promise.reject(new ConnectionIsNotSetError_2.ConnectionIsNotSetError("oracle"))];
                                    return [4 /*yield*/, this.closePool(this.master)];
                                case 1:
                                    _a.sent();
                                    return [4 /*yield*/, Promise.all(this.slaves.map(function (slave) { return _this.closePool(slave); }))];
                                case 2:
                                    _a.sent();
                                    this.master = undefined;
                                    this.slaves = [];
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Creates a schema builder used to build and sync a schema.
                 */
                OracleDriver.prototype.createSchemaBuilder = function () {
                    return new RdbmsSchemaBuilder_2.RdbmsSchemaBuilder(this.connection);
                };
                /**
                 * Creates a query runner used to execute database queries.
                 */
                OracleDriver.prototype.createQueryRunner = function (mode) {
                    if (mode === void 0) { mode = "master"; }
                    return new OracleQueryRunner_1.OracleQueryRunner(this, mode);
                };
                /**
                 * Replaces parameters in the given sql with special escaping character
                 * and an array of parameter names to be passed to a query.
                 */
                OracleDriver.prototype.escapeQueryWithParameters = function (sql, parameters) {
                    if (!parameters || !Object.keys(parameters).length)
                        return [sql, []];
                    var escapedParameters = [];
                    var keys = Object.keys(parameters).map(function (parameter) { return "(:" + parameter + "\\b)"; }).join("|");
                    sql = sql.replace(new RegExp(keys, "g"), function (key) {
                        var value = parameters[key.substr(1)];
                        if (value instanceof Function) {
                            return value();
                        }
                        else {
                            escapedParameters.push(value);
                            return key;
                        }
                    }); // todo: make replace only in value statements, otherwise problems
                    return [sql, escapedParameters];
                };
                /**
                 * Escapes a column name.
                 */
                OracleDriver.prototype.escape = function (columnName) {
                    return "\"" + columnName + "\"";
                };
                /**
                 * Prepares given value to a value to be persisted, based on its column type and metadata.
                 */
                OracleDriver.prototype.preparePersistentValue = function (value, columnMetadata) {
                    if (columnMetadata.transformer)
                        value = columnMetadata.transformer.to(value);
                    if (value === null || value === undefined)
                        return value;
                    if (columnMetadata.type === Boolean) {
                        return value === true ? 1 : 0;
                    }
                    else if (columnMetadata.type === "date") {
                        return DateUtils_3.DateUtils.mixedDateToDateString(value);
                    }
                    else if (columnMetadata.type === "time") {
                        return DateUtils_3.DateUtils.mixedDateToTimeString(value);
                    }
                    else if (columnMetadata.type === "datetime" || columnMetadata.type === Date) {
                        return DateUtils_3.DateUtils.mixedDateToUtcDatetimeString(value);
                    }
                    else if (columnMetadata.type === "json") {
                        return JSON.stringify(value);
                    }
                    else if (columnMetadata.type === "simple-array") {
                        return DateUtils_3.DateUtils.simpleArrayToString(value);
                    }
                    else if (columnMetadata.type === "simple-json") {
                        return DateUtils_3.DateUtils.simpleJsonToString(value);
                    }
                    return value;
                };
                /**
                 * Prepares given value to a value to be persisted, based on its column type or metadata.
                 */
                OracleDriver.prototype.prepareHydratedValue = function (value, columnMetadata) {
                    if (value === null || value === undefined)
                        return value;
                    if (columnMetadata.type === Boolean) {
                        value = value ? true : false;
                    }
                    else if (columnMetadata.type === "datetime") {
                        value = DateUtils_3.DateUtils.normalizeHydratedDate(value);
                    }
                    else if (columnMetadata.type === "date") {
                        value = DateUtils_3.DateUtils.mixedDateToDateString(value);
                    }
                    else if (columnMetadata.type === "time") {
                        value = DateUtils_3.DateUtils.mixedTimeToString(value);
                    }
                    else if (columnMetadata.type === "json") {
                        value = JSON.parse(value);
                    }
                    else if (columnMetadata.type === "simple-array") {
                        value = DateUtils_3.DateUtils.stringToSimpleArray(value);
                    }
                    else if (columnMetadata.type === "simple-json") {
                        value = DateUtils_3.DateUtils.stringToSimpleJson(value);
                    }
                    if (columnMetadata.transformer)
                        value = columnMetadata.transformer.from(value);
                    return value;
                };
                /**
                 * Creates a database type from a given column metadata.
                 */
                OracleDriver.prototype.normalizeType = function (column) {
                    var type = "";
                    if (column.type === Number) {
                        type += "integer";
                    }
                    else if (column.type === String) {
                        type += "nvarchar2";
                    }
                    else if (column.type === Date) {
                        type += "timestamp(0)";
                    }
                    else if (column.type === Boolean) {
                        type += "number(1)";
                    }
                    else if (column.type === "simple-array") {
                        type += "text";
                    }
                    else if (column.type === "simple-json") {
                        type += "text";
                    }
                    else {
                        type += column.type;
                    }
                    return type;
                };
                /**
                 * Normalizes "default" value of the column.
                 */
                OracleDriver.prototype.normalizeDefault = function (column) {
                    if (typeof column.default === "number") {
                        return "" + column.default;
                    }
                    else if (typeof column.default === "boolean") {
                        return column.default === true ? "true" : "false";
                    }
                    else if (typeof column.default === "function") {
                        return column.default();
                    }
                    else if (typeof column.default === "string") {
                        return "'" + column.default + "'";
                    }
                    else {
                        return column.default;
                    }
                };
                /**
                 * Normalizes "isUnique" value of the column.
                 */
                OracleDriver.prototype.normalizeIsUnique = function (column) {
                    return column.isUnique;
                };
                /**
                 * Calculates column length taking into account the default length values.
                 */
                OracleDriver.prototype.getColumnLength = function (column) {
                    if (column.length)
                        return column.length;
                    var normalizedType = this.normalizeType(column);
                    if (this.dataTypeDefaults && this.dataTypeDefaults[normalizedType] && this.dataTypeDefaults[normalizedType].length)
                        return this.dataTypeDefaults[normalizedType].length.toString();
                    return "";
                };
                OracleDriver.prototype.createFullType = function (column) {
                    var type = column.type;
                    if (column.length) {
                        type += "(" + column.length + ")";
                    }
                    else if (column.precision && column.scale) {
                        type += "(" + column.precision + "," + column.scale + ")";
                    }
                    else if (column.precision) {
                        type += "(" + column.precision + ")";
                    }
                    else if (column.scale) {
                        type += "(" + column.scale + ")";
                    }
                    else if (this.dataTypeDefaults && this.dataTypeDefaults[column.type] && this.dataTypeDefaults[column.type].length) {
                        type += "(" + this.dataTypeDefaults[column.type].length.toString() + ")";
                    }
                    if (column.isArray)
                        type += " array";
                    return type;
                };
                /**
                 * Obtains a new database connection to a master server.
                 * Used for replication.
                 * If replication is not setup then returns default connection's database connection.
                 */
                OracleDriver.prototype.obtainMasterConnection = function () {
                    var _this = this;
                    return new Promise(function (ok, fail) {
                        _this.master.getConnection(function (err, connection, release) {
                            if (err)
                                return fail(err);
                            ok(connection);
                        });
                    });
                };
                /**
                 * Obtains a new database connection to a slave server.
                 * Used for replication.
                 * If replication is not setup then returns master (default) connection's database connection.
                 */
                OracleDriver.prototype.obtainSlaveConnection = function () {
                    var _this = this;
                    if (!this.slaves.length)
                        return this.obtainMasterConnection();
                    return new Promise(function (ok, fail) {
                        var random = Math.floor(Math.random() * _this.slaves.length);
                        _this.slaves[random].getConnection(function (err, connection) {
                            if (err)
                                return fail(err);
                            ok(connection);
                        });
                    });
                };
                // -------------------------------------------------------------------------
                // Protected Methods
                // -------------------------------------------------------------------------
                /**
                 * Loads all driver dependencies.
                 */
                OracleDriver.prototype.loadDependencies = function () {
                    try {
                        this.oracle = PlatformTools_4.PlatformTools.load("oracledb");
                    }
                    catch (e) {
                        throw new DriverPackageNotInstalledError_2.DriverPackageNotInstalledError("Oracle", "oracledb");
                    }
                };
                /**
                 * Creates a new connection pool for a given database credentials.
                 */
                OracleDriver.prototype.createPool = function (options, credentials) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var connectionOptions;
                        return __generator(this, function (_a) {
                            credentials = Object.assign(credentials, DriverUtils_1.DriverUtils.buildDriverOptions(credentials)); // todo: do it better way
                            connectionOptions = Object.assign({}, {
                                user: credentials.username,
                                password: credentials.password,
                                connectString: credentials.host + ":" + credentials.port + "/" + credentials.sid,
                            }, options.extra || {});
                            // pooling is enabled either when its set explicitly to true,
                            // either when its not defined at all (e.g. enabled by default)
                            return [2 /*return*/, new Promise(function (ok, fail) {
                                    _this.oracle.createPool(connectionOptions, function (err, pool) {
                                        if (err)
                                            return fail(err);
                                        ok(pool);
                                    });
                                })];
                        });
                    });
                };
                /**
                 * Closes connection pool.
                 */
                OracleDriver.prototype.closePool = function (pool) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            return [2 /*return*/, new Promise(function (ok, fail) {
                                    pool.close(function (err) { return err ? fail(err) : ok(); });
                                    pool = undefined;
                                })];
                        });
                    });
                };
                return OracleDriver;
            }());
            exports_106("OracleDriver", OracleDriver);
        }
    };
});
System.register("typeorm/schema-builder/schema/Table", ["typeorm/schema-builder/schema/TableColumn", "typeorm/driver/sqlite-abstract/AbstractSqliteDriver", "typeorm/driver/mysql/MysqlDriver", "typeorm/driver/oracle/OracleDriver"], function (exports_107, context_107) {
    "use strict";
    var __moduleName = context_107 && context_107.id;
    var TableColumn_4, AbstractSqliteDriver_1, MysqlDriver_1, OracleDriver_1, Table;
    return {
        setters: [
            function (TableColumn_4_1) {
                TableColumn_4 = TableColumn_4_1;
            },
            function (AbstractSqliteDriver_1_1) {
                AbstractSqliteDriver_1 = AbstractSqliteDriver_1_1;
            },
            function (MysqlDriver_1_1) {
                MysqlDriver_1 = MysqlDriver_1_1;
            },
            function (OracleDriver_1_1) {
                OracleDriver_1 = OracleDriver_1_1;
            }
        ],
        execute: function () {
            /**
             * Table in the database represented in this class.
             */
            Table = /** @class */ (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function Table(name, columns, justCreated, engine, database, schema) {
                    /**
                     * Table columns.
                     */
                    this.columns = [];
                    /**
                     * Table indices.
                     */
                    this.indices = [];
                    /**
                     * Table foreign keys.
                     */
                    this.foreignKeys = [];
                    /**
                     * Table primary keys.
                     */
                    this.primaryKeys = [];
                    /**
                     * Indicates if table was just created.
                     * This is needed, for example to check if we need to skip primary keys creation
                     * for new tables.
                     */
                    this.justCreated = false;
                    this.name = name;
                    if (columns) {
                        this.columns = columns.map(function (column) {
                            if (column instanceof TableColumn_4.TableColumn) {
                                return column;
                            }
                            else {
                                return new TableColumn_4.TableColumn(column);
                            }
                        });
                    }
                    if (justCreated !== undefined)
                        this.justCreated = justCreated;
                    this.engine = engine;
                    this.database = database;
                    this.schema = schema;
                }
                Object.defineProperty(Table.prototype, "primaryKeysWithoutGenerated", {
                    // -------------------------------------------------------------------------
                    // Accessors
                    // -------------------------------------------------------------------------
                    /**
                     * Gets only those primary keys that does not
                     */
                    get: function () {
                        var generatedColumn = this.columns.find(function (column) { return column.isGenerated; });
                        if (!generatedColumn)
                            return this.primaryKeys;
                        return this.primaryKeys.filter(function (primaryKey) {
                            return primaryKey.columnName !== generatedColumn.name;
                        });
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Table.prototype, "hasGeneratedColumn", {
                    get: function () {
                        return !!this.columns.find(function (column) { return column.isGenerated; });
                    },
                    enumerable: true,
                    configurable: true
                });
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Clones this table to a new table with all properties cloned.
                 */
                Table.prototype.clone = function () {
                    var cloned = new Table(this.name);
                    cloned.columns = this.columns.map(function (column) { return column.clone(); });
                    cloned.indices = this.indices.map(function (index) { return index.clone(); });
                    cloned.foreignKeys = this.foreignKeys.map(function (key) { return key.clone(); });
                    cloned.primaryKeys = this.primaryKeys.map(function (key) { return key.clone(); });
                    cloned.engine = this.engine;
                    cloned.database = this.database;
                    cloned.schema = this.schema;
                    return cloned;
                };
                /**
                 * Adds columns.
                 */
                Table.prototype.addColumns = function (columns) {
                    this.columns = this.columns.concat(columns);
                };
                /**
                 * Replaces given column.
                 */
                Table.prototype.replaceColumn = function (oldColumn, newColumn) {
                    this.columns[this.columns.indexOf(oldColumn)] = newColumn;
                };
                /**
                 * Removes a columns from this table.
                 */
                Table.prototype.removeColumn = function (columnToRemove) {
                    var foundColumn = this.columns.find(function (column) { return column.name === columnToRemove.name; });
                    if (foundColumn)
                        this.columns.splice(this.columns.indexOf(foundColumn), 1);
                };
                /**
                 * Remove all columns from this table.
                 */
                Table.prototype.removeColumns = function (columns) {
                    var _this = this;
                    columns.forEach(function (column) { return _this.removeColumn(column); });
                };
                /**
                 * Adds all given primary keys.
                 */
                Table.prototype.addPrimaryKeys = function (addedKeys) {
                    var _this = this;
                    addedKeys.forEach(function (key) {
                        _this.primaryKeys.push(key);
                        var index = _this.columns.findIndex(function (column) { return column.name === key.columnName; });
                        if (index !== -1) {
                            _this.columns[index].isPrimary = true;
                        }
                    });
                };
                /**
                 * Removes all given primary keys.
                 */
                Table.prototype.removePrimaryKeys = function (droppedKeys) {
                    var _this = this;
                    droppedKeys.forEach(function (key) {
                        _this.primaryKeys.splice(_this.primaryKeys.indexOf(key), 1);
                        var index = _this.columns.findIndex(function (column) { return column.name === key.columnName; });
                        if (index !== -1) {
                            _this.columns[index].isPrimary = false;
                        }
                    });
                };
                /**
                 * Removes primary keys of the given columns.
                 */
                Table.prototype.removePrimaryKeysOfColumns = function (columns) {
                    this.primaryKeys = this.primaryKeys.filter(function (primaryKey) {
                        return !columns.find(function (column) { return column.name === primaryKey.columnName; });
                    });
                };
                /**
                 * Adds foreign keys.
                 */
                Table.prototype.addForeignKeys = function (foreignKeys) {
                    this.foreignKeys = this.foreignKeys.concat(foreignKeys);
                };
                /**
                 * Removes foreign key from this table.
                 */
                Table.prototype.removeForeignKey = function (removedForeignKey) {
                    var fk = this.foreignKeys.find(function (foreignKey) { return foreignKey.name === removedForeignKey.name; }); // this must be by name
                    if (fk)
                        this.foreignKeys.splice(this.foreignKeys.indexOf(fk), 1);
                };
                /**
                 * Removes all foreign keys from this table.
                 */
                Table.prototype.removeForeignKeys = function (dbForeignKeys) {
                    var _this = this;
                    dbForeignKeys.forEach(function (foreignKey) { return _this.removeForeignKey(foreignKey); });
                };
                /**
                 * Removes indices from this table.
                 */
                Table.prototype.removeIndex = function (tableIndex) {
                    var index = this.indices.find(function (index) { return index.name === tableIndex.name; });
                    if (index)
                        this.indices.splice(this.indices.indexOf(index), 1);
                };
                /**
                 * Differentiate columns of this table and columns from the given column metadatas columns
                 * and returns only changed.
                 */
                Table.prototype.findChangedColumns = function (driver, columnMetadatas) {
                    var _this = this;
                    return this.columns.filter(function (tableColumn) {
                        var columnMetadata = columnMetadatas.find(function (columnMetadata) { return columnMetadata.databaseName === tableColumn.name; });
                        if (!columnMetadata)
                            return false; // we don't need new columns, we only need exist and changed
                        // console.log(tableColumn.name, "!==", columnMetadata.databaseName); //  ||
                        // console.log(tableColumn.type, "!==", driver.normalizeType(columnMetadata)); // ||
                        // console.log(tableColumn.comment, "!==", columnMetadata.comment); //  ||
                        // console.log(this.compareDefaultValues(driver.normalizeDefault(columnMetadata), tableColumn.default)); // || // we included check for generated here, because generated columns already can have default values
                        // console.log(tableColumn.isNullable, "!==", columnMetadata.isNullable); //  ||
                        // console.log(tableColumn.isUnique, "!==", columnMetadata.isUnique); //  ||
                        // console.log(tableColumn.isGenerated, "!==", columnMetadata.isGenerated);
                        var skipGenerationCheck = columnMetadata.generationStrategy === "uuid" && (driver instanceof AbstractSqliteDriver_1.AbstractSqliteDriver || driver instanceof MysqlDriver_1.MysqlDriver || driver instanceof OracleDriver_1.OracleDriver);
                        return tableColumn.name !== columnMetadata.databaseName ||
                            tableColumn.type !== driver.normalizeType(columnMetadata) ||
                            tableColumn.comment !== columnMetadata.comment ||
                            (!tableColumn.isGenerated && !_this.compareDefaultValues(driver.normalizeDefault(columnMetadata), tableColumn.default)) || // we included check for generated here, because generated columns already can have default values
                            tableColumn.isNullable !== columnMetadata.isNullable ||
                            tableColumn.isUnique !== driver.normalizeIsUnique(columnMetadata) ||
                            // tableColumn.isPrimary !== columnMetadata.isPrimary ||
                            (skipGenerationCheck === false && tableColumn.isGenerated !== columnMetadata.isGenerated) ||
                            !_this.compareColumnLengths(driver, tableColumn, columnMetadata);
                    });
                };
                Table.prototype.findColumnByName = function (name) {
                    return this.columns.find(function (column) { return column.name === name; });
                };
                // -------------------------------------------------------------------------
                // Protected Methods
                // -------------------------------------------------------------------------
                /**
                 * Compare column lengths only if the datatype supports it.
                 */
                Table.prototype.compareColumnLengths = function (driver, tableColumn, columnMetadata) {
                    var normalizedColumn = driver.normalizeType(columnMetadata);
                    if (driver.withLengthColumnTypes.indexOf(normalizedColumn) !== -1) {
                        var metadataLength = driver.getColumnLength(columnMetadata);
                        // if we found something to compare with then do it, else skip it
                        // use use case insensitive comparison to catch "MAX" vs "Max" case
                        if (metadataLength)
                            return tableColumn.length.toLowerCase() === metadataLength.toLowerCase();
                    }
                    return true;
                };
                /**
                 * Checks if "DEFAULT" values in the column metadata and in the database are equal.
                 */
                Table.prototype.compareDefaultValues = function (columnMetadataValue, databaseValue) {
                    // if (typeof columnMetadataValue === "number")
                    //     return columnMetadataValue === parseInt(databaseValue);
                    // if (typeof columnMetadataValue === "boolean")
                    //     return columnMetadataValue === (!!databaseValue || databaseValue === "false");
                    // if (typeof columnMetadataValue === "function")
                    // if (typeof columnMetadataValue === "string" && typeof databaseValue === "string")
                    //     return columnMetadataValue.toLowerCase() === databaseValue.toLowerCase();
                    if (typeof columnMetadataValue === "string" && typeof databaseValue === "string") {
                        // we need to cut out "((x))" where x number generated by mssql
                        columnMetadataValue = columnMetadataValue.replace(/\(\([0-9.]*\)\)$/g, "$1");
                        databaseValue = databaseValue.replace(/\(\(([0-9.]*?)\)\)$/g, "$1");
                        // we need to cut out "(" because in mssql we can understand returned value is a string or a function
                        // as result compare cannot understand if default is really changed or not
                        columnMetadataValue = columnMetadataValue.replace(/^\(|\)$/g, "");
                        databaseValue = databaseValue.replace(/^\(|\)$/g, "");
                        // we need to cut out "'" because in mysql we can understand returned value is a string or a function
                        // as result compare cannot understand if default is really changed or not
                        columnMetadataValue = columnMetadataValue.replace(/^'+|'+$/g, "");
                        databaseValue = databaseValue.replace(/^'+|'+$/g, "");
                    }
                    // console.log("columnMetadataValue", columnMetadataValue);
                    // console.log("databaseValue", databaseValue);
                    return columnMetadataValue === databaseValue;
                };
                // -------------------------------------------------------------------------
                // Static Methods
                // -------------------------------------------------------------------------
                /**
                 * Creates table from a given entity metadata.
                 *
                 * todo: need deeper implementation
                 */
                Table.create = function (entityMetadata, driver) {
                    var table = new Table(entityMetadata.tableName);
                    table.engine = entityMetadata.engine;
                    table.database = entityMetadata.database;
                    table.schema = entityMetadata.schema;
                    entityMetadata.columns.forEach(function (column) {
                        var tableColumn = TableColumn_4.TableColumn.create(column, driver.normalizeType(column), driver.normalizeDefault(column), driver.getColumnLength(column));
                        table.columns.push(tableColumn);
                    });
                    return table;
                };
                return Table;
            }());
            exports_107("Table", Table);
        }
    };
});
System.register("typeorm/driver/mysql/MysqlQueryRunner", ["typeorm/error/TransactionAlreadyStartedError", "typeorm/error/TransactionNotStartedError", "typeorm/schema-builder/schema/TableColumn", "typeorm/schema-builder/schema/Table", "typeorm/schema-builder/schema/TableForeignKey", "typeorm/schema-builder/schema/TablePrimaryKey", "typeorm/schema-builder/schema/TableIndex", "typeorm/error/QueryRunnerAlreadyReleasedError", "typeorm/util/OrmUtils", "typeorm/error/QueryFailedError"], function (exports_108, context_108) {
    "use strict";
    var __moduleName = context_108 && context_108.id;
    var TransactionAlreadyStartedError_3, TransactionNotStartedError_3, TableColumn_5, Table_4, TableForeignKey_4, TablePrimaryKey_4, TableIndex_4, QueryRunnerAlreadyReleasedError_2, OrmUtils_3, QueryFailedError_2, MysqlQueryRunner;
    return {
        setters: [
            function (TransactionAlreadyStartedError_3_1) {
                TransactionAlreadyStartedError_3 = TransactionAlreadyStartedError_3_1;
            },
            function (TransactionNotStartedError_3_1) {
                TransactionNotStartedError_3 = TransactionNotStartedError_3_1;
            },
            function (TableColumn_5_1) {
                TableColumn_5 = TableColumn_5_1;
            },
            function (Table_4_1) {
                Table_4 = Table_4_1;
            },
            function (TableForeignKey_4_1) {
                TableForeignKey_4 = TableForeignKey_4_1;
            },
            function (TablePrimaryKey_4_1) {
                TablePrimaryKey_4 = TablePrimaryKey_4_1;
            },
            function (TableIndex_4_1) {
                TableIndex_4 = TableIndex_4_1;
            },
            function (QueryRunnerAlreadyReleasedError_2_1) {
                QueryRunnerAlreadyReleasedError_2 = QueryRunnerAlreadyReleasedError_2_1;
            },
            function (OrmUtils_3_1) {
                OrmUtils_3 = OrmUtils_3_1;
            },
            function (QueryFailedError_2_1) {
                QueryFailedError_2 = QueryFailedError_2_1;
            }
        ],
        execute: function () {
            /**
             * Runs queries on a single mysql database connection.
             */
            MysqlQueryRunner = /** @class */ (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function MysqlQueryRunner(driver, mode) {
                    if (mode === void 0) { mode = "master"; }
                    /**
                     * Indicates if connection for this query runner is released.
                     * Once its released, query runner cannot run queries anymore.
                     */
                    this.isReleased = false;
                    /**
                     * Indicates if transaction is in progress.
                     */
                    this.isTransactionActive = false;
                    /**
                     * Stores temporarily user data.
                     * Useful for sharing data with subscribers.
                     */
                    this.data = {};
                    /**
                     * Indicates if special query runner mode in which sql queries won't be executed is enabled.
                     */
                    this.sqlMemoryMode = false;
                    /**
                     * Sql-s stored if "sql in memory" mode is enabled.
                     */
                    this.sqlsInMemory = [];
                    this.driver = driver;
                    this.connection = driver.connection;
                    this.mode = mode;
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Creates/uses database connection from the connection pool to perform further operations.
                 * Returns obtained database connection.
                 */
                MysqlQueryRunner.prototype.connect = function () {
                    var _this = this;
                    if (this.databaseConnection)
                        return Promise.resolve(this.databaseConnection);
                    if (this.databaseConnectionPromise)
                        return this.databaseConnectionPromise;
                    if (this.mode === "slave" && this.driver.isReplicated) {
                        this.databaseConnectionPromise = this.driver.obtainSlaveConnection().then(function (connection) {
                            _this.databaseConnection = connection;
                            return _this.databaseConnection;
                        });
                    }
                    else { // master
                        this.databaseConnectionPromise = this.driver.obtainMasterConnection().then(function (connection) {
                            _this.databaseConnection = connection;
                            return _this.databaseConnection;
                        });
                    }
                    return this.databaseConnectionPromise;
                };
                /**
                 * Releases used database connection.
                 * You cannot use query runner methods once its released.
                 */
                MysqlQueryRunner.prototype.release = function () {
                    this.isReleased = true;
                    if (this.databaseConnection)
                        this.databaseConnection.release();
                    return Promise.resolve();
                };
                /**
                 * Starts transaction on the current connection.
                 */
                MysqlQueryRunner.prototype.startTransaction = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isTransactionActive)
                                        throw new TransactionAlreadyStartedError_3.TransactionAlreadyStartedError();
                                    this.isTransactionActive = true;
                                    return [4 /*yield*/, this.query("START TRANSACTION")];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Commits transaction.
                 * Error will be thrown if transaction was not started.
                 */
                MysqlQueryRunner.prototype.commitTransaction = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (!this.isTransactionActive)
                                        throw new TransactionNotStartedError_3.TransactionNotStartedError();
                                    return [4 /*yield*/, this.query("COMMIT")];
                                case 1:
                                    _a.sent();
                                    this.isTransactionActive = false;
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Rollbacks transaction.
                 * Error will be thrown if transaction was not started.
                 */
                MysqlQueryRunner.prototype.rollbackTransaction = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (!this.isTransactionActive)
                                        throw new TransactionNotStartedError_3.TransactionNotStartedError();
                                    return [4 /*yield*/, this.query("ROLLBACK")];
                                case 1:
                                    _a.sent();
                                    this.isTransactionActive = false;
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Executes a raw SQL query.
                 */
                MysqlQueryRunner.prototype.query = function (query, parameters) {
                    var _this = this;
                    if (this.isReleased)
                        throw new QueryRunnerAlreadyReleasedError_2.QueryRunnerAlreadyReleasedError();
                    return new Promise(function (ok, fail) { return __awaiter(_this, void 0, void 0, function () {
                        var _this = this;
                        var databaseConnection, queryStartTime_2, err_3;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    _a.trys.push([0, 2, , 3]);
                                    return [4 /*yield*/, this.connect()];
                                case 1:
                                    databaseConnection = _a.sent();
                                    this.driver.connection.logger.logQuery(query, parameters, this);
                                    queryStartTime_2 = +new Date();
                                    databaseConnection.query(query, parameters, function (err, result) {
                                        // log slow queries if maxQueryExecution time is set
                                        var maxQueryExecutionTime = _this.driver.connection.options.maxQueryExecutionTime;
                                        var queryEndTime = +new Date();
                                        var queryExecutionTime = queryEndTime - queryStartTime_2;
                                        if (maxQueryExecutionTime && queryExecutionTime > maxQueryExecutionTime)
                                            _this.driver.connection.logger.logQuerySlow(queryExecutionTime, query, parameters, _this);
                                        if (err) {
                                            _this.driver.connection.logger.logQueryError(err, query, parameters, _this);
                                            return fail(new QueryFailedError_2.QueryFailedError(query, parameters, err));
                                        }
                                        ok(result);
                                    });
                                    return [3 /*break*/, 3];
                                case 2:
                                    err_3 = _a.sent();
                                    fail(err_3);
                                    return [3 /*break*/, 3];
                                case 3: return [2 /*return*/];
                            }
                        });
                    }); });
                };
                /**
                 * Returns raw data stream.
                 */
                MysqlQueryRunner.prototype.stream = function (query, parameters, onEnd, onError) {
                    var _this = this;
                    if (this.isReleased)
                        throw new QueryRunnerAlreadyReleasedError_2.QueryRunnerAlreadyReleasedError();
                    return new Promise(function (ok, fail) { return __awaiter(_this, void 0, void 0, function () {
                        var databaseConnection, stream, err_4;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    _a.trys.push([0, 2, , 3]);
                                    return [4 /*yield*/, this.connect()];
                                case 1:
                                    databaseConnection = _a.sent();
                                    this.driver.connection.logger.logQuery(query, parameters, this);
                                    stream = databaseConnection.query(query, parameters);
                                    if (onEnd)
                                        stream.on("end", onEnd);
                                    if (onError)
                                        stream.on("error", onError);
                                    ok(stream);
                                    return [3 /*break*/, 3];
                                case 2:
                                    err_4 = _a.sent();
                                    fail(err_4);
                                    return [3 /*break*/, 3];
                                case 3: return [2 /*return*/];
                            }
                        });
                    }); });
                };
                /**
                 * Insert a new row with given values into the given table.
                 * Returns value of the generated column if given and generate column exist in the table.
                 */
                MysqlQueryRunner.prototype.insert = function (tablePath, keyValues) {
                    return __awaiter(this, void 0, void 0, function () {
                        var keys, columns, values, parameters, generatedColumns, sql, result, generatedMap;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    keys = Object.keys(keyValues);
                                    columns = keys.map(function (key) { return "`" + key + "`"; }).join(", ");
                                    values = keys.map(function (key) { return "?"; }).join(",");
                                    parameters = keys.map(function (key) { return keyValues[key]; });
                                    generatedColumns = this.connection.hasMetadata(tablePath) ? this.connection.getMetadata(tablePath).generatedColumns : [];
                                    sql = "INSERT INTO `" + this.escapeTablePath(tablePath) + "`(" + columns + ") VALUES (" + values + ")";
                                    return [4 /*yield*/, this.query(sql, parameters)];
                                case 1:
                                    result = _a.sent();
                                    generatedMap = generatedColumns.reduce(function (map, generatedColumn) {
                                        var value = generatedColumn.isPrimary && result.insertId ? result.insertId : keyValues[generatedColumn.databaseName];
                                        if (!value)
                                            return map;
                                        return OrmUtils_3.OrmUtils.mergeDeep(map, generatedColumn.createValueMap(value));
                                    }, {});
                                    return [2 /*return*/, {
                                            result: result,
                                            generatedMap: Object.keys(generatedMap).length > 0 ? generatedMap : undefined
                                        }];
                            }
                        });
                    });
                };
                /**
                 * Updates rows that match given conditions in the given table.
                 */
                MysqlQueryRunner.prototype.update = function (tablePath, valuesMap, conditions) {
                    return __awaiter(this, void 0, void 0, function () {
                        var updateValues, conditionString, sql, conditionParams, updateParams, allParameters;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    updateValues = this.parametrize(valuesMap).join(", ");
                                    conditionString = this.parametrize(conditions).join(" AND ");
                                    sql = "UPDATE `" + this.escapeTablePath(tablePath) + "` SET " + updateValues + " " + (conditionString ? (" WHERE " + conditionString) : "");
                                    conditionParams = Object.keys(conditions).map(function (key) { return conditions[key]; });
                                    updateParams = Object.keys(valuesMap).map(function (key) { return valuesMap[key]; });
                                    allParameters = updateParams.concat(conditionParams);
                                    return [4 /*yield*/, this.query(sql, allParameters)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Deletes from the given table by a given conditions.
                 */
                MysqlQueryRunner.prototype.delete = function (tablePath, conditions, maybeParameters) {
                    return __awaiter(this, void 0, void 0, function () {
                        var conditionString, parameters, sql;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    conditionString = typeof conditions === "string" ? conditions : this.parametrize(conditions).join(" AND ");
                                    parameters = conditions instanceof Object ? Object.keys(conditions).map(function (key) { return conditions[key]; }) : maybeParameters;
                                    sql = "DELETE FROM `" + this.escapeTablePath(tablePath) + "` WHERE " + conditionString;
                                    return [4 /*yield*/, this.query(sql, parameters)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Inserts rows into the closure table.
                 */
                MysqlQueryRunner.prototype.insertIntoClosureTable = function (tablePath, newEntityId, parentId, hasLevel) {
                    return __awaiter(this, void 0, void 0, function () {
                        var results;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (!hasLevel) return [3 /*break*/, 2];
                                    return [4 /*yield*/, this.query("INSERT INTO `" + this.escapeTablePath(tablePath) + "`(`ancestor`, `descendant`, `level`) " +
                                            ("SELECT `ancestor`, " + newEntityId + ", `level` + 1 FROM `" + this.escapeTablePath(tablePath) + "` WHERE `descendant` = " + parentId + " ") +
                                            ("UNION ALL SELECT " + newEntityId + ", " + newEntityId + ", 1"))];
                                case 1:
                                    _a.sent();
                                    return [3 /*break*/, 4];
                                case 2: return [4 /*yield*/, this.query("INSERT INTO `" + this.escapeTablePath(tablePath) + "`(`ancestor`, `descendant`) " +
                                        ("SELECT `ancestor`, " + newEntityId + " FROM `" + this.escapeTablePath(tablePath) + "` WHERE `descendant` = " + parentId + " ") +
                                        ("UNION ALL SELECT " + newEntityId + ", " + newEntityId))];
                                case 3:
                                    _a.sent();
                                    _a.label = 4;
                                case 4:
                                    if (!hasLevel) return [3 /*break*/, 6];
                                    return [4 /*yield*/, this.query("SELECT MAX(`level`) as `level` FROM `" + this.escapeTablePath(tablePath) + "` WHERE `descendant` = " + parentId)];
                                case 5:
                                    results = _a.sent();
                                    return [2 /*return*/, results && results[0] && results[0]["level"] ? parseInt(results[0]["level"]) + 1 : 1];
                                case 6: return [2 /*return*/, -1];
                            }
                        });
                    });
                };
                /**
                 * Loads given table's data from the database.
                 */
                MysqlQueryRunner.prototype.getTable = function (tableName) {
                    return __awaiter(this, void 0, void 0, function () {
                        var tables;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.getTables([tableName])];
                                case 1:
                                    tables = _a.sent();
                                    return [2 /*return*/, tables.length > 0 ? tables[0] : undefined];
                            }
                        });
                    });
                };
                /**
                 * Loads all tables (with given names) from the database and creates a Table from them.
                 */
                MysqlQueryRunner.prototype.getTables = function (tablePaths) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var tableNames, dbNames, databaseNamesString, tableNamesString, tablesSql, columnsSql, indicesSql, foreignKeysSql, _a, dbTables, dbColumns, dbIndices, dbForeignKeys, isMariaDb;
                        return __generator(this, function (_b) {
                            switch (_b.label) {
                                case 0:
                                    if (this.sqlMemoryMode)
                                        throw new Error("Loading table is not supported in sql memory mode");
                                    // if no tables given then no need to proceed
                                    if (!tablePaths || !tablePaths.length)
                                        return [2 /*return*/, []];
                                    tableNames = tablePaths.map(function (tablePath) {
                                        return tablePath.indexOf(".") === -1 ? tablePath : tablePath.split(".")[1];
                                    });
                                    dbNames = tablePaths
                                        .filter(function (tablePath) { return tablePath.indexOf(".") !== -1; })
                                        .map(function (tablePath) { return tablePath.split(".")[0]; });
                                    if (this.driver.database && !dbNames.find(function (dbName) { return dbName === _this.driver.database; }))
                                        dbNames.push(this.driver.database);
                                    databaseNamesString = dbNames.map(function (dbName) { return "'" + dbName + "'"; }).join(", ");
                                    tableNamesString = tableNames.map(function (tableName) { return "'" + tableName + "'"; }).join(", ");
                                    tablesSql = "SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA IN (" + databaseNamesString + ") AND TABLE_NAME IN (" + tableNamesString + ")";
                                    columnsSql = "SELECT * FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_SCHEMA IN (" + databaseNamesString + ")";
                                    indicesSql = "SELECT * FROM INFORMATION_SCHEMA.STATISTICS WHERE TABLE_SCHEMA IN (" + databaseNamesString + ") AND INDEX_NAME != 'PRIMARY' ORDER BY SEQ_IN_INDEX";
                                    foreignKeysSql = "SELECT * FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE WHERE TABLE_SCHEMA IN (" + databaseNamesString + ") AND REFERENCED_COLUMN_NAME IS NOT NULL";
                                    return [4 /*yield*/, Promise.all([
                                            this.query(tablesSql),
                                            this.query(columnsSql),
                                            this.query(indicesSql),
                                            this.query(foreignKeysSql)
                                        ])];
                                case 1:
                                    _a = _b.sent(), dbTables = _a[0], dbColumns = _a[1], dbIndices = _a[2], dbForeignKeys = _a[3];
                                    // if tables were not found in the db, no need to proceed
                                    if (!dbTables.length)
                                        return [2 /*return*/, []];
                                    isMariaDb = this.driver.options.type === "mariadb";
                                    // create tables for loaded tables
                                    return [2 /*return*/, Promise.all(dbTables.map(function (dbTable) { return __awaiter(_this, void 0, void 0, function () {
                                            var table, primaryKeys;
                                            return __generator(this, function (_a) {
                                                switch (_a.label) {
                                                    case 0:
                                                        table = new Table_4.Table(dbTable["TABLE_NAME"]);
                                                        table.database = dbTable["TABLE_SCHEMA"];
                                                        return [4 /*yield*/, this.query("SHOW INDEX FROM `" + dbTable["TABLE_SCHEMA"] + "`.`" + dbTable["TABLE_NAME"] + "` WHERE Key_name = 'PRIMARY'")];
                                                    case 1:
                                                        primaryKeys = _a.sent();
                                                        // create columns from the loaded columns
                                                        table.columns = dbColumns
                                                            .filter(function (dbColumn) { return dbColumn["TABLE_NAME"] === table.name; })
                                                            .map(function (dbColumn) {
                                                            var tableColumn = new TableColumn_5.TableColumn();
                                                            tableColumn.name = dbColumn["COLUMN_NAME"];
                                                            var columnType = dbColumn["COLUMN_TYPE"].toLowerCase();
                                                            var endIndex = columnType.indexOf("(");
                                                            tableColumn.type = endIndex !== -1 ? columnType.substring(0, endIndex) : columnType;
                                                            if (dbColumn["COLUMN_DEFAULT"] === null || dbColumn["COLUMN_DEFAULT"] === undefined
                                                                || (isMariaDb && dbColumn["COLUMN_DEFAULT"] === "NULL")) {
                                                                tableColumn.default = undefined;
                                                            }
                                                            else {
                                                                tableColumn.default = dbColumn["COLUMN_DEFAULT"];
                                                            }
                                                            tableColumn.isNullable = dbColumn["IS_NULLABLE"] === "YES";
                                                            tableColumn.isPrimary = dbColumn["COLUMN_KEY"].indexOf("PRI") !== -1;
                                                            tableColumn.isUnique = dbColumn["COLUMN_KEY"].indexOf("UNI") !== -1;
                                                            tableColumn.isGenerated = dbColumn["EXTRA"].indexOf("auto_increment") !== -1;
                                                            tableColumn.comment = dbColumn["COLUMN_COMMENT"];
                                                            tableColumn.precision = dbColumn["NUMERIC_PRECISION"];
                                                            tableColumn.scale = dbColumn["NUMERIC_SCALE"];
                                                            tableColumn.charset = dbColumn["CHARACTER_SET_NAME"];
                                                            tableColumn.collation = dbColumn["COLLATION_NAME"];
                                                            if (tableColumn.type === "int" || tableColumn.type === "tinyint"
                                                                || tableColumn.type === "smallint" || tableColumn.type === "mediumint"
                                                                || tableColumn.type === "bigint" || tableColumn.type === "year") {
                                                                var length_1 = columnType.substring(columnType.indexOf("(") + 1, columnType.indexOf(")"));
                                                                tableColumn.length = length_1 ? length_1.toString() : "";
                                                            }
                                                            else {
                                                                tableColumn.length = dbColumn["CHARACTER_MAXIMUM_LENGTH"] ? dbColumn["CHARACTER_MAXIMUM_LENGTH"].toString() : "";
                                                            }
                                                            if (tableColumn.type === "enum") {
                                                                var colType = dbColumn["COLUMN_TYPE"];
                                                                var items = colType.substring(colType.indexOf("(") + 1, colType.indexOf(")")).split(",");
                                                                tableColumn.enum = items.map(function (item) {
                                                                    return item.substring(1, item.length - 1);
                                                                });
                                                            }
                                                            if (tableColumn.type === "datetime" || tableColumn.type === "time" || tableColumn.type === "timestamp") {
                                                                tableColumn.precision = dbColumn["DATETIME_PRECISION"];
                                                            }
                                                            return tableColumn;
                                                        });
                                                        // create primary keys
                                                        table.primaryKeys = primaryKeys.map(function (primaryKey) {
                                                            return new TablePrimaryKey_4.TablePrimaryKey(primaryKey["Key_name"], primaryKey["Column_name"]);
                                                        });
                                                        // create foreign key schemas from the loaded indices
                                                        table.foreignKeys = dbForeignKeys
                                                            .filter(function (dbForeignKey) { return dbForeignKey["TABLE_NAME"] === table.name; })
                                                            .map(function (dbForeignKey) { return new TableForeignKey_4.TableForeignKey(dbForeignKey["CONSTRAINT_NAME"], [], [], "", ""); }); // todo: fix missing params
                                                        // create index schemas from the loaded indices
                                                        table.indices = dbIndices
                                                            .filter(function (dbIndex) {
                                                            return dbIndex["TABLE_NAME"] === table.name &&
                                                                (!table.foreignKeys.find(function (foreignKey) { return foreignKey.name === dbIndex["INDEX_NAME"]; })) &&
                                                                (!table.primaryKeys.find(function (primaryKey) { return primaryKey.name === dbIndex["INDEX_NAME"]; }));
                                                        })
                                                            .map(function (dbIndex) { return dbIndex["INDEX_NAME"]; })
                                                            .filter(function (value, index, self) { return self.indexOf(value) === index; }) // unqiue
                                                            .map(function (dbIndexName) {
                                                            var currentDbIndices = dbIndices.filter(function (dbIndex) { return dbIndex["TABLE_NAME"] === table.name && dbIndex["INDEX_NAME"] === dbIndexName; });
                                                            var columnNames = currentDbIndices.map(function (dbIndex) { return dbIndex["COLUMN_NAME"]; });
                                                            // find a special index - unique index and
                                                            if (currentDbIndices.length === 1 && currentDbIndices[0]["NON_UNIQUE"] === 0) {
                                                                var column = table.columns.find(function (column) { return column.name === currentDbIndices[0]["INDEX_NAME"] && column.name === currentDbIndices[0]["COLUMN_NAME"]; });
                                                                if (column) {
                                                                    column.isUnique = true;
                                                                    return;
                                                                }
                                                            }
                                                            return new TableIndex_4.TableIndex(dbTable["TABLE_NAME"], dbIndexName, columnNames, currentDbIndices[0]["NON_UNIQUE"] === 0);
                                                        })
                                                            .filter(function (index) { return !!index; }); // remove empty returns
                                                        return [2 /*return*/, table];
                                                }
                                            });
                                        }); }))];
                            }
                        });
                    });
                };
                /**
                 * Checks if database with the given name exist.
                 */
                MysqlQueryRunner.prototype.hasDatabase = function (database) {
                    return __awaiter(this, void 0, void 0, function () {
                        var result;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.query("SELECT * FROM INFORMATION_SCHEMA.SCHEMATA WHERE SCHEMA_NAME = '" + database + "'")];
                                case 1:
                                    result = _a.sent();
                                    return [2 /*return*/, result.length ? true : false];
                            }
                        });
                    });
                };
                /**
                 * Checks if table with the given name exist in the database.
                 */
                MysqlQueryRunner.prototype.hasTable = function (tableOrPath) {
                    return __awaiter(this, void 0, void 0, function () {
                        var parsedTablePath, sql, result;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    parsedTablePath = this.parseTablePath(tableOrPath);
                                    sql = "SELECT * FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_SCHEMA = '" + parsedTablePath.database + "' AND TABLE_NAME = '" + parsedTablePath.tableName + "'";
                                    return [4 /*yield*/, this.query(sql)];
                                case 1:
                                    result = _a.sent();
                                    return [2 /*return*/, result.length ? true : false];
                            }
                        });
                    });
                };
                /**
                 * Checks if column with the given name exist in the given table.
                 */
                MysqlQueryRunner.prototype.hasColumn = function (tableOrPath, column) {
                    return __awaiter(this, void 0, void 0, function () {
                        var parsedTablePath, columnName, sql, result;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    parsedTablePath = this.parseTablePath(tableOrPath);
                                    columnName = column instanceof TableColumn_5.TableColumn ? column.name : column;
                                    sql = "SELECT * FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_SCHEMA = '" + parsedTablePath.database + "' AND TABLE_NAME = '" + parsedTablePath.tableName + "' AND COLUMN_NAME = '" + columnName + "'";
                                    return [4 /*yield*/, this.query(sql)];
                                case 1:
                                    result = _a.sent();
                                    return [2 /*return*/, result.length ? true : false];
                            }
                        });
                    });
                };
                /**
                 * Creates a database if it's not created.
                 */
                MysqlQueryRunner.prototype.createDatabase = function (database) {
                    return this.query("CREATE DATABASE IF NOT EXISTS " + database); // todo(dima): IT SHOULD NOT EXECUTE "IF NOT EXIST" if user already has a database (privileges issue)
                };
                /**
                 * Creates a schema if it's not created.
                 */
                MysqlQueryRunner.prototype.createSchema = function (schemas) {
                    return Promise.resolve([]);
                };
                /**
                 * Creates a new table from the given table and column inside it.
                 */
                MysqlQueryRunner.prototype.createTable = function (table) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var columnDefinitions, sql, primaryKeyColumns, revertSql;
                        return __generator(this, function (_a) {
                            columnDefinitions = table.columns.map(function (column) { return _this.buildCreateColumnSql(column, false); }).join(", ");
                            sql = "CREATE TABLE `" + this.escapeTablePath(table) + "` (" + columnDefinitions;
                            primaryKeyColumns = table.columns.filter(function (column) { return column.isPrimary && !column.isGenerated; });
                            if (primaryKeyColumns.length > 0)
                                sql += ", PRIMARY KEY(" + primaryKeyColumns.map(function (column) { return "`" + column.name + "`"; }).join(", ") + ")";
                            sql += ") ENGINE=" + (table.engine || "InnoDB");
                            revertSql = "DROP TABLE `" + this.escapeTablePath(table) + "`";
                            return [2 /*return*/, this.schemaQuery(sql, revertSql)];
                        });
                    });
                };
                /**
                 * Drop the table.
                 */
                MysqlQueryRunner.prototype.dropTable = function (tableOrPath) {
                    return __awaiter(this, void 0, void 0, function () {
                        var sql;
                        return __generator(this, function (_a) {
                            sql = "DROP TABLE `" + this.escapeTablePath(tableOrPath) + "`";
                            return [2 /*return*/, this.query(sql)];
                        });
                    });
                };
                /**
                 * Creates a new column from the column in the table.
                 */
                MysqlQueryRunner.prototype.addColumn = function (tableOrPath, column) {
                    return __awaiter(this, void 0, void 0, function () {
                        var sql, revertSql;
                        return __generator(this, function (_a) {
                            sql = "ALTER TABLE `" + this.escapeTablePath(tableOrPath) + "` ADD " + this.buildCreateColumnSql(column, false);
                            revertSql = "ALTER TABLE `" + this.escapeTablePath(tableOrPath) + "` DROP `" + column.name + "`";
                            return [2 /*return*/, this.schemaQuery(sql, revertSql)];
                        });
                    });
                };
                /**
                 * Creates a new columns from the column in the table.
                 */
                MysqlQueryRunner.prototype.addColumns = function (tableOrName, columns) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var queries;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    queries = columns.map(function (column) { return _this.addColumn(tableOrName, column); });
                                    return [4 /*yield*/, Promise.all(queries)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Renames column in the given table.
                 */
                MysqlQueryRunner.prototype.renameColumn = function (tableOrName, oldTableColumnOrName, newTableColumnOrName) {
                    return __awaiter(this, void 0, void 0, function () {
                        var table, oldColumn, newColumn;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    table = undefined;
                                    if (!(tableOrName instanceof Table_4.Table)) return [3 /*break*/, 1];
                                    table = tableOrName;
                                    return [3 /*break*/, 3];
                                case 1: return [4 /*yield*/, this.getTable(tableOrName)];
                                case 2:
                                    table = _a.sent(); // todo: throw exception, this wont work because of sql memory enabled. remove support by table name
                                    if (!table)
                                        throw new Error("Table " + tableOrName + " was not found.");
                                    _a.label = 3;
                                case 3:
                                    oldColumn = undefined;
                                    if (oldTableColumnOrName instanceof TableColumn_5.TableColumn) {
                                        oldColumn = oldTableColumnOrName;
                                    }
                                    else {
                                        oldColumn = table.columns.find(function (column) { return column.name === oldTableColumnOrName; });
                                    }
                                    if (!oldColumn)
                                        throw new Error("Column \"" + oldTableColumnOrName + "\" was not found in the \"" + tableOrName + "\" table.");
                                    newColumn = undefined;
                                    if (newTableColumnOrName instanceof TableColumn_5.TableColumn) {
                                        newColumn = newTableColumnOrName;
                                    }
                                    else {
                                        newColumn = oldColumn.clone();
                                        newColumn.name = newTableColumnOrName;
                                    }
                                    return [2 /*return*/, this.changeColumn(table, oldColumn, newColumn)];
                            }
                        });
                    });
                };
                /**
                 * Changes a column in the table.
                 */
                MysqlQueryRunner.prototype.changeColumn = function (tableOrName, oldTableColumnOrName, newColumn) {
                    return __awaiter(this, void 0, void 0, function () {
                        var table, oldColumn, sql, revertSql;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    table = undefined;
                                    if (!(tableOrName instanceof Table_4.Table)) return [3 /*break*/, 1];
                                    table = tableOrName;
                                    return [3 /*break*/, 3];
                                case 1: return [4 /*yield*/, this.getTable(tableOrName)];
                                case 2:
                                    table = _a.sent();
                                    _a.label = 3;
                                case 3:
                                    if (!table)
                                        throw new Error("Table " + tableOrName + " was not found.");
                                    oldColumn = undefined;
                                    if (oldTableColumnOrName instanceof TableColumn_5.TableColumn) {
                                        oldColumn = oldTableColumnOrName;
                                    }
                                    else {
                                        oldColumn = table.columns.find(function (column) { return column.name === oldTableColumnOrName; });
                                    }
                                    if (!oldColumn)
                                        throw new Error("Column \"" + oldTableColumnOrName + "\" was not found in the \"" + tableOrName + "\" table.");
                                    if (!(newColumn.isUnique === false && oldColumn.isUnique === true)) return [3 /*break*/, 5];
                                    return [4 /*yield*/, this.query("ALTER TABLE `" + this.escapeTablePath(table) + "` DROP INDEX `" + oldColumn.name + "`")];
                                case 4:
                                    _a.sent(); // todo: add revert code
                                    _a.label = 5;
                                case 5:
                                    sql = "ALTER TABLE `" + this.escapeTablePath(table) + "` CHANGE `" + oldColumn.name + "` " + this.buildCreateColumnSql(newColumn, oldColumn.isPrimary);
                                    revertSql = "ALTER TABLE `" + this.escapeTablePath(table) + "` CHANGE `" + oldColumn.name + "` " + this.buildCreateColumnSql(oldColumn, oldColumn.isPrimary);
                                    return [2 /*return*/, this.schemaQuery(sql, revertSql)];
                            }
                        });
                    });
                };
                /**
                 * Changes a column in the table.
                 */
                MysqlQueryRunner.prototype.changeColumns = function (table, changedColumns) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var updatePromises;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    updatePromises = changedColumns.map(function (changedColumn) { return __awaiter(_this, void 0, void 0, function () {
                                        return __generator(this, function (_a) {
                                            return [2 /*return*/, this.changeColumn(table, changedColumn.oldColumn, changedColumn.newColumn)];
                                        });
                                    }); });
                                    return [4 /*yield*/, Promise.all(updatePromises)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Drops column in the table.
                 */
                MysqlQueryRunner.prototype.dropColumn = function (table, column) {
                    return __awaiter(this, void 0, void 0, function () {
                        var sql, revertSql;
                        return __generator(this, function (_a) {
                            sql = "ALTER TABLE `" + this.escapeTablePath(table) + "` DROP `" + column.name + "`";
                            revertSql = "ALTER TABLE `" + this.escapeTablePath(table) + "` ADD " + this.buildCreateColumnSql(column, false);
                            return [2 /*return*/, this.schemaQuery(sql, revertSql)];
                        });
                    });
                };
                /**
                 * Drops the columns in the table.
                 */
                MysqlQueryRunner.prototype.dropColumns = function (table, columns) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var dropPromises;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    dropPromises = columns.map(function (column) { return _this.dropColumn(table, column); });
                                    return [4 /*yield*/, Promise.all(dropPromises)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Updates table's primary keys.
                 */
                MysqlQueryRunner.prototype.updatePrimaryKeys = function (table) {
                    return __awaiter(this, void 0, void 0, function () {
                        var primaryColumnNames, sql, revertSql;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (!!table.hasGeneratedColumn) return [3 /*break*/, 2];
                                    return [4 /*yield*/, this.query("ALTER TABLE `" + this.escapeTablePath(table) + "` DROP PRIMARY KEY")];
                                case 1:
                                    _a.sent();
                                    _a.label = 2;
                                case 2:
                                    primaryColumnNames = table.columns
                                        .filter(function (column) { return column.isPrimary && !column.isGenerated; })
                                        .map(function (column) { return "`" + column.name + "`"; });
                                    if (primaryColumnNames.length > 0) {
                                        sql = "ALTER TABLE `" + this.escapeTablePath(table) + "` ADD PRIMARY KEY (" + primaryColumnNames.join(", ") + ")";
                                        revertSql = "ALTER TABLE `" + this.escapeTablePath(table) + "` DROP PRIMARY KEY";
                                        return [2 /*return*/, this.schemaQuery(sql, revertSql)];
                                    }
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Creates a new foreign key.
                 */
                MysqlQueryRunner.prototype.createForeignKey = function (tableOrPath, foreignKey) {
                    return __awaiter(this, void 0, void 0, function () {
                        var columnNames, referencedColumnNames, sql, revertSql;
                        return __generator(this, function (_a) {
                            columnNames = foreignKey.columnNames.map(function (column) { return "`" + column + "`"; }).join(", ");
                            referencedColumnNames = foreignKey.referencedColumnNames.map(function (column) { return "`" + column + "`"; }).join(",");
                            sql = "ALTER TABLE `" + this.escapeTablePath(tableOrPath) + "` ADD CONSTRAINT `" + foreignKey.name + "` " +
                                ("FOREIGN KEY (" + columnNames + ") ") +
                                ("REFERENCES `" + foreignKey.referencedTableName + "`(" + referencedColumnNames + ")");
                            if (foreignKey.onDelete)
                                sql += " ON DELETE " + foreignKey.onDelete;
                            revertSql = "ALTER TABLE `" + this.escapeTablePath(tableOrPath) + "` DROP FOREIGN KEY `" + foreignKey.name + "`";
                            return [2 /*return*/, this.schemaQuery(sql, revertSql)];
                        });
                    });
                };
                /**
                 * Creates a new foreign keys.
                 */
                MysqlQueryRunner.prototype.createForeignKeys = function (tableOrName, foreignKeys) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var promises;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    promises = foreignKeys.map(function (foreignKey) { return _this.createForeignKey(tableOrName, foreignKey); });
                                    return [4 /*yield*/, Promise.all(promises)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Drops a foreign key from the table.
                 */
                MysqlQueryRunner.prototype.dropForeignKey = function (tableOrPath, foreignKey) {
                    return __awaiter(this, void 0, void 0, function () {
                        var sql, columnNames, referencedColumnNames, revertSql;
                        return __generator(this, function (_a) {
                            sql = "ALTER TABLE `" + this.escapeTablePath(tableOrPath) + "` DROP FOREIGN KEY `" + foreignKey.name + "`";
                            columnNames = foreignKey.columnNames.map(function (column) { return "`" + column + "`"; }).join(", ");
                            referencedColumnNames = foreignKey.referencedColumnNames.map(function (column) { return "`" + column + "`"; }).join(",");
                            revertSql = "ALTER TABLE `" + this.escapeTablePath(tableOrPath) + "` ADD CONSTRAINT `" + foreignKey.name + "` " +
                                ("FOREIGN KEY (" + columnNames + ") ") +
                                ("REFERENCES `" + foreignKey.referencedTableName + "`(" + referencedColumnNames + ")");
                            if (foreignKey.onDelete)
                                revertSql += " ON DELETE " + foreignKey.onDelete;
                            return [2 /*return*/, this.schemaQuery(sql, revertSql)];
                        });
                    });
                };
                /**
                 * Drops a foreign keys from the table.
                 */
                MysqlQueryRunner.prototype.dropForeignKeys = function (tableOrName, foreignKeys) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var promises;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    promises = foreignKeys.map(function (foreignKey) { return _this.dropForeignKey(tableOrName, foreignKey); });
                                    return [4 /*yield*/, Promise.all(promises)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Creates a new index.
                 */
                MysqlQueryRunner.prototype.createIndex = function (table, index) {
                    return __awaiter(this, void 0, void 0, function () {
                        var columns, sql, revertSql;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    columns = index.columnNames.map(function (columnName) { return "`" + columnName + "`"; }).join(", ");
                                    sql = "CREATE " + (index.isUnique ? "UNIQUE " : "") + "INDEX `" + index.name + "` ON `" + this.escapeTablePath(table) + "`(" + columns + ")";
                                    revertSql = "ALTER TABLE `" + this.escapeTablePath(table) + "` DROP INDEX `" + index.name + "`";
                                    return [4 /*yield*/, this.schemaQuery(sql, revertSql)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Drops an index from the table.
                 */
                MysqlQueryRunner.prototype.dropIndex = function (tableOrPath, index) {
                    return __awaiter(this, void 0, void 0, function () {
                        var indexName, sql, columns, revertSql;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    indexName = index instanceof TableIndex_4.TableIndex ? index.name : index;
                                    sql = "ALTER TABLE `" + this.escapeTablePath(tableOrPath) + "` DROP INDEX `" + indexName + "`";
                                    if (!(index instanceof TableIndex_4.TableIndex)) return [3 /*break*/, 2];
                                    columns = index.columnNames.map(function (columnName) { return "`" + columnName + "`"; }).join(", ");
                                    revertSql = "CREATE " + (index.isUnique ? "UNIQUE " : "") + "INDEX `" + index.name + "` ON `" + this.escapeTablePath(tableOrPath) + "`(" + columns + ")";
                                    return [4 /*yield*/, this.schemaQuery(sql, revertSql)];
                                case 1:
                                    _a.sent();
                                    return [3 /*break*/, 4];
                                case 2: return [4 /*yield*/, this.query(sql)];
                                case 3:
                                    _a.sent();
                                    _a.label = 4;
                                case 4: return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Truncates table.
                 */
                MysqlQueryRunner.prototype.truncate = function (tableOrPath) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.query("TRUNCATE TABLE `" + this.escapeTablePath(tableOrPath) + "`")];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Removes all tables from the currently connected database.
                 * Be careful using this method and avoid using it in production or migrations
                 * (because it can clear all your database).
                 */
                MysqlQueryRunner.prototype.clearDatabase = function (tables, database) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var disableForeignKeysCheckQuery, dropTablesQuery, enableForeignKeysCheckQuery, dropQueries, error_6, rollbackError_7;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.startTransaction()];
                                case 1:
                                    _a.sent();
                                    _a.label = 2;
                                case 2:
                                    _a.trys.push([2, 8, , 13]);
                                    disableForeignKeysCheckQuery = "SET FOREIGN_KEY_CHECKS = 0;";
                                    dropTablesQuery = "SELECT concat('DROP TABLE IF EXISTS `', table_schema, '`.`', table_name, '`;') AS query FROM information_schema.tables WHERE table_schema = '" + database + "'";
                                    enableForeignKeysCheckQuery = "SET FOREIGN_KEY_CHECKS = 1;";
                                    return [4 /*yield*/, this.query(disableForeignKeysCheckQuery)];
                                case 3:
                                    _a.sent();
                                    return [4 /*yield*/, this.query(dropTablesQuery)];
                                case 4:
                                    dropQueries = _a.sent();
                                    return [4 /*yield*/, Promise.all(dropQueries.map(function (query) { return _this.query(query["query"]); }))];
                                case 5:
                                    _a.sent();
                                    return [4 /*yield*/, this.query(enableForeignKeysCheckQuery)];
                                case 6:
                                    _a.sent();
                                    return [4 /*yield*/, this.commitTransaction()];
                                case 7:
                                    _a.sent();
                                    return [3 /*break*/, 13];
                                case 8:
                                    error_6 = _a.sent();
                                    _a.label = 9;
                                case 9:
                                    _a.trys.push([9, 11, , 12]);
                                    return [4 /*yield*/, this.rollbackTransaction()];
                                case 10:
                                    _a.sent();
                                    return [3 /*break*/, 12];
                                case 11:
                                    rollbackError_7 = _a.sent();
                                    return [3 /*break*/, 12];
                                case 12: throw error_6;
                                case 13: return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Enables special query runner mode in which sql queries won't be executed,
                 * instead they will be memorized into a special variable inside query runner.
                 * You can get memorized sql using getMemorySql() method.
                 */
                MysqlQueryRunner.prototype.enableSqlMemory = function () {
                    this.sqlMemoryMode = true;
                };
                /**
                 * Disables special query runner mode in which sql queries won't be executed
                 * started by calling enableSqlMemory() method.
                 *
                 * Previously memorized sql will be flushed.
                 */
                MysqlQueryRunner.prototype.disableSqlMemory = function () {
                    this.sqlsInMemory = [];
                    this.sqlMemoryMode = false;
                };
                /**
                 * Gets sql stored in the memory. Parameters in the sql are already replaced.
                 */
                MysqlQueryRunner.prototype.getMemorySql = function () {
                    return this.sqlsInMemory;
                };
                // -------------------------------------------------------------------------
                // Protected Methods
                // -------------------------------------------------------------------------
                /**
                 * Executes sql used special for schema build.
                 */
                MysqlQueryRunner.prototype.schemaQuery = function (upQuery, downQuery) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    // if sql-in-memory mode is enabled then simply store sql in memory and return
                                    if (this.sqlMemoryMode === true) {
                                        this.sqlsInMemory.push({ up: upQuery, down: downQuery });
                                        return [2 /*return*/, Promise.resolve()];
                                    }
                                    return [4 /*yield*/, this.query(upQuery)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                MysqlQueryRunner.prototype.parseTablePath = function (tableOrPath) {
                    if (tableOrPath instanceof Table_4.Table) {
                        return {
                            database: tableOrPath.database || this.driver.database,
                            tableName: tableOrPath.name
                        };
                    }
                    else {
                        return {
                            database: tableOrPath.indexOf(".") !== -1 ? tableOrPath.split(".")[0] : this.driver.database,
                            tableName: tableOrPath.indexOf(".") !== -1 ? tableOrPath.split(".")[1] : tableOrPath
                        };
                    }
                };
                MysqlQueryRunner.prototype.escapeTablePath = function (tableOrPath) {
                    if (tableOrPath instanceof Table_4.Table)
                        return tableOrPath.database ? tableOrPath.database + "`.`" + tableOrPath.name : "" + tableOrPath.name;
                    return tableOrPath.split(".").map(function (i) { return "" + i; }).join("\`.\`");
                };
                /**
                 * Parametrizes given object of values. Used to create column=value queries.
                 */
                MysqlQueryRunner.prototype.parametrize = function (objectLiteral) {
                    return Object.keys(objectLiteral).map(function (key) { return "`" + key + "`=?"; });
                };
                /**
                 * Builds a part of query to create/change a column.
                 */
                MysqlQueryRunner.prototype.buildCreateColumnSql = function (column, skipPrimary) {
                    var c = "`" + column.name + "` " + this.connection.driver.createFullType(column);
                    if (column.enum)
                        c += "(" + column.enum.map(function (value) { return "'" + value + "'"; }).join(", ") + ")";
                    if (column.charset)
                        c += " CHARACTER SET " + column.charset;
                    if (column.collation)
                        c += " COLLATE " + column.collation;
                    if (column.isNullable !== true)
                        c += " NOT NULL";
                    if (column.isUnique === true)
                        c += " UNIQUE";
                    if (column.isGenerated && column.isPrimary && !skipPrimary)
                        c += " PRIMARY KEY";
                    if (column.isGenerated === true && column.generationStrategy === "increment") // don't use skipPrimary here since updates can update already exist primary without auto inc.
                        c += " AUTO_INCREMENT";
                    if (column.comment)
                        c += " COMMENT '" + column.comment + "'";
                    if (column.default !== undefined && column.default !== null)
                        c += " DEFAULT " + column.default;
                    return c;
                };
                return MysqlQueryRunner;
            }());
            exports_108("MysqlQueryRunner", MysqlQueryRunner);
        }
    };
});
System.register("typeorm/driver/mysql/MysqlDriver", ["typeorm/error/ConnectionIsNotSetError", "typeorm/error/DriverPackageNotInstalledError", "typeorm/driver/DriverUtils", "typeorm/driver/mysql/MysqlQueryRunner", "typeorm/util/DateUtils", "typeorm/platform/PlatformTools", "typeorm/schema-builder/RdbmsSchemaBuilder", "typeorm/util/RandomGenerator"], function (exports_109, context_109) {
    "use strict";
    var __moduleName = context_109 && context_109.id;
    var ConnectionIsNotSetError_3, DriverPackageNotInstalledError_3, DriverUtils_2, MysqlQueryRunner_1, DateUtils_4, PlatformTools_5, RdbmsSchemaBuilder_3, RandomGenerator_3, MysqlDriver;
    return {
        setters: [
            function (ConnectionIsNotSetError_3_1) {
                ConnectionIsNotSetError_3 = ConnectionIsNotSetError_3_1;
            },
            function (DriverPackageNotInstalledError_3_1) {
                DriverPackageNotInstalledError_3 = DriverPackageNotInstalledError_3_1;
            },
            function (DriverUtils_2_1) {
                DriverUtils_2 = DriverUtils_2_1;
            },
            function (MysqlQueryRunner_1_1) {
                MysqlQueryRunner_1 = MysqlQueryRunner_1_1;
            },
            function (DateUtils_4_1) {
                DateUtils_4 = DateUtils_4_1;
            },
            function (PlatformTools_5_1) {
                PlatformTools_5 = PlatformTools_5_1;
            },
            function (RdbmsSchemaBuilder_3_1) {
                RdbmsSchemaBuilder_3 = RdbmsSchemaBuilder_3_1;
            },
            function (RandomGenerator_3_1) {
                RandomGenerator_3 = RandomGenerator_3_1;
            }
        ],
        execute: function () {
            /**
             * Organizes communication with MySQL DBMS.
             */
            MysqlDriver = /** @class */ (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function MysqlDriver(connection) {
                    /**
                     * Indicates if replication is enabled.
                     */
                    this.isReplicated = false;
                    /**
                     * Indicates if tree tables are supported by this driver.
                     */
                    this.treeSupport = true;
                    /**
                     * Gets list of supported column data types by a driver.
                     *
                     * @see https://www.tutorialspoint.com/mysql/mysql-data-types.htm
                     * @see https://dev.mysql.com/doc/refman/5.7/en/data-types.html
                     */
                    this.supportedDataTypes = [
                        "int",
                        "tinyint",
                        "smallint",
                        "mediumint",
                        "bigint",
                        "float",
                        "double",
                        "decimal",
                        "date",
                        "datetime",
                        "timestamp",
                        "time",
                        "year",
                        "char",
                        "varchar",
                        "blob",
                        "text",
                        "tinyblob",
                        "tinytext",
                        "mediumblob",
                        "mediumtext",
                        "longblob",
                        "longtext",
                        "enum",
                        "json"
                    ];
                    /**
                     * Gets list of column data types that support length by a driver.
                     */
                    this.withLengthColumnTypes = [
                        "int",
                        "tinyint",
                        "smallint",
                        "mediumint",
                        "bigint",
                        "char",
                        "varchar",
                        "blob",
                        "text"
                    ];
                    /**
                     * ORM has special columns and we need to know what database column types should be for those columns.
                     * Column types are driver dependant.
                     */
                    this.mappedDataTypes = {
                        createDate: "datetime",
                        createDatePrecision: 6,
                        createDateDefault: "CURRENT_TIMESTAMP(6)",
                        updateDate: "datetime",
                        updateDatePrecision: 6,
                        updateDateDefault: "CURRENT_TIMESTAMP(6)",
                        version: "int",
                        treeLevel: "int",
                        migrationName: "varchar",
                        migrationTimestamp: "bigint",
                        cacheId: "int",
                        cacheIdentifier: "varchar",
                        cacheTime: "bigint",
                        cacheDuration: "int",
                        cacheQuery: "text",
                        cacheResult: "text",
                    };
                    /**
                     * Default values of length, precision and scale depends on column data type.
                     * Used in the cases when length/precision/scale is not specified by user.
                     */
                    this.dataTypeDefaults = {
                        varchar: { length: 255 },
                        int: { length: 11 },
                        tinyint: { length: 4 },
                        smallint: { length: 5 },
                        mediumint: { length: 9 },
                        bigint: { length: 20 },
                        year: { length: 4 }
                    };
                    this.connection = connection;
                    this.options = connection.options;
                    this.isReplicated = this.options.replication ? true : false;
                    // load mysql package
                    this.loadDependencies();
                    // validate options to make sure everything is set
                    // todo: revisit validation with replication in mind
                    // if (!(this.options.host || (this.options.extra && this.options.extra.socketPath)) && !this.options.socketPath)
                    //     throw new DriverOptionNotSetError("socketPath and host");
                    // if (!this.options.username)
                    //     throw new DriverOptionNotSetError("username");
                    // if (!this.options.database)
                    //     throw new DriverOptionNotSetError("database");
                    // todo: check what is going on when connection is setup without database and how to connect to a database then?
                    // todo: provide options to auto-create a database if it does not exist yet
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Performs connection to the database.
                 */
                MysqlDriver.prototype.connect = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var _a;
                        return __generator(this, function (_b) {
                            switch (_b.label) {
                                case 0:
                                    if (!this.options.replication) return [3 /*break*/, 1];
                                    this.poolCluster = this.mysql.createPoolCluster(this.options.replication);
                                    this.options.replication.slaves.forEach(function (slave, index) {
                                        _this.poolCluster.add("SLAVE" + index, _this.createConnectionOptions(_this.options, slave));
                                    });
                                    this.poolCluster.add("MASTER", this.createConnectionOptions(this.options, this.options.replication.master));
                                    this.database = this.options.replication.master.database;
                                    return [3 /*break*/, 3];
                                case 1:
                                    _a = this;
                                    return [4 /*yield*/, this.createPool(this.createConnectionOptions(this.options, this.options))];
                                case 2:
                                    _a.pool = _b.sent();
                                    this.database = this.options.database;
                                    _b.label = 3;
                                case 3: return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Makes any action after connection (e.g. create extensions in Postgres driver).
                 */
                MysqlDriver.prototype.afterConnect = function () {
                    return Promise.resolve();
                };
                /**
                 * Closes connection with the database.
                 */
                MysqlDriver.prototype.disconnect = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        return __generator(this, function (_a) {
                            if (!this.poolCluster && !this.pool)
                                return [2 /*return*/, Promise.reject(new ConnectionIsNotSetError_3.ConnectionIsNotSetError("mysql"))];
                            if (this.poolCluster) {
                                return [2 /*return*/, new Promise(function (ok, fail) {
                                        _this.poolCluster.end(function (err) { return err ? fail(err) : ok(); });
                                        _this.poolCluster = undefined;
                                    })];
                            }
                            if (this.pool) {
                                return [2 /*return*/, new Promise(function (ok, fail) {
                                        _this.pool.end(function (err) {
                                            if (err)
                                                return fail(err);
                                            _this.pool = undefined;
                                            ok();
                                        });
                                    })];
                            }
                            return [2 /*return*/];
                        });
                    });
                };
                /**
                 * Creates a schema builder used to build and sync a schema.
                 */
                MysqlDriver.prototype.createSchemaBuilder = function () {
                    return new RdbmsSchemaBuilder_3.RdbmsSchemaBuilder(this.connection);
                };
                /**
                 * Creates a query runner used to execute database queries.
                 */
                MysqlDriver.prototype.createQueryRunner = function (mode) {
                    if (mode === void 0) { mode = "master"; }
                    return new MysqlQueryRunner_1.MysqlQueryRunner(this, mode);
                };
                /**
                 * Replaces parameters in the given sql with special escaping character
                 * and an array of parameter names to be passed to a query.
                 */
                MysqlDriver.prototype.escapeQueryWithParameters = function (sql, parameters) {
                    if (!parameters || !Object.keys(parameters).length)
                        return [sql, []];
                    var escapedParameters = [];
                    var keys = Object.keys(parameters).map(function (parameter) { return "(:" + parameter + "\\b)"; }).join("|");
                    sql = sql.replace(new RegExp(keys, "g"), function (key) {
                        var value = parameters[key.substr(1)];
                        if (value instanceof Function) {
                            return value();
                        }
                        else {
                            escapedParameters.push(parameters[key.substr(1)]);
                            return "?";
                        }
                    }); // todo: make replace only in value statements, otherwise problems
                    return [sql, escapedParameters];
                };
                /**
                 * Escapes a column name.
                 */
                MysqlDriver.prototype.escape = function (columnName) {
                    return "`" + columnName + "`";
                };
                /**
                 * Prepares given value to a value to be persisted, based on its column type and metadata.
                 */
                MysqlDriver.prototype.preparePersistentValue = function (value, columnMetadata) {
                    if (columnMetadata.transformer)
                        value = columnMetadata.transformer.to(value);
                    if (value === null || value === undefined)
                        return value;
                    if (columnMetadata.type === Boolean) {
                        return value === true ? 1 : 0;
                    }
                    else if (columnMetadata.type === "date") {
                        return DateUtils_4.DateUtils.mixedDateToDateString(value);
                    }
                    else if (columnMetadata.type === "time") {
                        return DateUtils_4.DateUtils.mixedDateToTimeString(value);
                    }
                    else if (columnMetadata.type === "json") {
                        return JSON.stringify(value);
                    }
                    else if (columnMetadata.type === "timestamp" || columnMetadata.type === "datetime" || columnMetadata.type === Date) {
                        return DateUtils_4.DateUtils.mixedDateToDate(value);
                    }
                    else if (columnMetadata.isGenerated && columnMetadata.generationStrategy === "uuid" && !value) {
                        return RandomGenerator_3.RandomGenerator.uuid4();
                    }
                    else if (columnMetadata.type === "simple-array") {
                        return DateUtils_4.DateUtils.simpleArrayToString(value);
                    }
                    else if (columnMetadata.type === "simple-json") {
                        return DateUtils_4.DateUtils.simpleJsonToString(value);
                    }
                    return value;
                };
                /**
                 * Prepares given value to a value to be persisted, based on its column type or metadata.
                 */
                MysqlDriver.prototype.prepareHydratedValue = function (value, columnMetadata) {
                    if (value === null || value === undefined)
                        return value;
                    if (columnMetadata.type === Boolean) {
                        value = value ? true : false;
                    }
                    else if (columnMetadata.type === "datetime" || columnMetadata.type === Date) {
                        value = DateUtils_4.DateUtils.normalizeHydratedDate(value);
                    }
                    else if (columnMetadata.type === "date") {
                        value = DateUtils_4.DateUtils.mixedDateToDateString(value);
                    }
                    else if (columnMetadata.type === "json") {
                        value = typeof value === "string" ? JSON.parse(value) : value;
                    }
                    else if (columnMetadata.type === "time") {
                        value = DateUtils_4.DateUtils.mixedTimeToString(value);
                    }
                    else if (columnMetadata.type === "simple-array") {
                        value = DateUtils_4.DateUtils.stringToSimpleArray(value);
                    }
                    else if (columnMetadata.type === "simple-json") {
                        value = DateUtils_4.DateUtils.stringToSimpleJson(value);
                    }
                    if (columnMetadata.transformer)
                        value = columnMetadata.transformer.from(value);
                    return value;
                };
                /**
                 * Creates a database type from a given column metadata.
                 */
                MysqlDriver.prototype.normalizeType = function (column) {
                    if (column.type === Number || column.type === "integer") {
                        return "int";
                    }
                    else if (column.type === String) {
                        return "varchar";
                    }
                    else if (column.type === Date) {
                        return "datetime";
                    }
                    else if (column.type === Buffer) {
                        return "blob";
                    }
                    else if (column.type === Boolean) {
                        return "tinyint";
                    }
                    else if (column.type === "uuid") {
                        return "varchar";
                    }
                    else if (column.type === "simple-array") {
                        return "text";
                    }
                    else if (column.type === "simple-json") {
                        return "text";
                    }
                    else {
                        return column.type || "";
                    }
                };
                /**
                 * Normalizes "default" value of the column.
                 */
                MysqlDriver.prototype.normalizeDefault = function (column) {
                    if (typeof column.default === "number") {
                        return "" + column.default;
                    }
                    else if (typeof column.default === "boolean") {
                        return column.default === true ? "1" : "0";
                    }
                    else if (typeof column.default === "function") {
                        return column.default();
                    }
                    else if (typeof column.default === "string") {
                        return "'" + column.default + "'";
                    }
                    else {
                        return column.default;
                    }
                };
                /**
                 * Normalizes "isUnique" value of the column.
                 */
                MysqlDriver.prototype.normalizeIsUnique = function (column) {
                    return column.isUnique ||
                        !!column.entityMetadata.indices.find(function (index) { return index.isUnique && index.columns.length === 1 && index.columns[0] === column; });
                };
                /**
                 * Calculates column length taking into account the default length values.
                 */
                MysqlDriver.prototype.getColumnLength = function (column) {
                    if (column.length)
                        return column.length;
                    var normalizedType = this.normalizeType(column);
                    if (this.dataTypeDefaults && this.dataTypeDefaults[normalizedType] && this.dataTypeDefaults[normalizedType].length)
                        return this.dataTypeDefaults[normalizedType].length.toString();
                    return "";
                };
                MysqlDriver.prototype.createFullType = function (column) {
                    var type = column.type;
                    if (column.length) {
                        type += "(" + column.length + ")";
                    }
                    else if (column.precision && column.scale) {
                        type += "(" + column.precision + "," + column.scale + ")";
                    }
                    else if (column.precision) {
                        type += "(" + column.precision + ")";
                    }
                    else if (column.scale) {
                        type += "(" + column.scale + ")";
                    }
                    else if (this.dataTypeDefaults && this.dataTypeDefaults[column.type] && this.dataTypeDefaults[column.type].length) {
                        type += "(" + this.dataTypeDefaults[column.type].length.toString() + ")";
                    }
                    if (column.isArray)
                        type += " array";
                    return type;
                };
                /**
                 * Obtains a new database connection to a master server.
                 * Used for replication.
                 * If replication is not setup then returns default connection's database connection.
                 */
                MysqlDriver.prototype.obtainMasterConnection = function () {
                    var _this = this;
                    return new Promise(function (ok, fail) {
                        if (_this.poolCluster) {
                            _this.poolCluster.getConnection("MASTER", function (err, dbConnection) {
                                err ? fail(err) : ok(_this.prepareDbConnection(dbConnection));
                            });
                        }
                        else if (_this.pool) {
                            _this.pool.getConnection(function (err, dbConnection) {
                                err ? fail(err) : ok(_this.prepareDbConnection(dbConnection));
                            });
                        }
                        else {
                            fail(new Error("Connection is not established with mysql database"));
                        }
                    });
                };
                /**
                 * Obtains a new database connection to a slave server.
                 * Used for replication.
                 * If replication is not setup then returns master (default) connection's database connection.
                 */
                MysqlDriver.prototype.obtainSlaveConnection = function () {
                    var _this = this;
                    if (!this.poolCluster)
                        return this.obtainMasterConnection();
                    return new Promise(function (ok, fail) {
                        _this.poolCluster.getConnection("SLAVE*", function (err, dbConnection) {
                            err ? fail(err) : ok(dbConnection);
                        });
                    });
                };
                // -------------------------------------------------------------------------
                // Protected Methods
                // -------------------------------------------------------------------------
                /**
                 * Loads all driver dependencies.
                 */
                MysqlDriver.prototype.loadDependencies = function () {
                    try {
                        this.mysql = PlatformTools_5.PlatformTools.load("mysql"); // try to load first supported package
                    }
                    catch (e) {
                        try {
                            this.mysql = PlatformTools_5.PlatformTools.load("mysql2"); // try to load second supported package
                        }
                        catch (e) {
                            throw new DriverPackageNotInstalledError_3.DriverPackageNotInstalledError("Mysql", "mysql");
                        }
                    }
                };
                /**
                 * Creates a new connection pool for a given database credentials.
                 */
                MysqlDriver.prototype.createConnectionOptions = function (options, credentials) {
                    credentials = Object.assign(credentials, DriverUtils_2.DriverUtils.buildDriverOptions(credentials)); // todo: do it better way
                    // build connection options for the driver
                    return Object.assign({}, {
                        charset: options.charset,
                        timezone: options.timezone,
                        connectTimeout: options.connectTimeout,
                        insecureAuth: options.insecureAuth,
                        supportBigNumbers: options.supportBigNumbers,
                        bigNumberStrings: options.bigNumberStrings,
                        dateStrings: options.dateStrings,
                        debug: options.debug,
                        trace: options.trace,
                        multipleStatements: options.multipleStatements,
                        flags: options.flags
                    }, {
                        host: credentials.host,
                        user: credentials.username,
                        password: credentials.password,
                        database: credentials.database,
                        port: credentials.port,
                        ssl: options.ssl
                    }, options.extra || {});
                };
                /**
                 * Creates a new connection pool for a given database credentials.
                 */
                MysqlDriver.prototype.createPool = function (connectionOptions) {
                    // create a connection pool
                    var pool = this.mysql.createPool(connectionOptions);
                    // make sure connection is working fine
                    return new Promise(function (ok, fail) {
                        // (issue #610) we make first connection to database to make sure if connection credentials are wrong
                        // we give error before calling any other method that creates actual query runner
                        pool.getConnection(function (err, connection) {
                            if (err)
                                return pool.end(function () { return fail(err); });
                            connection.release();
                            ok(pool);
                        });
                    });
                };
                /**
                 * Attaches all required base handlers to a database connection, such as the unhandled error handler.
                 */
                MysqlDriver.prototype.prepareDbConnection = function (connection) {
                    var logger = this.connection.logger;
                    /*
                      Attaching an error handler to connection errors is essential, as, otherwise, errors raised will go unhandled and
                      cause the hosting app to crash.
                     */
                    if (connection.listeners("error").length === 0) {
                        connection.on("error", function (error) { return logger.log("warn", "MySQL connection raised an error. " + error); });
                    }
                    return connection;
                };
                return MysqlDriver;
            }());
            exports_109("MysqlDriver", MysqlDriver);
        }
    };
});
System.register("typeorm/driver/sqlserver/MssqlParameter", [], function (exports_110, context_110) {
    "use strict";
    var __moduleName = context_110 && context_110.id;
    var MssqlParameter;
    return {
        setters: [],
        execute: function () {
            /**
             * Sql server driver requires parameter types to be specified fo input parameters used in the query.
             *
             * @see https://github.com/patriksimek/node-mssql#data-types
             */
            MssqlParameter = /** @class */ (function () {
                function MssqlParameter(value, type) {
                    var params = [];
                    for (var _i = 2; _i < arguments.length; _i++) {
                        params[_i - 2] = arguments[_i];
                    }
                    this.value = value;
                    this.type = type;
                    // -------------------------------------------------------------------------
                    // Public Properties
                    // -------------------------------------------------------------------------
                    this.params = [];
                    this.params = params || [];
                }
                return MssqlParameter;
            }());
            exports_110("MssqlParameter", MssqlParameter);
        }
    };
});
System.register("typeorm/driver/sqlserver/SqlServerQueryRunner", ["typeorm/error/TransactionAlreadyStartedError", "typeorm/error/TransactionNotStartedError", "typeorm/schema-builder/schema/TableColumn", "typeorm/schema-builder/schema/Table", "typeorm/schema-builder/schema/TableForeignKey", "typeorm/schema-builder/schema/TablePrimaryKey", "typeorm/schema-builder/schema/TableIndex", "typeorm/error/QueryRunnerAlreadyReleasedError", "typeorm/driver/sqlserver/MssqlParameter", "typeorm/util/OrmUtils", "typeorm/error/QueryFailedError", "typeorm/util/PromiseUtils"], function (exports_111, context_111) {
    "use strict";
    var __moduleName = context_111 && context_111.id;
    var TransactionAlreadyStartedError_4, TransactionNotStartedError_4, TableColumn_6, Table_5, TableForeignKey_5, TablePrimaryKey_5, TableIndex_5, QueryRunnerAlreadyReleasedError_3, MssqlParameter_1, OrmUtils_4, QueryFailedError_3, PromiseUtils_3, SqlServerQueryRunner;
    return {
        setters: [
            function (TransactionAlreadyStartedError_4_1) {
                TransactionAlreadyStartedError_4 = TransactionAlreadyStartedError_4_1;
            },
            function (TransactionNotStartedError_4_1) {
                TransactionNotStartedError_4 = TransactionNotStartedError_4_1;
            },
            function (TableColumn_6_1) {
                TableColumn_6 = TableColumn_6_1;
            },
            function (Table_5_1) {
                Table_5 = Table_5_1;
            },
            function (TableForeignKey_5_1) {
                TableForeignKey_5 = TableForeignKey_5_1;
            },
            function (TablePrimaryKey_5_1) {
                TablePrimaryKey_5 = TablePrimaryKey_5_1;
            },
            function (TableIndex_5_1) {
                TableIndex_5 = TableIndex_5_1;
            },
            function (QueryRunnerAlreadyReleasedError_3_1) {
                QueryRunnerAlreadyReleasedError_3 = QueryRunnerAlreadyReleasedError_3_1;
            },
            function (MssqlParameter_1_1) {
                MssqlParameter_1 = MssqlParameter_1_1;
            },
            function (OrmUtils_4_1) {
                OrmUtils_4 = OrmUtils_4_1;
            },
            function (QueryFailedError_3_1) {
                QueryFailedError_3 = QueryFailedError_3_1;
            },
            function (PromiseUtils_3_1) {
                PromiseUtils_3 = PromiseUtils_3_1;
            }
        ],
        execute: function () {
            /**
             * Runs queries on a single mysql database connection.
             */
            SqlServerQueryRunner = /** @class */ (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function SqlServerQueryRunner(driver, mode) {
                    if (mode === void 0) { mode = "master"; }
                    /**
                     * Indicates if connection for this query runner is released.
                     * Once its released, query runner cannot run queries anymore.
                     */
                    this.isReleased = false;
                    /**
                     * Indicates if transaction is in progress.
                     */
                    this.isTransactionActive = false;
                    /**
                     * Stores temporarily user data.
                     * Useful for sharing data with subscribers.
                     */
                    this.data = {};
                    /**
                     * Last executed query in a transaction.
                     * This is needed because in transaction mode mssql cannot execute parallel queries,
                     * that's why we store last executed query promise to wait it when we execute next query.
                     *
                     * @see https://github.com/patriksimek/node-mssql/issues/491
                     */
                    this.queryResponsibilityChain = [];
                    /**
                     * Indicates if special query runner mode in which sql queries won't be executed is enabled.
                     */
                    this.sqlMemoryMode = false;
                    /**
                     * Sql-s stored if "sql in memory" mode is enabled.
                     */
                    this.sqlsInMemory = [];
                    this.driver = driver;
                    this.connection = driver.connection;
                    this.mode = mode;
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Creates/uses database connection from the connection pool to perform further operations.
                 * Returns obtained database connection.
                 */
                SqlServerQueryRunner.prototype.connect = function () {
                    return Promise.resolve();
                };
                /**
                 * Releases used database connection.
                 * You cannot use query runner methods once its released.
                 */
                SqlServerQueryRunner.prototype.release = function () {
                    this.isReleased = true;
                    return Promise.resolve();
                };
                /**
                 * Starts transaction.
                 */
                SqlServerQueryRunner.prototype.startTransaction = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        return __generator(this, function (_a) {
                            if (this.isReleased)
                                throw new QueryRunnerAlreadyReleasedError_3.QueryRunnerAlreadyReleasedError();
                            if (this.isTransactionActive)
                                throw new TransactionAlreadyStartedError_4.TransactionAlreadyStartedError();
                            return [2 /*return*/, new Promise(function (ok, fail) { return __awaiter(_this, void 0, void 0, function () {
                                    var _this = this;
                                    var pool;
                                    return __generator(this, function (_a) {
                                        switch (_a.label) {
                                            case 0:
                                                this.isTransactionActive = true;
                                                return [4 /*yield*/, (this.mode === "slave" ? this.driver.obtainSlaveConnection() : this.driver.obtainMasterConnection())];
                                            case 1:
                                                pool = _a.sent();
                                                this.databaseConnection = pool.transaction();
                                                this.databaseConnection.begin(function (err) {
                                                    if (err) {
                                                        _this.isTransactionActive = false;
                                                        return fail(err);
                                                    }
                                                    ok();
                                                });
                                                return [2 /*return*/];
                                        }
                                    });
                                }); })];
                        });
                    });
                };
                /**
                 * Commits transaction.
                 * Error will be thrown if transaction was not started.
                 */
                SqlServerQueryRunner.prototype.commitTransaction = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        return __generator(this, function (_a) {
                            if (this.isReleased)
                                throw new QueryRunnerAlreadyReleasedError_3.QueryRunnerAlreadyReleasedError();
                            if (!this.isTransactionActive)
                                throw new TransactionNotStartedError_4.TransactionNotStartedError();
                            return [2 /*return*/, new Promise(function (ok, fail) {
                                    _this.databaseConnection.commit(function (err) {
                                        if (err)
                                            return fail(err);
                                        _this.isTransactionActive = false;
                                        _this.databaseConnection = null;
                                        ok();
                                    });
                                })];
                        });
                    });
                };
                /**
                 * Rollbacks transaction.
                 * Error will be thrown if transaction was not started.
                 */
                SqlServerQueryRunner.prototype.rollbackTransaction = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        return __generator(this, function (_a) {
                            if (this.isReleased)
                                throw new QueryRunnerAlreadyReleasedError_3.QueryRunnerAlreadyReleasedError();
                            if (!this.isTransactionActive)
                                throw new TransactionNotStartedError_4.TransactionNotStartedError();
                            return [2 /*return*/, new Promise(function (ok, fail) {
                                    _this.databaseConnection.rollback(function (err) {
                                        if (err)
                                            return fail(err);
                                        _this.isTransactionActive = false;
                                        _this.databaseConnection = null;
                                        ok();
                                    });
                                })];
                        });
                    });
                };
                SqlServerQueryRunner.prototype.mssqlParameterToNativeParameter = function (parameter) {
                    switch (this.driver.normalizeType({ type: parameter.type })) {
                        case "bit":
                            return this.driver.mssql.Bit;
                        case "bigint":
                            return this.driver.mssql.BigInt;
                        case "decimal":
                            return (_a = this.driver.mssql).Decimal.apply(_a, parameter.params);
                        case "float":
                            return this.driver.mssql.Float;
                        case "int":
                            return this.driver.mssql.Int;
                        case "money":
                            return this.driver.mssql.Money;
                        case "numeric":
                            return (_b = this.driver.mssql).Numeric.apply(_b, parameter.params);
                        case "smallint":
                            return this.driver.mssql.SmallInt;
                        case "smallmoney":
                            return this.driver.mssql.SmallMoney;
                        case "real":
                            return this.driver.mssql.Real;
                        case "tinyint":
                            return this.driver.mssql.TinyInt;
                        case "char":
                            return (_c = this.driver.mssql).Char.apply(_c, parameter.params);
                        case "nchar":
                            return (_d = this.driver.mssql).NChar.apply(_d, parameter.params);
                        case "text":
                            return this.driver.mssql.Text;
                        case "ntext":
                            return this.driver.mssql.Ntext;
                        case "varchar":
                            return (_e = this.driver.mssql).VarChar.apply(_e, parameter.params);
                        case "nvarchar":
                            return (_f = this.driver.mssql).NVarChar.apply(_f, parameter.params);
                        case "xml":
                            return this.driver.mssql.Xml;
                        case "time":
                            return (_g = this.driver.mssql).Time.apply(_g, parameter.params);
                        case "date":
                            return this.driver.mssql.Date;
                        case "datetime":
                            return this.driver.mssql.DateTime;
                        case "datetime2":
                            return (_h = this.driver.mssql).DateTime2.apply(_h, parameter.params);
                        case "datetimeoffset":
                            return (_j = this.driver.mssql).DateTimeOffset.apply(_j, parameter.params);
                        case "smalldatetime":
                            return this.driver.mssql.SmallDateTime;
                        case "uniqueidentifier":
                            return this.driver.mssql.UniqueIdentifier;
                        case "variant":
                            return this.driver.mssql.Variant;
                        case "binary":
                            return this.driver.mssql.Binary;
                        case "varbinary":
                            return (_k = this.driver.mssql).VarBinary.apply(_k, parameter.params);
                        case "image":
                            return this.driver.mssql.Image;
                        case "udt":
                            return this.driver.mssql.UDT;
                        case "geography":
                            return this.driver.mssql.Geography;
                        case "geometry":
                            return this.driver.mssql.Geometry;
                    }
                    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
                };
                /**
                 * Executes a given SQL query.
                 */
                SqlServerQueryRunner.prototype.query = function (query, parameters) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var waitingOkay, waitingPromise, otherWaitingPromises, promise;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_3.QueryRunnerAlreadyReleasedError();
                                    waitingPromise = new Promise(function (ok) { return waitingOkay = ok; });
                                    if (!this.queryResponsibilityChain.length) return [3 /*break*/, 2];
                                    otherWaitingPromises = this.queryResponsibilityChain.slice();
                                    this.queryResponsibilityChain.push(waitingPromise);
                                    return [4 /*yield*/, Promise.all(otherWaitingPromises)];
                                case 1:
                                    _a.sent();
                                    _a.label = 2;
                                case 2:
                                    promise = new Promise(function (ok, fail) { return __awaiter(_this, void 0, void 0, function () {
                                        var _this = this;
                                        var pool, request_1, queryStartTime_3, err_5;
                                        return __generator(this, function (_a) {
                                            switch (_a.label) {
                                                case 0:
                                                    _a.trys.push([0, 2, , 3]);
                                                    this.driver.connection.logger.logQuery(query, parameters, this);
                                                    return [4 /*yield*/, (this.mode === "slave" ? this.driver.obtainSlaveConnection() : this.driver.obtainMasterConnection())];
                                                case 1:
                                                    pool = _a.sent();
                                                    request_1 = new this.driver.mssql.Request(this.isTransactionActive ? this.databaseConnection : pool);
                                                    if (parameters && parameters.length) {
                                                        parameters.forEach(function (parameter, index) {
                                                            if (parameter instanceof MssqlParameter_1.MssqlParameter) {
                                                                var mssqlParameter = _this.mssqlParameterToNativeParameter(parameter);
                                                                if (mssqlParameter) {
                                                                    request_1.input(index, mssqlParameter, parameter.value);
                                                                }
                                                                else {
                                                                    request_1.input(index, parameter.value);
                                                                }
                                                            }
                                                            else {
                                                                request_1.input(index, parameter);
                                                            }
                                                        });
                                                    }
                                                    queryStartTime_3 = +new Date();
                                                    request_1.query(query, function (err, result) {
                                                        // log slow queries if maxQueryExecution time is set
                                                        var maxQueryExecutionTime = _this.driver.connection.options.maxQueryExecutionTime;
                                                        var queryEndTime = +new Date();
                                                        var queryExecutionTime = queryEndTime - queryStartTime_3;
                                                        if (maxQueryExecutionTime && queryExecutionTime > maxQueryExecutionTime)
                                                            _this.driver.connection.logger.logQuerySlow(queryExecutionTime, query, parameters, _this);
                                                        var resolveChain = function () {
                                                            if (promiseIndex !== -1)
                                                                _this.queryResponsibilityChain.splice(promiseIndex, 1);
                                                            if (waitingPromiseIndex !== -1)
                                                                _this.queryResponsibilityChain.splice(waitingPromiseIndex, 1);
                                                            waitingOkay();
                                                        };
                                                        var promiseIndex = _this.queryResponsibilityChain.indexOf(promise);
                                                        var waitingPromiseIndex = _this.queryResponsibilityChain.indexOf(waitingPromise);
                                                        if (err) {
                                                            _this.driver.connection.logger.logQueryError(err, query, parameters, _this);
                                                            resolveChain();
                                                            return fail(new QueryFailedError_3.QueryFailedError(query, parameters, err));
                                                        }
                                                        ok(result.recordset);
                                                        resolveChain();
                                                    });
                                                    return [3 /*break*/, 3];
                                                case 2:
                                                    err_5 = _a.sent();
                                                    fail(err_5);
                                                    return [3 /*break*/, 3];
                                                case 3: return [2 /*return*/];
                                            }
                                        });
                                    }); });
                                    if (this.isTransactionActive)
                                        this.queryResponsibilityChain.push(promise);
                                    return [2 /*return*/, promise];
                            }
                        });
                    });
                };
                /**
                 * Returns raw data stream.
                 */
                SqlServerQueryRunner.prototype.stream = function (query, parameters, onEnd, onError) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var waitingOkay, waitingPromise, otherWaitingPromises, promise;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_3.QueryRunnerAlreadyReleasedError();
                                    waitingPromise = new Promise(function (ok) { return waitingOkay = ok; });
                                    if (!this.queryResponsibilityChain.length) return [3 /*break*/, 2];
                                    otherWaitingPromises = this.queryResponsibilityChain.slice();
                                    this.queryResponsibilityChain.push(waitingPromise);
                                    return [4 /*yield*/, Promise.all(otherWaitingPromises)];
                                case 1:
                                    _a.sent();
                                    _a.label = 2;
                                case 2:
                                    promise = new Promise(function (ok, fail) { return __awaiter(_this, void 0, void 0, function () {
                                        var _this = this;
                                        var pool, request;
                                        return __generator(this, function (_a) {
                                            switch (_a.label) {
                                                case 0:
                                                    this.driver.connection.logger.logQuery(query, parameters, this);
                                                    return [4 /*yield*/, (this.mode === "slave" ? this.driver.obtainSlaveConnection() : this.driver.obtainMasterConnection())];
                                                case 1:
                                                    pool = _a.sent();
                                                    request = new this.driver.mssql.Request(this.isTransactionActive ? this.databaseConnection : pool);
                                                    request.stream = true;
                                                    if (parameters && parameters.length) {
                                                        parameters.forEach(function (parameter, index) {
                                                            if (parameter instanceof MssqlParameter_1.MssqlParameter) {
                                                                request.input(index, _this.mssqlParameterToNativeParameter(parameter), parameter.value);
                                                            }
                                                            else {
                                                                request.input(index, parameter);
                                                            }
                                                        });
                                                    }
                                                    request.query(query, function (err, result) {
                                                        var resolveChain = function () {
                                                            if (promiseIndex !== -1)
                                                                _this.queryResponsibilityChain.splice(promiseIndex, 1);
                                                            if (waitingPromiseIndex !== -1)
                                                                _this.queryResponsibilityChain.splice(waitingPromiseIndex, 1);
                                                            waitingOkay();
                                                        };
                                                        var promiseIndex = _this.queryResponsibilityChain.indexOf(promise);
                                                        var waitingPromiseIndex = _this.queryResponsibilityChain.indexOf(waitingPromise);
                                                        if (err) {
                                                            _this.driver.connection.logger.logQueryError(err, query, parameters, _this);
                                                            resolveChain();
                                                            return fail(err);
                                                        }
                                                        ok(result.recordset);
                                                        resolveChain();
                                                    });
                                                    if (onEnd)
                                                        request.on("done", onEnd);
                                                    if (onError)
                                                        request.on("error", onError);
                                                    ok(request);
                                                    return [2 /*return*/];
                                            }
                                        });
                                    }); });
                                    if (this.isTransactionActive)
                                        this.queryResponsibilityChain.push(promise);
                                    return [2 /*return*/, promise];
                            }
                        });
                    });
                };
                /**
                 * Insert a new row with given values into the given table.
                 * Returns value of the generated column if given and generate column exist in the table.
                 */
                SqlServerQueryRunner.prototype.insert = function (tablePath, keyValues) {
                    return __awaiter(this, void 0, void 0, function () {
                        var keys, columns, values, generatedColumns, generatedColumnNames, generatedColumnSql, sql, parameters, parametersArray, result, generatedMap;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    keys = Object.keys(keyValues);
                                    columns = keys.map(function (key) { return "\"" + key + "\""; }).join(", ");
                                    values = keys.map(function (key, index) { return "@" + index; }).join(",");
                                    generatedColumns = this.connection.hasMetadata(tablePath) ? this.connection.getMetadata(tablePath).generatedColumns : [];
                                    generatedColumnNames = generatedColumns.map(function (generatedColumn) { return "INSERTED.\"" + generatedColumn.databaseName + "\""; }).join(", ");
                                    generatedColumnSql = generatedColumns.length > 0 ? " OUTPUT " + generatedColumnNames : "";
                                    sql = columns.length > 0
                                        ? "INSERT INTO " + this.escapeTablePath(tablePath) + "(" + columns + ") " + generatedColumnSql + " VALUES (" + values + ")"
                                        : "INSERT INTO " + this.escapeTablePath(tablePath) + " " + generatedColumnSql + " DEFAULT VALUES ";
                                    parameters = this.driver.parametrizeMap(tablePath, keyValues);
                                    parametersArray = Object.keys(parameters).map(function (key) { return parameters[key]; });
                                    return [4 /*yield*/, this.query(sql, parametersArray)];
                                case 1:
                                    result = _a.sent();
                                    generatedMap = generatedColumns.reduce(function (map, column) {
                                        var valueMap = column.createValueMap(result[0][column.databaseName]);
                                        return OrmUtils_4.OrmUtils.mergeDeep(map, valueMap);
                                    }, {});
                                    return [2 /*return*/, {
                                            result: result,
                                            generatedMap: Object.keys(generatedMap).length > 0 ? generatedMap : undefined
                                        }];
                            }
                        });
                    });
                };
                /**
                 * Updates rows that match given conditions in the given table.
                 */
                SqlServerQueryRunner.prototype.update = function (tablePath, valuesMap, conditions) {
                    return __awaiter(this, void 0, void 0, function () {
                        var conditionParams, updateParams, allParameters, updateValues, conditionString, sql;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    valuesMap = this.driver.parametrizeMap(tablePath, valuesMap);
                                    conditions = this.driver.parametrizeMap(tablePath, conditions);
                                    conditionParams = Object.keys(conditions).map(function (key) { return conditions[key]; });
                                    updateParams = Object.keys(valuesMap).map(function (key) { return valuesMap[key]; });
                                    allParameters = updateParams.concat(conditionParams);
                                    updateValues = this.parametrize(valuesMap).join(", ");
                                    conditionString = this.parametrize(conditions, updateParams.length).join(" AND ");
                                    sql = "UPDATE " + this.escapeTablePath(tablePath) + " SET " + updateValues + " " + (conditionString ? (" WHERE " + conditionString) : "");
                                    return [4 /*yield*/, this.query(sql, allParameters)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Deletes from the given table by a given conditions.
                 */
                SqlServerQueryRunner.prototype.delete = function (tablePath, conditions, maybeParameters) {
                    return __awaiter(this, void 0, void 0, function () {
                        var conditionString, parameters, sql;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    conditions = typeof conditions === "object" ? this.driver.parametrizeMap(tablePath, conditions) : conditions;
                                    conditionString = typeof conditions === "string" ? conditions : this.parametrize(conditions).join(" AND ");
                                    parameters = conditions instanceof Object ? Object.keys(conditions).map(function (key) { return conditions[key]; }) : maybeParameters;
                                    sql = "DELETE FROM " + this.escapeTablePath(tablePath) + " WHERE " + conditionString;
                                    return [4 /*yield*/, this.query(sql, parameters)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Inserts rows into the closure table.
                 */
                SqlServerQueryRunner.prototype.insertIntoClosureTable = function (tablePath, newEntityId, parentId, hasLevel) {
                    return __awaiter(this, void 0, void 0, function () {
                        var sql, results;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    sql = "";
                                    if (hasLevel) { // todo: escape all parameters there
                                        sql = "INSERT INTO " + this.escapeTablePath(tablePath) + "(\"ancestor\", \"descendant\", \"level\") " +
                                            ("SELECT \"ancestor\", " + newEntityId + ", \"level\" + 1 FROM " + this.escapeTablePath(tablePath) + " WHERE \"descendant\" = " + parentId + " ") +
                                            ("UNION ALL SELECT " + newEntityId + ", " + newEntityId + ", 1");
                                    }
                                    else {
                                        sql = "INSERT INTO " + this.escapeTablePath(tablePath) + "(\"ancestor\", \"descendant\") " +
                                            ("SELECT \"ancestor\", " + newEntityId + " FROM " + this.escapeTablePath(tablePath) + " WHERE \"descendant\" = " + parentId + " ") +
                                            ("UNION ALL SELECT " + newEntityId + ", " + newEntityId);
                                    }
                                    return [4 /*yield*/, this.query(sql)];
                                case 1:
                                    _a.sent();
                                    if (!hasLevel) return [3 /*break*/, 3];
                                    return [4 /*yield*/, this.query("SELECT MAX(level) as level FROM " + this.escapeTablePath(tablePath) + " WHERE descendant = " + parentId)];
                                case 2:
                                    results = _a.sent();
                                    return [2 /*return*/, results && results[0] && results[0]["level"] ? parseInt(results[0]["level"]) + 1 : 1];
                                case 3: return [2 /*return*/, -1];
                            }
                        });
                    });
                };
                /**
                 * Loads given table's data from the database.
                 */
                SqlServerQueryRunner.prototype.getTable = function (tablePath) {
                    return __awaiter(this, void 0, void 0, function () {
                        var tables;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.getTables([tablePath])];
                                case 1:
                                    tables = _a.sent();
                                    return [2 /*return*/, tables.length > 0 ? tables[0] : undefined];
                            }
                        });
                    });
                };
                /**
                 * Loads all tables (with given names) from the database and creates a Table from them.
                 */
                SqlServerQueryRunner.prototype.getTables = function (tablePaths) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var tableNames, schemaNames, dbNames, schemaNamesString, tableNamesString, tablesSql, columnsSql, constraintsSql, identityColumnsSql, indicesSql, _a, dbTables, dbColumns, dbConstraints, dbIdentityColumns, dbIndices;
                        return __generator(this, function (_b) {
                            switch (_b.label) {
                                case 0:
                                    // if no tables given then no need to proceed
                                    if (!tablePaths || !tablePaths.length)
                                        return [2 /*return*/, []];
                                    tableNames = tablePaths.map(function (tablePath) {
                                        if (tablePath.split(".").length === 3) {
                                            return tablePath.split(".")[2];
                                        }
                                        else if (tablePath.split(".").length === 2) {
                                            return tablePath.split(".")[1];
                                        }
                                        else {
                                            return tablePath;
                                        }
                                    });
                                    schemaNames = [];
                                    tablePaths.filter(function (tablePath) { return tablePath.indexOf(".") !== -1; })
                                        .forEach(function (tablePath) {
                                        if (tablePath.split(".").length === 3) {
                                            if (tablePath.split(".")[1] !== "")
                                                schemaNames.push(tablePath.split(".")[1]);
                                        }
                                        else {
                                            schemaNames.push(tablePath.split(".")[0]);
                                        }
                                    });
                                    schemaNames.push(this.driver.options.schema || "SCHEMA_NAME()");
                                    dbNames = tablePaths
                                        .filter(function (tablePath) { return tablePath.split(".").length === 3; })
                                        .map(function (tablePath) { return tablePath.split(".")[0]; });
                                    if (this.driver.database && !dbNames.find(function (dbName) { return dbName === _this.driver.database; }))
                                        dbNames.push(this.driver.database);
                                    schemaNamesString = schemaNames.map(function (name) {
                                        return name === "SCHEMA_NAME()" ? name : "'" + name + "'";
                                    }).join(", ");
                                    tableNamesString = tableNames.map(function (name) { return "'" + name + "'"; }).join(", ");
                                    tablesSql = dbNames.map(function (dbName) {
                                        return "SELECT * FROM " + dbName + ".INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME IN (" + tableNamesString + ") AND TABLE_SCHEMA IN (" + schemaNamesString + ")";
                                    }).join(" UNION ALL ");
                                    columnsSql = dbNames.map(function (dbName) {
                                        return "SELECT * FROM " + dbName + ".INFORMATION_SCHEMA.COLUMNS WHERE TABLE_SCHEMA IN (" + schemaNamesString + ")";
                                    }).join(" UNION ALL ");
                                    constraintsSql = dbNames.map(function (dbName) {
                                        return "SELECT columnUsages.*, tableConstraints.CONSTRAINT_TYPE FROM " + dbName + ".INFORMATION_SCHEMA.KEY_COLUMN_USAGE columnUsages " +
                                            ("LEFT JOIN " + dbName + ".INFORMATION_SCHEMA.TABLE_CONSTRAINTS tableConstraints ON tableConstraints.CONSTRAINT_NAME = columnUsages.CONSTRAINT_NAME ") +
                                            ("WHERE columnUsages.TABLE_SCHEMA IN (" + schemaNamesString + ") AND tableConstraints.TABLE_SCHEMA IN (" + schemaNamesString + ")");
                                    }).join(" UNION ALL ");
                                    identityColumnsSql = dbNames.map(function (dbName) {
                                        return "SELECT COLUMN_NAME, TABLE_NAME FROM " + dbName + ".INFORMATION_SCHEMA.COLUMNS WHERE COLUMNPROPERTY(object_id(TABLE_SCHEMA + '.' + TABLE_NAME), COLUMN_NAME, 'IsIdentity') = 1 AND TABLE_SCHEMA IN (" + schemaNamesString + ")";
                                    }).join(" UNION ALL ");
                                    indicesSql = dbNames.map(function (dbName) {
                                        return "SELECT TABLE_NAME = t.name, INDEX_NAME = ind.name, IndexId = ind.index_id, ColumnId = ic.index_column_id, \n                    COLUMN_NAME = col.name, IS_UNIQUE = ind.is_unique, ind.*, ic.*, col.* \n                    FROM " + dbName + ".sys.indexes ind \n                    INNER JOIN " + dbName + ".sys.index_columns ic ON ind.object_id = ic.object_id and ind.index_id = ic.index_id\n                    INNER JOIN " + dbName + ".sys.columns col ON ic.object_id = col.object_id and ic.column_id = col.column_id \n                    INNER JOIN " + dbName + ".sys.tables t ON ind.object_id = t.object_id WHERE ind.is_primary_key = 0 \n                    AND ind.is_unique_constraint = 0 AND t.is_ms_shipped = 0";
                                    }).join(" UNION ALL ");
                                    return [4 /*yield*/, Promise.all([
                                            this.query(tablesSql),
                                            this.query(columnsSql),
                                            this.query(constraintsSql),
                                            this.query(identityColumnsSql),
                                            this.query(indicesSql),
                                        ])];
                                case 1:
                                    _a = _b.sent(), dbTables = _a[0], dbColumns = _a[1], dbConstraints = _a[2], dbIdentityColumns = _a[3], dbIndices = _a[4];
                                    // if tables were not found in the db, no need to proceed
                                    if (!dbTables.length)
                                        return [2 /*return*/, []];
                                    // create table schemas for loaded tables
                                    return [2 /*return*/, Promise.all(dbTables.map(function (dbTable) { return __awaiter(_this, void 0, void 0, function () {
                                            var table;
                                            return __generator(this, function (_a) {
                                                table = new Table_5.Table(dbTable["TABLE_NAME"]);
                                                table.database = dbTable["TABLE_CATALOG"];
                                                table.schema = dbTable["TABLE_SCHEMA"];
                                                // create columns from the loaded columns
                                                table.columns = dbColumns
                                                    .filter(function (dbColumn) { return dbColumn["TABLE_NAME"] === table.name; })
                                                    .map(function (dbColumn) {
                                                    var isPrimary = !!dbConstraints.find(function (dbConstraint) {
                                                        return dbConstraint["TABLE_NAME"] === table.name &&
                                                            dbConstraint["COLUMN_NAME"] === dbColumn["COLUMN_NAME"] &&
                                                            dbConstraint["CONSTRAINT_TYPE"] === "PRIMARY KEY";
                                                    });
                                                    var isGenerated = !!dbIdentityColumns.find(function (column) {
                                                        return column["TABLE_NAME"] === table.name &&
                                                            column["COLUMN_NAME"] === dbColumn["COLUMN_NAME"];
                                                    });
                                                    var isUnique = !!dbConstraints.find(function (dbConstraint) {
                                                        return dbConstraint["TABLE_NAME"] === table.name &&
                                                            dbConstraint["COLUMN_NAME"] === dbColumn["COLUMN_NAME"] &&
                                                            dbConstraint["CONSTRAINT_TYPE"] === "UNIQUE";
                                                    });
                                                    var tableColumn = new TableColumn_6.TableColumn();
                                                    tableColumn.name = dbColumn["COLUMN_NAME"];
                                                    tableColumn.type = dbColumn["DATA_TYPE"].toLowerCase();
                                                    tableColumn.length = dbColumn["CHARACTER_MAXIMUM_LENGTH"] ? dbColumn["CHARACTER_MAXIMUM_LENGTH"].toString() : "";
                                                    if (tableColumn.length === "-1")
                                                        tableColumn.length = "MAX";
                                                    tableColumn.precision = dbColumn["NUMERIC_PRECISION"];
                                                    tableColumn.scale = dbColumn["NUMERIC_SCALE"];
                                                    tableColumn.default = dbColumn["COLUMN_DEFAULT"] !== null && dbColumn["COLUMN_DEFAULT"] !== undefined ? dbColumn["COLUMN_DEFAULT"] : undefined;
                                                    tableColumn.isNullable = dbColumn["IS_NULLABLE"] === "YES";
                                                    tableColumn.isPrimary = isPrimary;
                                                    tableColumn.isGenerated = isGenerated;
                                                    if (tableColumn.default === "(newsequentialid())") {
                                                        tableColumn.isGenerated = true;
                                                        tableColumn.default = undefined;
                                                    }
                                                    tableColumn.isUnique = isUnique;
                                                    tableColumn.charset = dbColumn["CHARACTER_SET_NAME"];
                                                    tableColumn.collation = dbColumn["COLLATION_NAME"];
                                                    tableColumn.comment = ""; // todo: less priority, implement this later
                                                    if (tableColumn.type === "datetime2" || tableColumn.type === "time" || tableColumn.type === "datetimeoffset") {
                                                        tableColumn.precision = dbColumn["DATETIME_PRECISION"];
                                                    }
                                                    return tableColumn;
                                                });
                                                // create primary key schema
                                                table.primaryKeys = dbConstraints
                                                    .filter(function (dbConstraint) {
                                                    return dbConstraint["TABLE_NAME"] === table.name &&
                                                        dbConstraint["CONSTRAINT_TYPE"] === "PRIMARY KEY";
                                                })
                                                    .map(function (keyColumnUsage) {
                                                    return new TablePrimaryKey_5.TablePrimaryKey(keyColumnUsage["CONSTRAINT_NAME"], keyColumnUsage["COLUMN_NAME"]);
                                                });
                                                // create foreign key schemas from the loaded indices
                                                table.foreignKeys = dbConstraints
                                                    .filter(function (dbConstraint) {
                                                    return dbConstraint["TABLE_NAME"] === table.name &&
                                                        dbConstraint["CONSTRAINT_TYPE"] === "FOREIGN KEY";
                                                })
                                                    .map(function (dbConstraint) { return new TableForeignKey_5.TableForeignKey(dbConstraint["CONSTRAINT_NAME"], [], [], "", ""); }); // todo: fix missing params
                                                // create index schemas from the loaded indices
                                                table.indices = dbIndices
                                                    .filter(function (dbIndex) {
                                                    return dbIndex["TABLE_NAME"] === table.name &&
                                                        (!table.foreignKeys.find(function (foreignKey) { return foreignKey.name === dbIndex["INDEX_NAME"]; })) &&
                                                        (!table.primaryKeys.find(function (primaryKey) { return primaryKey.name === dbIndex["INDEX_NAME"]; }));
                                                })
                                                    .map(function (dbIndex) { return dbIndex["INDEX_NAME"]; })
                                                    .filter(function (value, index, self) { return self.indexOf(value) === index; }) // unqiue
                                                    .map(function (dbIndexName) {
                                                    var columnNames = dbIndices
                                                        .filter(function (dbIndex) { return dbIndex["TABLE_NAME"] === table.name && dbIndex["INDEX_NAME"] === dbIndexName; })
                                                        .map(function (dbIndex) { return dbIndex["COLUMN_NAME"]; });
                                                    var isUnique = !!dbIndices.find(function (dbIndex) { return dbIndex["TABLE_NAME"] === table.name && dbIndex["INDEX_NAME"] === dbIndexName && dbIndex["IS_UNIQUE"] === true; });
                                                    return new TableIndex_5.TableIndex(dbTable["TABLE_NAME"], dbIndexName, columnNames, isUnique);
                                                });
                                                return [2 /*return*/, table];
                                            });
                                        }); }))];
                            }
                        });
                    });
                };
                /**
                 * Checks if database with the given name exist.
                 */
                SqlServerQueryRunner.prototype.hasDatabase = function (database) {
                    return __awaiter(this, void 0, void 0, function () {
                        var result, dbId;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.query("SELECT DB_ID('" + database + "') as db_id")];
                                case 1:
                                    result = _a.sent();
                                    dbId = result[0]["db_id"];
                                    return [2 /*return*/, !!dbId];
                            }
                        });
                    });
                };
                /**
                 * Checks if table with the given name exist in the database.
                 */
                SqlServerQueryRunner.prototype.hasTable = function (tablePath) {
                    return __awaiter(this, void 0, void 0, function () {
                        var parsedTablePath, sql, result;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    parsedTablePath = this.parseTablePath(tablePath);
                                    sql = "SELECT * FROM " + parsedTablePath.database + ".INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = '" + parsedTablePath.tableName + "' AND TABLE_SCHEMA = " + (parsedTablePath.schema === "SCHEMA_NAME()" ? parsedTablePath.schema : "'" + parsedTablePath.schema + "'");
                                    return [4 /*yield*/, this.query(sql)];
                                case 1:
                                    result = _a.sent();
                                    return [2 /*return*/, result.length ? true : false];
                            }
                        });
                    });
                };
                /**
                 * Creates a database if it's not created.
                 */
                SqlServerQueryRunner.prototype.createDatabase = function (database) {
                    return this.query("IF DB_ID('" + database + "') IS NULL CREATE DATABASE " + database);
                };
                /**
                 * Creates a schema if it's not created.
                 */
                SqlServerQueryRunner.prototype.createSchema = function (schemaPaths) {
                    var _this = this;
                    if (this.driver.options.schema)
                        schemaPaths.push(this.driver.options.schema);
                    return PromiseUtils_3.PromiseUtils.runInSequence(schemaPaths, function (path) { return __awaiter(_this, void 0, void 0, function () {
                        var query, dbName, schema, currentDBQuery, currentDB, query;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (!(path.indexOf(".") === -1)) return [3 /*break*/, 1];
                                    query = "IF SCHEMA_ID('" + path + "') IS NULL BEGIN EXEC sp_executesql N'CREATE SCHEMA " + path + "' END";
                                    return [2 /*return*/, this.query(query)];
                                case 1:
                                    dbName = path.split(".")[0];
                                    schema = path.split(".")[1];
                                    return [4 /*yield*/, this.query("SELECT DB_NAME() AS db_name")];
                                case 2:
                                    currentDBQuery = _a.sent();
                                    currentDB = currentDBQuery[0]["db_name"];
                                    return [4 /*yield*/, this.query("USE " + dbName)];
                                case 3:
                                    _a.sent();
                                    query = "IF SCHEMA_ID('" + schema + "') IS NULL BEGIN EXEC sp_executesql N'CREATE SCHEMA " + schema + "' END";
                                    return [4 /*yield*/, this.query(query)];
                                case 4:
                                    _a.sent();
                                    return [2 /*return*/, this.query("USE " + currentDB)];
                            }
                        });
                    }); });
                };
                /**
                 * Creates a new table from the given table metadata and column metadatas.
                 */
                SqlServerQueryRunner.prototype.createTable = function (table) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var columnDefinitions, sql, primaryKeyColumns;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    columnDefinitions = table.columns.map(function (column) { return _this.buildCreateColumnSql(table.name, column, false, true); }).join(", ");
                                    sql = "CREATE TABLE " + this.escapeTablePath(table) + " (" + columnDefinitions;
                                    sql += table.columns
                                        .filter(function (column) { return column.isUnique; })
                                        .map(function (column) {
                                        var constraintName = table.name + "_" + column.name;
                                        var schema = table.schema || _this.driver.options.schema;
                                        if (schema)
                                            constraintName = schema + "_" + constraintName;
                                        return ", CONSTRAINT \"uk_" + constraintName + "\" UNIQUE (\"" + column.name + "\")";
                                    }).join(" ");
                                    primaryKeyColumns = table.columns.filter(function (column) { return column.isPrimary; });
                                    if (primaryKeyColumns.length > 0)
                                        sql += ", PRIMARY KEY(" + primaryKeyColumns.map(function (column) { return "\"" + column.name + "\""; }).join(", ") + ")";
                                    sql += ")";
                                    return [4 /*yield*/, this.query(sql)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Drops the table.
                 */
                SqlServerQueryRunner.prototype.dropTable = function (tablePath) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.query("DROP TABLE " + this.escapeTablePath(tablePath))];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Checks if column with the given name exist in the given table.
                 */
                SqlServerQueryRunner.prototype.hasColumn = function (tablePath, columnName) {
                    return __awaiter(this, void 0, void 0, function () {
                        var parsedTablePath, sql, result;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    parsedTablePath = this.parseTablePath(tablePath);
                                    sql = "SELECT * FROM " + parsedTablePath.database + ".INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = '" + parsedTablePath.tableName + "' AND COLUMN_NAME = '" + columnName + "' AND TABLE_SCHEMA = " + (parsedTablePath.schema === "SCHEMA_NAME()" ? parsedTablePath.schema : "'" + parsedTablePath.schema + "'");
                                    return [4 /*yield*/, this.query(sql)];
                                case 1:
                                    result = _a.sent();
                                    return [2 /*return*/, result.length ? true : false];
                            }
                        });
                    });
                };
                /**
                 * Creates a new column from the column in the table.
                 */
                SqlServerQueryRunner.prototype.addColumn = function (tableOrPath, column) {
                    return __awaiter(this, void 0, void 0, function () {
                        var tableName, sql;
                        return __generator(this, function (_a) {
                            tableName = tableOrPath instanceof Table_5.Table ? tableOrPath.name : this.parseTablePath(tableOrPath).tableName;
                            sql = "ALTER TABLE " + this.escapeTablePath(tableOrPath) + " ADD " + this.buildCreateColumnSql(tableName, column, false, true);
                            return [2 /*return*/, this.query(sql)];
                        });
                    });
                };
                /**
                 * Creates a new columns from the column in the table.
                 */
                SqlServerQueryRunner.prototype.addColumns = function (tableOrName, columns) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var queries;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    queries = columns.map(function (column) { return _this.addColumn(tableOrName, column); });
                                    return [4 /*yield*/, Promise.all(queries)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Renames column in the given table.
                 */
                SqlServerQueryRunner.prototype.renameColumn = function (tableOrName, oldTableColumnOrName, newTableColumnOrName) {
                    return __awaiter(this, void 0, void 0, function () {
                        var table, oldColumn, newColumn;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    table = undefined;
                                    if (!(tableOrName instanceof Table_5.Table)) return [3 /*break*/, 1];
                                    table = tableOrName;
                                    return [3 /*break*/, 3];
                                case 1: return [4 /*yield*/, this.getTable(tableOrName)];
                                case 2:
                                    table = _a.sent();
                                    _a.label = 3;
                                case 3:
                                    if (!table)
                                        throw new Error("Table " + tableOrName + " was not found.");
                                    oldColumn = undefined;
                                    if (oldTableColumnOrName instanceof TableColumn_6.TableColumn) {
                                        oldColumn = oldTableColumnOrName;
                                    }
                                    else {
                                        oldColumn = table.columns.find(function (column) { return column.name === oldTableColumnOrName; });
                                    }
                                    if (!oldColumn)
                                        throw new Error("Column \"" + oldTableColumnOrName + "\" was not found in the \"" + tableOrName + "\" table.");
                                    newColumn = undefined;
                                    if (newTableColumnOrName instanceof TableColumn_6.TableColumn) {
                                        newColumn = newTableColumnOrName;
                                    }
                                    else {
                                        newColumn = oldColumn.clone();
                                        newColumn.name = newTableColumnOrName;
                                    }
                                    return [2 /*return*/, this.changeColumn(table, oldColumn, newColumn)];
                            }
                        });
                    });
                };
                /**
                 * Changes a column in the table.
                 */
                SqlServerQueryRunner.prototype.changeColumn = function (tableOrName, oldTableColumnOrName, newColumn) {
                    return __awaiter(this, void 0, void 0, function () {
                        var table, oldColumn, sql;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    table = undefined;
                                    if (!(tableOrName instanceof Table_5.Table)) return [3 /*break*/, 1];
                                    table = tableOrName;
                                    return [3 /*break*/, 3];
                                case 1: return [4 /*yield*/, this.getTable(tableOrName)];
                                case 2:
                                    table = _a.sent();
                                    _a.label = 3;
                                case 3:
                                    if (!table)
                                        throw new Error("Table " + tableOrName + " was not found.");
                                    oldColumn = undefined;
                                    if (oldTableColumnOrName instanceof TableColumn_6.TableColumn) {
                                        oldColumn = oldTableColumnOrName;
                                    }
                                    else {
                                        oldColumn = table.columns.find(function (column) { return column.name === oldTableColumnOrName; });
                                    }
                                    if (!oldColumn)
                                        throw new Error("Column \"" + oldTableColumnOrName + "\" was not found in the \"" + tableOrName + "\" table.");
                                    if (!(newColumn.isGenerated !== oldColumn.isGenerated)) return [3 /*break*/, 6];
                                    return [4 /*yield*/, this.query("ALTER TABLE " + this.escapeTablePath(tableOrName) + " DROP COLUMN \"" + newColumn.name + "\"")];
                                case 4:
                                    _a.sent();
                                    return [4 /*yield*/, this.query("ALTER TABLE " + this.escapeTablePath(tableOrName) + " ADD " + this.buildCreateColumnSql(table.name, newColumn, false, false))];
                                case 5:
                                    _a.sent();
                                    _a.label = 6;
                                case 6:
                                    sql = "ALTER TABLE " + this.escapeTablePath(tableOrName) + " ALTER COLUMN " + this.buildCreateColumnSql(table.name, newColumn, true, false);
                                    return [4 /*yield*/, this.query(sql)];
                                case 7:
                                    _a.sent();
                                    if (!(newColumn.isUnique !== oldColumn.isUnique)) return [3 /*break*/, 11];
                                    if (!(newColumn.isUnique === true)) return [3 /*break*/, 9];
                                    return [4 /*yield*/, this.query("ALTER TABLE " + this.escapeTablePath(tableOrName) + " ADD CONSTRAINT \"uk_" + table.name + "_" + newColumn.name + "\" UNIQUE (\"" + newColumn.name + "\")")];
                                case 8:
                                    _a.sent();
                                    return [3 /*break*/, 11];
                                case 9:
                                    if (!(newColumn.isUnique === false)) return [3 /*break*/, 11];
                                    return [4 /*yield*/, this.query("ALTER TABLE " + this.escapeTablePath(tableOrName) + " DROP CONSTRAINT \"uk_" + table.name + "_" + newColumn.name + "\"")];
                                case 10:
                                    _a.sent();
                                    _a.label = 11;
                                case 11:
                                    if (!(newColumn.default !== oldColumn.default)) return [3 /*break*/, 16];
                                    if (!(newColumn.default !== null && newColumn.default !== undefined)) return [3 /*break*/, 14];
                                    return [4 /*yield*/, this.query("ALTER TABLE " + this.escapeTablePath(tableOrName) + " DROP CONSTRAINT \"df_" + table.name + "_" + newColumn.name + "\"")];
                                case 12:
                                    _a.sent();
                                    return [4 /*yield*/, this.query("ALTER TABLE " + this.escapeTablePath(tableOrName) + " ADD CONSTRAINT \"df_" + table.name + "_" + newColumn.name + "\" DEFAULT " + newColumn.default + " FOR \"" + newColumn.name + "\"")];
                                case 13:
                                    _a.sent();
                                    return [3 /*break*/, 16];
                                case 14:
                                    if (!(oldColumn.default !== null && oldColumn.default !== undefined)) return [3 /*break*/, 16];
                                    return [4 /*yield*/, this.query("ALTER TABLE " + this.escapeTablePath(tableOrName) + " DROP CONSTRAINT \"df_" + table.name + "_" + newColumn.name + "\"")];
                                case 15:
                                    _a.sent();
                                    _a.label = 16;
                                case 16: return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Changes a column in the table.
                 */
                SqlServerQueryRunner.prototype.changeColumns = function (table, changedColumns) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var updatePromises;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    updatePromises = changedColumns.map(function (changedColumn) { return __awaiter(_this, void 0, void 0, function () {
                                        return __generator(this, function (_a) {
                                            return [2 /*return*/, this.changeColumn(table, changedColumn.oldColumn, changedColumn.newColumn)];
                                        });
                                    }); });
                                    return [4 /*yield*/, Promise.all(updatePromises)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Drops column in the table.
                 */
                SqlServerQueryRunner.prototype.dropColumn = function (table, column) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (!column.default) return [3 /*break*/, 2];
                                    return [4 /*yield*/, this.query("ALTER TABLE " + this.escapeTablePath(table) + " DROP CONSTRAINT \"df_" + table.name + "_" + column.name + "\"")];
                                case 1:
                                    _a.sent();
                                    _a.label = 2;
                                case 2: return [4 /*yield*/, this.query("ALTER TABLE " + this.escapeTablePath(table) + " DROP COLUMN \"" + column.name + "\"")];
                                case 3:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Drops the columns in the table.
                 */
                SqlServerQueryRunner.prototype.dropColumns = function (table, columns) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var dropPromises;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    dropPromises = columns.map(function (column) { return _this.dropColumn(table, column); });
                                    return [4 /*yield*/, Promise.all(dropPromises)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Updates table's primary keys.
                 */
                SqlServerQueryRunner.prototype.updatePrimaryKeys = function (table) {
                    return __awaiter(this, void 0, void 0, function () {
                        var schema, database, oldPrimaryKeySql, oldPrimaryKey, primaryColumnNames;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    schema = table.schema || "SCHEMA_NAME()";
                                    database = table.database || this.driver.database;
                                    oldPrimaryKeySql = "SELECT columnUsages.*, tableConstraints.CONSTRAINT_TYPE FROM " + database + ".INFORMATION_SCHEMA.KEY_COLUMN_USAGE columnUsages\nLEFT JOIN " + database + ".INFORMATION_SCHEMA.TABLE_CONSTRAINTS tableConstraints ON tableConstraints.CONSTRAINT_NAME = columnUsages.CONSTRAINT_NAME AND tableConstraints.CONSTRAINT_TYPE = 'PRIMARY KEY'\nWHERE tableConstraints.TABLE_CATALOG = '" + database + "' AND columnUsages.TABLE_SCHEMA = '" + schema + "' AND tableConstraints.TABLE_SCHEMA = '" + schema + "'";
                                    return [4 /*yield*/, this.query(oldPrimaryKeySql)];
                                case 1:
                                    oldPrimaryKey = _a.sent();
                                    if (!(oldPrimaryKey.length > 0)) return [3 /*break*/, 3];
                                    return [4 /*yield*/, this.query("ALTER TABLE " + this.escapeTablePath(table) + " DROP CONSTRAINT \"" + oldPrimaryKey[0]["CONSTRAINT_NAME"] + "\"")];
                                case 2:
                                    _a.sent();
                                    _a.label = 3;
                                case 3:
                                    primaryColumnNames = table.primaryKeys.map(function (primaryKey) { return "\"" + primaryKey.columnName + "\""; });
                                    if (!(primaryColumnNames.length > 0)) return [3 /*break*/, 5];
                                    return [4 /*yield*/, this.query("ALTER TABLE " + this.escapeTablePath(table) + " ADD PRIMARY KEY (" + primaryColumnNames.join(", ") + ")")];
                                case 4:
                                    _a.sent();
                                    _a.label = 5;
                                case 5: return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Creates a new foreign key.
                 */
                SqlServerQueryRunner.prototype.createForeignKey = function (tableOrPath, foreignKey) {
                    return __awaiter(this, void 0, void 0, function () {
                        var columnNames, referencedColumnNames, sql;
                        return __generator(this, function (_a) {
                            columnNames = foreignKey.columnNames.map(function (column) { return "\"" + column + "\""; }).join(", ");
                            referencedColumnNames = foreignKey.referencedColumnNames.map(function (column) { return "\"" + column + "\""; }).join(",");
                            sql = "ALTER TABLE " + this.escapeTablePath(tableOrPath) + " ADD CONSTRAINT \"" + foreignKey.name + "\" " +
                                ("FOREIGN KEY (" + columnNames + ") ") +
                                ("REFERENCES " + this.escapeTablePath(foreignKey.referencedTablePath) + "(" + referencedColumnNames + ")");
                            if (foreignKey.onDelete)
                                sql += " ON DELETE " + foreignKey.onDelete;
                            return [2 /*return*/, this.query(sql)];
                        });
                    });
                };
                /**
                 * Creates a new foreign keys.
                 */
                SqlServerQueryRunner.prototype.createForeignKeys = function (tableOrName, foreignKeys) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var promises;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    promises = foreignKeys.map(function (foreignKey) { return _this.createForeignKey(tableOrName, foreignKey); });
                                    return [4 /*yield*/, Promise.all(promises)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Drops a foreign key from the table.
                 */
                SqlServerQueryRunner.prototype.dropForeignKey = function (tableOrPath, foreignKey) {
                    return __awaiter(this, void 0, void 0, function () {
                        var sql;
                        return __generator(this, function (_a) {
                            sql = "ALTER TABLE " + this.escapeTablePath(tableOrPath) + " DROP CONSTRAINT \"" + foreignKey.name + "\"";
                            return [2 /*return*/, this.query(sql)];
                        });
                    });
                };
                /**
                 * Drops a foreign keys from the table.
                 */
                SqlServerQueryRunner.prototype.dropForeignKeys = function (tableOrName, foreignKeys) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var promises;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    promises = foreignKeys.map(function (foreignKey) { return _this.dropForeignKey(tableOrName, foreignKey); });
                                    return [4 /*yield*/, Promise.all(promises)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Creates a new index.
                 */
                SqlServerQueryRunner.prototype.createIndex = function (tablePath, index) {
                    return __awaiter(this, void 0, void 0, function () {
                        var columns, sql;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    columns = index.columnNames.map(function (columnName) { return "\"" + columnName + "\""; }).join(", ");
                                    sql = "CREATE " + (index.isUnique ? "UNIQUE " : "") + "INDEX \"" + index.name + "\" ON " + this.escapeTablePath(tablePath) + "(" + columns + ")";
                                    return [4 /*yield*/, this.query(sql)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Drops an index from the table.
                 */
                SqlServerQueryRunner.prototype.dropIndex = function (tableSchemeOrName, indexName) {
                    return __awaiter(this, void 0, void 0, function () {
                        var sql;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    sql = "DROP INDEX \"" + indexName + "\" ON " + this.escapeTablePath(tableSchemeOrName);
                                    return [4 /*yield*/, this.query(sql)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Truncates table.
                 */
                SqlServerQueryRunner.prototype.truncate = function (tablePath) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.query("TRUNCATE TABLE " + this.escapeTablePath(tablePath))];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Removes all tables from the currently connected database.
                 */
                SqlServerQueryRunner.prototype.clearDatabase = function (schemas, database) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var isDatabaseExist, schemaNamesString, allTablesSql, allTablesResults, error_7, rollbackError_8;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.hasDatabase(database)];
                                case 1:
                                    isDatabaseExist = _a.sent();
                                    if (!isDatabaseExist)
                                        return [2 /*return*/, Promise.resolve()];
                                    if (!schemas)
                                        schemas = [];
                                    schemas.push(this.driver.options.schema || "SCHEMA_NAME()");
                                    schemaNamesString = schemas.map(function (name) {
                                        return name === "SCHEMA_NAME()" ? name : "'" + name + "'";
                                    }).join(", ");
                                    return [4 /*yield*/, this.startTransaction()];
                                case 2:
                                    _a.sent();
                                    _a.label = 3;
                                case 3:
                                    _a.trys.push([3, 8, , 13]);
                                    allTablesSql = "SELECT * FROM " + database + ".INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = 'BASE TABLE' AND TABLE_SCHEMA IN (" + schemaNamesString + ")";
                                    return [4 /*yield*/, this.query(allTablesSql)];
                                case 4:
                                    allTablesResults = _a.sent();
                                    return [4 /*yield*/, Promise.all(allTablesResults.map(function (tablesResult) { return __awaiter(_this, void 0, void 0, function () {
                                            var _this = this;
                                            var dropForeignKeySql, dropFkQueries;
                                            return __generator(this, function (_a) {
                                                switch (_a.label) {
                                                    case 0:
                                                        dropForeignKeySql = "SELECT 'ALTER TABLE \"" + database + "\".\"' + OBJECT_SCHEMA_NAME(fk.parent_object_id, DB_ID('" + database + "')) + '\".\"' + OBJECT_NAME(fk.parent_object_id, DB_ID('" + database + "')) + '\" DROP CONSTRAINT \"' + fk.name + '\"' as query FROM " + database + ".sys.foreign_keys AS fk WHERE fk.referenced_object_id = object_id('\"" + database + "\".\"" + tablesResult["TABLE_SCHEMA"] + "\".\"" + tablesResult["TABLE_NAME"] + "\"')";
                                                        return [4 /*yield*/, this.query(dropForeignKeySql)];
                                                    case 1:
                                                        dropFkQueries = _a.sent();
                                                        return [2 /*return*/, Promise.all(dropFkQueries.map(function (result) { return result["query"]; }).map(function (dropQuery) {
                                                                return _this.query(dropQuery);
                                                            }))];
                                                }
                                            });
                                        }); }))];
                                case 5:
                                    _a.sent();
                                    return [4 /*yield*/, Promise.all(allTablesResults.map(function (tablesResult) {
                                            var dropTableSql = "DROP TABLE \"" + tablesResult["TABLE_CATALOG"] + "\".\"" + tablesResult["TABLE_SCHEMA"] + "\".\"" + tablesResult["TABLE_NAME"] + "\"";
                                            return _this.query(dropTableSql);
                                        }))];
                                case 6:
                                    _a.sent();
                                    return [4 /*yield*/, this.commitTransaction()];
                                case 7:
                                    _a.sent();
                                    return [3 /*break*/, 13];
                                case 8:
                                    error_7 = _a.sent();
                                    _a.label = 9;
                                case 9:
                                    _a.trys.push([9, 11, , 12]);
                                    return [4 /*yield*/, this.rollbackTransaction()];
                                case 10:
                                    _a.sent();
                                    return [3 /*break*/, 12];
                                case 11:
                                    rollbackError_8 = _a.sent();
                                    return [3 /*break*/, 12];
                                case 12: throw error_7;
                                case 13: return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Enables special query runner mode in which sql queries won't be executed,
                 * instead they will be memorized into a special variable inside query runner.
                 * You can get memorized sql using getMemorySql() method.
                 */
                SqlServerQueryRunner.prototype.enableSqlMemory = function () {
                    this.sqlMemoryMode = true;
                };
                /**
                 * Disables special query runner mode in which sql queries won't be executed
                 * started by calling enableSqlMemory() method.
                 *
                 * Previously memorized sql will be flushed.
                 */
                SqlServerQueryRunner.prototype.disableSqlMemory = function () {
                    this.sqlsInMemory = [];
                    this.sqlMemoryMode = false;
                };
                /**
                 * Gets sql stored in the memory. Parameters in the sql are already replaced.
                 */
                SqlServerQueryRunner.prototype.getMemorySql = function () {
                    return this.sqlsInMemory;
                };
                // -------------------------------------------------------------------------
                // Protected Methods
                // -------------------------------------------------------------------------
                /**
                 * Escapes given table path.
                 */
                SqlServerQueryRunner.prototype.escapeTablePath = function (tableOrPath, disableEscape) {
                    var tablePath;
                    if (tableOrPath instanceof Table_5.Table) {
                        var schema = tableOrPath.schema || this.driver.options.schema;
                        if (schema) {
                            tablePath = schema + "." + tableOrPath.name;
                            if (tableOrPath.database)
                                tablePath = tableOrPath.database + "." + tablePath;
                        }
                        else {
                            tablePath = tableOrPath.name;
                            if (tableOrPath.database)
                                tablePath = tableOrPath.database + ".." + tablePath;
                        }
                    }
                    else {
                        tablePath = tableOrPath.indexOf(".") === -1 && this.driver.options.schema ? this.driver.options.schema + "." + tableOrPath : tableOrPath;
                    }
                    return tablePath.split(".").map(function (i) {
                        // this condition need because when custom database name was specified and schema name was not, we got `dbName..tableName` string, and doesn't need to escape middle empty string
                        if (i === "")
                            return i;
                        return disableEscape ? i : "\"" + i + "\"";
                    }).join(".");
                };
                SqlServerQueryRunner.prototype.parseTablePath = function (target) {
                    var tableName = target instanceof Table_5.Table ? target.name : target;
                    if (tableName.split(".").length === 3) {
                        return {
                            database: tableName.split(".")[0],
                            schema: tableName.split(".")[1] === "" ? "SCHEMA_NAME()" : tableName.split(".")[1],
                            tableName: tableName.split(".")[2]
                        };
                    }
                    else if (tableName.split(".").length === 2) {
                        return {
                            database: this.driver.database,
                            schema: tableName.split(".")[0],
                            tableName: tableName.split(".")[1]
                        };
                    }
                    else {
                        return {
                            database: this.driver.database,
                            schema: this.driver.options.schema ? this.driver.options.schema : "SCHEMA_NAME()",
                            tableName: tableName
                        };
                    }
                };
                /**
                 * Parametrizes given object of values. Used to create column=value queries.
                 */
                SqlServerQueryRunner.prototype.parametrize = function (objectLiteral, startFrom) {
                    if (startFrom === void 0) { startFrom = 0; }
                    return Object.keys(objectLiteral).map(function (key, index) {
                        return "\"" + key + "\"" + "=@" + (startFrom + index);
                    });
                };
                /**
                 * Builds a query for create column.
                 */
                SqlServerQueryRunner.prototype.buildCreateColumnSql = function (tableName, column, skipIdentity, createDefault) {
                    var c = "\"" + column.name + "\" " + this.connection.driver.createFullType(column);
                    if (column.collation)
                        c += " COLLATE " + column.collation;
                    if (column.isNullable !== true)
                        c += " NOT NULL";
                    if (column.isGenerated === true && column.generationStrategy === "increment" && !skipIdentity) // don't use skipPrimary here since updates can update already exist primary without auto inc.
                        c += " IDENTITY(1,1)";
                    // if (column.isPrimary === true && !skipPrimary)
                    //     c += " PRIMARY KEY";
                    if (column.comment)
                        c += " COMMENT '" + column.comment + "'";
                    if (createDefault) {
                        if (column.default !== undefined && column.default !== null) {
                            c += " CONSTRAINT \"df_" + tableName + "_" + column.name + "\" DEFAULT " + column.default;
                        }
                    }
                    if (column.isGenerated && column.generationStrategy === "uuid" && !column.default)
                        c += " DEFAULT NEWSEQUENTIALID()";
                    return c;
                };
                return SqlServerQueryRunner;
            }());
            exports_111("SqlServerQueryRunner", SqlServerQueryRunner);
        }
    };
});
System.register("typeorm/driver/sqlserver/SqlServerDriver", ["typeorm/error/ConnectionIsNotSetError", "typeorm/error/DriverPackageNotInstalledError", "typeorm/driver/DriverUtils", "typeorm/driver/sqlserver/SqlServerQueryRunner", "typeorm/util/DateUtils", "typeorm/platform/PlatformTools", "typeorm/schema-builder/RdbmsSchemaBuilder", "typeorm/driver/sqlserver/MssqlParameter"], function (exports_112, context_112) {
    "use strict";
    var __moduleName = context_112 && context_112.id;
    var ConnectionIsNotSetError_4, DriverPackageNotInstalledError_4, DriverUtils_3, SqlServerQueryRunner_1, DateUtils_5, PlatformTools_6, RdbmsSchemaBuilder_4, MssqlParameter_2, SqlServerDriver;
    return {
        setters: [
            function (ConnectionIsNotSetError_4_1) {
                ConnectionIsNotSetError_4 = ConnectionIsNotSetError_4_1;
            },
            function (DriverPackageNotInstalledError_4_1) {
                DriverPackageNotInstalledError_4 = DriverPackageNotInstalledError_4_1;
            },
            function (DriverUtils_3_1) {
                DriverUtils_3 = DriverUtils_3_1;
            },
            function (SqlServerQueryRunner_1_1) {
                SqlServerQueryRunner_1 = SqlServerQueryRunner_1_1;
            },
            function (DateUtils_5_1) {
                DateUtils_5 = DateUtils_5_1;
            },
            function (PlatformTools_6_1) {
                PlatformTools_6 = PlatformTools_6_1;
            },
            function (RdbmsSchemaBuilder_4_1) {
                RdbmsSchemaBuilder_4 = RdbmsSchemaBuilder_4_1;
            },
            function (MssqlParameter_2_1) {
                MssqlParameter_2 = MssqlParameter_2_1;
            }
        ],
        execute: function () {
            /**
             * Organizes communication with SQL Server DBMS.
             */
            SqlServerDriver = /** @class */ (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function SqlServerDriver(connection) {
                    /**
                     * Pool for slave databases.
                     * Used in replication.
                     */
                    this.slaves = [];
                    /**
                     * Indicates if replication is enabled.
                     */
                    this.isReplicated = false;
                    /**
                     * Indicates if tree tables are supported by this driver.
                     */
                    this.treeSupport = true;
                    /**
                     * Gets list of supported column data types by a driver.
                     *
                     * @see https://docs.microsoft.com/en-us/sql/t-sql/data-types/data-types-transact-sql
                     */
                    this.supportedDataTypes = [
                        "bigint",
                        "bit",
                        "decimal",
                        "int",
                        "money",
                        "numeric",
                        "smallint",
                        "smallmoney",
                        "tinyint",
                        "float",
                        "real",
                        "date",
                        "datetime2",
                        "datetime",
                        "datetimeoffset",
                        "smalldatetime",
                        "time",
                        "char",
                        "text",
                        "varchar",
                        "nchar",
                        "ntext",
                        "nvarchar",
                        "binary",
                        "image",
                        "varbinary",
                        "cursor",
                        "hierarchyid",
                        "sql_variant",
                        "table",
                        "timestamp",
                        "uniqueidentifier",
                        "xml"
                    ];
                    /**
                     * Gets list of column data types that support length by a driver.
                     */
                    this.withLengthColumnTypes = [
                        "char",
                        "varchar",
                        "nchar",
                        "nvarchar",
                        "binary",
                        "varbinary"
                    ];
                    /**
                     * Orm has special columns and we need to know what database column types should be for those types.
                     * Column types are driver dependant.
                     */
                    this.mappedDataTypes = {
                        createDate: "datetime2",
                        createDateDefault: "getdate()",
                        updateDate: "datetime2",
                        updateDateDefault: "getdate()",
                        version: "int",
                        treeLevel: "int",
                        migrationName: "varchar",
                        migrationTimestamp: "bigint",
                        cacheId: "int",
                        cacheIdentifier: "nvarchar",
                        cacheTime: "bigint",
                        cacheDuration: "int",
                        cacheQuery: "nvarchar(MAX)",
                        cacheResult: "nvarchar(MAX)",
                    };
                    /**
                     * Default values of length, precision and scale depends on column data type.
                     * Used in the cases when length/precision/scale is not specified by user.
                     */
                    this.dataTypeDefaults = {
                        varchar: { length: 255 },
                        nvarchar: { length: 255 }
                    };
                    this.connection = connection;
                    this.options = connection.options;
                    this.isReplicated = this.options.replication ? true : false;
                    // load mssql package
                    this.loadDependencies();
                    // Object.assign(connection.options, DriverUtils.buildDriverOptions(connection.options)); // todo: do it better way
                    // validate options to make sure everything is set
                    // if (!this.options.host)
                    // throw new DriverOptionNotSetError("host");
                    // if (!this.options.username)
                    //     throw new DriverOptionNotSetError("username");
                    // if (!this.options.database)
                    //     throw new DriverOptionNotSetError("database");
                }
                // -------------------------------------------------------------------------
                // Public Implemented Methods
                // -------------------------------------------------------------------------
                /**
                 * Performs connection to the database.
                 * Based on pooling options, it can either create connection immediately,
                 * either create a pool and create connection when needed.
                 */
                SqlServerDriver.prototype.connect = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var _a, _b, _c;
                        return __generator(this, function (_d) {
                            switch (_d.label) {
                                case 0:
                                    if (!this.options.replication) return [3 /*break*/, 3];
                                    _a = this;
                                    return [4 /*yield*/, Promise.all(this.options.replication.slaves.map(function (slave) {
                                            return _this.createPool(_this.options, slave);
                                        }))];
                                case 1:
                                    _a.slaves = _d.sent();
                                    _b = this;
                                    return [4 /*yield*/, this.createPool(this.options, this.options.replication.master)];
                                case 2:
                                    _b.master = _d.sent();
                                    this.database = this.options.replication.master.database;
                                    return [3 /*break*/, 5];
                                case 3:
                                    _c = this;
                                    return [4 /*yield*/, this.createPool(this.options, this.options)];
                                case 4:
                                    _c.master = _d.sent();
                                    this.database = this.options.database;
                                    _d.label = 5;
                                case 5: return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Makes any action after connection (e.g. create extensions in Postgres driver).
                 */
                SqlServerDriver.prototype.afterConnect = function () {
                    return Promise.resolve();
                };
                /**
                 * Closes connection with the database.
                 */
                SqlServerDriver.prototype.disconnect = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            if (!this.master)
                                return [2 /*return*/, Promise.reject(new ConnectionIsNotSetError_4.ConnectionIsNotSetError("mssql"))];
                            this.master.close();
                            this.slaves.forEach(function (slave) { return slave.close(); });
                            this.master = undefined;
                            this.slaves = [];
                            return [2 /*return*/];
                        });
                    });
                };
                /**
                 * Creates a schema builder used to build and sync a schema.
                 */
                SqlServerDriver.prototype.createSchemaBuilder = function () {
                    return new RdbmsSchemaBuilder_4.RdbmsSchemaBuilder(this.connection);
                };
                /**
                 * Creates a query runner used to execute database queries.
                 */
                SqlServerDriver.prototype.createQueryRunner = function (mode) {
                    if (mode === void 0) { mode = "master"; }
                    return new SqlServerQueryRunner_1.SqlServerQueryRunner(this, mode);
                };
                /**
                 * Replaces parameters in the given sql with special escaping character
                 * and an array of parameter names to be passed to a query.
                 */
                SqlServerDriver.prototype.escapeQueryWithParameters = function (sql, parameters) {
                    if (!parameters || !Object.keys(parameters).length)
                        return [sql, []];
                    var escapedParameters = [];
                    var keys = Object.keys(parameters).map(function (parameter) { return "(:" + parameter + "\\b)"; }).join("|");
                    sql = sql.replace(new RegExp(keys, "g"), function (key) {
                        var value = parameters[key.substr(1)];
                        if (value instanceof Array) {
                            return value.map(function (v) {
                                escapedParameters.push(v);
                                return "@" + (escapedParameters.length - 1);
                            }).join(", ");
                        }
                        else if (value instanceof Function) {
                            return value();
                        }
                        else {
                            escapedParameters.push(value);
                            return "@" + (escapedParameters.length - 1);
                        }
                    }); // todo: make replace only in value statements, otherwise problems
                    return [sql, escapedParameters];
                };
                /**
                 * Escapes a column name.
                 */
                SqlServerDriver.prototype.escape = function (columnName) {
                    return "\"" + columnName + "\"";
                };
                /**
                 * Prepares given value to a value to be persisted, based on its column type and metadata.
                 */
                SqlServerDriver.prototype.preparePersistentValue = function (value, columnMetadata) {
                    if (columnMetadata.transformer)
                        value = columnMetadata.transformer.to(value);
                    if (value === null || value === undefined)
                        return value;
                    if (columnMetadata.type === Boolean) {
                        return value === true ? 1 : 0;
                    }
                    else if (columnMetadata.type === "date") {
                        return DateUtils_5.DateUtils.mixedDateToDate(value);
                    }
                    else if (columnMetadata.type === "time") {
                        return DateUtils_5.DateUtils.mixedTimeToDate(value);
                    }
                    else if (columnMetadata.type === "datetime"
                        || columnMetadata.type === "smalldatetime"
                        || columnMetadata.type === Date) {
                        return DateUtils_5.DateUtils.mixedDateToDate(value, false, false);
                    }
                    else if (columnMetadata.type === "datetime2"
                        || columnMetadata.type === "datetimeoffset") {
                        return DateUtils_5.DateUtils.mixedDateToDate(value, false, true);
                    }
                    else if (columnMetadata.type === "simple-array") {
                        return DateUtils_5.DateUtils.simpleArrayToString(value);
                    }
                    else if (columnMetadata.type === "simple-json") {
                        return DateUtils_5.DateUtils.simpleJsonToString(value);
                    }
                    return value;
                };
                /**
                 * Prepares given value to a value to be persisted, based on its column type or metadata.
                 */
                SqlServerDriver.prototype.prepareHydratedValue = function (value, columnMetadata) {
                    if (value === null || value === undefined)
                        return value;
                    if (columnMetadata.type === Boolean) {
                        value = value ? true : false;
                    }
                    else if (columnMetadata.type === "datetime"
                        || columnMetadata.type === Date
                        || columnMetadata.type === "datetime2"
                        || columnMetadata.type === "smalldatetime"
                        || columnMetadata.type === "datetimeoffset") {
                        value = DateUtils_5.DateUtils.normalizeHydratedDate(value);
                    }
                    else if (columnMetadata.type === "date") {
                        value = DateUtils_5.DateUtils.mixedDateToDateString(value);
                    }
                    else if (columnMetadata.type === "time") {
                        value = DateUtils_5.DateUtils.mixedTimeToString(value);
                    }
                    else if (columnMetadata.type === "simple-array") {
                        value = DateUtils_5.DateUtils.stringToSimpleArray(value);
                    }
                    else if (columnMetadata.type === "simple-json") {
                        value = DateUtils_5.DateUtils.stringToSimpleJson(value);
                    }
                    if (columnMetadata.transformer)
                        value = columnMetadata.transformer.from(value);
                    return value;
                };
                /**
                 * Creates a database type from a given column metadata.
                 */
                SqlServerDriver.prototype.normalizeType = function (column) {
                    if (column.type === Number) {
                        return "int";
                    }
                    else if (column.type === String) {
                        return "nvarchar";
                    }
                    else if (column.type === Date) {
                        return "datetime";
                    }
                    else if (column.type === Boolean) {
                        return "bit";
                    }
                    else if (column.type === Buffer) {
                        return "binary";
                    }
                    else if (column.type === "uuid") {
                        return "uniqueidentifier";
                    }
                    else if (column.type === "simple-array") {
                        return "ntext";
                    }
                    else if (column.type === "simple-json") {
                        return "ntext";
                    }
                    else if (column.type === "integer") {
                        return "int";
                    }
                    else if (column.type === "dec") {
                        return "decimal";
                    }
                    else if (column.type === "float" && (column.precision && (column.precision >= 1 && column.precision < 25))) {
                        return "real";
                    }
                    else if (column.type === "double precision") {
                        return "float";
                    }
                    else {
                        return column.type || "";
                    }
                };
                /**
                 * Normalizes "default" value of the column.
                 */
                SqlServerDriver.prototype.normalizeDefault = function (column) {
                    if (typeof column.default === "number") {
                        return "" + column.default;
                    }
                    else if (typeof column.default === "boolean") {
                        return column.default === true ? "1" : "0";
                    }
                    else if (typeof column.default === "function") {
                        return "(" + column.default() + ")";
                    }
                    else if (typeof column.default === "string") {
                        return "'" + column.default + "'";
                    }
                    else {
                        return column.default;
                    }
                };
                /**
                 * Normalizes "isUnique" value of the column.
                 */
                SqlServerDriver.prototype.normalizeIsUnique = function (column) {
                    return column.isUnique;
                };
                /**
                 * Calculates column length taking into account the default length values.
                 */
                SqlServerDriver.prototype.getColumnLength = function (column) {
                    if (column.length)
                        return column.length;
                    var normalizedType = this.normalizeType(column);
                    if (this.dataTypeDefaults && this.dataTypeDefaults[normalizedType] && this.dataTypeDefaults[normalizedType].length)
                        return this.dataTypeDefaults[normalizedType].length.toString();
                    return "";
                };
                SqlServerDriver.prototype.createFullType = function (column) {
                    var type = column.type;
                    if (column.length) {
                        type += "(" + column.length + ")";
                    }
                    else if (column.precision && column.scale) {
                        type += "(" + column.precision + "," + column.scale + ")";
                    }
                    else if (column.precision && column.type !== "real") {
                        type += "(" + column.precision + ")";
                    }
                    else if (column.scale) {
                        type += "(" + column.scale + ")";
                    }
                    else if (this.dataTypeDefaults && this.dataTypeDefaults[column.type] && this.dataTypeDefaults[column.type].length) {
                        type += "(" + this.dataTypeDefaults[column.type].length.toString() + ")";
                    }
                    if (column.isArray)
                        type += " array";
                    return type;
                };
                /**
                 * Obtains a new database connection to a master server.
                 * Used for replication.
                 * If replication is not setup then returns default connection's database connection.
                 */
                SqlServerDriver.prototype.obtainMasterConnection = function () {
                    return Promise.resolve(this.master);
                };
                /**
                 * Obtains a new database connection to a slave server.
                 * Used for replication.
                 * If replication is not setup then returns master (default) connection's database connection.
                 */
                SqlServerDriver.prototype.obtainSlaveConnection = function () {
                    if (!this.slaves.length)
                        return this.obtainMasterConnection();
                    var random = Math.floor(Math.random() * this.slaves.length);
                    return Promise.resolve(this.slaves[random]);
                };
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Sql server's parameters needs to be wrapped into special object with type information about this value.
                 * This method wraps given value into MssqlParameter based on its column definition.
                 */
                SqlServerDriver.prototype.parametrizeValue = function (column, value) {
                    // if its already MssqlParameter then simply return it
                    if (value instanceof MssqlParameter_2.MssqlParameter)
                        return value;
                    var normalizedType = this.normalizeType({ type: column.type });
                    if (column.length) {
                        return new MssqlParameter_2.MssqlParameter(value, normalizedType, column.length);
                    }
                    else if (column.precision && column.scale) {
                        return new MssqlParameter_2.MssqlParameter(value, normalizedType, column.precision, column.scale);
                    }
                    else if (column.precision) {
                        return new MssqlParameter_2.MssqlParameter(value, normalizedType, column.precision);
                    }
                    else if (column.scale) {
                        return new MssqlParameter_2.MssqlParameter(value, normalizedType, column.scale);
                    }
                    return new MssqlParameter_2.MssqlParameter(value, normalizedType);
                };
                /**
                 * Sql server's parameters needs to be wrapped into special object with type information about this value.
                 * This method wraps all values of the given object into MssqlParameter based on their column definitions in the given table.
                 */
                SqlServerDriver.prototype.parametrizeMap = function (tablePath, map) {
                    var _this = this;
                    // find metadata for the given table
                    if (!this.connection.hasMetadata(tablePath)) // if no metadata found then we can't proceed because we don't have columns and their types
                        return map;
                    var metadata = this.connection.getMetadata(tablePath);
                    return Object.keys(map).reduce(function (newMap, key) {
                        var value = map[key];
                        // find column metadata
                        var column = metadata.findColumnWithDatabaseName(key);
                        if (!column) // if we didn't find a column then we can't proceed because we don't have a column type
                            return value;
                        newMap[key] = _this.parametrizeValue(column, value);
                        return newMap;
                    }, {});
                };
                // -------------------------------------------------------------------------
                // Protected Methods
                // -------------------------------------------------------------------------
                /**
                 * If driver dependency is not given explicitly, then try to load it via "require".
                 */
                SqlServerDriver.prototype.loadDependencies = function () {
                    try {
                        this.mssql = PlatformTools_6.PlatformTools.load("mssql");
                    }
                    catch (e) { // todo: better error for browser env
                        throw new DriverPackageNotInstalledError_4.DriverPackageNotInstalledError("SQL Server", "mssql");
                    }
                };
                /**
                 * Creates a new connection pool for a given database credentials.
                 */
                SqlServerDriver.prototype.createPool = function (options, credentials) {
                    var _this = this;
                    credentials = Object.assign(credentials, DriverUtils_3.DriverUtils.buildDriverOptions(credentials)); // todo: do it better way
                    // build connection options for the driver
                    var connectionOptions = Object.assign({}, {
                        connectionTimeout: this.options.connectionTimeout,
                        requestTimeout: this.options.requestTimeout,
                        stream: this.options.stream,
                        pool: this.options.pool,
                        options: this.options.options,
                    }, {
                        server: credentials.host,
                        user: credentials.username,
                        password: credentials.password,
                        database: credentials.database,
                        port: credentials.port,
                        domain: credentials.domain,
                    }, options.extra || {});
                    // set default useUTC option if it hasn't been set
                    if (!connectionOptions.options)
                        connectionOptions.options = { useUTC: false };
                    else if (!connectionOptions.options.useUTC)
                        connectionOptions.options.useUTC = false;
                    // pooling is enabled either when its set explicitly to true,
                    // either when its not defined at all (e.g. enabled by default)
                    return new Promise(function (ok, fail) {
                        var pool = new _this.mssql.ConnectionPool(connectionOptions);
                        var logger = _this.connection.logger;
                        /*
                          Attaching an error handler to pool errors is essential, as, otherwise, errors raised will go unhandled and
                          cause the hosting app to crash.
                         */
                        pool.on("error", function (error) { return logger.log("warn", "MSSQL pool raised an error. " + error); });
                        var connection = pool.connect(function (err) {
                            if (err)
                                return fail(err);
                            ok(connection);
                        });
                    });
                };
                return SqlServerDriver;
            }());
            exports_112("SqlServerDriver", SqlServerDriver);
        }
    };
});
System.register("typeorm/driver/postgres/PostgresQueryRunner", ["typeorm/error/TransactionAlreadyStartedError", "typeorm/error/TransactionNotStartedError", "typeorm/schema-builder/schema/TableColumn", "typeorm/schema-builder/schema/Table", "typeorm/schema-builder/schema/TableIndex", "typeorm/schema-builder/schema/TableForeignKey", "typeorm/schema-builder/schema/TablePrimaryKey", "typeorm/error/QueryRunnerAlreadyReleasedError", "typeorm/error/QueryFailedError", "typeorm/util/OrmUtils"], function (exports_113, context_113) {
    "use strict";
    var __moduleName = context_113 && context_113.id;
    var TransactionAlreadyStartedError_5, TransactionNotStartedError_5, TableColumn_7, Table_6, TableIndex_6, TableForeignKey_6, TablePrimaryKey_6, QueryRunnerAlreadyReleasedError_4, QueryFailedError_4, OrmUtils_5, PostgresQueryRunner;
    return {
        setters: [
            function (TransactionAlreadyStartedError_5_1) {
                TransactionAlreadyStartedError_5 = TransactionAlreadyStartedError_5_1;
            },
            function (TransactionNotStartedError_5_1) {
                TransactionNotStartedError_5 = TransactionNotStartedError_5_1;
            },
            function (TableColumn_7_1) {
                TableColumn_7 = TableColumn_7_1;
            },
            function (Table_6_1) {
                Table_6 = Table_6_1;
            },
            function (TableIndex_6_1) {
                TableIndex_6 = TableIndex_6_1;
            },
            function (TableForeignKey_6_1) {
                TableForeignKey_6 = TableForeignKey_6_1;
            },
            function (TablePrimaryKey_6_1) {
                TablePrimaryKey_6 = TablePrimaryKey_6_1;
            },
            function (QueryRunnerAlreadyReleasedError_4_1) {
                QueryRunnerAlreadyReleasedError_4 = QueryRunnerAlreadyReleasedError_4_1;
            },
            function (QueryFailedError_4_1) {
                QueryFailedError_4 = QueryFailedError_4_1;
            },
            function (OrmUtils_5_1) {
                OrmUtils_5 = OrmUtils_5_1;
            }
        ],
        execute: function () {
            /**
             * Runs queries on a single postgres database connection.
             */
            PostgresQueryRunner = /** @class */ (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function PostgresQueryRunner(driver, mode) {
                    if (mode === void 0) { mode = "master"; }
                    /**
                     * Indicates if connection for this query runner is released.
                     * Once its released, query runner cannot run queries anymore.
                     */
                    this.isReleased = false;
                    /**
                     * Indicates if transaction is in progress.
                     */
                    this.isTransactionActive = false;
                    /**
                     * Stores temporarily user data.
                     * Useful for sharing data with subscribers.
                     */
                    this.data = {};
                    /**
                     * Indicates if special query runner mode in which sql queries won't be executed is enabled.
                     */
                    this.sqlMemoryMode = false;
                    /**
                     * Sql-s stored if "sql in memory" mode is enabled.
                     */
                    this.sqlsInMemory = [];
                    this.driver = driver;
                    this.connection = driver.connection;
                    this.mode = mode;
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Creates/uses database connection from the connection pool to perform further operations.
                 * Returns obtained database connection.
                 */
                PostgresQueryRunner.prototype.connect = function () {
                    var _this = this;
                    if (this.databaseConnection)
                        return Promise.resolve(this.databaseConnection);
                    if (this.databaseConnectionPromise)
                        return this.databaseConnectionPromise;
                    if (this.mode === "slave" && this.driver.isReplicated) {
                        this.databaseConnectionPromise = this.driver.obtainSlaveConnection().then(function (_a) {
                            var connection = _a[0], release = _a[1];
                            _this.driver.connectedQueryRunners.push(_this);
                            _this.databaseConnection = connection;
                            _this.releaseCallback = release;
                            return _this.databaseConnection;
                        });
                    }
                    else { // master
                        this.databaseConnectionPromise = this.driver.obtainMasterConnection().then(function (_a) {
                            var connection = _a[0], release = _a[1];
                            _this.driver.connectedQueryRunners.push(_this);
                            _this.databaseConnection = connection;
                            _this.releaseCallback = release;
                            return _this.databaseConnection;
                        });
                    }
                    return this.databaseConnectionPromise;
                };
                /**
                 * Releases used database connection.
                 * You cannot use query runner methods once its released.
                 */
                PostgresQueryRunner.prototype.release = function () {
                    this.isReleased = true;
                    if (this.releaseCallback)
                        this.releaseCallback();
                    var index = this.driver.connectedQueryRunners.indexOf(this);
                    if (index !== -1)
                        this.driver.connectedQueryRunners.splice(index);
                    return Promise.resolve();
                };
                /**
                 * Starts transaction.
                 */
                PostgresQueryRunner.prototype.startTransaction = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isTransactionActive)
                                        throw new TransactionAlreadyStartedError_5.TransactionAlreadyStartedError();
                                    this.isTransactionActive = true;
                                    return [4 /*yield*/, this.query("START TRANSACTION")];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Commits transaction.
                 * Error will be thrown if transaction was not started.
                 */
                PostgresQueryRunner.prototype.commitTransaction = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (!this.isTransactionActive)
                                        throw new TransactionNotStartedError_5.TransactionNotStartedError();
                                    return [4 /*yield*/, this.query("COMMIT")];
                                case 1:
                                    _a.sent();
                                    this.isTransactionActive = false;
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Rollbacks transaction.
                 * Error will be thrown if transaction was not started.
                 */
                PostgresQueryRunner.prototype.rollbackTransaction = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (!this.isTransactionActive)
                                        throw new TransactionNotStartedError_5.TransactionNotStartedError();
                                    return [4 /*yield*/, this.query("ROLLBACK")];
                                case 1:
                                    _a.sent();
                                    this.isTransactionActive = false;
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Executes a given SQL query.
                 */
                PostgresQueryRunner.prototype.query = function (query, parameters) {
                    var _this = this;
                    if (this.isReleased)
                        throw new QueryRunnerAlreadyReleasedError_4.QueryRunnerAlreadyReleasedError();
                    // console.log("query: ", query);
                    // console.log("parameters: ", parameters);
                    return new Promise(function (ok, fail) { return __awaiter(_this, void 0, void 0, function () {
                        var _this = this;
                        var databaseConnection, queryStartTime;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.connect()];
                                case 1:
                                    databaseConnection = _a.sent();
                                    this.driver.connection.logger.logQuery(query, parameters, this);
                                    queryStartTime = +new Date();
                                    databaseConnection.query(query, parameters, function (err, result) {
                                        // log slow queries if maxQueryExecution time is set
                                        var maxQueryExecutionTime = _this.driver.connection.options.maxQueryExecutionTime;
                                        var queryEndTime = +new Date();
                                        var queryExecutionTime = queryEndTime - queryStartTime;
                                        if (maxQueryExecutionTime && queryExecutionTime > maxQueryExecutionTime)
                                            _this.driver.connection.logger.logQuerySlow(queryExecutionTime, query, parameters, _this);
                                        if (err) {
                                            _this.driver.connection.logger.logQueryError(err, query, parameters, _this);
                                            fail(new QueryFailedError_4.QueryFailedError(query, parameters, err));
                                        }
                                        else {
                                            ok(result.rows);
                                        }
                                    });
                                    return [2 /*return*/];
                            }
                        });
                    }); });
                };
                /**
                 * Returns raw data stream.
                 */
                PostgresQueryRunner.prototype.stream = function (query, parameters, onEnd, onError) {
                    var _this = this;
                    var QueryStream = this.driver.loadStreamDependency();
                    if (this.isReleased)
                        throw new QueryRunnerAlreadyReleasedError_4.QueryRunnerAlreadyReleasedError();
                    return new Promise(function (ok, fail) { return __awaiter(_this, void 0, void 0, function () {
                        var databaseConnection, stream, err_6;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    _a.trys.push([0, 2, , 3]);
                                    return [4 /*yield*/, this.connect()];
                                case 1:
                                    databaseConnection = _a.sent();
                                    this.driver.connection.logger.logQuery(query, parameters, this);
                                    stream = databaseConnection.query(new QueryStream(query, parameters));
                                    if (onEnd)
                                        stream.on("end", onEnd);
                                    if (onError)
                                        stream.on("error", onError);
                                    ok(stream);
                                    return [3 /*break*/, 3];
                                case 2:
                                    err_6 = _a.sent();
                                    fail(err_6);
                                    return [3 /*break*/, 3];
                                case 3: return [2 /*return*/];
                            }
                        });
                    }); });
                };
                /**
                 * Insert a new row with given values into the given table.
                 * Returns value of the generated column if given and generate column exist in the table.
                 */
                PostgresQueryRunner.prototype.insert = function (tablePath, keyValues) {
                    return __awaiter(this, void 0, void 0, function () {
                        var keys, columns, values, generatedColumns, generatedColumnNames, generatedColumnSql, sql, parameters, result, generatedMap;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    keys = Object.keys(keyValues);
                                    columns = keys.map(function (key) { return "\"" + key + "\""; }).join(", ");
                                    values = keys.map(function (key, index) { return "$" + (index + 1); }).join(",");
                                    generatedColumns = this.connection.hasMetadata(tablePath) ? this.connection.getMetadata(tablePath).generatedColumns : [];
                                    generatedColumnNames = generatedColumns.map(function (generatedColumn) { return "\"" + generatedColumn.databaseName + "\""; }).join(", ");
                                    generatedColumnSql = generatedColumns.length > 0 ? " RETURNING " + generatedColumnNames : "";
                                    sql = columns.length > 0
                                        ? "INSERT INTO " + this.escapeTablePath(tablePath) + "(" + columns + ") VALUES (" + values + ") " + generatedColumnSql
                                        : "INSERT INTO " + this.escapeTablePath(tablePath) + " DEFAULT VALUES " + generatedColumnSql;
                                    parameters = keys.map(function (key) { return keyValues[key]; });
                                    return [4 /*yield*/, this.query(sql, parameters)];
                                case 1:
                                    result = _a.sent();
                                    generatedMap = generatedColumns.reduce(function (map, column) {
                                        var valueMap = column.createValueMap(result[0][column.databaseName]);
                                        return OrmUtils_5.OrmUtils.mergeDeep(map, valueMap);
                                    }, {});
                                    return [2 /*return*/, {
                                            result: result,
                                            generatedMap: Object.keys(generatedMap).length > 0 ? generatedMap : undefined
                                        }];
                            }
                        });
                    });
                };
                /**
                 * Updates rows that match given conditions in the given table.
                 */
                PostgresQueryRunner.prototype.update = function (tablePath, valuesMap, conditions) {
                    return __awaiter(this, void 0, void 0, function () {
                        var updateValues, conditionString, query, updateParams, conditionParams, allParameters;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    updateValues = this.parametrize(valuesMap).join(", ");
                                    conditionString = this.parametrize(conditions, Object.keys(valuesMap).length).join(" AND ");
                                    query = "UPDATE " + this.escapeTablePath(tablePath) + " SET " + updateValues + (conditionString ? (" WHERE " + conditionString) : "");
                                    updateParams = Object.keys(valuesMap).map(function (key) { return valuesMap[key]; });
                                    conditionParams = Object.keys(conditions).map(function (key) { return conditions[key]; });
                                    allParameters = updateParams.concat(conditionParams);
                                    return [4 /*yield*/, this.query(query, allParameters)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Deletes from the given table by a given conditions.
                 */
                PostgresQueryRunner.prototype.delete = function (tablePath, conditions, maybeParameters) {
                    return __awaiter(this, void 0, void 0, function () {
                        var conditionString, parameters, sql;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    conditionString = typeof conditions === "string" ? conditions : this.parametrize(conditions).join(" AND ");
                                    parameters = conditions instanceof Object ? Object.keys(conditions).map(function (key) { return conditions[key]; }) : maybeParameters;
                                    sql = "DELETE FROM " + this.escapeTablePath(tablePath) + " WHERE " + conditionString;
                                    return [4 /*yield*/, this.query(sql, parameters)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Inserts rows into closure table.
                 *
                 * todo: rethink its place
                 */
                PostgresQueryRunner.prototype.insertIntoClosureTable = function (tablePath, newEntityId, parentId, hasLevel) {
                    return __awaiter(this, void 0, void 0, function () {
                        var sql, results;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    sql = "";
                                    if (hasLevel) {
                                        sql = "INSERT INTO " + this.escapeTablePath(tablePath) + "(\"ancestor\", \"descendant\", \"level\") " +
                                            ("SELECT \"ancestor\", " + newEntityId + ", \"level\" + 1 FROM " + this.escapeTablePath(tablePath) + " WHERE \"descendant\" = " + parentId + " ") +
                                            ("UNION ALL SELECT " + newEntityId + ", " + newEntityId + ", 1");
                                    }
                                    else {
                                        sql = "INSERT INTO " + this.escapeTablePath(tablePath) + "(\"ancestor\", \"descendant\") " +
                                            ("SELECT \"ancestor\", " + newEntityId + " FROM " + this.escapeTablePath(tablePath) + " WHERE \"descendant\" = " + parentId + " ") +
                                            ("UNION ALL SELECT " + newEntityId + ", " + newEntityId);
                                    }
                                    return [4 /*yield*/, this.query(sql)];
                                case 1:
                                    _a.sent();
                                    if (!hasLevel) return [3 /*break*/, 3];
                                    return [4 /*yield*/, this.query("SELECT MAX(level) as level FROM " + this.escapeTablePath(tablePath) + " WHERE descendant = " + parentId)];
                                case 2:
                                    results = _a.sent();
                                    return [2 /*return*/, results && results[0] && results[0]["level"] ? parseInt(results[0]["level"]) + 1 : 1];
                                case 3: return [2 /*return*/, -1];
                            }
                        });
                    });
                };
                /**
                 * Loads given table's data from the database.
                 */
                PostgresQueryRunner.prototype.getTable = function (tablePath) {
                    return __awaiter(this, void 0, void 0, function () {
                        var tables;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.getTables([tablePath])];
                                case 1:
                                    tables = _a.sent();
                                    return [2 /*return*/, tables.length > 0 ? tables[0] : undefined];
                            }
                        });
                    });
                };
                /**
                 * Loads all tables (with given names) from the database and creates a Table from them.
                 */
                PostgresQueryRunner.prototype.getTables = function (tablePaths) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var tableNames, currentSchemaQuery, currentSchema, schemaNames, tableNamesString, schemaNamesString, tablesCondition, tablesSql, columnsSql, indicesSql, foreignKeysSql, uniqueKeysSql, primaryKeysSql, _a, dbTables, dbColumns, dbIndices, dbForeignKeys, dbUniqueKeys, primaryKeys;
                        return __generator(this, function (_b) {
                            switch (_b.label) {
                                case 0:
                                    // if no tables given then no need to proceed
                                    if (!tablePaths || !tablePaths.length)
                                        return [2 /*return*/, []];
                                    tableNames = tablePaths.map(function (tablePath) {
                                        return tablePath.indexOf(".") === -1 ? tablePath : tablePath.split(".")[1];
                                    });
                                    return [4 /*yield*/, this.query("SELECT * FROM current_schema()")];
                                case 1:
                                    currentSchemaQuery = _b.sent();
                                    currentSchema = currentSchemaQuery[0]["current_schema"];
                                    schemaNames = tablePaths
                                        .filter(function (tablePath) { return tablePath.indexOf(".") !== -1; })
                                        .map(function (tablePath) { return tablePath.split(".")[0]; });
                                    schemaNames.push(this.driver.options.schema || currentSchema);
                                    tableNamesString = tableNames.map(function (name) { return "'" + name + "'"; }).join(", ");
                                    schemaNamesString = schemaNames.map(function (name) { return "'" + name + "'"; }).join(", ");
                                    tablesCondition = tablePaths.map(function (tablePath) {
                                        var _a = tablePath.split("."), schemaName = _a[0], tableName = _a[1];
                                        if (!tableName) {
                                            tableName = schemaName;
                                            schemaName = _this.driver.options.schema || currentSchema;
                                        }
                                        return "table_schema = '" + schemaName + "' AND table_name = '" + tableName + "'";
                                    }).join(" OR ");
                                    tablesSql = "SELECT * FROM information_schema.tables WHERE " + tablesCondition;
                                    columnsSql = "SELECT * FROM information_schema.columns WHERE table_schema IN (" + schemaNamesString + ")";
                                    indicesSql = "SELECT t.relname AS table_name, i.relname AS index_name, a.attname AS column_name, ix.indisunique AS is_unique, a.attnum, ix.indkey FROM pg_class t, pg_class i, pg_index ix, pg_attribute a, pg_namespace ns\nWHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid\nAND a.attnum = ANY(ix.indkey) AND t.relkind = 'r' AND t.relname IN (" + tableNamesString + ") AND t.relnamespace = ns.OID AND ns.nspname IN (" + schemaNamesString + ") ORDER BY t.relname, i.relname";
                                    foreignKeysSql = "SELECT table_name, constraint_name FROM information_schema.table_constraints WHERE table_schema IN (" + schemaNamesString + ") AND constraint_type = 'FOREIGN KEY'";
                                    uniqueKeysSql = "SELECT * FROM information_schema.table_constraints WHERE table_schema IN (" + schemaNamesString + ") AND constraint_type = 'UNIQUE'";
                                    primaryKeysSql = "SELECT c.column_name, tc.table_name, tc.constraint_name FROM information_schema.table_constraints tc\nJOIN information_schema.constraint_column_usage AS ccu USING (constraint_schema, constraint_name)\nJOIN information_schema.columns AS c ON c.table_schema = tc.constraint_schema AND tc.table_name = c.table_name AND ccu.column_name = c.column_name\nwhere constraint_type = 'PRIMARY KEY' AND c.table_schema IN (" + schemaNamesString + ")";
                                    return [4 /*yield*/, Promise.all([
                                            this.query(tablesSql),
                                            this.query(columnsSql),
                                            this.query(indicesSql),
                                            this.query(foreignKeysSql),
                                            this.query(uniqueKeysSql),
                                            this.query(primaryKeysSql),
                                        ])];
                                case 2:
                                    _a = _b.sent(), dbTables = _a[0], dbColumns = _a[1], dbIndices = _a[2], dbForeignKeys = _a[3], dbUniqueKeys = _a[4], primaryKeys = _a[5];
                                    // if tables were not found in the db, no need to proceed
                                    if (!dbTables.length)
                                        return [2 /*return*/, []];
                                    // create tables for loaded tables
                                    return [2 /*return*/, dbTables.map(function (dbTable) {
                                            var table = new Table_6.Table(dbTable["table_name"]);
                                            table.database = dbTable["table_catalog"];
                                            table.schema = dbTable["table_schema"];
                                            // create columns from the loaded columns
                                            table.columns = dbColumns
                                                .filter(function (dbColumn) { return dbColumn["table_name"] === table.name; })
                                                .map(function (dbColumn) {
                                                var seqName = table.schema === currentSchema
                                                    ? dbColumn["table_name"] + "_" + dbColumn["column_name"] + "_seq"
                                                    : table.schema + "." + dbColumn["table_name"] + "_" + dbColumn["column_name"] + "_seq";
                                                var isGenerated = !!dbColumn["column_default"]
                                                    && (dbColumn["column_default"].replace(/"/gi, "") === "nextval('" + seqName + "'::regclass)" || /^uuid\_generate\_v\d\(\)/.test(dbColumn["column_default"]));
                                                var tableColumn = new TableColumn_7.TableColumn();
                                                tableColumn.name = dbColumn["column_name"];
                                                tableColumn.type = dbColumn["data_type"].toLowerCase();
                                                tableColumn.length = dbColumn["character_maximum_length"] ? dbColumn["character_maximum_length"].toString() : "";
                                                tableColumn.precision = dbColumn["numeric_precision"];
                                                tableColumn.scale = dbColumn["numeric_scale"];
                                                tableColumn.default = dbColumn["column_default"] !== null && dbColumn["column_default"] !== undefined ? dbColumn["column_default"].replace(/::character varying/, "") : undefined;
                                                tableColumn.isNullable = dbColumn["is_nullable"] === "YES";
                                                // tableColumn.isPrimary = dbColumn["column_key"].indexOf("PRI") !== -1;
                                                tableColumn.isGenerated = isGenerated;
                                                tableColumn.comment = ""; // dbColumn["COLUMN_COMMENT"];
                                                tableColumn.charset = dbColumn["character_set_name"];
                                                tableColumn.collation = dbColumn["collation_name"];
                                                tableColumn.isUnique = !!dbUniqueKeys.find(function (key) { return key["constraint_name"] === "uk_" + dbColumn["table_name"] + "_" + dbColumn["column_name"]; });
                                                if (tableColumn.type === "array") {
                                                    tableColumn.isArray = true;
                                                    var type = dbColumn["udt_name"].substring(1);
                                                    tableColumn.type = _this.connection.driver.normalizeType({ type: type });
                                                }
                                                if (tableColumn.type === "time without time zone"
                                                    || tableColumn.type === "time with time zone"
                                                    || tableColumn.type === "timestamp without time zone"
                                                    || tableColumn.type === "timestamp with time zone") {
                                                    tableColumn.precision = dbColumn["datetime_precision"];
                                                }
                                                return tableColumn;
                                            });
                                            // create primary key schema
                                            table.primaryKeys = primaryKeys
                                                .filter(function (primaryKey) { return primaryKey["table_name"] === table.name; })
                                                .map(function (primaryKey) { return new TablePrimaryKey_6.TablePrimaryKey(primaryKey["constraint_name"], primaryKey["column_name"]); });
                                            // create foreign key schemas from the loaded indices
                                            table.foreignKeys = dbForeignKeys
                                                .filter(function (dbForeignKey) { return dbForeignKey["table_name"] === table.name; })
                                                .map(function (dbForeignKey) { return new TableForeignKey_6.TableForeignKey(dbForeignKey["constraint_name"], [], [], "", ""); }); // todo: fix missing params
                                            // create unique key schemas from the loaded indices
                                            /*table.uniqueKeys = dbUniqueKeys
                                                .filter(dbUniqueKey => dbUniqueKey["table_name"] === table.name)
                                                .map(dbUniqueKey => {
                                                    return new UniqueKeySchema(dbUniqueKey["TABLE_NAME"], dbUniqueKey["CONSTRAINT_NAME"], [/!* todo *!/]);
                                                });*/
                                            // create index schemas from the loaded indices
                                            table.indices = dbIndices
                                                .filter(function (dbIndex) {
                                                return dbIndex["table_name"] === table.name &&
                                                    (!table.foreignKeys.find(function (foreignKey) { return foreignKey.name === dbIndex["index_name"]; })) &&
                                                    (!table.primaryKeys.find(function (primaryKey) { return primaryKey.name === dbIndex["index_name"]; })) &&
                                                    (!dbUniqueKeys.find(function (key) { return key["constraint_name"] === dbIndex["index_name"]; }));
                                            })
                                                .map(function (dbIndex) { return dbIndex["index_name"]; })
                                                .filter(function (value, index, self) { return self.indexOf(value) === index; }) // unqiue
                                                .map(function (dbIndexName) {
                                                var dbIndicesInfos = dbIndices
                                                    .filter(function (dbIndex) { return dbIndex["table_name"] === table.name && dbIndex["index_name"] === dbIndexName; });
                                                var columnPositions = dbIndicesInfos[0]["indkey"].split(" ")
                                                    .map(function (x) { return parseInt(x); });
                                                var columnNames = columnPositions
                                                    .map(function (pos) { return dbIndicesInfos.find(function (idx) { return idx.attnum === pos; })["column_name"]; });
                                                return new TableIndex_6.TableIndex(dbTable["table_name"], dbIndexName, columnNames, dbIndicesInfos[0]["is_unique"]);
                                            });
                                            return table;
                                        })];
                            }
                        });
                    });
                };
                /**
                 * Checks if database with the given name exist.
                 */
                PostgresQueryRunner.prototype.hasDatabase = function (database) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            return [2 /*return*/, Promise.resolve(false)];
                        });
                    });
                };
                /**
                 * Checks if table with the given name exist in the database.
                 */
                PostgresQueryRunner.prototype.hasTable = function (tablePath) {
                    return __awaiter(this, void 0, void 0, function () {
                        var parsedTablePath, sql, result;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    parsedTablePath = this.parseTablePath(tablePath);
                                    sql = "SELECT * FROM information_schema.tables WHERE table_schema = " + parsedTablePath.schema + " AND table_name = " + parsedTablePath.tableName;
                                    return [4 /*yield*/, this.query(sql)];
                                case 1:
                                    result = _a.sent();
                                    return [2 /*return*/, result.length ? true : false];
                            }
                        });
                    });
                };
                /**
                 * Creates a database if it's not created.
                 * Postgres does not supports database creation inside a transaction block.
                 */
                PostgresQueryRunner.prototype.createDatabase = function (database) {
                    return Promise.resolve([]);
                };
                /**
                 * Creates a schema if it's not created.
                 */
                PostgresQueryRunner.prototype.createSchema = function (schemas) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        return __generator(this, function (_a) {
                            if (this.driver.options.schema)
                                schemas.push(this.driver.options.schema);
                            return [2 /*return*/, Promise.all(schemas.map(function (schema) { return _this.query("CREATE SCHEMA IF NOT EXISTS \"" + schema + "\""); }))];
                        });
                    });
                };
                /**
                 * Creates a new table from the given table metadata and column metadatas.
                 */
                PostgresQueryRunner.prototype.createTable = function (table) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var schema, columnDefinitions, up, primaryKeyColumns, down;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    schema = table.schema || this.driver.options.schema;
                                    columnDefinitions = table.columns.map(function (column) { return _this.buildCreateColumnSql(column, false); }).join(", ");
                                    up = "CREATE TABLE " + this.escapeTablePath(table) + " (" + columnDefinitions;
                                    up += table.columns
                                        .filter(function (column) { return column.isUnique; })
                                        .map(function (column) {
                                        return schema ? ", CONSTRAINT \"uk_" + schema + "_" + table.name + "_" + column.name + "\" UNIQUE (\"" + column.name + "\")"
                                            : ", CONSTRAINT \"uk_" + table.name + "_" + column.name + "\" UNIQUE (\"" + column.name + "\")";
                                    }).join(" ");
                                    primaryKeyColumns = table.columns.filter(function (column) { return column.isPrimary; });
                                    if (primaryKeyColumns.length > 0)
                                        up += ", PRIMARY KEY(" + primaryKeyColumns.map(function (column) { return "\"" + column.name + "\""; }).join(", ") + ")";
                                    up += ")";
                                    down = "DROP TABLE \"" + table.name + "\"";
                                    return [4 /*yield*/, this.schemaQuery(up, down)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Drops the table.
                 */
                PostgresQueryRunner.prototype.dropTable = function (tablePath) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.query("DROP TABLE " + this.escapeTablePath(tablePath))];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Checks if column with the given name exist in the given table.
                 */
                PostgresQueryRunner.prototype.hasColumn = function (tablePath, columnName) {
                    return __awaiter(this, void 0, void 0, function () {
                        var parsedTablePath, sql, result;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    parsedTablePath = this.parseTablePath(tablePath);
                                    sql = "SELECT * FROM information_schema.columns WHERE table_schema = " + parsedTablePath.schema + " AND table_name = '" + parsedTablePath.tableName + "' AND column_name = '" + columnName + "'";
                                    return [4 /*yield*/, this.query(sql)];
                                case 1:
                                    result = _a.sent();
                                    return [2 /*return*/, result.length ? true : false];
                            }
                        });
                    });
                };
                /**
                 * Creates a new column from the column in the table.
                 */
                PostgresQueryRunner.prototype.addColumn = function (tableOrPath, column) {
                    return __awaiter(this, void 0, void 0, function () {
                        var up, down;
                        return __generator(this, function (_a) {
                            up = "ALTER TABLE " + this.escapeTablePath(tableOrPath) + " ADD " + this.buildCreateColumnSql(column, false);
                            down = "ALTER TABLE " + this.escapeTablePath(tableOrPath) + " DROP \"" + column.name + "\"";
                            return [2 /*return*/, this.schemaQuery(up, down)];
                        });
                    });
                };
                /**
                 * Creates a new columns from the column in the table.
                 */
                PostgresQueryRunner.prototype.addColumns = function (tableOrName, columns) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var queries;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    queries = columns.map(function (column) { return _this.addColumn(tableOrName, column); });
                                    return [4 /*yield*/, Promise.all(queries)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Renames column in the given table.
                 */
                PostgresQueryRunner.prototype.renameColumn = function (tableOrName, oldTableColumnOrName, newTableColumnOrName) {
                    return __awaiter(this, void 0, void 0, function () {
                        var table, oldColumn, newColumn;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    table = undefined;
                                    if (!(tableOrName instanceof Table_6.Table)) return [3 /*break*/, 1];
                                    table = tableOrName;
                                    return [3 /*break*/, 3];
                                case 1: return [4 /*yield*/, this.getTable(tableOrName)];
                                case 2:
                                    table = _a.sent();
                                    _a.label = 3;
                                case 3:
                                    if (!table)
                                        throw new Error("Table " + tableOrName + " was not found.");
                                    oldColumn = undefined;
                                    if (oldTableColumnOrName instanceof TableColumn_7.TableColumn) {
                                        oldColumn = oldTableColumnOrName;
                                    }
                                    else {
                                        oldColumn = table.columns.find(function (column) { return column.name === oldTableColumnOrName; });
                                    }
                                    if (!oldColumn)
                                        throw new Error("Column \"" + oldTableColumnOrName + "\" was not found in the \"" + tableOrName + "\" table.");
                                    newColumn = undefined;
                                    if (newTableColumnOrName instanceof TableColumn_7.TableColumn) {
                                        newColumn = newTableColumnOrName;
                                    }
                                    else {
                                        newColumn = oldColumn.clone();
                                        newColumn.name = newTableColumnOrName;
                                    }
                                    return [2 /*return*/, this.changeColumn(table, oldColumn, newColumn)];
                            }
                        });
                    });
                };
                /**
                 * Changes a column in the table.
                 */
                PostgresQueryRunner.prototype.changeColumn = function (tableOrName, oldTableColumnOrName, newColumn) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var table, sql, oldColumn, up, up, schema, up, up2, up, up2, up, up, up, up, up;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    table = undefined;
                                    sql = [];
                                    if (!(tableOrName instanceof Table_6.Table)) return [3 /*break*/, 1];
                                    table = tableOrName;
                                    return [3 /*break*/, 3];
                                case 1: return [4 /*yield*/, this.getTable(tableOrName)];
                                case 2:
                                    table = _a.sent();
                                    _a.label = 3;
                                case 3:
                                    if (!table)
                                        throw new Error("Table " + tableOrName + " was not found.");
                                    oldColumn = undefined;
                                    if (oldTableColumnOrName instanceof TableColumn_7.TableColumn) {
                                        oldColumn = oldTableColumnOrName;
                                    }
                                    else {
                                        oldColumn = table.columns.find(function (column) { return column.name === oldTableColumnOrName; });
                                    }
                                    if (!oldColumn)
                                        throw new Error("Column \"" + oldTableColumnOrName + "\" was not found in the \"" + tableOrName + "\" table.");
                                    if (this.connection.driver.createFullType(oldColumn) !== this.connection.driver.createFullType(newColumn) ||
                                        oldColumn.name !== newColumn.name) {
                                        up = "ALTER TABLE " + this.escapeTablePath(tableOrName) + " ALTER COLUMN \"" + oldColumn.name + "\"";
                                        if (this.connection.driver.createFullType(oldColumn) !== this.connection.driver.createFullType(newColumn)) {
                                            up += " TYPE " + this.connection.driver.createFullType(newColumn);
                                        }
                                        if (oldColumn.name !== newColumn.name) { // todo: make rename in a separate query too. Need also change sequences and their defaults
                                            up += " RENAME TO " + newColumn.name;
                                        }
                                        sql.push({ up: up, down: "-- TODO: revert " + up }); // TODO: Add revert logic
                                    }
                                    if (oldColumn.isNullable !== newColumn.isNullable) {
                                        up = "ALTER TABLE " + this.escapeTablePath(tableOrName) + " ALTER COLUMN \"" + oldColumn.name + "\"";
                                        if (newColumn.isNullable) {
                                            up += " DROP NOT NULL";
                                        }
                                        else {
                                            up += " SET NOT NULL";
                                        }
                                        sql.push({ up: up, down: "-- TODO: revert " + up }); // TODO: Add revert logic
                                    }
                                    // update sequence generation
                                    if (oldColumn.isGenerated !== newColumn.isGenerated) {
                                        schema = table.schema || this.driver.options.schema;
                                        if (!oldColumn.isGenerated && newColumn.type !== "uuid") {
                                            up = schema
                                                ? "CREATE SEQUENCE \"" + schema + "\".\"" + table.name + "_" + oldColumn.name + "_seq\" OWNED BY " + this.escapeTablePath(table) + ".\"" + oldColumn.name + "\""
                                                : "CREATE SEQUENCE \"" + table.name + "_" + oldColumn.name + "_seq\" OWNED BY " + this.escapeTablePath(table) + ".\"" + oldColumn.name + "\"";
                                            sql.push({ up: up, down: "-- TODO: revert " + up }); // TODO: Add revert logic
                                            up2 = schema
                                                ? "ALTER TABLE " + this.escapeTablePath(table) + " ALTER COLUMN \"" + oldColumn.name + "\" SET DEFAULT nextval('\"" + schema + "." + table.name + "_" + oldColumn.name + "_seq\"')"
                                                : "ALTER TABLE " + this.escapeTablePath(table) + " ALTER COLUMN \"" + oldColumn.name + "\" SET DEFAULT nextval('\"" + table.name + "_" + oldColumn.name + "_seq\"')";
                                            sql.push({ up: up2, down: "-- TODO: revert " + up2 }); // TODO: Add revert logic
                                        }
                                        else {
                                            up = "ALTER TABLE " + this.escapeTablePath(table) + " ALTER COLUMN \"" + oldColumn.name + "\" DROP DEFAULT";
                                            sql.push({ up: up, down: "-- TODO: revert " + up }); // TODO: Add revert logic
                                            up2 = schema
                                                ? "DROP SEQUENCE \"" + schema + "\".\"" + table.name + "_" + oldColumn.name + "_seq\""
                                                : "DROP SEQUENCE \"" + table.name + "_" + oldColumn.name + "_seq\"";
                                            sql.push({ up: up2, down: "-- TODO: revert " + up2 }); // TODO: Add revert logic
                                        }
                                    }
                                    if (oldColumn.comment !== newColumn.comment) {
                                        up = "COMMENT ON COLUMN " + this.escapeTablePath(tableOrName) + ".\"" + oldColumn.name + "\" is '" + newColumn.comment + "'";
                                        sql.push({ up: up, down: "-- TODO: revert " + up }); // TODO: Add revert logic
                                    }
                                    if (oldColumn.isUnique !== newColumn.isUnique) {
                                        if (newColumn.isUnique === true) {
                                            up = "ALTER TABLE " + this.escapeTablePath(tableOrName) + " ADD CONSTRAINT \"uk_" + table.name + "_" + newColumn.name + "\" UNIQUE (\"" + newColumn.name + "\")";
                                            sql.push({ up: up, down: "-- TODO: revert " + up }); // TODO: Add revert logic
                                        }
                                        else if (newColumn.isUnique === false) {
                                            up = "ALTER TABLE " + this.escapeTablePath(tableOrName) + " DROP CONSTRAINT \"uk_" + table.name + "_" + newColumn.name + "\"";
                                            sql.push({ up: up, down: "-- TODO: revert " + up }); // TODO: Add revert logic
                                        }
                                    }
                                    if (newColumn.default !== oldColumn.default) {
                                        if (newColumn.default !== null && newColumn.default !== undefined) {
                                            up = "ALTER TABLE " + this.escapeTablePath(tableOrName) + " ALTER COLUMN \"" + newColumn.name + "\" SET DEFAULT " + newColumn.default;
                                            sql.push({ up: up, down: "-- TODO: revert " + up }); // TODO: Add revert logic
                                        }
                                        else if (oldColumn.default !== null && oldColumn.default !== undefined) {
                                            up = "ALTER TABLE " + this.escapeTablePath(tableOrName) + " ALTER COLUMN \"" + newColumn.name + "\" DROP DEFAULT";
                                            sql.push({ up: up, down: "-- TODO: revert " + up }); // TODO: Add revert logic
                                        }
                                    }
                                    return [4 /*yield*/, Promise.all(sql.map(function (_a) {
                                            var up = _a.up, down = _a.down;
                                            return _this.schemaQuery(up, down);
                                        }))];
                                case 4:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Changes a column in the table.
                 */
                PostgresQueryRunner.prototype.changeColumns = function (table, changedColumns) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var updatePromises;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    updatePromises = changedColumns.map(function (changedColumn) { return __awaiter(_this, void 0, void 0, function () {
                                        return __generator(this, function (_a) {
                                            return [2 /*return*/, this.changeColumn(table, changedColumn.oldColumn, changedColumn.newColumn)];
                                        });
                                    }); });
                                    return [4 /*yield*/, Promise.all(updatePromises)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Drops column in the table.
                 */
                PostgresQueryRunner.prototype.dropColumn = function (table, column) {
                    return __awaiter(this, void 0, void 0, function () {
                        var up, down;
                        return __generator(this, function (_a) {
                            up = "ALTER TABLE " + this.escapeTablePath(table) + " DROP \"" + column.name + "\"";
                            down = "ALTER TABLE " + this.escapeTablePath(table) + " ADD " + this.buildCreateColumnSql(column, false);
                            return [2 /*return*/, this.schemaQuery(up, down)];
                        });
                    });
                };
                /**
                 * Drops the columns in the table.
                 */
                PostgresQueryRunner.prototype.dropColumns = function (table, columns) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var dropPromises;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    dropPromises = columns.map(function (column) { return _this.dropColumn(table, column); });
                                    return [4 /*yield*/, Promise.all(dropPromises)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Updates table's primary keys.
                 */
                PostgresQueryRunner.prototype.updatePrimaryKeys = function (table) {
                    return __awaiter(this, void 0, void 0, function () {
                        var primaryColumnNames, up, down, up2, down2, up3, down3;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    primaryColumnNames = table.primaryKeys.map(function (primaryKey) { return "\"" + primaryKey.columnName + "\""; });
                                    up = "ALTER TABLE " + this.escapeTablePath(table) + " DROP CONSTRAINT IF EXISTS \"" + table.name + "_pkey\"";
                                    down = "-- TODO: revert " + up;
                                    return [4 /*yield*/, this.schemaQuery(up, down)];
                                case 1:
                                    _a.sent(); // TODO: Add revert logic
                                    up2 = "DROP INDEX IF EXISTS \"" + table.name + "_pkey\"";
                                    down2 = "-- TODO: revert " + up2;
                                    return [4 /*yield*/, this.schemaQuery(up2, down2)];
                                case 2:
                                    _a.sent(); // TODO: Add revert logic
                                    if (!(primaryColumnNames.length > 0)) return [3 /*break*/, 4];
                                    up3 = "ALTER TABLE " + this.escapeTablePath(table) + " ADD PRIMARY KEY (" + primaryColumnNames.join(", ") + ")";
                                    down3 = "ALTER TABLE " + this.escapeTablePath(table) + " DROP PRIMARY KEY (" + primaryColumnNames.join(", ") + ")";
                                    return [4 /*yield*/, this.schemaQuery(up3, down3)];
                                case 3:
                                    _a.sent();
                                    _a.label = 4;
                                case 4: return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Creates a new foreign key.
                 */
                PostgresQueryRunner.prototype.createForeignKey = function (tableOrName, foreignKey) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _a, up, down;
                        return __generator(this, function (_b) {
                            _a = this.foreignKeySql(tableOrName, foreignKey), up = _a.add, down = _a.drop;
                            return [2 /*return*/, this.schemaQuery(up, down)];
                        });
                    });
                };
                /**
                 * Creates a new foreign keys.
                 */
                PostgresQueryRunner.prototype.createForeignKeys = function (tableOrName, foreignKeys) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var promises;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    promises = foreignKeys.map(function (foreignKey) { return _this.createForeignKey(tableOrName, foreignKey); });
                                    return [4 /*yield*/, Promise.all(promises)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Drops a foreign key from the table.
                 */
                PostgresQueryRunner.prototype.dropForeignKey = function (tableOrName, foreignKey) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _a, down, up;
                        return __generator(this, function (_b) {
                            _a = this.foreignKeySql(tableOrName, foreignKey), down = _a.add, up = _a.drop;
                            return [2 /*return*/, this.schemaQuery(up, down)];
                        });
                    });
                };
                /**
                 * Drops a foreign keys from the table.
                 */
                PostgresQueryRunner.prototype.dropForeignKeys = function (tableOrName, foreignKeys) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var promises;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    promises = foreignKeys.map(function (foreignKey) { return _this.dropForeignKey(tableOrName, foreignKey); });
                                    return [4 /*yield*/, Promise.all(promises)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Creates a new index.
                 */
                PostgresQueryRunner.prototype.createIndex = function (table, index) {
                    return __awaiter(this, void 0, void 0, function () {
                        var columnNames, up, down;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    columnNames = index.columnNames.map(function (columnName) { return "\"" + columnName + "\""; }).join(",");
                                    up = "CREATE " + (index.isUnique ? "UNIQUE " : "") + "INDEX \"" + index.name + "\" ON " + this.escapeTablePath(table) + "(" + columnNames + ")";
                                    down = "-- TODO: revert " + up;
                                    return [4 /*yield*/, this.schemaQuery(up, down)];
                                case 1:
                                    _a.sent(); // TODO: Add revert logic
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Drops an index from the table.
                 */
                PostgresQueryRunner.prototype.dropIndex = function (tableSchemeOrPath, indexName) {
                    return __awaiter(this, void 0, void 0, function () {
                        var schema, up, down;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    schema = this.extractSchema(tableSchemeOrPath);
                                    up = schema ? "DROP INDEX \"" + schema + "\".\"" + indexName + "\"" : "DROP INDEX \"" + indexName + "\"";
                                    down = "-- TODO: revert " + up;
                                    return [4 /*yield*/, this.schemaQuery(up, down)];
                                case 1:
                                    _a.sent(); // TODO: Add revert logic
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Truncates table.
                 */
                PostgresQueryRunner.prototype.truncate = function (tablePath) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.query("TRUNCATE TABLE " + this.escapeTablePath(tablePath))];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Removes all tables from the currently connected database.
                 */
                PostgresQueryRunner.prototype.clearDatabase = function (schemas) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var schemaNamesString, selectDropsQuery, dropQueries, error_8, rollbackError_9;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (!schemas)
                                        schemas = [];
                                    schemas.push(this.driver.options.schema || "current_schema()");
                                    schemaNamesString = schemas.map(function (name) {
                                        return name === "current_schema()" ? name : "'" + name + "'";
                                    }).join(", ");
                                    return [4 /*yield*/, this.startTransaction()];
                                case 1:
                                    _a.sent();
                                    _a.label = 2;
                                case 2:
                                    _a.trys.push([2, 6, , 11]);
                                    selectDropsQuery = "SELECT 'DROP TABLE IF EXISTS \"' || schemaname || '\".\"' || tablename || '\" CASCADE;' as query FROM pg_tables WHERE schemaname IN (" + schemaNamesString + ")";
                                    return [4 /*yield*/, this.query(selectDropsQuery)];
                                case 3:
                                    dropQueries = _a.sent();
                                    return [4 /*yield*/, Promise.all(dropQueries.map(function (q) { return _this.query(q["query"]); }))];
                                case 4:
                                    _a.sent();
                                    return [4 /*yield*/, this.commitTransaction()];
                                case 5:
                                    _a.sent();
                                    return [3 /*break*/, 11];
                                case 6:
                                    error_8 = _a.sent();
                                    _a.label = 7;
                                case 7:
                                    _a.trys.push([7, 9, , 10]);
                                    return [4 /*yield*/, this.rollbackTransaction()];
                                case 8:
                                    _a.sent();
                                    return [3 /*break*/, 10];
                                case 9:
                                    rollbackError_9 = _a.sent();
                                    return [3 /*break*/, 10];
                                case 10: throw error_8;
                                case 11: return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Enables special query runner mode in which sql queries won't be executed,
                 * instead they will be memorized into a special variable inside query runner.
                 * You can get memorized sql using getMemorySql() method.
                 */
                PostgresQueryRunner.prototype.enableSqlMemory = function () {
                    this.sqlMemoryMode = true;
                };
                /**
                 * Disables special query runner mode in which sql queries won't be executed
                 * started by calling enableSqlMemory() method.
                 *
                 * Previously memorized sql will be flushed.
                 */
                PostgresQueryRunner.prototype.disableSqlMemory = function () {
                    this.sqlsInMemory = [];
                    this.sqlMemoryMode = false;
                };
                /**
                 * Gets sql stored in the memory. Parameters in the sql are already replaced.
                 */
                PostgresQueryRunner.prototype.getMemorySql = function () {
                    return this.sqlsInMemory;
                };
                /**
                 * Executes sql used special for schema build.
                 */
                PostgresQueryRunner.prototype.schemaQuery = function (upQuery, downQuery) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    // if sql-in-memory mode is enabled then simply store sql in memory and return
                                    if (this.sqlMemoryMode === true) {
                                        this.sqlsInMemory.push({ up: upQuery, down: downQuery });
                                        return [2 /*return*/, Promise.resolve()];
                                    }
                                    return [4 /*yield*/, this.query(upQuery)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                // -------------------------------------------------------------------------
                // Protected Methods
                // -------------------------------------------------------------------------
                /**
                 * Extracts schema name from given Table object or tablePath string.
                 */
                PostgresQueryRunner.prototype.extractSchema = function (tableOrPath) {
                    if (tableOrPath instanceof Table_6.Table) {
                        return tableOrPath.schema || this.driver.options.schema;
                    }
                    else {
                        return tableOrPath.indexOf(".") === -1 ? this.driver.options.schema : tableOrPath.split(".")[0];
                    }
                };
                PostgresQueryRunner.prototype.foreignKeySql = function (tableOrPath, foreignKey) {
                    var add = "ALTER TABLE " + this.escapeTablePath(tableOrPath) + " ADD CONSTRAINT \"" + foreignKey.name + "\" " +
                        ("FOREIGN KEY (\"" + foreignKey.columnNames.join("\", \"") + "\") ") +
                        ("REFERENCES " + this.escapeTablePath(foreignKey.referencedTablePath) + "(\"" + foreignKey.referencedColumnNames.join("\", \"") + "\")");
                    if (foreignKey.onDelete)
                        add += " ON DELETE " + foreignKey.onDelete;
                    var drop = "ALTER TABLE " + this.escapeTablePath(tableOrPath) + " DROP CONSTRAINT \"" + foreignKey.name + "\"";
                    return { add: add, drop: drop };
                };
                /**
                 * Escapes given table path.
                 */
                PostgresQueryRunner.prototype.escapeTablePath = function (tableOrPath, disableEscape) {
                    if (tableOrPath instanceof Table_6.Table) {
                        var schema = tableOrPath.schema || this.driver.options.schema;
                        if (schema) {
                            tableOrPath = schema + "." + tableOrPath.name;
                        }
                        else {
                            tableOrPath = tableOrPath.name;
                        }
                    }
                    else {
                        tableOrPath = tableOrPath.indexOf(".") === -1 && this.driver.options.schema ? this.driver.options.schema + "." + tableOrPath : tableOrPath;
                    }
                    return tableOrPath.split(".").map(function (i) {
                        return disableEscape ? i : "\"" + i + "\"";
                    }).join(".");
                };
                PostgresQueryRunner.prototype.parseTablePath = function (tablePath) {
                    if (tablePath.indexOf(".") === -1) {
                        return {
                            schema: this.driver.options.schema ? "'" + this.driver.options.schema + "'" : "current_schema()",
                            tableName: "'" + tablePath + "'"
                        };
                    }
                    else {
                        return {
                            schema: "'" + tablePath.split(".")[0] + "'",
                            tableName: "'" + tablePath.split(".")[1] + "'"
                        };
                    }
                };
                /**
                 * Parametrizes given object of values. Used to create column=value queries.
                 */
                PostgresQueryRunner.prototype.parametrize = function (objectLiteral, startIndex) {
                    if (startIndex === void 0) { startIndex = 0; }
                    return Object.keys(objectLiteral).map(function (key, index) { return "\"" + key + "\"=$" + (startIndex + index + 1); });
                };
                /**
                 * Builds a query for create column.
                 */
                PostgresQueryRunner.prototype.buildCreateColumnSql = function (column, skipPrimary) {
                    var c = "\"" + column.name + "\"";
                    if (column.isGenerated === true && column.generationStrategy === "increment") { // don't use skipPrimary here since updates can update already exist primary without auto inc.
                        if (column.type === "integer")
                            c += " SERIAL";
                        if (column.type === "smallint")
                            c += " SMALLSERIAL";
                        if (column.type === "bigint")
                            c += " BIGSERIAL";
                    }
                    if (!column.isGenerated || column.type === "uuid")
                        c += " " + this.connection.driver.createFullType(column);
                    if (column.charset)
                        c += " CHARACTER SET \"" + column.charset + "\"";
                    if (column.collation)
                        c += " COLLATE \"" + column.collation + "\"";
                    if (column.isNullable !== true)
                        c += " NOT NULL";
                    // if (column.isPrimary)
                    //     c += " PRIMARY KEY";
                    if (column.default !== undefined && column.default !== null) { // todo: same code in all drivers. make it DRY
                        c += " DEFAULT " + column.default;
                    }
                    if (column.isGenerated && column.generationStrategy === "uuid" && !column.default)
                        c += " DEFAULT uuid_generate_v4()";
                    return c;
                };
                return PostgresQueryRunner;
            }());
            exports_113("PostgresQueryRunner", PostgresQueryRunner);
        }
    };
});
System.register("typeorm/driver/postgres/PostgresDriver", ["typeorm/error/ConnectionIsNotSetError", "typeorm/error/DriverPackageNotInstalledError", "typeorm/driver/DriverUtils", "typeorm/driver/postgres/PostgresQueryRunner", "typeorm/util/DateUtils", "typeorm/platform/PlatformTools", "typeorm/schema-builder/RdbmsSchemaBuilder"], function (exports_114, context_114) {
    "use strict";
    var __moduleName = context_114 && context_114.id;
    var ConnectionIsNotSetError_5, DriverPackageNotInstalledError_5, DriverUtils_4, PostgresQueryRunner_1, DateUtils_6, PlatformTools_7, RdbmsSchemaBuilder_5, PostgresDriver;
    return {
        setters: [
            function (ConnectionIsNotSetError_5_1) {
                ConnectionIsNotSetError_5 = ConnectionIsNotSetError_5_1;
            },
            function (DriverPackageNotInstalledError_5_1) {
                DriverPackageNotInstalledError_5 = DriverPackageNotInstalledError_5_1;
            },
            function (DriverUtils_4_1) {
                DriverUtils_4 = DriverUtils_4_1;
            },
            function (PostgresQueryRunner_1_1) {
                PostgresQueryRunner_1 = PostgresQueryRunner_1_1;
            },
            function (DateUtils_6_1) {
                DateUtils_6 = DateUtils_6_1;
            },
            function (PlatformTools_7_1) {
                PlatformTools_7 = PlatformTools_7_1;
            },
            function (RdbmsSchemaBuilder_5_1) {
                RdbmsSchemaBuilder_5 = RdbmsSchemaBuilder_5_1;
            }
        ],
        execute: function () {
            /**
             * Organizes communication with PostgreSQL DBMS.
             */
            PostgresDriver = /** @class */ (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function PostgresDriver(connection) {
                    /**
                     * Pool for slave databases.
                     * Used in replication.
                     */
                    this.slaves = [];
                    /**
                     * We store all created query runners because we need to release them.
                     */
                    this.connectedQueryRunners = [];
                    /**
                     * Indicates if replication is enabled.
                     */
                    this.isReplicated = false;
                    /**
                     * Indicates if tree tables are supported by this driver.
                     */
                    this.treeSupport = true;
                    /**
                     * Gets list of supported column data types by a driver.
                     *
                     * @see https://www.tutorialspoint.com/postgresql/postgresql_data_types.htm
                     * @see https://www.postgresql.org/docs/9.2/static/datatype.html
                     */
                    this.supportedDataTypes = [
                        "smallint",
                        "integer",
                        "bigint",
                        "decimal",
                        "numeric",
                        "real",
                        "double precision",
                        "money",
                        "character varying",
                        "varchar",
                        "character",
                        "char",
                        "text",
                        "citext",
                        "bytea",
                        "bit",
                        "bit varying",
                        "timestamp",
                        "timestamp without time zone",
                        "timestamp with time zone",
                        "date",
                        "time",
                        "time without time zone",
                        "time with time zone",
                        "interval",
                        "boolean",
                        "enum",
                        "point",
                        "line",
                        "lseg",
                        "box",
                        "path",
                        "polygon",
                        "circle",
                        "cidr",
                        "inet",
                        "macaddr",
                        "tsvector",
                        "tsquery",
                        "uuid",
                        "xml",
                        "json",
                        "jsonb"
                    ];
                    /**
                     * Gets list of column data types that support length by a driver.
                     */
                    this.withLengthColumnTypes = [
                        "character varying",
                        "varchar",
                        "character",
                        "char",
                        "bit",
                        "bit varying"
                    ];
                    /**
                     * Orm has special columns and we need to know what database column types should be for those types.
                     * Column types are driver dependant.
                     */
                    this.mappedDataTypes = {
                        createDate: "timestamp",
                        createDateDefault: "now()",
                        updateDate: "timestamp",
                        updateDateDefault: "now()",
                        version: "int",
                        treeLevel: "int",
                        migrationName: "varchar",
                        migrationTimestamp: "bigint",
                        cacheId: "int",
                        cacheIdentifier: "varchar",
                        cacheTime: "bigint",
                        cacheDuration: "int",
                        cacheQuery: "text",
                        cacheResult: "text",
                    };
                    this.connection = connection;
                    this.options = connection.options;
                    this.isReplicated = this.options.replication ? true : false;
                    // load postgres package
                    this.loadDependencies();
                    // Object.assign(this.options, DriverUtils.buildDriverOptions(connection.options)); // todo: do it better way
                    // validate options to make sure everything is set
                    // todo: revisit validation with replication in mind
                    // if (!this.options.host)
                    //     throw new DriverOptionNotSetError("host");
                    // if (!this.options.username)
                    //     throw new DriverOptionNotSetError("username");
                    // if (!this.options.database)
                    //     throw new DriverOptionNotSetError("database");
                }
                // -------------------------------------------------------------------------
                // Public Implemented Methods
                // -------------------------------------------------------------------------
                /**
                 * Performs connection to the database.
                 * Based on pooling options, it can either create connection immediately,
                 * either create a pool and create connection when needed.
                 */
                PostgresDriver.prototype.connect = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var _a, _b, _c;
                        return __generator(this, function (_d) {
                            switch (_d.label) {
                                case 0:
                                    if (!this.options.replication) return [3 /*break*/, 3];
                                    _a = this;
                                    return [4 /*yield*/, Promise.all(this.options.replication.slaves.map(function (slave) {
                                            return _this.createPool(_this.options, slave);
                                        }))];
                                case 1:
                                    _a.slaves = _d.sent();
                                    _b = this;
                                    return [4 /*yield*/, this.createPool(this.options, this.options.replication.master)];
                                case 2:
                                    _b.master = _d.sent();
                                    this.database = this.options.replication.master.database;
                                    return [3 /*break*/, 5];
                                case 3:
                                    _c = this;
                                    return [4 /*yield*/, this.createPool(this.options, this.options)];
                                case 4:
                                    _c.master = _d.sent();
                                    this.database = this.options.database;
                                    _d.label = 5;
                                case 5: return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Makes any action after connection (e.g. create extensions in Postgres driver).
                 */
                PostgresDriver.prototype.afterConnect = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var hasUuidColumns, hasCitextColumns;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    hasUuidColumns = this.connection.entityMetadatas.some(function (metadata) {
                                        return metadata.generatedColumns.filter(function (column) { return column.generationStrategy === "uuid"; }).length > 0;
                                    });
                                    hasCitextColumns = this.connection.entityMetadatas.some(function (metadata) {
                                        return metadata.columns.filter(function (column) { return column.type === "citext"; }).length > 0;
                                    });
                                    if (!(hasUuidColumns || hasCitextColumns)) return [3 /*break*/, 2];
                                    return [4 /*yield*/, Promise.all([this.master].concat(this.slaves).map(function (pool) {
                                            return new Promise(function (ok, fail) {
                                                pool.connect(function (err, connection, release) { return __awaiter(_this, void 0, void 0, function () {
                                                    var logger, _1, _2;
                                                    return __generator(this, function (_a) {
                                                        switch (_a.label) {
                                                            case 0:
                                                                logger = this.connection.logger;
                                                                if (err)
                                                                    return [2 /*return*/, fail(err)];
                                                                if (!hasUuidColumns) return [3 /*break*/, 4];
                                                                _a.label = 1;
                                                            case 1:
                                                                _a.trys.push([1, 3, , 4]);
                                                                return [4 /*yield*/, this.executeQuery(connection, "CREATE extension IF NOT EXISTS \"uuid-ossp\"")];
                                                            case 2:
                                                                _a.sent();
                                                                return [3 /*break*/, 4];
                                                            case 3:
                                                                _1 = _a.sent();
                                                                logger.log("warn", "At least one of the entities has uuid column, but the 'uuid-ossp' extension cannot be installed automatically. Please install it manually using superuser rights");
                                                                return [3 /*break*/, 4];
                                                            case 4:
                                                                if (!hasCitextColumns) return [3 /*break*/, 8];
                                                                _a.label = 5;
                                                            case 5:
                                                                _a.trys.push([5, 7, , 8]);
                                                                return [4 /*yield*/, this.executeQuery(connection, "CREATE extension IF NOT EXISTS \"citext\"")];
                                                            case 6:
                                                                _a.sent();
                                                                return [3 /*break*/, 8];
                                                            case 7:
                                                                _2 = _a.sent();
                                                                logger.log("warn", "At least one of the entities has citext column, but the 'citext' extension cannot be installed automatically. Please install it manually using superuser rights");
                                                                return [3 /*break*/, 8];
                                                            case 8:
                                                                release();
                                                                ok();
                                                                return [2 /*return*/];
                                                        }
                                                    });
                                                }); });
                                            });
                                        }))];
                                case 1:
                                    _a.sent();
                                    _a.label = 2;
                                case 2: return [2 /*return*/, Promise.resolve()];
                            }
                        });
                    });
                };
                /**
                 * Closes connection with database.
                 */
                PostgresDriver.prototype.disconnect = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (!this.master)
                                        return [2 /*return*/, Promise.reject(new ConnectionIsNotSetError_5.ConnectionIsNotSetError("postgres"))];
                                    return [4 /*yield*/, this.closePool(this.master)];
                                case 1:
                                    _a.sent();
                                    return [4 /*yield*/, Promise.all(this.slaves.map(function (slave) { return _this.closePool(slave); }))];
                                case 2:
                                    _a.sent();
                                    this.master = undefined;
                                    this.slaves = [];
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Creates a schema builder used to build and sync a schema.
                 */
                PostgresDriver.prototype.createSchemaBuilder = function () {
                    return new RdbmsSchemaBuilder_5.RdbmsSchemaBuilder(this.connection);
                };
                /**
                 * Creates a query runner used to execute database queries.
                 */
                PostgresDriver.prototype.createQueryRunner = function (mode) {
                    if (mode === void 0) { mode = "master"; }
                    return new PostgresQueryRunner_1.PostgresQueryRunner(this, mode);
                };
                /**
                 * Prepares given value to a value to be persisted, based on its column type and metadata.
                 */
                PostgresDriver.prototype.preparePersistentValue = function (value, columnMetadata) {
                    if (columnMetadata.transformer)
                        value = columnMetadata.transformer.to(value);
                    if (value === null || value === undefined)
                        return value;
                    if (columnMetadata.type === Boolean) {
                        return value === true ? 1 : 0;
                    }
                    else if (columnMetadata.type === "date") {
                        return DateUtils_6.DateUtils.mixedDateToDateString(value);
                    }
                    else if (columnMetadata.type === "time") {
                        return DateUtils_6.DateUtils.mixedDateToTimeString(value);
                    }
                    else if (columnMetadata.type === "datetime"
                        || columnMetadata.type === Date
                        || columnMetadata.type === "timestamp"
                        || columnMetadata.type === "timestamp with time zone"
                        || columnMetadata.type === "timestamp without time zone") {
                        return DateUtils_6.DateUtils.mixedDateToDate(value);
                    }
                    else if (columnMetadata.type === "json" || columnMetadata.type === "jsonb") {
                        return JSON.stringify(value);
                    }
                    else if (columnMetadata.type === "simple-array") {
                        return DateUtils_6.DateUtils.simpleArrayToString(value);
                    }
                    else if (columnMetadata.type === "simple-json") {
                        return DateUtils_6.DateUtils.simpleJsonToString(value);
                    }
                    return value;
                };
                /**
                 * Prepares given value to a value to be persisted, based on its column type or metadata.
                 */
                PostgresDriver.prototype.prepareHydratedValue = function (value, columnMetadata) {
                    if (value === null || value === undefined)
                        return value;
                    if (columnMetadata.type === Boolean) {
                        value = value ? true : false;
                    }
                    else if (columnMetadata.type === "datetime"
                        || columnMetadata.type === Date
                        || columnMetadata.type === "timestamp"
                        || columnMetadata.type === "timestamp with time zone"
                        || columnMetadata.type === "timestamp without time zone") {
                        value = DateUtils_6.DateUtils.normalizeHydratedDate(value);
                    }
                    else if (columnMetadata.type === "date") {
                        value = DateUtils_6.DateUtils.mixedDateToDateString(value);
                    }
                    else if (columnMetadata.type === "time") {
                        value = DateUtils_6.DateUtils.mixedTimeToString(value);
                    }
                    else if (columnMetadata.type === "simple-array") {
                        value = DateUtils_6.DateUtils.stringToSimpleArray(value);
                    }
                    else if (columnMetadata.type === "simple-json") {
                        value = DateUtils_6.DateUtils.stringToSimpleJson(value);
                    }
                    if (columnMetadata.transformer)
                        value = columnMetadata.transformer.from(value);
                    return value;
                };
                /**
                 * Replaces parameters in the given sql with special escaping character
                 * and an array of parameter names to be passed to a query.
                 */
                PostgresDriver.prototype.escapeQueryWithParameters = function (sql, parameters) {
                    if (!parameters || !Object.keys(parameters).length)
                        return [sql, []];
                    var builtParameters = [];
                    var keys = Object.keys(parameters).map(function (parameter) { return "(:" + parameter + "\\b)"; }).join("|");
                    sql = sql.replace(new RegExp(keys, "g"), function (key) {
                        var value = parameters[key.substr(1)];
                        if (value instanceof Array) {
                            return value.map(function (v) {
                                builtParameters.push(v);
                                return "$" + builtParameters.length;
                            }).join(", ");
                        }
                        else if (value instanceof Function) {
                            return value();
                        }
                        else {
                            builtParameters.push(value);
                            return "$" + builtParameters.length;
                        }
                    }); // todo: make replace only in value statements, otherwise problems
                    return [sql, builtParameters];
                };
                /**
                 * Escapes a column name.
                 */
                PostgresDriver.prototype.escape = function (columnName) {
                    return "\"" + columnName + "\"";
                };
                /**
                 * Creates a database type from a given column metadata.
                 */
                PostgresDriver.prototype.normalizeType = function (column) {
                    var type = "";
                    if (column.type === Number) {
                        type += "integer";
                    }
                    else if (column.type === String) {
                        type += "character varying";
                    }
                    else if (column.type === Date) {
                        type += "timestamp";
                    }
                    else if (column.type === Boolean) {
                        type += "boolean";
                    }
                    else if (column.type === "simple-array") {
                        type += "text";
                    }
                    else if (column.type === "simple-json") {
                        type += "text";
                    }
                    else {
                        type += column.type;
                    }
                    // normalize shortcuts
                    if (type === "int" || type === "int4") {
                        type = "integer";
                    }
                    else if (type === "int2") {
                        type = "smallint";
                    }
                    else if (type === "int8") {
                        type = "bigint";
                    }
                    else if (type === "decimal") {
                        type = "numeric";
                    }
                    else if (type === "float8") {
                        type = "double precision";
                    }
                    else if (type === "float4") {
                        type = "real";
                    }
                    else if (type === "citext") {
                        type = "citext";
                    }
                    else if (type === "char") {
                        type = "character";
                    }
                    else if (type === "varchar") {
                        type = "character varying";
                    }
                    else if (type === "time") {
                        type = "time without time zone";
                    }
                    else if (type === "timetz") {
                        type = "time with time zone";
                    }
                    else if (type === "timestamptz") {
                        type = "timestamp with time zone";
                    }
                    else if (type === "bool") {
                        type = "boolean";
                    }
                    else if (type === "varbit") {
                        type = "bit varying";
                    }
                    else if (type === "timestamp") {
                        type = "timestamp without time zone";
                    }
                    return type;
                };
                /**
                 * Normalizes "default" value of the column.
                 */
                PostgresDriver.prototype.normalizeDefault = function (column) {
                    var arrayCast = column.isArray ? "::" + column.type + "[]" : "";
                    if (typeof column.default === "number") {
                        return "" + column.default;
                    }
                    else if (typeof column.default === "boolean") {
                        return column.default === true ? "true" : "false";
                    }
                    else if (typeof column.default === "function") {
                        return column.default();
                    }
                    else if (typeof column.default === "string") {
                        return "'" + column.default + "'" + arrayCast;
                    }
                    else if (typeof column.default === "object") {
                        return "'" + JSON.stringify(column.default) + "'";
                    }
                    else {
                        return column.default;
                    }
                };
                /**
                 * Normalizes "isUnique" value of the column.
                 */
                PostgresDriver.prototype.normalizeIsUnique = function (column) {
                    return column.isUnique;
                };
                /**
                 * Calculates column length taking into account the default length values.
                 */
                PostgresDriver.prototype.getColumnLength = function (column) {
                    if (column.length)
                        return column.length;
                    var normalizedType = this.normalizeType(column);
                    if (this.dataTypeDefaults && this.dataTypeDefaults[normalizedType] && this.dataTypeDefaults[normalizedType].length)
                        return this.dataTypeDefaults[normalizedType].length.toString();
                    return "";
                };
                /**
                 * Normalizes "default" value of the column.
                 */
                PostgresDriver.prototype.createFullType = function (column) {
                    var type = column.type;
                    if (column.length) {
                        type += "(" + column.length + ")";
                    }
                    else if (column.precision && column.scale) {
                        type += "(" + column.precision + "," + column.scale + ")";
                    }
                    else if (column.precision) {
                        type += "(" + column.precision + ")";
                    }
                    else if (column.scale) {
                        type += "(" + column.scale + ")";
                    }
                    else if (this.dataTypeDefaults && this.dataTypeDefaults[column.type] && this.dataTypeDefaults[column.type].length) {
                        type += "(" + this.dataTypeDefaults[column.type].length.toString() + ")";
                    }
                    if (column.type === "time without time zone") {
                        type = "TIME" + (column.precision ? "(" + column.precision + ")" : "");
                    }
                    else if (column.type === "time with time zone") {
                        type = "TIME" + (column.precision ? "(" + column.precision + ")" : "") + " WITH TIME ZONE";
                    }
                    else if (column.type === "timestamp without time zone") {
                        type = "TIMESTAMP" + (column.precision ? "(" + column.precision + ")" : "");
                    }
                    else if (column.type === "timestamp with time zone") {
                        type = "TIMESTAMP" + (column.precision ? "(" + column.precision + ")" : "") + " WITH TIME ZONE";
                    }
                    if (column.isArray)
                        type += " array";
                    return type;
                };
                /**
                 * Obtains a new database connection to a master server.
                 * Used for replication.
                 * If replication is not setup then returns default connection's database connection.
                 */
                PostgresDriver.prototype.obtainMasterConnection = function () {
                    var _this = this;
                    return new Promise(function (ok, fail) {
                        _this.master.connect(function (err, connection, release) {
                            err ? fail(err) : ok([connection, release]);
                        });
                    });
                };
                /**
                 * Obtains a new database connection to a slave server.
                 * Used for replication.
                 * If replication is not setup then returns master (default) connection's database connection.
                 */
                PostgresDriver.prototype.obtainSlaveConnection = function () {
                    var _this = this;
                    if (!this.slaves.length)
                        return this.obtainMasterConnection();
                    return new Promise(function (ok, fail) {
                        var random = Math.floor(Math.random() * _this.slaves.length);
                        _this.slaves[random].connect(function (err, connection, release) {
                            err ? fail(err) : ok([connection, release]);
                        });
                    });
                };
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Loads postgres query stream package.
                 */
                PostgresDriver.prototype.loadStreamDependency = function () {
                    try {
                        return PlatformTools_7.PlatformTools.load("pg-query-stream");
                    }
                    catch (e) { // todo: better error for browser env
                        throw new Error("To use streams you should install pg-query-stream package. Please run npm i pg-query-stream --save command.");
                    }
                };
                // -------------------------------------------------------------------------
                // Protected Methods
                // -------------------------------------------------------------------------
                /**
                 * If driver dependency is not given explicitly, then try to load it via "require".
                 */
                PostgresDriver.prototype.loadDependencies = function () {
                    try {
                        this.postgres = PlatformTools_7.PlatformTools.load("pg");
                        try {
                            var pgNative = PlatformTools_7.PlatformTools.load("pg-native");
                            if (pgNative && this.postgres.native)
                                this.postgres = this.postgres.native;
                        }
                        catch (e) { }
                    }
                    catch (e) { // todo: better error for browser env
                        throw new DriverPackageNotInstalledError_5.DriverPackageNotInstalledError("Postgres", "pg");
                    }
                };
                /**
                 * Creates a new connection pool for a given database credentials.
                 */
                PostgresDriver.prototype.createPool = function (options, credentials) {
                    return __awaiter(this, void 0, void 0, function () {
                        var connectionOptions, pool, logger;
                        return __generator(this, function (_a) {
                            credentials = Object.assign(credentials, DriverUtils_4.DriverUtils.buildDriverOptions(credentials)); // todo: do it better way
                            connectionOptions = Object.assign({}, {
                                host: credentials.host,
                                user: credentials.username,
                                password: credentials.password,
                                database: credentials.database,
                                port: credentials.port,
                                ssl: credentials.ssl
                            }, options.extra || {});
                            pool = new this.postgres.Pool(connectionOptions);
                            logger = this.connection.logger;
                            /*
                              Attaching an error handler to pool errors is essential, as, otherwise, errors raised will go unhandled and
                              cause the hosting app to crash.
                             */
                            pool.on("error", function (error) { return logger.log("warn", "Postgres pool raised an error. " + error); });
                            return [2 /*return*/, new Promise(function (ok, fail) {
                                    pool.connect(function (err, connection, release) {
                                        if (err)
                                            return fail(err);
                                        release();
                                        ok(pool);
                                    });
                                })];
                        });
                    });
                };
                /**
                 * Closes connection pool.
                 */
                PostgresDriver.prototype.closePool = function (pool) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, Promise.all(this.connectedQueryRunners.map(function (queryRunner) { return queryRunner.release(); }))];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/, new Promise(function (ok, fail) {
                                            pool.end(function (err) { return err ? fail(err) : ok(); });
                                        })];
                            }
                        });
                    });
                };
                /**
                 * Executes given query.
                 */
                PostgresDriver.prototype.executeQuery = function (connection, query) {
                    return new Promise(function (ok, fail) {
                        connection.query(query, function (err, result) {
                            if (err)
                                return fail(err);
                            ok(result);
                        });
                    });
                };
                return PostgresDriver;
            }());
            exports_114("PostgresDriver", PostgresDriver);
        }
    };
});
System.register("typeorm/query-builder/Brackets", [], function (exports_115, context_115) {
    "use strict";
    var __moduleName = context_115 && context_115.id;
    var Brackets;
    return {
        setters: [],
        execute: function () {
            /**
             * Syntax sugar.
             * Allows to use brackets in WHERE expressions for better syntax.
             */
            Brackets = /** @class */ (function () {
                /**
                 * Given WHERE query builder that will build a WHERE expression that will be taken into brackets.
                 */
                function Brackets(whereFactory) {
                    this.whereFactory = whereFactory;
                }
                return Brackets;
            }());
            exports_115("Brackets", Brackets);
        }
    };
});
System.register("typeorm/query-builder/WhereExpression", [], function (exports_116, context_116) {
    "use strict";
    var __moduleName = context_116 && context_116.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/metadata/EntityMetadataUtils", [], function (exports_117, context_117) {
    "use strict";
    var __moduleName = context_117 && context_117.id;
    var EntityMetadataUtils;
    return {
        setters: [],
        execute: function () {
            /**
             * Utils used to work with EntityMetadata objects.
             */
            EntityMetadataUtils = /** @class */ (function () {
                function EntityMetadataUtils() {
                }
                /**
                 * Creates a property paths for a given entity.
                 */
                EntityMetadataUtils.createPropertyPath = function (metadata, entity, prefix) {
                    var _this = this;
                    if (prefix === void 0) { prefix = ""; }
                    var paths = [];
                    Object.keys(entity).forEach(function (key) {
                        // check for function is needed in the cases when createPropertyPath used on values containing a function as a value
                        // example: .update().set({ name: () => `SUBSTR('', 1, 2)` })
                        var parentPath = prefix ? prefix + "." + key : key;
                        if (metadata.hasEmbeddedWithPropertyPath(parentPath)) {
                            var subPaths = _this.createPropertyPath(metadata, entity[key], key);
                            paths.push.apply(paths, subPaths);
                        }
                        else {
                            var path = prefix ? prefix + "." + key : key;
                            paths.push(path);
                        }
                    });
                    return paths;
                };
                /**
                 * Creates a property paths for a given entity.
                 */
                EntityMetadataUtils.getPropertyPathValue = function (entity, propertyPath) {
                    var properties = propertyPath.split(".");
                    var recursive = function (object) {
                        var propertyName = properties.shift();
                        var value = propertyName ? object[propertyName] : object;
                        if (properties.length)
                            return recursive(value);
                        return value;
                    };
                    return recursive(entity);
                };
                return EntityMetadataUtils;
            }());
            exports_117("EntityMetadataUtils", EntityMetadataUtils);
        }
    };
});
System.register("typeorm/error/LimitOnUpdateNotSupportedError", [], function (exports_118, context_118) {
    "use strict";
    var __moduleName = context_118 && context_118.id;
    var LimitOnUpdateNotSupportedError;
    return {
        setters: [],
        execute: function () {
            /**
             * Thrown when user tries to build an UPDATE query with LIMIT but the database does not support it.
            */
            LimitOnUpdateNotSupportedError = /** @class */ (function (_super) {
                __extends(LimitOnUpdateNotSupportedError, _super);
                function LimitOnUpdateNotSupportedError() {
                    var _this = _super.call(this, "Your database does not support LIMIT on UPDATE statements.") || this;
                    Object.setPrototypeOf(_this, LimitOnUpdateNotSupportedError.prototype);
                    _this.name = "LimitOnUpdateNotSupportedError";
                    return _this;
                }
                return LimitOnUpdateNotSupportedError;
            }(Error));
            exports_118("LimitOnUpdateNotSupportedError", LimitOnUpdateNotSupportedError);
        }
    };
});
System.register("typeorm/query-builder/UpdateQueryBuilder", ["typeorm/query-builder/QueryBuilder", "typeorm/driver/mysql/MysqlDriver", "typeorm/driver/sqlserver/SqlServerDriver", "typeorm/driver/postgres/PostgresDriver", "typeorm/metadata/EntityMetadataUtils", "typeorm/error/LimitOnUpdateNotSupportedError"], function (exports_119, context_119) {
    "use strict";
    var __moduleName = context_119 && context_119.id;
    var QueryBuilder_1, MysqlDriver_2, SqlServerDriver_1, PostgresDriver_1, EntityMetadataUtils_1, LimitOnUpdateNotSupportedError_1, UpdateQueryBuilder;
    return {
        setters: [
            function (QueryBuilder_1_1) {
                QueryBuilder_1 = QueryBuilder_1_1;
            },
            function (MysqlDriver_2_1) {
                MysqlDriver_2 = MysqlDriver_2_1;
            },
            function (SqlServerDriver_1_1) {
                SqlServerDriver_1 = SqlServerDriver_1_1;
            },
            function (PostgresDriver_1_1) {
                PostgresDriver_1 = PostgresDriver_1_1;
            },
            function (EntityMetadataUtils_1_1) {
                EntityMetadataUtils_1 = EntityMetadataUtils_1_1;
            },
            function (LimitOnUpdateNotSupportedError_1_1) {
                LimitOnUpdateNotSupportedError_1 = LimitOnUpdateNotSupportedError_1_1;
            }
        ],
        execute: function () {
            /**
             * Allows to build complex sql queries in a fashion way and execute those queries.
             */
            UpdateQueryBuilder = /** @class */ (function (_super) {
                __extends(UpdateQueryBuilder, _super);
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function UpdateQueryBuilder(connectionOrQueryBuilder, queryRunner) {
                    var _this = _super.call(this, connectionOrQueryBuilder, queryRunner) || this;
                    _this.expressionMap.aliasNamePrefixingEnabled = false;
                    return _this;
                }
                // -------------------------------------------------------------------------
                // Public Implemented Methods
                // -------------------------------------------------------------------------
                /**
                 * Gets generated sql query without parameters being replaced.
                 */
                UpdateQueryBuilder.prototype.getQuery = function () {
                    var sql = this.createUpdateExpression();
                    sql += this.createOrderByExpression();
                    sql += this.createLimitExpression();
                    return sql.trim();
                };
                /**
                 * Optional returning/output clause.
                 */
                UpdateQueryBuilder.prototype.output = function (output) {
                    return this.returning(output);
                };
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Values needs to be updated.
                 */
                UpdateQueryBuilder.prototype.set = function (values) {
                    this.expressionMap.valuesSet = values;
                    return this;
                };
                /**
                 * Sets WHERE condition in the query builder.
                 * If you had previously WHERE expression defined,
                 * calling this function will override previously set WHERE conditions.
                 * Additionally you can add parameters used in where expression.
                 */
                UpdateQueryBuilder.prototype.where = function (where, parameters) {
                    this.expressionMap.wheres = []; // don't move this block below since computeWhereParameter can add where expressions
                    var condition = this.computeWhereParameter(where);
                    if (condition)
                        this.expressionMap.wheres = [{ type: "simple", condition: condition }];
                    if (parameters)
                        this.setParameters(parameters);
                    return this;
                };
                /**
                 * Adds new AND WHERE condition in the query builder.
                 * Additionally you can add parameters used in where expression.
                 */
                UpdateQueryBuilder.prototype.andWhere = function (where, parameters) {
                    this.expressionMap.wheres.push({ type: "and", condition: this.computeWhereParameter(where) });
                    if (parameters)
                        this.setParameters(parameters);
                    return this;
                };
                /**
                 * Adds new OR WHERE condition in the query builder.
                 * Additionally you can add parameters used in where expression.
                 */
                UpdateQueryBuilder.prototype.orWhere = function (where, parameters) {
                    this.expressionMap.wheres.push({ type: "or", condition: this.computeWhereParameter(where) });
                    if (parameters)
                        this.setParameters(parameters);
                    return this;
                };
                /**
                 * Adds new AND WHERE with conditions for the given ids.
                 */
                UpdateQueryBuilder.prototype.whereInIds = function (ids) {
                    ids = ids instanceof Array ? ids : [ids];
                    var _a = this.createWhereIdsExpression(ids), whereExpression = _a[0], parameters = _a[1];
                    this.where(whereExpression, parameters);
                    return this;
                };
                /**
                 * Adds new AND WHERE with conditions for the given ids.
                 */
                UpdateQueryBuilder.prototype.andWhereInIds = function (ids) {
                    ids = ids instanceof Array ? ids : [ids];
                    var _a = this.createWhereIdsExpression(ids), whereExpression = _a[0], parameters = _a[1];
                    this.andWhere(whereExpression, parameters);
                    return this;
                };
                /**
                 * Adds new OR WHERE with conditions for the given ids.
                 */
                UpdateQueryBuilder.prototype.orWhereInIds = function (ids) {
                    ids = ids instanceof Array ? ids : [ids];
                    var _a = this.createWhereIdsExpression(ids), whereExpression = _a[0], parameters = _a[1];
                    this.orWhere(whereExpression, parameters);
                    return this;
                };
                /**
                 * Sets ORDER BY condition in the query builder.
                 * If you had previously ORDER BY expression defined,
                 * calling this function will override previously set ORDER BY conditions.
                 */
                UpdateQueryBuilder.prototype.orderBy = function (sort, order, nulls) {
                    if (order === void 0) { order = "ASC"; }
                    if (sort) {
                        if (sort instanceof Object) {
                            this.expressionMap.orderBys = sort;
                        }
                        else {
                            if (nulls) {
                                this.expressionMap.orderBys = (_a = {}, _a[sort] = { order: order, nulls: nulls }, _a);
                            }
                            else {
                                this.expressionMap.orderBys = (_b = {}, _b[sort] = order, _b);
                            }
                        }
                    }
                    else {
                        this.expressionMap.orderBys = {};
                    }
                    return this;
                    var _a, _b;
                };
                /**
                 * Adds ORDER BY condition in the query builder.
                 */
                UpdateQueryBuilder.prototype.addOrderBy = function (sort, order, nulls) {
                    if (order === void 0) { order = "ASC"; }
                    if (nulls) {
                        this.expressionMap.orderBys[sort] = { order: order, nulls: nulls };
                    }
                    else {
                        this.expressionMap.orderBys[sort] = order;
                    }
                    return this;
                };
                /**
                 * Sets LIMIT - maximum number of rows to be selected.
                 */
                UpdateQueryBuilder.prototype.limit = function (limit) {
                    this.expressionMap.limit = limit;
                    return this;
                };
                /**
                 * Optional returning/output clause.
                 */
                UpdateQueryBuilder.prototype.returning = function (returning) {
                    if (this.connection.driver instanceof SqlServerDriver_1.SqlServerDriver || this.connection.driver instanceof PostgresDriver_1.PostgresDriver) {
                        this.expressionMap.returning = returning;
                        return this;
                    }
                    else
                        throw new Error("OUTPUT or RETURNING clause only supported by MS SQLServer or PostgreSQL");
                };
                // -------------------------------------------------------------------------
                // Protected Methods
                // -------------------------------------------------------------------------
                /**
                 * Creates UPDATE express used to perform insert query.
                 */
                UpdateQueryBuilder.prototype.createUpdateExpression = function () {
                    var _this = this;
                    var valuesSet = this.getValueSet();
                    var metadata = this.expressionMap.mainAlias.hasMetadata ? this.expressionMap.mainAlias.metadata : undefined;
                    // prepare columns and values to be updated
                    var updateColumnAndValues = [];
                    if (metadata) {
                        EntityMetadataUtils_1.EntityMetadataUtils.createPropertyPath(metadata, valuesSet).forEach(function (propertyPath) {
                            // todo: make this and other query builder to work with properly with tables without metadata
                            var column = metadata.findColumnWithPropertyPath(propertyPath);
                            // we update an entity and entity can contain property which aren't columns, so we just skip them
                            if (!column)
                                return;
                            var paramName = "_updated_" + column.databaseName;
                            var value = _this.connection.driver.preparePersistentValue(column.getEntityValue(valuesSet), column);
                            // todo: duplication zone
                            if (value instanceof Function) { // support for SQL expressions in update query
                                updateColumnAndValues.push(_this.escape(column.databaseName) + " = " + value());
                            }
                            else {
                                if (_this.connection.driver instanceof SqlServerDriver_1.SqlServerDriver) {
                                    _this.setParameter(paramName, _this.connection.driver.parametrizeValue(column, value));
                                }
                                else {
                                    _this.setParameter(paramName, value);
                                }
                                updateColumnAndValues.push(_this.escape(column.databaseName) + " = :" + paramName);
                            }
                        });
                    }
                    else {
                        Object.keys(valuesSet).map(function (key) {
                            var value = valuesSet[key];
                            // todo: duplication zone
                            if (value instanceof Function) { // support for SQL expressions in update query
                                updateColumnAndValues.push(_this.escape(key) + " = " + value());
                            }
                            else {
                                updateColumnAndValues.push(_this.escape(key) + " = :" + key);
                                _this.setParameter(key, value);
                            }
                        });
                    }
                    // get a table name and all column database names
                    var whereExpression = this.createWhereExpression();
                    // generate and return sql update query
                    if (this.expressionMap.returning !== "" && this.connection.driver instanceof PostgresDriver_1.PostgresDriver) {
                        return "UPDATE " + this.getTableName(this.getMainTableName()) + " SET " + updateColumnAndValues.join(", ") + whereExpression + " RETURNING " + this.expressionMap.returning;
                    }
                    else if (this.expressionMap.returning !== "" && this.connection.driver instanceof SqlServerDriver_1.SqlServerDriver) {
                        return "UPDATE " + this.getTableName(this.getMainTableName()) + " SET " + updateColumnAndValues.join(", ") + " OUTPUT " + this.expressionMap.returning + whereExpression;
                    }
                    else {
                        return "UPDATE " + this.getTableName(this.getMainTableName()) + " SET " + updateColumnAndValues.join(", ") + whereExpression; // todo: how do we replace aliases in where to nothing?
                    }
                };
                /**
                 * Creates "ORDER BY" part of SQL query.
                 */
                UpdateQueryBuilder.prototype.createOrderByExpression = function () {
                    var _this = this;
                    var orderBys = this.expressionMap.orderBys;
                    if (Object.keys(orderBys).length > 0)
                        return " ORDER BY " + Object.keys(orderBys)
                            .map(function (columnName) {
                            if (typeof orderBys[columnName] === "string") {
                                return _this.replacePropertyNames(columnName) + " " + orderBys[columnName];
                            }
                            else {
                                return _this.replacePropertyNames(columnName) + " " + orderBys[columnName].order + " " + orderBys[columnName].nulls;
                            }
                        })
                            .join(", ");
                    return "";
                };
                /**
                 * Creates "LIMIT" parts of SQL query.
                 */
                UpdateQueryBuilder.prototype.createLimitExpression = function () {
                    var limit = this.expressionMap.limit;
                    if (limit) {
                        if (this.connection.driver instanceof MysqlDriver_2.MysqlDriver) {
                            return " LIMIT " + limit;
                        }
                        else {
                            throw new LimitOnUpdateNotSupportedError_1.LimitOnUpdateNotSupportedError();
                        }
                    }
                    return "";
                };
                /**
                 * Gets array of values need to be inserted into the target table.
                 */
                UpdateQueryBuilder.prototype.getValueSet = function () {
                    if (this.expressionMap.valuesSet instanceof Object)
                        return this.expressionMap.valuesSet;
                    throw new Error("Cannot perform update query because update values are not defined. Call \"qb.set(...)\" method to specify inserted values.");
                };
                return UpdateQueryBuilder;
            }(QueryBuilder_1.QueryBuilder));
            exports_119("UpdateQueryBuilder", UpdateQueryBuilder);
        }
    };
});
System.register("typeorm/query-builder/DeleteQueryBuilder", ["typeorm/query-builder/QueryBuilder", "typeorm/driver/sqlserver/SqlServerDriver", "typeorm/driver/postgres/PostgresDriver"], function (exports_120, context_120) {
    "use strict";
    var __moduleName = context_120 && context_120.id;
    var QueryBuilder_2, SqlServerDriver_2, PostgresDriver_2, DeleteQueryBuilder;
    return {
        setters: [
            function (QueryBuilder_2_1) {
                QueryBuilder_2 = QueryBuilder_2_1;
            },
            function (SqlServerDriver_2_1) {
                SqlServerDriver_2 = SqlServerDriver_2_1;
            },
            function (PostgresDriver_2_1) {
                PostgresDriver_2 = PostgresDriver_2_1;
            }
        ],
        execute: function () {
            /**
             * Allows to build complex sql queries in a fashion way and execute those queries.
             */
            DeleteQueryBuilder = /** @class */ (function (_super) {
                __extends(DeleteQueryBuilder, _super);
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function DeleteQueryBuilder(connectionOrQueryBuilder, queryRunner) {
                    var _this = _super.call(this, connectionOrQueryBuilder, queryRunner) || this;
                    _this.expressionMap.aliasNamePrefixingEnabled = false;
                    return _this;
                }
                // -------------------------------------------------------------------------
                // Public Implemented Methods
                // -------------------------------------------------------------------------
                /**
                 * Gets generated sql query without parameters being replaced.
                 */
                DeleteQueryBuilder.prototype.getQuery = function () {
                    var sql = this.createDeleteExpression();
                    return sql.trim();
                };
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Specifies FROM which entity's table select/update/delete will be executed.
                 * Also sets a main string alias of the selection data.
                 */
                DeleteQueryBuilder.prototype.from = function (entityTarget, aliasName) {
                    var mainAlias = this.createFromAlias(entityTarget, aliasName);
                    this.expressionMap.setMainAlias(mainAlias);
                    return this;
                };
                /**
                 * Sets WHERE condition in the query builder.
                 * If you had previously WHERE expression defined,
                 * calling this function will override previously set WHERE conditions.
                 * Additionally you can add parameters used in where expression.
                 */
                DeleteQueryBuilder.prototype.where = function (where, parameters) {
                    this.expressionMap.wheres = []; // don't move this block below since computeWhereParameter can add where expressions
                    var condition = this.computeWhereParameter(where);
                    if (condition)
                        this.expressionMap.wheres = [{ type: "simple", condition: condition }];
                    if (parameters)
                        this.setParameters(parameters);
                    return this;
                };
                /**
                 * Adds new AND WHERE condition in the query builder.
                 * Additionally you can add parameters used in where expression.
                 */
                DeleteQueryBuilder.prototype.andWhere = function (where, parameters) {
                    this.expressionMap.wheres.push({ type: "and", condition: this.computeWhereParameter(where) });
                    if (parameters)
                        this.setParameters(parameters);
                    return this;
                };
                /**
                 * Adds new OR WHERE condition in the query builder.
                 * Additionally you can add parameters used in where expression.
                 */
                DeleteQueryBuilder.prototype.orWhere = function (where, parameters) {
                    this.expressionMap.wheres.push({ type: "or", condition: this.computeWhereParameter(where) });
                    if (parameters)
                        this.setParameters(parameters);
                    return this;
                };
                /**
                 * Adds new AND WHERE with conditions for the given ids.
                 */
                DeleteQueryBuilder.prototype.whereInIds = function (ids) {
                    ids = ids instanceof Array ? ids : [ids];
                    var _a = this.createWhereIdsExpression(ids), whereExpression = _a[0], parameters = _a[1];
                    this.where(whereExpression, parameters);
                    return this;
                };
                /**
                 * Adds new AND WHERE with conditions for the given ids.
                 */
                DeleteQueryBuilder.prototype.andWhereInIds = function (ids) {
                    var _a = this.createWhereIdsExpression(ids), whereExpression = _a[0], parameters = _a[1];
                    this.andWhere(whereExpression, parameters);
                    return this;
                };
                /**
                 * Adds new OR WHERE with conditions for the given ids.
                 */
                DeleteQueryBuilder.prototype.orWhereInIds = function (ids) {
                    var _a = this.createWhereIdsExpression(ids), whereExpression = _a[0], parameters = _a[1];
                    this.orWhere(whereExpression, parameters);
                    return this;
                };
                /**
                 * Optional returning/output clause.
                 */
                DeleteQueryBuilder.prototype.returning = function (returning) {
                    if (this.connection.driver instanceof SqlServerDriver_2.SqlServerDriver || this.connection.driver instanceof PostgresDriver_2.PostgresDriver) {
                        this.expressionMap.returning = returning;
                        return this;
                    }
                    else
                        throw new Error("OUTPUT or RETURNING clause only supported by MS SQLServer or PostgreSQL");
                };
                /**
                 * Optional returning/output clause.
                 */
                DeleteQueryBuilder.prototype.output = function (output) {
                    return this.returning(output);
                };
                // -------------------------------------------------------------------------
                // Protected Methods
                // -------------------------------------------------------------------------
                /**
                 * Creates DELETE express used to perform query.
                 */
                DeleteQueryBuilder.prototype.createDeleteExpression = function () {
                    var whereExpression = this.createWhereExpression();
                    if (this.expressionMap.returning !== "" && this.connection.driver instanceof PostgresDriver_2.PostgresDriver) {
                        return "DELETE FROM " + this.getTableName(this.getMainTableName()) + whereExpression + " RETURNING " + this.expressionMap.returning;
                    }
                    else if (this.expressionMap.returning !== "" && this.connection.driver instanceof SqlServerDriver_2.SqlServerDriver) {
                        return "DELETE FROM " + this.getTableName(this.getMainTableName()) + " OUTPUT " + this.expressionMap.returning + whereExpression;
                    }
                    else {
                        return "DELETE FROM " + this.getTableName(this.getMainTableName()) + whereExpression; // todo: how do we replace aliases in where to nothing?
                    }
                };
                return DeleteQueryBuilder;
            }(QueryBuilder_2.QueryBuilder));
            exports_120("DeleteQueryBuilder", DeleteQueryBuilder);
        }
    };
});
System.register("typeorm/query-builder/InsertQueryBuilder", ["typeorm/query-builder/QueryBuilder", "typeorm/driver/sqlserver/SqlServerDriver", "typeorm/driver/postgres/PostgresDriver", "typeorm/driver/sqlite-abstract/AbstractSqliteDriver"], function (exports_121, context_121) {
    "use strict";
    var __moduleName = context_121 && context_121.id;
    var QueryBuilder_3, SqlServerDriver_3, PostgresDriver_3, AbstractSqliteDriver_2, InsertQueryBuilder;
    return {
        setters: [
            function (QueryBuilder_3_1) {
                QueryBuilder_3 = QueryBuilder_3_1;
            },
            function (SqlServerDriver_3_1) {
                SqlServerDriver_3 = SqlServerDriver_3_1;
            },
            function (PostgresDriver_3_1) {
                PostgresDriver_3 = PostgresDriver_3_1;
            },
            function (AbstractSqliteDriver_2_1) {
                AbstractSqliteDriver_2 = AbstractSqliteDriver_2_1;
            }
        ],
        execute: function () {
            /**
             * Allows to build complex sql queries in a fashion way and execute those queries.
             */
            InsertQueryBuilder = /** @class */ (function (_super) {
                __extends(InsertQueryBuilder, _super);
                function InsertQueryBuilder() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                // -------------------------------------------------------------------------
                // Public Implemented Methods
                // -------------------------------------------------------------------------
                /**
                 * Gets generated sql query without parameters being replaced.
                 */
                InsertQueryBuilder.prototype.getQuery = function () {
                    var sql = this.createInsertExpression();
                    return sql.trim();
                };
                /**
                 * Optional returning/output clause.
                 */
                InsertQueryBuilder.prototype.output = function (output) {
                    return this.returning(output);
                };
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Specifies INTO which entity's table insertion will be executed.
                 */
                InsertQueryBuilder.prototype.into = function (entityTarget, columns) {
                    var mainAlias = this.createFromAlias(entityTarget);
                    this.expressionMap.setMainAlias(mainAlias);
                    this.expressionMap.insertColumns = columns || [];
                    return this;
                };
                /**
                 * Values needs to be inserted into table.
                 */
                InsertQueryBuilder.prototype.values = function (values) {
                    this.expressionMap.valuesSet = values;
                    return this;
                };
                /**
                 * Optional returning/output clause.
                 */
                InsertQueryBuilder.prototype.returning = function (returning) {
                    if (this.connection.driver instanceof SqlServerDriver_3.SqlServerDriver || this.connection.driver instanceof PostgresDriver_3.PostgresDriver) {
                        this.expressionMap.returning = returning;
                        return this;
                    }
                    else
                        throw new Error("OUTPUT or RETURNING clause only supported by MS SQLServer or PostgreSQL");
                };
                /**
                 * Adds additional ON CONFLICT statement supported in postgres.
                 */
                InsertQueryBuilder.prototype.onConflict = function (statement) {
                    this.expressionMap.onConflict = statement;
                    return this;
                };
                // -------------------------------------------------------------------------
                // Protected Methods
                // -------------------------------------------------------------------------
                /**
                 * Creates INSERT express used to perform insert query.
                 */
                InsertQueryBuilder.prototype.createInsertExpression = function () {
                    var _this = this;
                    var valueSets = this.getValueSets();
                    var values, columnNames;
                    if (this.expressionMap.mainAlias.hasMetadata) {
                        var columns_1 = this.expressionMap.mainAlias.metadata.columns.filter(function (column) {
                            if (!_this.expressionMap.insertColumns.length)
                                return !column.isGenerated;
                            return _this.expressionMap.insertColumns.indexOf(column.propertyPath) !== -1;
                        });
                        // get a table name and all column database names
                        columnNames = columns_1.map(function (column) { return _this.escape(column.databaseName); }).join(", ");
                        // get values needs to be inserted
                        values = valueSets.map(function (valueSet, insertionIndex) {
                            var columnValues = columns_1.map(function (column) {
                                var paramName = "_inserted_" + insertionIndex + "_" + column.databaseName;
                                var value = _this.connection.driver.preparePersistentValue(column.getEntityValue(valueSet), column);
                                if (value instanceof Function) { // support for SQL expressions in update query
                                    return value();
                                }
                                else if (value === undefined) {
                                    if (_this.connection.driver instanceof AbstractSqliteDriver_2.AbstractSqliteDriver) {
                                        return "NULL";
                                    }
                                    else {
                                        return "DEFAULT";
                                    }
                                }
                                else {
                                    if (_this.connection.driver instanceof SqlServerDriver_3.SqlServerDriver) {
                                        _this.setParameter(paramName, _this.connection.driver.parametrizeValue(column, value));
                                    }
                                    else {
                                        _this.setParameter(paramName, value);
                                    }
                                    return ":" + paramName;
                                }
                            });
                            return "(" + columnValues.join(",") + ")";
                        }).join(", ");
                    }
                    else { // for tables without metadata
                        // get a table name and all column database names
                        columnNames = this.expressionMap.insertColumns.join(", ");
                        // get values needs to be inserted
                        values = valueSets.map(function (valueSet, insertionIndex) {
                            var columnValues = Object.keys(valueSet).map(function (columnName) {
                                var paramName = "_inserted_" + insertionIndex + "_" + columnName;
                                var value = valueSet[columnName];
                                if (value instanceof Function) { // support for SQL expressions in update query
                                    return value();
                                }
                                else if (value === undefined) {
                                    if (_this.connection.driver instanceof AbstractSqliteDriver_2.AbstractSqliteDriver) {
                                        return "NULL";
                                    }
                                    else {
                                        return "DEFAULT";
                                    }
                                }
                                else {
                                    _this.setParameter(paramName, value);
                                    return ":" + paramName;
                                }
                            });
                            return "(" + columnValues.join(",") + ")";
                        }).join(", ");
                    }
                    // generate sql query
                    if (this.expressionMap.returning !== "" && this.connection.driver instanceof PostgresDriver_3.PostgresDriver) {
                        return "INSERT INTO " + this.getTableName(this.getMainTableName()) + (columnNames ? "(" + columnNames + ")" : "") + " VALUES " + values + (this.expressionMap.onConflict ? " ON CONFLICT " + this.expressionMap.onConflict : "") + " RETURNING " + this.expressionMap.returning;
                    }
                    else if (this.expressionMap.returning !== "" && this.connection.driver instanceof SqlServerDriver_3.SqlServerDriver) {
                        return "INSERT INTO " + this.getTableName(this.getMainTableName()) + "(" + columnNames + ") OUTPUT " + this.expressionMap.returning + " VALUES " + values;
                    }
                    else {
                        return "INSERT INTO " + this.getTableName(this.getMainTableName()) + "(" + columnNames + ") VALUES " + values + (this.expressionMap.onConflict ? " ON CONFLICT " + this.expressionMap.onConflict : "");
                    }
                };
                /**
                 * Gets array of values need to be inserted into the target table.
                 */
                InsertQueryBuilder.prototype.getValueSets = function () {
                    if (this.expressionMap.valuesSet instanceof Array && this.expressionMap.valuesSet.length > 0)
                        return this.expressionMap.valuesSet;
                    if (this.expressionMap.valuesSet instanceof Object)
                        return [this.expressionMap.valuesSet];
                    throw new Error("Cannot perform insert query because values are not defined. Call \"qb.values(...)\" method to specify inserted values.");
                };
                return InsertQueryBuilder;
            }(QueryBuilder_3.QueryBuilder));
            exports_121("InsertQueryBuilder", InsertQueryBuilder);
        }
    };
});
System.register("typeorm/query-builder/RelationUpdater", [], function (exports_122, context_122) {
    "use strict";
    var __moduleName = context_122 && context_122.id;
    var RelationUpdater;
    return {
        setters: [],
        execute: function () {
            /**
             * Allows to work with entity relations and perform specific operations with those relations.
             *
             * todo: add transactions everywhere
             */
            RelationUpdater = /** @class */ (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function RelationUpdater(queryBuilder, expressionMap) {
                    this.queryBuilder = queryBuilder;
                    this.expressionMap = expressionMap;
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Performs set or add operation on a relation.
                 */
                RelationUpdater.prototype.update = function (value) {
                    return __awaiter(this, void 0, void 0, function () {
                        var relation, updateSet, updateSet_1, ofs, parameters_1, conditions_2, condition, of_1, updateSet, junctionMetadata_1, ofs, values, firstColumnValues, secondColumnValues_1, bulkInserted_1;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    relation = this.expressionMap.relationMetadata;
                                    if (!(relation.isManyToOne || relation.isOneToOneOwner)) return [3 /*break*/, 2];
                                    updateSet = relation.joinColumns.reduce(function (updateSet, joinColumn) {
                                        var relationValue = value instanceof Object ? joinColumn.referencedColumn.getEntityValue(value) : value;
                                        joinColumn.setEntityValue(updateSet, relationValue);
                                        return updateSet;
                                    }, {});
                                    if (!this.expressionMap.of || (this.expressionMap.of instanceof Array && !this.expressionMap.of.length))
                                        return [2 /*return*/];
                                    return [4 /*yield*/, this.queryBuilder
                                            .createQueryBuilder()
                                            .update(relation.entityMetadata.target)
                                            .set(updateSet)
                                            .whereInIds(this.expressionMap.of)
                                            .execute()];
                                case 1:
                                    _a.sent();
                                    return [3 /*break*/, 8];
                                case 2:
                                    if (!((relation.isOneToOneNotOwner || relation.isOneToMany) && value === null)) return [3 /*break*/, 4];
                                    updateSet_1 = {};
                                    relation.inverseRelation.joinColumns.forEach(function (column) {
                                        updateSet_1[column.propertyName] = null;
                                    });
                                    ofs = this.expressionMap.of instanceof Array ? this.expressionMap.of : [this.expressionMap.of];
                                    parameters_1 = {};
                                    conditions_2 = [];
                                    ofs.forEach(function (of, ofIndex) {
                                        relation.inverseRelation.joinColumns.map(function (column, columnIndex) {
                                            var parameterName = "joinColumn_" + ofIndex + "_" + columnIndex;
                                            parameters_1[parameterName] = of instanceof Object ? column.referencedColumn.getEntityValue(of) : of;
                                            conditions_2.push(column.propertyPath + " = :" + parameterName);
                                        });
                                    });
                                    condition = conditions_2.map(function (str) { return "(" + str + ")"; }).join(" OR ");
                                    if (!condition)
                                        return [2 /*return*/];
                                    return [4 /*yield*/, this.queryBuilder
                                            .createQueryBuilder()
                                            .update(relation.inverseEntityMetadata.target)
                                            .set(updateSet_1)
                                            .where(condition)
                                            .setParameters(parameters_1)
                                            .execute()];
                                case 3:
                                    _a.sent();
                                    return [3 /*break*/, 8];
                                case 4:
                                    if (!(relation.isOneToOneNotOwner || relation.isOneToMany)) return [3 /*break*/, 6];
                                    if (this.expressionMap.of instanceof Array)
                                        throw new Error("You cannot update relations of multiple entities with the same related object. Provide a single entity into .of method.");
                                    of_1 = this.expressionMap.of;
                                    updateSet = relation.inverseRelation.joinColumns.reduce(function (updateSet, joinColumn) {
                                        var relationValue = of_1 instanceof Object ? joinColumn.referencedColumn.getEntityValue(of_1) : of_1;
                                        joinColumn.setEntityValue(updateSet, relationValue);
                                        return updateSet;
                                    }, {});
                                    if (!value || (value instanceof Array && !value.length))
                                        return [2 /*return*/];
                                    return [4 /*yield*/, this.queryBuilder
                                            .createQueryBuilder()
                                            .update(relation.inverseEntityMetadata.target)
                                            .set(updateSet)
                                            .whereInIds(value)
                                            .execute()];
                                case 5:
                                    _a.sent();
                                    return [3 /*break*/, 8];
                                case 6:
                                    junctionMetadata_1 = relation.junctionEntityMetadata;
                                    ofs = this.expressionMap.of instanceof Array ? this.expressionMap.of : [this.expressionMap.of];
                                    values = value instanceof Array ? value : [value];
                                    firstColumnValues = relation.isManyToManyOwner ? ofs : values;
                                    secondColumnValues_1 = relation.isManyToManyOwner ? values : ofs;
                                    bulkInserted_1 = [];
                                    firstColumnValues.forEach(function (firstColumnVal) {
                                        secondColumnValues_1.forEach(function (secondColumnVal) {
                                            var inserted = {};
                                            junctionMetadata_1.ownerColumns.forEach(function (column) {
                                                inserted[column.databaseName] = firstColumnVal instanceof Object ? column.referencedColumn.getEntityValue(firstColumnVal) : firstColumnVal;
                                            });
                                            junctionMetadata_1.inverseColumns.forEach(function (column) {
                                                inserted[column.databaseName] = secondColumnVal instanceof Object ? column.referencedColumn.getEntityValue(secondColumnVal) : secondColumnVal;
                                            });
                                            bulkInserted_1.push(inserted);
                                        });
                                    });
                                    if (!bulkInserted_1.length)
                                        return [2 /*return*/];
                                    return [4 /*yield*/, this.queryBuilder
                                            .createQueryBuilder()
                                            .insert()
                                            .into(junctionMetadata_1.tableName)
                                            .values(bulkInserted_1)
                                            .execute()];
                                case 7:
                                    _a.sent();
                                    _a.label = 8;
                                case 8: return [2 /*return*/];
                            }
                        });
                    });
                };
                return RelationUpdater;
            }());
            exports_122("RelationUpdater", RelationUpdater);
        }
    };
});
System.register("typeorm/query-builder/RelationRemover", [], function (exports_123, context_123) {
    "use strict";
    var __moduleName = context_123 && context_123.id;
    var RelationRemover;
    return {
        setters: [],
        execute: function () {
            /**
             * Allows to work with entity relations and perform specific operations with those relations.
             *
             * todo: add transactions everywhere
             */
            RelationRemover = /** @class */ (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function RelationRemover(queryBuilder, expressionMap) {
                    this.queryBuilder = queryBuilder;
                    this.expressionMap = expressionMap;
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Performs remove operation on a relation.
                 */
                RelationRemover.prototype.remove = function (value) {
                    return __awaiter(this, void 0, void 0, function () {
                        var relation, ofs, values_1, updateSet_2, parameters_2, conditions_3, condition, junctionMetadata_2, ofs, values, firstColumnValues, secondColumnValues_2, parameters_3, conditions_4, condition;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    relation = this.expressionMap.relationMetadata;
                                    if (!relation.isOneToMany) return [3 /*break*/, 2];
                                    ofs = this.expressionMap.of instanceof Array ? this.expressionMap.of : [this.expressionMap.of];
                                    values_1 = value instanceof Array ? value : [value];
                                    updateSet_2 = {};
                                    relation.inverseRelation.joinColumns.forEach(function (column) {
                                        updateSet_2[column.propertyName] = null;
                                    });
                                    parameters_2 = {};
                                    conditions_3 = [];
                                    ofs.forEach(function (of, ofIndex) {
                                        conditions_3.push.apply(conditions_3, values_1.map(function (value, valueIndex) {
                                            return relation.inverseRelation.joinColumns.map(function (column, columnIndex) {
                                                var parameterName = "joinColumn_" + ofIndex + "_" + valueIndex + "_" + columnIndex;
                                                parameters_2[parameterName] = of instanceof Object ? column.referencedColumn.getEntityValue(of) : of;
                                                return column.propertyPath + " = :" + parameterName;
                                            }).concat(relation.inverseRelation.entityMetadata.primaryColumns.map(function (column, columnIndex) {
                                                var parameterName = "primaryColumn_" + valueIndex + "_" + valueIndex + "_" + columnIndex;
                                                parameters_2[parameterName] = value instanceof Object ? column.getEntityValue(value) : value;
                                                return column.propertyPath + " = :" + parameterName;
                                            })).join(" AND ");
                                        }));
                                    });
                                    condition = conditions_3.map(function (str) { return "(" + str + ")"; }).join(" OR ");
                                    if (!condition)
                                        return [2 /*return*/];
                                    return [4 /*yield*/, this.queryBuilder
                                            .createQueryBuilder()
                                            .update(relation.inverseEntityMetadata.target)
                                            .set(updateSet_2)
                                            .where(condition)
                                            .setParameters(parameters_2)
                                            .execute()];
                                case 1:
                                    _a.sent();
                                    return [3 /*break*/, 4];
                                case 2:
                                    junctionMetadata_2 = relation.junctionEntityMetadata;
                                    ofs = this.expressionMap.of instanceof Array ? this.expressionMap.of : [this.expressionMap.of];
                                    values = value instanceof Array ? value : [value];
                                    firstColumnValues = relation.isManyToManyOwner ? ofs : values;
                                    secondColumnValues_2 = relation.isManyToManyOwner ? values : ofs;
                                    parameters_3 = {};
                                    conditions_4 = [];
                                    firstColumnValues.forEach(function (firstColumnVal, firstColumnValIndex) {
                                        conditions_4.push.apply(conditions_4, secondColumnValues_2.map(function (secondColumnVal, secondColumnValIndex) {
                                            return junctionMetadata_2.ownerColumns.map(function (column, columnIndex) {
                                                var parameterName = "firstValue_" + firstColumnValIndex + "_" + secondColumnValIndex + "_" + columnIndex;
                                                parameters_3[parameterName] = firstColumnVal instanceof Object ? column.referencedColumn.getEntityValue(firstColumnVal) : firstColumnVal;
                                                return column.databaseName + " = :" + parameterName;
                                            }).concat(junctionMetadata_2.inverseColumns.map(function (column, columnIndex) {
                                                var parameterName = "secondValue_" + firstColumnValIndex + "_" + secondColumnValIndex + "_" + columnIndex;
                                                parameters_3[parameterName] = firstColumnVal instanceof Object ? column.referencedColumn.getEntityValue(secondColumnVal) : secondColumnVal;
                                                return column.databaseName + " = :" + parameterName;
                                            })).join(" AND ");
                                        }));
                                    });
                                    condition = conditions_4.map(function (str) { return "(" + str + ")"; }).join(" OR ");
                                    return [4 /*yield*/, this.queryBuilder
                                            .createQueryBuilder()
                                            .delete()
                                            .from(junctionMetadata_2.tableName)
                                            .where(condition)
                                            .setParameters(parameters_3)
                                            .execute()];
                                case 3:
                                    _a.sent();
                                    _a.label = 4;
                                case 4: return [2 /*return*/];
                            }
                        });
                    });
                };
                return RelationRemover;
            }());
            exports_123("RelationRemover", RelationRemover);
        }
    };
});
System.register("typeorm/query-builder/RelationLoader", [], function (exports_124, context_124) {
    "use strict";
    var __moduleName = context_124 && context_124.id;
    var RelationLoader;
    return {
        setters: [],
        execute: function () {
            /**
             * Wraps entities and creates getters/setters for their relations
             * to be able to lazily load relations when accessing these relations.
             */
            RelationLoader = /** @class */ (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function RelationLoader(connection) {
                    this.connection = connection;
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Loads relation data for the given entity and its relation.
                 */
                RelationLoader.prototype.load = function (relation, entity) {
                    if (relation.isManyToOne || relation.isOneToOneOwner) {
                        return this.loadManyToOneOrOneToOneOwner(relation, entity);
                    }
                    else if (relation.isOneToMany || relation.isOneToOneNotOwner) {
                        return this.loadOneToManyOrOneToOneNotOwner(relation, entity);
                    }
                    else if (relation.isManyToManyOwner) {
                        return this.loadManyToManyOwner(relation, entity);
                    }
                    else { // many-to-many non owner
                        return this.loadManyToManyNotOwner(relation, entity);
                    }
                };
                /**
                 * Loads data for many-to-one and one-to-one owner relations.
                 *
                 * (ow) post.category<=>category.post
                 * loaded: category from post
                 * example: SELECT category.id AS category_id, category.name AS category_name FROM category category
                 *              INNER JOIN post Post ON Post.category=category.id WHERE Post.id=1
                 */
                RelationLoader.prototype.loadManyToOneOrOneToOneOwner = function (relation, entity) {
                    var primaryColumns = relation.entityMetadata.primaryColumns;
                    var joinColumns = relation.isOwning ? relation.joinColumns : relation.inverseRelation.joinColumns;
                    var conditions = joinColumns.map(function (joinColumn) {
                        return relation.entityMetadata.name + "." + relation.propertyName + " = " + relation.propertyName + "." + joinColumn.referencedColumn.propertyName;
                    }).join(" AND ");
                    var qb = this.connection
                        .createQueryBuilder()
                        .select(relation.propertyName) // category
                        .from(relation.type, relation.propertyName) // Category, category
                        .innerJoin(relation.entityMetadata.target, relation.entityMetadata.name, conditions);
                    primaryColumns.forEach(function (primaryColumn) {
                        qb.andWhere(relation.entityMetadata.name + "." + primaryColumn.propertyPath + " = :" + primaryColumn.propertyName)
                            .setParameter("" + primaryColumn.propertyName, primaryColumn.getEntityValue(entity));
                    });
                    return qb.getOne();
                };
                /**
                 * Loads data for one-to-many and one-to-one not owner relations.
                 *
                 * SELECT post
                 * FROM post post
                 * WHERE post.[joinColumn.name] = entity[joinColumn.referencedColumn]
                 */
                RelationLoader.prototype.loadOneToManyOrOneToOneNotOwner = function (relation, entity) {
                    var qb = this.connection
                        .createQueryBuilder()
                        .select(relation.propertyName)
                        .from(relation.inverseRelation.entityMetadata.target, relation.propertyName);
                    relation.inverseRelation.joinColumns.forEach(function (joinColumn) {
                        qb.andWhere(relation.propertyName + "." + joinColumn.propertyName + " = :" + joinColumn.referencedColumn.propertyName)
                            .setParameter("" + joinColumn.referencedColumn.propertyName, joinColumn.referencedColumn.getEntityValue(entity));
                    });
                    return relation.isOneToMany ? qb.getMany() : qb.getOne();
                };
                /**
                 * Loads data for many-to-many owner relations.
                 *
                 * SELECT category
                 * FROM category category
                 * INNER JOIN post_categories post_categories
                 * ON post_categories.postId = :postId
                 * AND post_categories.categoryId = category.id
                 */
                RelationLoader.prototype.loadManyToManyOwner = function (relation, entity) {
                    var mainAlias = relation.propertyName;
                    var joinAlias = relation.junctionEntityMetadata.tableName;
                    var joinColumnConditions = relation.joinColumns.map(function (joinColumn) {
                        return joinAlias + "." + joinColumn.propertyName + " = :" + joinColumn.propertyName;
                    });
                    var inverseJoinColumnConditions = relation.inverseJoinColumns.map(function (inverseJoinColumn) {
                        return joinAlias + "." + inverseJoinColumn.propertyName + "=" + mainAlias + "." + inverseJoinColumn.referencedColumn.propertyName;
                    });
                    var parameters = relation.joinColumns.reduce(function (parameters, joinColumn) {
                        parameters[joinColumn.propertyName] = joinColumn.referencedColumn.getEntityValue(entity);
                        return parameters;
                    }, {});
                    return this.connection
                        .createQueryBuilder()
                        .select(mainAlias)
                        .from(relation.type, mainAlias)
                        .innerJoin(joinAlias, joinAlias, joinColumnConditions.concat(inverseJoinColumnConditions).join(" AND "))
                        .setParameters(parameters)
                        .getMany();
                };
                /**
                 * Loads data for many-to-many not owner relations.
                 *
                 * SELECT post
                 * FROM post post
                 * INNER JOIN post_categories post_categories
                 * ON post_categories.postId = post.id
                 * AND post_categories.categoryId = post_categories.categoryId
                 */
                RelationLoader.prototype.loadManyToManyNotOwner = function (relation, entity) {
                    var mainAlias = relation.propertyName;
                    var joinAlias = relation.junctionEntityMetadata.tableName;
                    var joinColumnConditions = relation.inverseRelation.joinColumns.map(function (joinColumn) {
                        return joinAlias + "." + joinColumn.propertyName + " = " + mainAlias + "." + joinColumn.referencedColumn.propertyName;
                    });
                    var inverseJoinColumnConditions = relation.inverseRelation.inverseJoinColumns.map(function (inverseJoinColumn) {
                        return joinAlias + "." + inverseJoinColumn.propertyName + " = :" + inverseJoinColumn.propertyName;
                    });
                    var parameters = relation.inverseRelation.inverseJoinColumns.reduce(function (parameters, joinColumn) {
                        parameters[joinColumn.propertyName] = joinColumn.referencedColumn.getEntityValue(entity);
                        return parameters;
                    }, {});
                    return this.connection
                        .createQueryBuilder()
                        .select(mainAlias)
                        .from(relation.type, mainAlias)
                        .innerJoin(joinAlias, joinAlias, joinColumnConditions.concat(inverseJoinColumnConditions).join(" AND "))
                        .setParameters(parameters)
                        .getMany();
                };
                return RelationLoader;
            }());
            exports_124("RelationLoader", RelationLoader);
        }
    };
});
System.register("typeorm/query-builder/RelationQueryBuilder", ["typeorm/query-builder/QueryBuilder", "typeorm/query-builder/RelationUpdater", "typeorm/query-builder/RelationRemover", "typeorm/query-builder/RelationLoader"], function (exports_125, context_125) {
    "use strict";
    var __moduleName = context_125 && context_125.id;
    var QueryBuilder_4, RelationUpdater_1, RelationRemover_1, RelationLoader_1, RelationQueryBuilder;
    return {
        setters: [
            function (QueryBuilder_4_1) {
                QueryBuilder_4 = QueryBuilder_4_1;
            },
            function (RelationUpdater_1_1) {
                RelationUpdater_1 = RelationUpdater_1_1;
            },
            function (RelationRemover_1_1) {
                RelationRemover_1 = RelationRemover_1_1;
            },
            function (RelationLoader_1_1) {
                RelationLoader_1 = RelationLoader_1_1;
            }
        ],
        execute: function () {
            /**
             * Allows to work with entity relations and perform specific operations with those relations.
             *
             * todo: add transactions everywhere
             */
            RelationQueryBuilder = /** @class */ (function (_super) {
                __extends(RelationQueryBuilder, _super);
                function RelationQueryBuilder() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                // -------------------------------------------------------------------------
                // Public Implemented Methods
                // -------------------------------------------------------------------------
                /**
                 * Gets generated sql query without parameters being replaced.
                 */
                RelationQueryBuilder.prototype.getQuery = function () {
                    return "";
                };
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Sets entity (target) which relations will be updated.
                 */
                RelationQueryBuilder.prototype.of = function (entity) {
                    this.expressionMap.of = entity;
                    return this;
                };
                /**
                 * Sets entity relation's value.
                 * Value can be entity, entity id or entity id map (if entity has composite ids).
                 * Works only for many-to-one and one-to-one relations.
                 * For many-to-many and one-to-many relations use #add and #remove methods instead.
                 */
                RelationQueryBuilder.prototype.set = function (value) {
                    return __awaiter(this, void 0, void 0, function () {
                        var relation, updater;
                        return __generator(this, function (_a) {
                            relation = this.expressionMap.relationMetadata;
                            if (!this.expressionMap.of) // todo: move this check before relation query builder creation?
                                throw new Error("Entity whose relation needs to be set is not set. Use .of method to define whose relation you want to set.");
                            if (relation.isManyToMany || relation.isOneToMany)
                                throw new Error("Set operation is only supported for many-to-one and one-to-one relations. " +
                                    ("However given \"" + relation.propertyPath + "\" has " + relation.relationType + " relation. ") +
                                    "Use .add() method instead.");
                            // if there are multiple join columns then user must send id map as "value" argument. check if he really did it
                            if (relation.joinColumns &&
                                relation.joinColumns.length > 1 &&
                                (!(value instanceof Object) || Object.keys(value).length < relation.joinColumns.length))
                                throw new Error("Value to be set into the relation must be a map of relation ids, for example: .set({ firstName: \"...\", lastName: \"...\" })");
                            updater = new RelationUpdater_1.RelationUpdater(this, this.expressionMap);
                            return [2 /*return*/, updater.update(value)];
                        });
                    });
                };
                /**
                 * Adds (binds) given value to entity relation.
                 * Value can be entity, entity id or entity id map (if entity has composite ids).
                 * Value also can be array of entities, array of entity ids or array of entity id maps (if entity has composite ids).
                 * Works only for many-to-many and one-to-many relations.
                 * For many-to-one and one-to-one use #set method instead.
                 */
                RelationQueryBuilder.prototype.add = function (value) {
                    return __awaiter(this, void 0, void 0, function () {
                        var relation, updater;
                        return __generator(this, function (_a) {
                            if (value instanceof Array && value.length === 0)
                                return [2 /*return*/];
                            relation = this.expressionMap.relationMetadata;
                            if (!this.expressionMap.of) // todo: move this check before relation query builder creation?
                                throw new Error("Entity whose relation needs to be set is not set. Use .of method to define whose relation you want to set.");
                            if (relation.isManyToOne || relation.isOneToOne)
                                throw new Error("Add operation is only supported for many-to-many and one-to-many relations. " +
                                    ("However given \"" + relation.propertyPath + "\" has " + relation.relationType + " relation. ") +
                                    "Use .set() method instead.");
                            // if there are multiple join columns then user must send id map as "value" argument. check if he really did it
                            if (relation.joinColumns &&
                                relation.joinColumns.length > 1 &&
                                (!(value instanceof Object) || Object.keys(value).length < relation.joinColumns.length))
                                throw new Error("Value to be set into the relation must be a map of relation ids, for example: .set({ firstName: \"...\", lastName: \"...\" })");
                            updater = new RelationUpdater_1.RelationUpdater(this, this.expressionMap);
                            return [2 /*return*/, updater.update(value)];
                        });
                    });
                };
                /**
                 * Removes (unbinds) given value from entity relation.
                 * Value can be entity, entity id or entity id map (if entity has composite ids).
                 * Value also can be array of entities, array of entity ids or array of entity id maps (if entity has composite ids).
                 * Works only for many-to-many and one-to-many relations.
                 * For many-to-one and one-to-one use #set method instead.
                 */
                RelationQueryBuilder.prototype.remove = function (value) {
                    return __awaiter(this, void 0, void 0, function () {
                        var relation, remover;
                        return __generator(this, function (_a) {
                            if (value instanceof Array && value.length === 0)
                                return [2 /*return*/];
                            relation = this.expressionMap.relationMetadata;
                            if (!this.expressionMap.of) // todo: move this check before relation query builder creation?
                                throw new Error("Entity whose relation needs to be set is not set. Use .of method to define whose relation you want to set.");
                            if (relation.isManyToOne || relation.isOneToOne)
                                throw new Error("Add operation is only supported for many-to-many and one-to-many relations. " +
                                    ("However given \"" + relation.propertyPath + "\" has " + relation.relationType + " relation. ") +
                                    "Use .set(null) method instead.");
                            remover = new RelationRemover_1.RelationRemover(this, this.expressionMap);
                            return [2 /*return*/, remover.remove(value)];
                        });
                    });
                };
                /**
                 * Adds (binds) and removes (unbinds) given values to/from entity relation.
                 * Value can be entity, entity id or entity id map (if entity has composite ids).
                 * Value also can be array of entities, array of entity ids or array of entity id maps (if entity has composite ids).
                 * Works only for many-to-many and one-to-many relations.
                 * For many-to-one and one-to-one use #set method instead.
                 */
                RelationQueryBuilder.prototype.addAndRemove = function (added, removed) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.remove(removed)];
                                case 1:
                                    _a.sent();
                                    return [4 /*yield*/, this.add(added)];
                                case 2:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Gets entity's relation id.
                async getId(): Promise<any> {
            
                }*/
                /**
                 * Gets entity's relation ids.
                async getIds(): Promise<any[]> {
                    return [];
                }*/
                /**
                 * Loads a single entity (relational) from the relation.
                 * You can also provide id of relational entity to filter by.
                 */
                RelationQueryBuilder.prototype.loadOne = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var of, metadata, relationLoader;
                        return __generator(this, function (_a) {
                            of = this.expressionMap.of;
                            if (!(of instanceof Object)) {
                                metadata = this.expressionMap.mainAlias.metadata;
                                if (metadata.hasMultiplePrimaryKeys)
                                    throw new Error("Cannot load entity because only one primary key was specified, however entity contains multiple primary keys");
                                of = metadata.primaryColumns[0].createValueMap(of);
                            }
                            relationLoader = new RelationLoader_1.RelationLoader(this.connection);
                            return [2 /*return*/, relationLoader.load(this.expressionMap.relationMetadata, of)];
                        });
                    });
                };
                /**
                 * Loads many entities (relational) from the relation.
                 * You can also provide ids of relational entities to filter by.
                 */
                RelationQueryBuilder.prototype.loadMany = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            return [2 /*return*/, this.loadOne()];
                        });
                    });
                };
                return RelationQueryBuilder;
            }(QueryBuilder_4.QueryBuilder));
            exports_125("RelationQueryBuilder", RelationQueryBuilder);
        }
    };
});
System.register("typeorm/driver/sqljs/SqljsQueryRunner", ["typeorm/error/QueryRunnerAlreadyReleasedError", "typeorm/util/OrmUtils", "typeorm/driver/sqlite-abstract/AbstractSqliteQueryRunner"], function (exports_126, context_126) {
    "use strict";
    var __moduleName = context_126 && context_126.id;
    var QueryRunnerAlreadyReleasedError_5, OrmUtils_6, AbstractSqliteQueryRunner_2, SqljsQueryRunner;
    return {
        setters: [
            function (QueryRunnerAlreadyReleasedError_5_1) {
                QueryRunnerAlreadyReleasedError_5 = QueryRunnerAlreadyReleasedError_5_1;
            },
            function (OrmUtils_6_1) {
                OrmUtils_6 = OrmUtils_6_1;
            },
            function (AbstractSqliteQueryRunner_2_1) {
                AbstractSqliteQueryRunner_2 = AbstractSqliteQueryRunner_2_1;
            }
        ],
        execute: function () {
            /**
             * Runs queries on a single sqlite database connection.
             *
             * Does not support compose primary keys with autoincrement field.
             * todo: need to throw exception for this case.
             */
            SqljsQueryRunner = /** @class */ (function (_super) {
                __extends(SqljsQueryRunner, _super);
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function SqljsQueryRunner(driver) {
                    var _this = _super.call(this, driver) || this;
                    _this.driver = driver;
                    _this.connection = driver.connection;
                    return _this;
                }
                // -------------------------------------------------------------------------
                // Public methods
                // -------------------------------------------------------------------------
                /**
                 * Commits transaction.
                 * Error will be thrown if transaction was not started.
                 */
                SqljsQueryRunner.prototype.commitTransaction = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, _super.prototype.commitTransaction.call(this)];
                                case 1:
                                    _a.sent();
                                    return [4 /*yield*/, this.driver.autoSave()];
                                case 2:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Executes a given SQL query.
                 */
                SqljsQueryRunner.prototype.query = function (query, parameters) {
                    var _this = this;
                    if (this.isReleased)
                        throw new QueryRunnerAlreadyReleasedError_5.QueryRunnerAlreadyReleasedError();
                    return new Promise(function (ok, fail) { return __awaiter(_this, void 0, void 0, function () {
                        var databaseConnection, queryStartTime, statement, maxQueryExecutionTime, queryEndTime, queryExecutionTime, result;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.connect()];
                                case 1:
                                    databaseConnection = _a.sent();
                                    this.driver.connection.logger.logQuery(query, parameters, this);
                                    queryStartTime = +new Date();
                                    try {
                                        statement = databaseConnection.prepare(query);
                                        statement.bind(parameters);
                                        maxQueryExecutionTime = this.driver.connection.options.maxQueryExecutionTime;
                                        queryEndTime = +new Date();
                                        queryExecutionTime = queryEndTime - queryStartTime;
                                        if (maxQueryExecutionTime && queryExecutionTime > maxQueryExecutionTime)
                                            this.driver.connection.logger.logQuerySlow(queryExecutionTime, query, parameters, this);
                                        result = [];
                                        while (statement.step()) {
                                            result.push(statement.getAsObject());
                                        }
                                        statement.free();
                                        ok(result);
                                    }
                                    catch (e) {
                                        fail(e);
                                    }
                                    return [2 /*return*/];
                            }
                        });
                    }); });
                };
                /**
                 * Insert a new row with given values into the given table.
                 * Returns value of the generated column if given and generate column exist in the table.
                 */
                SqljsQueryRunner.prototype.insert = function (tableName, keyValues) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var keys, columns, values, generatedColumns, sql, parameters;
                        return __generator(this, function (_a) {
                            keys = Object.keys(keyValues);
                            columns = keys.map(function (key) { return "\"" + key + "\""; }).join(", ");
                            values = keys.map(function (key) { return "?"; }).join(",");
                            generatedColumns = this.connection.hasMetadata(tableName) ? this.connection.getMetadata(tableName).generatedColumns : [];
                            sql = columns.length > 0 ? ("INSERT INTO \"" + tableName + "\"(" + columns + ") VALUES (" + values + ")") : "INSERT INTO \"" + tableName + "\" DEFAULT VALUES";
                            parameters = keys.map(function (key) { return keyValues[key]; });
                            return [2 /*return*/, new Promise(function (ok, fail) { return __awaiter(_this, void 0, void 0, function () {
                                    var databaseConnection, statement, generatedMap, e_1;
                                    return __generator(this, function (_a) {
                                        switch (_a.label) {
                                            case 0:
                                                this.driver.connection.logger.logQuery(sql, parameters, this);
                                                return [4 /*yield*/, this.connect()];
                                            case 1:
                                                databaseConnection = _a.sent();
                                                _a.label = 2;
                                            case 2:
                                                _a.trys.push([2, 5, , 6]);
                                                statement = databaseConnection.prepare(sql);
                                                statement.bind(parameters);
                                                statement.step();
                                                generatedMap = generatedColumns.reduce(function (map, generatedColumn) {
                                                    var value = keyValues[generatedColumn.databaseName];
                                                    // seems to be the only way to get the inserted id, see https://github.com/kripken/sql.js/issues/77
                                                    if (generatedColumn.isPrimary && generatedColumn.generationStrategy === "increment") {
                                                        value = databaseConnection.exec("SELECT last_insert_rowid()")[0].values[0][0];
                                                    }
                                                    if (!value)
                                                        return map;
                                                    return OrmUtils_6.OrmUtils.mergeDeep(map, generatedColumn.createValueMap(value));
                                                }, {});
                                                if (!!this.isTransactionActive) return [3 /*break*/, 4];
                                                return [4 /*yield*/, this.driver.autoSave()];
                                            case 3:
                                                _a.sent();
                                                _a.label = 4;
                                            case 4:
                                                ok({
                                                    result: undefined,
                                                    generatedMap: Object.keys(generatedMap).length > 0 ? generatedMap : undefined
                                                });
                                                return [3 /*break*/, 6];
                                            case 5:
                                                e_1 = _a.sent();
                                                fail(e_1);
                                                return [3 /*break*/, 6];
                                            case 6: return [2 /*return*/];
                                        }
                                    });
                                }); })];
                        });
                    });
                };
                /**
                 * Updates rows that match given conditions in the given table.
                 * Calls AbstractSqliteQueryRunner.update() and runs autoSave if update() was not called in a transaction.
                 */
                SqljsQueryRunner.prototype.update = function (tableName, valuesMap, conditions) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, _super.prototype.update.call(this, tableName, valuesMap, conditions)];
                                case 1:
                                    _a.sent();
                                    if (!!this.isTransactionActive) return [3 /*break*/, 3];
                                    return [4 /*yield*/, this.driver.autoSave()];
                                case 2:
                                    _a.sent();
                                    _a.label = 3;
                                case 3: return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Deletes from the given table by a given conditions.
                 * Calls AbstractSqliteQueryRunner.delete() and runs autoSave if delete() was not called in a transaction.
                 */
                SqljsQueryRunner.prototype.delete = function (tableName, conditions, maybeParameters) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, _super.prototype.delete.call(this, tableName, conditions, maybeParameters)];
                                case 1:
                                    _a.sent();
                                    if (!!this.isTransactionActive) return [3 /*break*/, 3];
                                    return [4 /*yield*/, this.driver.autoSave()];
                                case 2:
                                    _a.sent();
                                    _a.label = 3;
                                case 3: return [2 /*return*/];
                            }
                        });
                    });
                };
                return SqljsQueryRunner;
            }(AbstractSqliteQueryRunner_2.AbstractSqliteQueryRunner));
            exports_126("SqljsQueryRunner", SqljsQueryRunner);
        }
    };
});
System.register("typeorm/error/DriverOptionNotSetError", [], function (exports_127, context_127) {
    "use strict";
    var __moduleName = context_127 && context_127.id;
    var DriverOptionNotSetError;
    return {
        setters: [],
        execute: function () {
            /**
             * Thrown if some required driver's option is not set.
             */
            DriverOptionNotSetError = /** @class */ (function (_super) {
                __extends(DriverOptionNotSetError, _super);
                function DriverOptionNotSetError(optionName) {
                    var _this = _super.call(this) || this;
                    _this.name = "DriverOptionNotSetError";
                    _this.message = "Driver option (" + optionName + ") is not set. Please set it to perform connection to the database.";
                    return _this;
                }
                return DriverOptionNotSetError;
            }(Error));
            exports_127("DriverOptionNotSetError", DriverOptionNotSetError);
        }
    };
});
System.register("typeorm/driver/sqljs/SqljsDriver", ["typeorm/driver/sqlite-abstract/AbstractSqliteDriver", "typeorm/driver/sqljs/SqljsQueryRunner", "typeorm/error/DriverPackageNotInstalledError", "typeorm/error/DriverOptionNotSetError", "typeorm/platform/PlatformTools"], function (exports_128, context_128) {
    "use strict";
    var __moduleName = context_128 && context_128.id;
    var AbstractSqliteDriver_3, SqljsQueryRunner_1, DriverPackageNotInstalledError_6, DriverOptionNotSetError_1, PlatformTools_8, SqljsDriver;
    return {
        setters: [
            function (AbstractSqliteDriver_3_1) {
                AbstractSqliteDriver_3 = AbstractSqliteDriver_3_1;
            },
            function (SqljsQueryRunner_1_1) {
                SqljsQueryRunner_1 = SqljsQueryRunner_1_1;
            },
            function (DriverPackageNotInstalledError_6_1) {
                DriverPackageNotInstalledError_6 = DriverPackageNotInstalledError_6_1;
            },
            function (DriverOptionNotSetError_1_1) {
                DriverOptionNotSetError_1 = DriverOptionNotSetError_1_1;
            },
            function (PlatformTools_8_1) {
                PlatformTools_8 = PlatformTools_8_1;
            }
        ],
        execute: function () {
            SqljsDriver = /** @class */ (function (_super) {
                __extends(SqljsDriver, _super);
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function SqljsDriver(connection) {
                    var _this = _super.call(this, connection) || this;
                    // If autoSave is enabled by user, location or autoSaveCallback have to be set
                    // because either autoSave saves to location or calls autoSaveCallback.
                    if (_this.options.autoSave && !_this.options.location && !_this.options.autoSaveCallback) {
                        throw new DriverOptionNotSetError_1.DriverOptionNotSetError("location or autoSaveCallback");
                    }
                    // load sql.js package
                    _this.loadDependencies();
                    return _this;
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Performs connection to the database.
                 */
                SqljsDriver.prototype.connect = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var _a;
                        return __generator(this, function (_b) {
                            switch (_b.label) {
                                case 0:
                                    _a = this;
                                    return [4 /*yield*/, this.createDatabaseConnection()];
                                case 1:
                                    _a.databaseConnection = _b.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Closes connection with database.
                 */
                SqljsDriver.prototype.disconnect = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        return __generator(this, function (_a) {
                            return [2 /*return*/, new Promise(function (ok, fail) {
                                    try {
                                        _this.queryRunner = undefined;
                                        _this.databaseConnection.close();
                                        ok();
                                    }
                                    catch (e) {
                                        fail(e);
                                    }
                                })];
                        });
                    });
                };
                /**
                 * Creates a query runner used to execute database queries.
                 */
                SqljsDriver.prototype.createQueryRunner = function (mode) {
                    if (mode === void 0) { mode = "master"; }
                    if (!this.queryRunner)
                        this.queryRunner = new SqljsQueryRunner_1.SqljsQueryRunner(this);
                    return this.queryRunner;
                };
                /**
                 * Loads a database from a given file (Node.js), local storage key (browser) or array.
                 * This will delete the current database!
                 */
                SqljsDriver.prototype.load = function (fileNameOrLocalStorageOrData) {
                    if (typeof fileNameOrLocalStorageOrData === "string") {
                        // content has to be loaded
                        if (PlatformTools_8.PlatformTools.type === "node") {
                            // Node.js
                            // fileNameOrLocalStorageOrData should be a path to the file
                            if (PlatformTools_8.PlatformTools.fileExist(fileNameOrLocalStorageOrData)) {
                                var database = PlatformTools_8.PlatformTools.readFileSync(fileNameOrLocalStorageOrData);
                                return this.createDatabaseConnectionWithImport(database);
                            }
                            else {
                                throw new Error("File " + fileNameOrLocalStorageOrData + " does not exist");
                            }
                        }
                        else {
                            // browser
                            // fileNameOrLocalStorageOrData should be a local storage key
                            var localStorageContent = PlatformTools_8.PlatformTools.getGlobalVariable().localStorage.getItem(fileNameOrLocalStorageOrData);
                            return this.createDatabaseConnectionWithImport(JSON.parse(localStorageContent));
                        }
                    }
                    else {
                        return this.createDatabaseConnectionWithImport(fileNameOrLocalStorageOrData);
                    }
                };
                /**
                 * Saved the current database to the given file (Node.js) or local storage key (browser).
                 * If no location path is given, the location path in the options (if specified) will be used.
                 */
                SqljsDriver.prototype.save = function (location) {
                    return __awaiter(this, void 0, void 0, function () {
                        var path, content, e_2, database, databaseArray;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (!location && !this.options.location) {
                                        throw new Error("No location is set, specify a location parameter or add the location option to your configuration");
                                    }
                                    path = "";
                                    if (location) {
                                        path = location;
                                    }
                                    else if (this.options.location) {
                                        path = this.options.location;
                                    }
                                    if (!(PlatformTools_8.PlatformTools.type === "node")) return [3 /*break*/, 5];
                                    _a.label = 1;
                                case 1:
                                    _a.trys.push([1, 3, , 4]);
                                    content = new Buffer(this.databaseConnection.export());
                                    return [4 /*yield*/, PlatformTools_8.PlatformTools.writeFile(path, content)];
                                case 2:
                                    _a.sent();
                                    return [3 /*break*/, 4];
                                case 3:
                                    e_2 = _a.sent();
                                    throw new Error("Could not save database, error: " + e_2);
                                case 4: return [3 /*break*/, 6];
                                case 5:
                                    database = this.databaseConnection.export();
                                    databaseArray = [].slice.call(database);
                                    PlatformTools_8.PlatformTools.getGlobalVariable().localStorage.setItem(path, JSON.stringify(databaseArray));
                                    _a.label = 6;
                                case 6: return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * This gets called by the QueryRunner when a change to the database is made.
                 * If a custom autoSaveCallback is specified, it get's called with the database as Uint8Array,
                 * otherwise the save method is called which saves it to file (Node.js) or localstorage (browser).
                 */
                SqljsDriver.prototype.autoSave = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (!this.options.autoSave) return [3 /*break*/, 4];
                                    if (!this.options.autoSaveCallback) return [3 /*break*/, 2];
                                    return [4 /*yield*/, this.options.autoSaveCallback(this.export())];
                                case 1:
                                    _a.sent();
                                    return [3 /*break*/, 4];
                                case 2: return [4 /*yield*/, this.save()];
                                case 3:
                                    _a.sent();
                                    _a.label = 4;
                                case 4: return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Returns the current database as Uint8Array.
                 */
                SqljsDriver.prototype.export = function () {
                    return this.databaseConnection.export();
                };
                // -------------------------------------------------------------------------
                // Protected Methods
                // -------------------------------------------------------------------------
                /**
                 * Creates connection with the database.
                 * If the location option is set, the database is loaded first.
                 */
                SqljsDriver.prototype.createDatabaseConnection = function () {
                    if (this.options.location) {
                        return this.load(this.options.location);
                    }
                    return this.createDatabaseConnectionWithImport(this.options.database);
                };
                /**
                 * Creates connection with an optional database.
                 * If database is specified it is loaded, otherwise a new empty database is created.
                 */
                SqljsDriver.prototype.createDatabaseConnectionWithImport = function (database) {
                    var _this = this;
                    if (database && database.length > 0) {
                        this.databaseConnection = new this.sqlite.Database(database);
                    }
                    else {
                        this.databaseConnection = new this.sqlite.Database();
                    }
                    // Enable foreign keys for database
                    return new Promise(function (ok, fail) {
                        try {
                            _this.databaseConnection.exec("PRAGMA foreign_keys = ON;");
                            ok(_this.databaseConnection);
                        }
                        catch (e) {
                            fail(e);
                        }
                    });
                };
                /**
                 * If driver dependency is not given explicitly, then try to load it via "require".
                 */
                SqljsDriver.prototype.loadDependencies = function () {
                    if (PlatformTools_8.PlatformTools.type === "browser") {
                        this.sqlite = window.SQL;
                    }
                    else {
                        try {
                            this.sqlite = PlatformTools_8.PlatformTools.load("sql.js");
                        }
                        catch (e) {
                            throw new DriverPackageNotInstalledError_6.DriverPackageNotInstalledError("sql.js", "sql.js");
                        }
                    }
                };
                return SqljsDriver;
            }(AbstractSqliteDriver_3.AbstractSqliteDriver));
            exports_128("SqljsDriver", SqljsDriver);
        }
    };
});
System.register("typeorm/query-builder/QueryBuilder", ["typeorm/query-builder/QueryExpressionMap", "typeorm/query-builder/Brackets", "typeorm/metadata/EntityMetadataUtils", "typeorm/driver/sqljs/SqljsDriver"], function (exports_129, context_129) {
    "use strict";
    var __moduleName = context_129 && context_129.id;
    var QueryExpressionMap_1, Brackets_1, EntityMetadataUtils_2, SqljsDriver_1, QueryBuilder;
    return {
        setters: [
            function (QueryExpressionMap_1_1) {
                QueryExpressionMap_1 = QueryExpressionMap_1_1;
            },
            function (Brackets_1_1) {
                Brackets_1 = Brackets_1_1;
            },
            function (EntityMetadataUtils_2_1) {
                EntityMetadataUtils_2 = EntityMetadataUtils_2_1;
            },
            function (SqljsDriver_1_1) {
                SqljsDriver_1 = SqljsDriver_1_1;
            }
        ],
        execute: function () {
            // todo: completely cover query builder with tests
            // todo: entityOrProperty can be target name. implement proper behaviour if it is.
            // todo: check in persistment if id exist on object and throw exception (can be in partial selection?)
            // todo: fix problem with long aliases eg getMaxIdentifierLength
            // todo: fix replacing in .select("COUNT(post.id) AS cnt") statement
            // todo: implement joinAlways in relations and relationId
            // todo: finish partial selection
            // todo: sugar methods like: .addCount and .selectCount, selectCountAndMap, selectSum, selectSumAndMap, ...
            // todo: implement @Select decorator
            // todo: add select and map functions
            // todo: implement relation/entity loading and setting them into properties within a separate query
            // .loadAndMap("post.categories", "post.categories", qb => ...)
            // .loadAndMap("post.categories", Category, qb => ...)
            /**
             * Allows to build complex sql queries in a fashion way and execute those queries.
             */
            QueryBuilder = /** @class */ (function () {
                /**
                 * QueryBuilder can be initialized from given Connection and QueryRunner objects or from given other QueryBuilder.
                 */
                function QueryBuilder(connectionOrQueryBuilder, queryRunner) {
                    if (connectionOrQueryBuilder instanceof QueryBuilder) {
                        this.connection = connectionOrQueryBuilder.connection;
                        this.queryRunner = connectionOrQueryBuilder.queryRunner;
                        this.expressionMap = connectionOrQueryBuilder.expressionMap.clone();
                    }
                    else {
                        this.connection = connectionOrQueryBuilder;
                        this.queryRunner = queryRunner;
                        this.expressionMap = new QueryExpressionMap_1.QueryExpressionMap(this.connection);
                    }
                }
                Object.defineProperty(QueryBuilder.prototype, "alias", {
                    // -------------------------------------------------------------------------
                    // Accessors
                    // -------------------------------------------------------------------------
                    /**
                     * Gets the main alias string used in this query builder.
                     */
                    get: function () {
                        if (!this.expressionMap.mainAlias)
                            throw new Error("Main alias is not set"); // todo: better exception
                        return this.expressionMap.mainAlias.name;
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Creates SELECT query and selects given data.
                 * Replaces all previous selections if they exist.
                 */
                QueryBuilder.prototype.select = function (selection, selectionAliasName) {
                    this.expressionMap.queryType = "select";
                    if (selection instanceof Array) {
                        this.expressionMap.selects = selection.map(function (selection) { return ({ selection: selection }); });
                    }
                    else if (selection) {
                        this.expressionMap.selects = [{ selection: selection, aliasName: selectionAliasName }];
                    }
                    // loading it dynamically because of circular issue
                    var SelectQueryBuilderCls = require("./SelectQueryBuilder").SelectQueryBuilder;
                    if (this instanceof SelectQueryBuilderCls)
                        return this;
                    return new SelectQueryBuilderCls(this);
                };
                /**
                 * Creates INSERT query.
                 */
                QueryBuilder.prototype.insert = function () {
                    this.expressionMap.queryType = "insert";
                    // loading it dynamically because of circular issue
                    var InsertQueryBuilderCls = require("./InsertQueryBuilder").InsertQueryBuilder;
                    if (this instanceof InsertQueryBuilderCls)
                        return this;
                    return new InsertQueryBuilderCls(this);
                };
                /**
                 * Creates UPDATE query and applies given update values.
                 */
                QueryBuilder.prototype.update = function (entityOrTableNameUpdateSet, maybeUpdateSet) {
                    var updateSet = maybeUpdateSet ? maybeUpdateSet : entityOrTableNameUpdateSet;
                    if (entityOrTableNameUpdateSet instanceof Function || typeof entityOrTableNameUpdateSet === "string") {
                        var mainAlias = this.createFromAlias(entityOrTableNameUpdateSet);
                        this.expressionMap.setMainAlias(mainAlias);
                    }
                    this.expressionMap.queryType = "update";
                    this.expressionMap.valuesSet = updateSet;
                    // loading it dynamically because of circular issue
                    var UpdateQueryBuilderCls = require("./UpdateQueryBuilder").UpdateQueryBuilder;
                    if (this instanceof UpdateQueryBuilderCls)
                        return this;
                    return new UpdateQueryBuilderCls(this);
                };
                /**
                 * Creates DELETE query.
                 */
                QueryBuilder.prototype.delete = function () {
                    this.expressionMap.queryType = "delete";
                    // loading it dynamically because of circular issue
                    var DeleteQueryBuilderCls = require("./DeleteQueryBuilder").DeleteQueryBuilder;
                    if (this instanceof DeleteQueryBuilderCls)
                        return this;
                    return new DeleteQueryBuilderCls(this);
                };
                /**
                 * Sets entity's relation with which this query builder gonna work.
                 */
                QueryBuilder.prototype.relation = function (entityTargetOrPropertyPath, maybePropertyPath) {
                    var entityTarget = arguments.length === 2 ? entityTargetOrPropertyPath : undefined;
                    var propertyPath = arguments.length === 2 ? maybePropertyPath : entityTargetOrPropertyPath;
                    this.expressionMap.queryType = "relation";
                    this.expressionMap.relationPropertyPath = propertyPath;
                    if (entityTarget) {
                        var mainAlias = this.createFromAlias(entityTarget);
                        this.expressionMap.setMainAlias(mainAlias);
                    }
                    // loading it dynamically because of circular issue
                    var RelationQueryBuilderCls = require("./RelationQueryBuilder").RelationQueryBuilder;
                    if (this instanceof RelationQueryBuilderCls)
                        return this;
                    return new RelationQueryBuilderCls(this);
                };
                /**
                 * Checks if given relation or relations exist in the entity.
                 * Returns true if relation exists, false otherwise.
                 */
                QueryBuilder.prototype.hasRelation = function (target, relation) {
                    var entityMetadata = this.connection.getMetadata(target);
                    var relations = relation instanceof Array ? relation : [relation];
                    return relations.every(function (relation) {
                        return !!entityMetadata.findRelationWithPropertyPath(relation);
                    });
                };
                /**
                 * Sets parameter name and its value.
                 */
                QueryBuilder.prototype.setParameter = function (key, value) {
                    this.expressionMap.parameters[key] = value;
                    return this;
                };
                /**
                 * Adds all parameters from the given object.
                 */
                QueryBuilder.prototype.setParameters = function (parameters) {
                    var _this = this;
                    // set parent query builder parameters as well in sub-query mode
                    if (this.expressionMap.parentQueryBuilder)
                        this.expressionMap.parentQueryBuilder.setParameters(parameters);
                    Object.keys(parameters).forEach(function (key) {
                        _this.expressionMap.parameters[key] = parameters[key];
                    });
                    return this;
                };
                /**
                 * Gets all parameters.
                 */
                QueryBuilder.prototype.getParameters = function () {
                    var parameters = Object.assign({}, this.expressionMap.parameters);
                    // add discriminator column parameter if it exist
                    if (this.expressionMap.mainAlias && this.expressionMap.mainAlias.hasMetadata) {
                        var metadata = this.expressionMap.mainAlias.metadata;
                        if (metadata.discriminatorColumn && metadata.parentEntityMetadata) {
                            var values = metadata.childEntityMetadatas
                                .filter(function (childMetadata) { return childMetadata.discriminatorColumn; })
                                .map(function (childMetadata) { return childMetadata.discriminatorValue; });
                            values.push(metadata.discriminatorValue);
                            parameters["discriminatorColumnValues"] = values;
                        }
                    }
                    return parameters;
                };
                /**
                 * Gets generated sql that will be executed.
                 * Parameters in the query are escaped for the currently used driver.
                 */
                QueryBuilder.prototype.getSql = function () {
                    return this.connection.driver.escapeQueryWithParameters(this.getQuery(), this.getParameters())[0];
                };
                /**
                 * Prints sql to stdout using console.log.
                 */
                QueryBuilder.prototype.printSql = function () {
                    console.log(this.getSql());
                    return this;
                };
                /**
                 * Gets query to be executed with all parameters used in it.
                 */
                QueryBuilder.prototype.getQueryAndParameters = function () {
                    return this.connection.driver.escapeQueryWithParameters(this.getQuery(), this.getParameters());
                };
                /**
                 * Executes sql generated by query builder and returns raw database results.
                 */
                QueryBuilder.prototype.execute = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var _a, sql, parameters, queryRunner;
                        return __generator(this, function (_b) {
                            switch (_b.label) {
                                case 0:
                                    _a = this.getQueryAndParameters(), sql = _a[0], parameters = _a[1];
                                    queryRunner = this.obtainQueryRunner();
                                    _b.label = 1;
                                case 1:
                                    _b.trys.push([1, , 3, 8]);
                                    return [4 /*yield*/, queryRunner.query(sql, parameters)];
                                case 2: return [2 /*return*/, _b.sent()]; // await is needed here because we are using finally
                                case 3:
                                    if (!(queryRunner !== this.queryRunner)) return [3 /*break*/, 5];
                                    return [4 /*yield*/, queryRunner.release()];
                                case 4:
                                    _b.sent();
                                    _b.label = 5;
                                case 5:
                                    if (!(this.connection.driver instanceof SqljsDriver_1.SqljsDriver)) return [3 /*break*/, 7];
                                    return [4 /*yield*/, this.connection.driver.autoSave()];
                                case 6:
                                    _b.sent();
                                    _b.label = 7;
                                case 7: return [7 /*endfinally*/];
                                case 8: return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Creates a completely new query builder.
                 * Uses same query runner as current QueryBuilder.
                 */
                QueryBuilder.prototype.createQueryBuilder = function () {
                    return new this.constructor(this.connection, this.queryRunner);
                };
                /**
                 * Clones query builder as it is.
                 * Note: it uses new query runner, if you want query builder that uses exactly same query runner,
                 * you can create query builder using its constructor, for example new SelectQueryBuilder(queryBuilder)
                 * where queryBuilder is cloned QueryBuilder.
                 */
                QueryBuilder.prototype.clone = function () {
                    return new this.constructor(this);
                };
                /**
                 * Disables escaping.
                 */
                QueryBuilder.prototype.disableEscaping = function () {
                    this.expressionMap.disableEscaping = false;
                    return this;
                };
                /**
                 * Escapes table name, column name or alias name using current database's escaping character.
                 */
                QueryBuilder.prototype.escape = function (name) {
                    if (!this.expressionMap.disableEscaping)
                        return name;
                    return this.connection.driver.escape(name);
                };
                /**
                 * Sets or overrides query builder's QueryRunner.
                 */
                QueryBuilder.prototype.setQueryRunner = function (queryRunner) {
                    this.queryRunner = queryRunner;
                    return this;
                };
                // -------------------------------------------------------------------------
                // Protected Methods
                // -------------------------------------------------------------------------
                /**
                 * Gets escaped table name with schema name if SqlServer driver used with custom
                 * schema name, otherwise returns escaped table name.
                 */
                QueryBuilder.prototype.getTableName = function (tablePath) {
                    // let tablePath = tableName;
                    // const driver = this.connection.driver;
                    // const schema = (driver.options as SqlServerConnectionOptions|PostgresConnectionOptions).schema;
                    // const metadata = this.connection.hasMetadata(tableName) ? this.connection.getMetadata(tableName) : undefined;
                    var _this = this;
                    /*if (driver instanceof SqlServerDriver || driver instanceof PostgresDriver || driver instanceof MysqlDriver) {
                        if (metadata) {
                            if (metadata.schema) {
                                tablePath = `${metadata.schema}.${tableName}`;
                            } else if (schema) {
                                tablePath = `${schema}.${tableName}`;
                            }
            
                            if (metadata.database && !(driver instanceof PostgresDriver)) {
                                if (!schema && !metadata.schema && driver instanceof SqlServerDriver) {
                                    tablePath = `${metadata.database}..${tablePath}`;
                                } else {
                                    tablePath = `${metadata.database}.${tablePath}`;
                                }
                            }
            
                        } else if (schema) {
                            tablePath = `${schema!}.${tableName}`;
                        }
                    }*/
                    return tablePath.split(".")
                        .map(function (i) {
                        // this condition need because in SQL Server driver when custom database name was specified and schema name was not, we got `dbName..tableName` string, and doesn't need to escape middle empty string
                        if (i === "")
                            return i;
                        return _this.escape(i);
                    }).join(".");
                };
                /**
                 * Gets name of the table where insert should be performed.
                 */
                QueryBuilder.prototype.getMainTableName = function () {
                    if (!this.expressionMap.mainAlias)
                        throw new Error("Entity where values should be inserted is not specified. Call \"qb.into(entity)\" method to specify it.");
                    if (this.expressionMap.mainAlias.hasMetadata)
                        return this.expressionMap.mainAlias.metadata.tablePath;
                    return this.expressionMap.mainAlias.tablePath;
                };
                /**
                 * Specifies FROM which entity's table select/update/delete will be executed.
                 * Also sets a main string alias of the selection data.
                 */
                QueryBuilder.prototype.createFromAlias = function (entityTarget, aliasName) {
                    // if table has a metadata then find it to properly escape its properties
                    // const metadata = this.connection.entityMetadatas.find(metadata => metadata.tableName === tableName);
                    if (this.connection.hasMetadata(entityTarget)) {
                        var metadata = this.connection.getMetadata(entityTarget);
                        return this.expressionMap.createAlias({
                            type: "from",
                            name: aliasName,
                            metadata: this.connection.getMetadata(entityTarget),
                            tablePath: metadata.tablePath
                        });
                    }
                    else {
                        var subQuery = "";
                        if (entityTarget instanceof Function) {
                            var subQueryBuilder = entityTarget(this.subQuery());
                            this.setParameters(subQueryBuilder.getParameters());
                            subQuery = subQueryBuilder.getQuery();
                        }
                        else {
                            subQuery = entityTarget;
                        }
                        var isSubQuery = entityTarget instanceof Function || entityTarget.substr(0, 1) === "(" && entityTarget.substr(-1) === ")";
                        return this.expressionMap.createAlias({
                            type: "from",
                            name: aliasName,
                            tablePath: isSubQuery === false ? entityTarget : undefined,
                            subQuery: isSubQuery === true ? subQuery : undefined,
                        });
                    }
                };
                /**
                 * Replaces all entity's propertyName to name in the given statement.
                 */
                QueryBuilder.prototype.replacePropertyNames = function (statement) {
                    var _this = this;
                    this.expressionMap.aliases.forEach(function (alias) {
                        if (!alias.hasMetadata)
                            return;
                        var replaceAliasNamePrefix = _this.expressionMap.aliasNamePrefixingEnabled ? alias.name + "\\." : "";
                        var replacementAliasNamePrefix = _this.expressionMap.aliasNamePrefixingEnabled ? _this.escape(alias.name) + "." : "";
                        alias.metadata.columns.forEach(function (column) {
                            var expression = "([ =\(]|^.{0})" + replaceAliasNamePrefix + column.propertyPath + "([ =\)\,]|.{0}$)";
                            statement = statement.replace(new RegExp(expression, "gm"), "$1" + replacementAliasNamePrefix + _this.escape(column.databaseName) + "$2");
                            var expression2 = "([ =\(]|^.{0})" + replaceAliasNamePrefix + column.propertyName + "([ =\)\,]|.{0}$)";
                            statement = statement.replace(new RegExp(expression2, "gm"), "$1" + replacementAliasNamePrefix + _this.escape(column.databaseName) + "$2");
                        });
                        alias.metadata.relations.forEach(function (relation) {
                            relation.joinColumns.concat(relation.inverseJoinColumns).forEach(function (joinColumn) {
                                var expression = "([ =\(]|^.{0})" + replaceAliasNamePrefix + relation.propertyPath + "\\." + joinColumn.referencedColumn.propertyPath + "([ =\)\,]|.{0}$)";
                                statement = statement.replace(new RegExp(expression, "gm"), "$1" + replacementAliasNamePrefix + _this.escape(joinColumn.databaseName) + "$2"); // todo: fix relation.joinColumns[0], what if multiple columns
                            });
                            if (relation.joinColumns.length > 0) {
                                var expression = "([ =\(]|^.{0})" + replaceAliasNamePrefix + relation.propertyPath + "([ =\)\,]|.{0}$)";
                                statement = statement.replace(new RegExp(expression, "gm"), "$1" + replacementAliasNamePrefix + _this.escape(relation.joinColumns[0].databaseName) + "$2"); // todo: fix relation.joinColumns[0], what if multiple columns
                            }
                        });
                    });
                    return statement;
                };
                /**
                 * Creates "WHERE" expression.
                 */
                QueryBuilder.prototype.createWhereExpression = function () {
                    var conditions = this.createWhereExpressionString();
                    if (this.expressionMap.mainAlias.hasMetadata) {
                        var metadata = this.expressionMap.mainAlias.metadata;
                        if (metadata.discriminatorColumn && metadata.parentEntityMetadata) {
                            var condition = this.replacePropertyNames(this.expressionMap.mainAlias.name + "." + metadata.discriminatorColumn.databaseName) + " IN (:discriminatorColumnValues)";
                            return " WHERE " + (conditions.length ? "(" + conditions + ") AND" : "") + " " + condition;
                        }
                    }
                    if (!conditions.length) // TODO copy in to discriminator condition
                        return this.expressionMap.extraAppendedAndWhereCondition ? " WHERE " + this.replacePropertyNames(this.expressionMap.extraAppendedAndWhereCondition) : "";
                    if (this.expressionMap.extraAppendedAndWhereCondition)
                        return " WHERE (" + conditions + ") AND " + this.replacePropertyNames(this.expressionMap.extraAppendedAndWhereCondition);
                    return " WHERE " + conditions;
                };
                /**
                 * Concatenates all added where expressions into one string.
                 */
                QueryBuilder.prototype.createWhereExpressionString = function () {
                    var _this = this;
                    return this.expressionMap.wheres.map(function (where, index) {
                        switch (where.type) {
                            case "and":
                                return (index > 0 ? "AND " : "") + _this.replacePropertyNames(where.condition);
                            case "or":
                                return (index > 0 ? "OR " : "") + _this.replacePropertyNames(where.condition);
                            default:
                                return _this.replacePropertyNames(where.condition);
                        }
                    }).join(" ");
                };
                /**
                 * Creates "WHERE" expression and variables for the given "ids".
                 */
                QueryBuilder.prototype.createWhereIdsExpression = function (ids) {
                    var _this = this;
                    var metadata = this.expressionMap.mainAlias.metadata;
                    // create shortcuts for better readability
                    var alias = this.expressionMap.aliasNamePrefixingEnabled ? this.escape(this.expressionMap.mainAlias.name) + "." : "";
                    var parameters = {};
                    var whereStrings = ids.map(function (id, index) {
                        id = id instanceof Object ? id : metadata.createEntityIdMap(id);
                        var whereSubStrings = [];
                        metadata.primaryColumns.forEach(function (primaryColumn, secondIndex) {
                            whereSubStrings.push(alias + _this.escape(primaryColumn.databaseName) + "=:id_" + index + "_" + secondIndex);
                            parameters["id_" + index + "_" + secondIndex] = primaryColumn.getEntityValue(id);
                        });
                        metadata.parentIdColumns.forEach(function (parentIdColumn, secondIndex) {
                            whereSubStrings.push(alias + _this.escape(parentIdColumn.databaseName) + "=:parentId_" + index + "_" + secondIndex);
                            parameters["parentId_" + index + "_" + secondIndex] = parentIdColumn.getEntityValue(id);
                        });
                        return whereSubStrings.join(" AND ");
                    });
                    var whereString = whereStrings.length > 1 ? "(" + whereStrings.join(" OR ") + ")" : whereStrings[0];
                    return [whereString, parameters];
                };
                /**
                 * Computes given where argument - transforms to a where string all forms it can take.
                 */
                QueryBuilder.prototype.computeWhereParameter = function (where) {
                    var _this = this;
                    if (typeof where === "string")
                        return where;
                    if (where instanceof Brackets_1.Brackets) {
                        var whereQueryBuilder = this.createQueryBuilder();
                        where.whereFactory(whereQueryBuilder);
                        var whereString = whereQueryBuilder.createWhereExpressionString();
                        this.setParameters(whereQueryBuilder.getParameters());
                        return whereString ? "(" + whereString + ")" : "";
                    }
                    else if (where instanceof Function) {
                        return where(this);
                    }
                    else if (where instanceof Object) {
                        if (this.expressionMap.mainAlias.metadata) {
                            var propertyPaths = EntityMetadataUtils_2.EntityMetadataUtils.createPropertyPath(this.expressionMap.mainAlias.metadata, where);
                            propertyPaths.forEach(function (propertyPath, propertyIndex) {
                                var columns = _this.expressionMap.mainAlias.metadata.findColumnsWithPropertyPath(propertyPath);
                                columns.forEach(function (column, columnIndex) {
                                    var parameterValue = column.getEntityValue(where);
                                    var aliasPath = _this.expressionMap.aliasNamePrefixingEnabled ? _this.alias + "." + propertyPath : column.propertyPath;
                                    if (parameterValue === null) {
                                        _this.andWhere(aliasPath + " IS NULL");
                                    }
                                    else {
                                        var parameterName = "where_" + propertyIndex + "_" + columnIndex;
                                        _this.andWhere(aliasPath + "=:" + parameterName);
                                        _this.setParameter(parameterName, parameterValue);
                                    }
                                });
                            });
                        }
                        else {
                            Object.keys(where).forEach(function (key, index) {
                                var parameterValue = where[key];
                                var aliasPath = _this.expressionMap.aliasNamePrefixingEnabled ? _this.alias + "." + key : key;
                                if (parameterValue === null) {
                                    _this.andWhere(aliasPath + " IS NULL");
                                }
                                else {
                                    var parameterName = "where_" + index;
                                    _this.andWhere(aliasPath + "=:" + parameterName);
                                    _this.setParameter(parameterName, parameterValue);
                                }
                            });
                        }
                    }
                    return "";
                };
                /**
                 * Creates a query builder used to execute sql queries inside this query builder.
                 */
                QueryBuilder.prototype.obtainQueryRunner = function () {
                    return this.queryRunner || this.connection.createQueryRunner("master");
                };
                return QueryBuilder;
            }());
            exports_129("QueryBuilder", QueryBuilder);
        }
    };
});
System.register("typeorm/query-builder/QueryExpressionMap", ["typeorm/query-builder/Alias", "typeorm/query-builder/JoinAttribute", "typeorm/query-builder/relation-id/RelationIdAttribute", "typeorm/query-builder/relation-count/RelationCountAttribute"], function (exports_130, context_130) {
    "use strict";
    var __moduleName = context_130 && context_130.id;
    var Alias_1, JoinAttribute_1, RelationIdAttribute_1, RelationCountAttribute_1, QueryExpressionMap;
    return {
        setters: [
            function (Alias_1_1) {
                Alias_1 = Alias_1_1;
            },
            function (JoinAttribute_1_1) {
                JoinAttribute_1 = JoinAttribute_1_1;
            },
            function (RelationIdAttribute_1_1) {
                RelationIdAttribute_1 = RelationIdAttribute_1_1;
            },
            function (RelationCountAttribute_1_1) {
                RelationCountAttribute_1 = RelationCountAttribute_1_1;
            }
        ],
        execute: function () {
            /**
             * Contains all properties of the QueryBuilder that needs to be build a final query.
             */
            QueryExpressionMap = /** @class */ (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function QueryExpressionMap(connection) {
                    this.connection = connection;
                    // -------------------------------------------------------------------------
                    // Public Properties
                    // -------------------------------------------------------------------------
                    /**
                     * Indicates if QueryBuilder used to select entities and not a raw results.
                     */
                    this.queryEntity = false;
                    /**
                     * All aliases (including main alias) used in the query.
                     */
                    this.aliases = [];
                    /**
                     * Represents query type. QueryBuilder is able to build SELECT, UPDATE and DELETE queries.
                     */
                    this.queryType = "select";
                    /**
                     * Data needs to be SELECT-ed.
                     */
                    this.selects = [];
                    /**
                     * Optional returning (or output) clause for insert, update or delete queries.
                     */
                    this.returning = "";
                    /**
                     * Optional on conflict statement used in insertion query in postgres.
                     */
                    this.onConflict = "";
                    /**
                     * JOIN queries.
                     */
                    this.joinAttributes = [];
                    /**
                     * RelationId queries.
                     */
                    this.relationIdAttributes = [];
                    /**
                     * Relation count queries.
                     */
                    this.relationCountAttributes = [];
                    /**
                     * WHERE queries.
                     */
                    this.wheres = [];
                    /**
                     * HAVING queries.
                     */
                    this.havings = [];
                    /**
                     * ORDER BY queries.
                     */
                    this.orderBys = {};
                    /**
                     * GROUP BY queries.
                     */
                    this.groupBys = [];
                    /**
                     * Parameters used to be escaped in final query.
                     */
                    this.parameters = {};
                    /**
                     * Indicates if alias, table names and column names will be ecaped by driver, or not.
                     *
                     * todo: rename to isQuotingDisabled, also think if it should be named "escaping"
                     */
                    this.disableEscaping = true;
                    /**
                     * todo: needs more information.
                     */
                    this.ignoreParentTablesJoins = false;
                    /**
                     * Indicates if virtual columns should be included in entity result.
                     *
                     * todo: what to do with it? is it properly used? what about persistence?
                     */
                    this.enableRelationIdValues = false;
                    /**
                     * Extra where condition appended to the end of original where conditions with AND keyword.
                     * Original condition will be wrapped into brackets.
                     */
                    this.extraAppendedAndWhereCondition = "";
                    /**
                     * Indicates if query builder creates a subquery.
                     */
                    this.subQuery = false;
                    /**
                     * Indicates if property names are prefixed with alias names during property replacement.
                     * By default this is enabled, however we need this because aliases are not supported in UPDATE and DELETE queries,
                     * but user can use them in WHERE expressions.
                     */
                    this.aliasNamePrefixingEnabled = true;
                    /**
                     * Indicates if query result cache is enabled or not.
                     */
                    this.cache = false;
                    /**
                     * List of columns where data should be inserted.
                     * Used in INSERT query.
                     */
                    this.insertColumns = [];
                }
                Object.defineProperty(QueryExpressionMap.prototype, "allOrderBys", {
                    // -------------------------------------------------------------------------
                    // Accessors
                    // -------------------------------------------------------------------------
                    /**
                     * Get all ORDER BY queries - if order by is specified by user then it uses them,
                     * otherwise it uses default entity order by if it was set.
                     */
                    get: function () {
                        var _this = this;
                        if (!Object.keys(this.orderBys).length && this.mainAlias.hasMetadata) {
                            var entityOrderBy_1 = this.mainAlias.metadata.orderBy || {};
                            return Object.keys(entityOrderBy_1).reduce(function (orderBy, key) {
                                orderBy[_this.mainAlias.name + "." + key] = entityOrderBy_1[key];
                                return orderBy;
                            }, {});
                        }
                        return this.orderBys;
                    },
                    enumerable: true,
                    configurable: true
                });
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Creates a main alias and adds it to the current expression map.
                 */
                QueryExpressionMap.prototype.setMainAlias = function (alias) {
                    // if main alias is already set then remove it from the array
                    if (this.mainAlias)
                        this.aliases.splice(this.aliases.indexOf(this.mainAlias));
                    // set new main alias
                    this.mainAlias = alias;
                    return alias;
                };
                /**
                 * Creates a new alias and adds it to the current expression map.
                 */
                QueryExpressionMap.prototype.createAlias = function (options) {
                    var aliasName = options.name;
                    if (!aliasName && options.tablePath)
                        aliasName = options.tablePath;
                    if (!aliasName && options.target instanceof Function)
                        aliasName = options.target.name;
                    if (!aliasName && typeof options.target === "string")
                        aliasName = options.target;
                    var alias = new Alias_1.Alias();
                    alias.type = options.type;
                    if (aliasName)
                        alias.name = aliasName;
                    if (options.metadata)
                        alias.metadata = options.metadata;
                    if (options.target && !alias.hasMetadata)
                        alias.metadata = this.connection.getMetadata(options.target);
                    if (options.tablePath)
                        alias.tablePath = options.tablePath;
                    if (options.subQuery)
                        alias.subQuery = options.subQuery;
                    this.aliases.push(alias);
                    return alias;
                };
                /**
                 * Finds alias with the given name.
                 * If alias was not found it throw an exception.
                 */
                QueryExpressionMap.prototype.findAliasByName = function (aliasName) {
                    var alias = this.aliases.find(function (alias) { return alias.name === aliasName; });
                    if (!alias)
                        throw new Error("\"" + aliasName + "\" alias was not found. Maybe you forgot to join it?");
                    return alias;
                };
                QueryExpressionMap.prototype.findColumnByAliasExpression = function (aliasExpression) {
                    var _a = aliasExpression.split("."), aliasName = _a[0], propertyPath = _a[1];
                    var alias = this.findAliasByName(aliasName);
                    return alias.metadata.findColumnWithPropertyName(propertyPath);
                };
                Object.defineProperty(QueryExpressionMap.prototype, "relationMetadata", {
                    /**
                     * Gets relation metadata of the relation this query builder works with.
                     *
                     * todo: add proper exceptions
                     */
                    get: function () {
                        if (!this.mainAlias)
                            throw new Error("Entity to work with is not specified!"); // todo: better message
                        var relationMetadata = this.mainAlias.metadata.findRelationWithPropertyPath(this.relationPropertyPath);
                        if (!relationMetadata)
                            throw new Error("Relation " + this.relationPropertyPath + " was not found in entity " + this.mainAlias.name); // todo: better message
                        return relationMetadata;
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Copies all properties of the current QueryExpressionMap into a new one.
                 * Useful when QueryBuilder needs to create a copy of itself.
                 */
                QueryExpressionMap.prototype.clone = function () {
                    var _this = this;
                    var map = new QueryExpressionMap(this.connection);
                    map.queryType = this.queryType;
                    map.selects = this.selects.map(function (select) { return select; });
                    this.aliases.forEach(function (alias) { return map.aliases.push(new Alias_1.Alias(alias)); });
                    map.mainAlias = this.mainAlias;
                    map.valuesSet = this.valuesSet;
                    map.returning = this.returning;
                    map.onConflict = this.onConflict;
                    map.joinAttributes = this.joinAttributes.map(function (join) { return new JoinAttribute_1.JoinAttribute(_this.connection, _this, join); });
                    map.relationIdAttributes = this.relationIdAttributes.map(function (relationId) { return new RelationIdAttribute_1.RelationIdAttribute(_this, relationId); });
                    map.relationCountAttributes = this.relationCountAttributes.map(function (relationCount) { return new RelationCountAttribute_1.RelationCountAttribute(_this, relationCount); });
                    map.wheres = this.wheres.map(function (where) { return (__assign({}, where)); });
                    map.havings = this.havings.map(function (having) { return (__assign({}, having)); });
                    map.orderBys = Object.assign({}, this.orderBys);
                    map.groupBys = this.groupBys.map(function (groupBy) { return groupBy; });
                    map.limit = this.limit;
                    map.offset = this.offset;
                    map.skip = this.skip;
                    map.take = this.take;
                    map.lockMode = this.lockMode;
                    map.lockVersion = this.lockVersion;
                    map.parameters = Object.assign({}, this.parameters);
                    map.disableEscaping = this.disableEscaping;
                    map.ignoreParentTablesJoins = this.ignoreParentTablesJoins;
                    map.enableRelationIdValues = this.enableRelationIdValues;
                    map.extraAppendedAndWhereCondition = this.extraAppendedAndWhereCondition;
                    map.subQuery = this.subQuery;
                    map.aliasNamePrefixingEnabled = this.aliasNamePrefixingEnabled;
                    map.cache = this.cache;
                    map.cacheId = this.cacheId;
                    map.cacheDuration = this.cacheDuration;
                    map.relationPropertyPath = this.relationPropertyPath;
                    map.of = this.of;
                    return map;
                };
                return QueryExpressionMap;
            }());
            exports_130("QueryExpressionMap", QueryExpressionMap);
        }
    };
});
System.register("typeorm/query-builder/relation-id/RelationIdAttribute", ["typeorm/query-builder/QueryBuilderUtils"], function (exports_131, context_131) {
    "use strict";
    var __moduleName = context_131 && context_131.id;
    var QueryBuilderUtils_3, RelationIdAttribute;
    return {
        setters: [
            function (QueryBuilderUtils_3_1) {
                QueryBuilderUtils_3 = QueryBuilderUtils_3_1;
            }
        ],
        execute: function () {
            /**
             * Stores all join relation id attributes which will be used to build a JOIN query.
             */
            RelationIdAttribute = /** @class */ (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function RelationIdAttribute(queryExpressionMap, relationIdAttribute) {
                    this.queryExpressionMap = queryExpressionMap;
                    /**
                     * Indicates if relation id should NOT be loaded as id map.
                     */
                    this.disableMixedMap = false;
                    Object.assign(this, relationIdAttribute || {});
                }
                Object.defineProperty(RelationIdAttribute.prototype, "joinInverseSideMetadata", {
                    // -------------------------------------------------------------------------
                    // Public Methods
                    // -------------------------------------------------------------------------
                    get: function () {
                        return this.relation.inverseEntityMetadata;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(RelationIdAttribute.prototype, "parentAlias", {
                    /**
                     * Alias of the parent of this join.
                     * For example, if we join ("post.category", "categoryAlias") then "post" is a parent alias.
                     * This value is extracted from entityOrProperty value.
                     * This is available when join was made using "post.category" syntax.
                     */
                    get: function () {
                        if (!QueryBuilderUtils_3.QueryBuilderUtils.isAliasProperty(this.relationName))
                            throw new Error("Given value must be a string representation of alias property");
                        return this.relationName.substr(0, this.relationName.indexOf("."));
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(RelationIdAttribute.prototype, "relationPropertyPath", {
                    /**
                     * Relation property name of the parent.
                     * This is used to understand what is joined.
                     * For example, if we join ("post.category", "categoryAlias") then "category" is a relation property.
                     * This value is extracted from entityOrProperty value.
                     * This is available when join was made using "post.category" syntax.
                     */
                    get: function () {
                        if (!QueryBuilderUtils_3.QueryBuilderUtils.isAliasProperty(this.relationName))
                            throw new Error("Given value must be a string representation of alias property");
                        return this.relationName.substr(this.relationName.indexOf(".") + 1);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(RelationIdAttribute.prototype, "relation", {
                    /**
                     * Relation of the parent.
                     * This is used to understand what is joined.
                     * This is available when join was made using "post.category" syntax.
                     */
                    get: function () {
                        if (!QueryBuilderUtils_3.QueryBuilderUtils.isAliasProperty(this.relationName))
                            throw new Error("Given value must be a string representation of alias property");
                        var relationOwnerSelection = this.queryExpressionMap.findAliasByName(this.parentAlias);
                        var relation = relationOwnerSelection.metadata.findRelationWithPropertyPath(this.relationPropertyPath);
                        if (!relation)
                            throw new Error("Relation with property path " + this.relationPropertyPath + " in entity was not found.");
                        return relation;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(RelationIdAttribute.prototype, "junctionAlias", {
                    /**
                     * Generates alias of junction table, whose ids we get.
                     */
                    get: function () {
                        var _a = this.relationName.split("."), parentAlias = _a[0], relationProperty = _a[1];
                        return parentAlias + "_" + relationProperty + "_relation_id";
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(RelationIdAttribute.prototype, "junctionMetadata", {
                    /**
                     * Metadata of the joined entity.
                     * If extra condition without entity was joined, then it will return undefined.
                     */
                    get: function () {
                        return this.relation.junctionEntityMetadata;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(RelationIdAttribute.prototype, "mapToPropertyParentAlias", {
                    get: function () {
                        return this.mapToProperty.substr(0, this.mapToProperty.indexOf("."));
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(RelationIdAttribute.prototype, "mapToPropertyPropertyPath", {
                    get: function () {
                        return this.mapToProperty.substr(this.mapToProperty.indexOf(".") + 1);
                    },
                    enumerable: true,
                    configurable: true
                });
                return RelationIdAttribute;
            }());
            exports_131("RelationIdAttribute", RelationIdAttribute);
        }
    };
});
System.register("typeorm/query-builder/relation-id/RelationIdLoadResult", [], function (exports_132, context_132) {
    "use strict";
    var __moduleName = context_132 && context_132.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/query-builder/relation-count/RelationCountLoadResult", [], function (exports_133, context_133) {
    "use strict";
    var __moduleName = context_133 && context_133.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/query-builder/transformer/RawSqlResultsToEntityTransformer", ["typeorm/util/OrmUtils"], function (exports_134, context_134) {
    "use strict";
    var __moduleName = context_134 && context_134.id;
    var OrmUtils_7, RawSqlResultsToEntityTransformer;
    return {
        setters: [
            function (OrmUtils_7_1) {
                OrmUtils_7 = OrmUtils_7_1;
            }
        ],
        execute: function () {
            /**
             * Transforms raw sql results returned from the database into entity object.
             * Entity is constructed based on its entity metadata.
             */
            RawSqlResultsToEntityTransformer = /** @class */ (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function RawSqlResultsToEntityTransformer(expressionMap, driver, rawRelationIdResults, rawRelationCountResults) {
                    this.expressionMap = expressionMap;
                    this.driver = driver;
                    this.rawRelationIdResults = rawRelationIdResults;
                    this.rawRelationCountResults = rawRelationCountResults;
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Since db returns a duplicated rows of the data where accuracies of the same object can be duplicated
                 * we need to group our result and we must have some unique id (primary key in our case)
                 */
                RawSqlResultsToEntityTransformer.prototype.transform = function (rawResults, alias) {
                    var _this = this;
                    var group = this.group(rawResults, alias);
                    var entities = [];
                    group.forEach(function (results) {
                        var entity = _this.transformRawResultsGroup(results, alias);
                        if (entity !== undefined)
                            entities.push(entity);
                    });
                    return entities;
                };
                // -------------------------------------------------------------------------
                // Protected Methods
                // -------------------------------------------------------------------------
                /**
                 * Groups given raw results by ids of given alias.
                 */
                RawSqlResultsToEntityTransformer.prototype.group = function (rawResults, alias) {
                    var map = new Map();
                    var keys = alias.metadata.primaryColumns.map(function (column) { return alias.name + "_" + column.databaseName; });
                    rawResults.forEach(function (rawResult) {
                        var id = keys.map(function (key) { return rawResult[key]; }).join("_"); // todo: check partial
                        if (!id)
                            return;
                        var items = map.get(id);
                        if (!items) {
                            map.set(id, [rawResult]);
                        }
                        else {
                            items.push(rawResult);
                        }
                    });
                    return map;
                };
                /**
                 * Transforms set of data results into single entity.
                 */
                RawSqlResultsToEntityTransformer.prototype.transformRawResultsGroup = function (rawResults, alias) {
                    var hasColumns = false, hasEmbeddedColumns = false, hasParentColumns = false, hasParentEmbeddedColumns = false, hasRelations = false, hasRelationIds = false, hasRelationCounts = false;
                    var entity = alias.metadata.create();
                    if (alias.metadata.discriminatorColumn) {
                        var discriminatorValues_1 = rawResults.map(function (result) { return result[alias.name + "_" + alias.metadata.discriminatorColumn.databaseName]; });
                        var metadata = alias.metadata.childEntityMetadatas.find(function (childEntityMetadata) {
                            return !!discriminatorValues_1.find(function (value) { return value === childEntityMetadata.discriminatorValue; });
                        });
                        if (metadata)
                            entity = metadata.create();
                    }
                    // get value from columns selections and put them into newly created entity
                    hasColumns = this.transformColumns(rawResults, alias, entity, alias.metadata);
                    hasRelations = this.transformJoins(rawResults, entity, alias);
                    hasRelationIds = this.transformRelationIds(rawResults, alias, entity);
                    hasRelationCounts = this.transformRelationCounts(rawResults, alias, entity);
                    // this.removeVirtualColumns(entity, alias);
                    return (hasColumns || hasEmbeddedColumns || hasParentColumns || hasParentEmbeddedColumns || hasRelations || hasRelationIds || hasRelationCounts) ? entity : undefined;
                };
                // get value from columns selections and put them into object
                RawSqlResultsToEntityTransformer.prototype.transformColumns = function (rawResults, alias, entity, metadata) {
                    var _this = this;
                    var hasData = false;
                    metadata.columns.forEach(function (column) {
                        var value = rawResults[0][alias.name + "_" + column.databaseName];
                        if (value === undefined || column.isVirtual || column.isParentId || column.isDiscriminator)
                            return;
                        // if user does not selected the whole entity or he used partial selection and does not select this particular column
                        // then we don't add this column and its value into the entity
                        if (!_this.expressionMap.selects.find(function (select) { return select.selection === alias.name || select.selection === alias.name + "." + column.propertyName; }))
                            return;
                        column.setEntityValue(entity, _this.driver.prepareHydratedValue(value, column));
                        if (value !== null) // we don't mark it as has data because if we will have all nulls in our object - we don't need such object
                            hasData = true;
                    });
                    if (alias.metadata.parentEntityMetadata) {
                        alias.metadata.parentEntityMetadata.columns.forEach(function (column) {
                            var value = rawResults[0]["parentIdColumn_" + alias.metadata.parentEntityMetadata.tableName + "_" + column.databaseName];
                            if (value === undefined || column.isVirtual || column.isParentId || column.isDiscriminator)
                                return;
                            column.setEntityValue(entity, _this.driver.prepareHydratedValue(value, column));
                            if (value !== null) // we don't mark it as has data because if we will have all nulls in our object - we don't need such object
                                hasData = true;
                        });
                    }
                    return hasData;
                };
                /**
                 * Transforms joined entities in the given raw results by a given alias and stores to the given (parent) entity
                 */
                RawSqlResultsToEntityTransformer.prototype.transformJoins = function (rawResults, entity, alias) {
                    var _this = this;
                    var hasData = false;
                    var discriminatorValue = "";
                    if (alias.metadata.discriminatorColumn)
                        discriminatorValue = rawResults[0][alias.name + "_" + alias.metadata.discriminatorColumn.databaseName];
                    this.expressionMap.joinAttributes.forEach(function (join) {
                        // skip joins without metadata
                        if (!join.metadata)
                            return;
                        // this check need to avoid setting properties than not belong to entity when single table inheritance used.
                        var metadata = alias.metadata.childEntityMetadatas.find(function (childEntityMetadata) { return discriminatorValue === childEntityMetadata.discriminatorValue; });
                        if (metadata && join.relation && metadata.target !== join.relation.target)
                            return;
                        // some checks to make sure this join is for current alias
                        if (join.mapToProperty) {
                            if (join.mapToPropertyParentAlias !== alias.name)
                                return;
                        }
                        else {
                            if (!join.relation || join.parentAlias !== alias.name || join.relationPropertyPath !== join.relation.propertyPath)
                                return;
                        }
                        // transform joined data into entities
                        var mappedEntities = _this.transform(rawResults, join.alias);
                        var result = !join.isMany ? mappedEntities[0] : mappedEntities;
                        if (!result) // if nothing was joined then simply return
                            return;
                        // if join was mapped to some property then save result to that property
                        if (join.mapToPropertyPropertyName) {
                            entity[join.mapToPropertyPropertyName] = result; // todo: fix embeds
                        }
                        else { // otherwise set to relation
                            join.relation.setEntityValue(entity, result);
                        }
                        hasData = true;
                    });
                    return hasData;
                };
                RawSqlResultsToEntityTransformer.prototype.transformRelationIds = function (rawSqlResults, alias, entity) {
                    var _this = this;
                    var hasData = false;
                    this.rawRelationIdResults.forEach(function (rawRelationIdResult) {
                        if (rawRelationIdResult.relationIdAttribute.parentAlias !== alias.name)
                            return;
                        var relation = rawRelationIdResult.relationIdAttribute.relation;
                        var valueMap = _this.createValueMapFromJoinColumns(relation, rawRelationIdResult.relationIdAttribute.parentAlias, rawSqlResults);
                        if (valueMap === undefined || valueMap === null)
                            return;
                        var idMaps = rawRelationIdResult.results.map(function (result) {
                            var entityPrimaryIds = _this.extractEntityPrimaryIds(relation, result);
                            if (!alias.metadata.compareIds(entityPrimaryIds, valueMap))
                                return;
                            var columns;
                            if (relation.isManyToOne || relation.isOneToOneOwner) {
                                columns = relation.joinColumns.map(function (joinColumn) { return joinColumn; });
                            }
                            else if (relation.isOneToMany || relation.isOneToOneNotOwner) {
                                columns = relation.inverseEntityMetadata.primaryColumns.map(function (joinColumn) { return joinColumn; });
                            }
                            else { // ManyToMany
                                if (relation.isOwning) {
                                    columns = relation.inverseJoinColumns.map(function (joinColumn) { return joinColumn; });
                                }
                                else {
                                    columns = relation.inverseRelation.joinColumns.map(function (joinColumn) { return joinColumn; });
                                }
                            }
                            // const idMapColumns = (relation.isOneToMany || relation.isOneToOneNotOwner) ? columns : columns.map(column => column.referencedColumn!);
                            // const idMap = idMapColumns.reduce((idMap, column) => {
                            //     return OrmUtils.mergeDeep(idMap, column.createValueMap(result[column.databaseName]));
                            // }, {} as ObjectLiteral); // need to create reusable function for this process
                            var idMap = columns.reduce(function (idMap, column) {
                                if (relation.isOneToMany || relation.isOneToOneNotOwner) {
                                    return OrmUtils_7.OrmUtils.mergeDeep(idMap, column.createValueMap(result[column.databaseName]));
                                }
                                else {
                                    return OrmUtils_7.OrmUtils.mergeDeep(idMap, column.referencedColumn.createValueMap(result[column.databaseName]));
                                }
                            }, {});
                            if (columns.length === 1 && rawRelationIdResult.relationIdAttribute.disableMixedMap === false) {
                                if (relation.isOneToMany || relation.isOneToOneNotOwner) {
                                    return columns[0].getEntityValue(idMap);
                                }
                                else {
                                    return columns[0].referencedColumn.getEntityValue(idMap);
                                }
                            }
                            return idMap;
                        }).filter(function (result) { return result; });
                        var properties = rawRelationIdResult.relationIdAttribute.mapToPropertyPropertyPath.split(".");
                        var mapToProperty = function (properties, map, value) {
                            var property = properties.shift();
                            if (property && properties.length === 0) {
                                map[property] = value;
                                return map;
                            }
                            else if (property && properties.length > 0) {
                                mapToProperty(properties, map[property], value);
                            }
                            else {
                                return map;
                            }
                        };
                        if (relation.isOneToOne || relation.isManyToOne) {
                            if (idMaps[0] !== undefined) {
                                mapToProperty(properties, entity, idMaps[0]);
                                hasData = true;
                            }
                        }
                        else {
                            mapToProperty(properties, entity, idMaps);
                            if (idMaps.length > 0) {
                                hasData = true;
                            }
                        }
                    });
                    return hasData;
                };
                RawSqlResultsToEntityTransformer.prototype.transformRelationCounts = function (rawSqlResults, alias, entity) {
                    var hasData = false;
                    this.rawRelationCountResults
                        .filter(function (rawRelationCountResult) { return rawRelationCountResult.relationCountAttribute.parentAlias === alias.name; })
                        .forEach(function (rawRelationCountResult) {
                        var relation = rawRelationCountResult.relationCountAttribute.relation;
                        var referenceColumnName;
                        if (relation.isOneToMany) {
                            referenceColumnName = relation.inverseRelation.joinColumns[0].referencedColumn.databaseName; // todo: fix joinColumns[0]
                        }
                        else {
                            referenceColumnName = relation.isOwning ? relation.joinColumns[0].referencedColumn.databaseName : relation.inverseRelation.joinColumns[0].referencedColumn.databaseName;
                        }
                        var referenceColumnValue = rawSqlResults[0][alias.name + "_" + referenceColumnName]; // we use zero index since its grouped data // todo: selection with alias for entity columns wont work
                        if (referenceColumnValue !== undefined && referenceColumnValue !== null) {
                            entity[rawRelationCountResult.relationCountAttribute.mapToPropertyPropertyName] = 0;
                            rawRelationCountResult.results
                                .filter(function (result) { return result["parentId"] === referenceColumnValue; })
                                .forEach(function (result) {
                                entity[rawRelationCountResult.relationCountAttribute.mapToPropertyPropertyName] = parseInt(result["cnt"]);
                                hasData = true;
                            });
                        }
                    });
                    return hasData;
                };
                RawSqlResultsToEntityTransformer.prototype.createValueMapFromJoinColumns = function (relation, parentAlias, rawSqlResults) {
                    var columns;
                    if (relation.isManyToOne || relation.isOneToOneOwner) {
                        columns = relation.entityMetadata.primaryColumns.map(function (joinColumn) { return joinColumn; });
                    }
                    else if (relation.isOneToMany || relation.isOneToOneNotOwner) {
                        columns = relation.inverseRelation.joinColumns.map(function (joinColumn) { return joinColumn; });
                    }
                    else {
                        if (relation.isOwning) {
                            columns = relation.joinColumns.map(function (joinColumn) { return joinColumn; });
                        }
                        else {
                            columns = relation.inverseRelation.inverseJoinColumns.map(function (joinColumn) { return joinColumn; });
                        }
                    }
                    return columns.reduce(function (valueMap, column) {
                        rawSqlResults.forEach(function (rawSqlResult) {
                            if (relation.isManyToOne || relation.isOneToOneOwner) {
                                valueMap[column.databaseName] = rawSqlResult[parentAlias + "_" + column.databaseName];
                            }
                            else {
                                valueMap[column.databaseName] = rawSqlResult[parentAlias + "_" + column.referencedColumn.databaseName];
                            }
                        });
                        return valueMap;
                    }, {});
                };
                RawSqlResultsToEntityTransformer.prototype.extractEntityPrimaryIds = function (relation, relationIdRawResult) {
                    var columns;
                    if (relation.isManyToOne || relation.isOneToOneOwner) {
                        columns = relation.entityMetadata.primaryColumns.map(function (joinColumn) { return joinColumn; });
                    }
                    else if (relation.isOneToMany || relation.isOneToOneNotOwner) {
                        columns = relation.inverseRelation.joinColumns.map(function (joinColumn) { return joinColumn; });
                    }
                    else {
                        if (relation.isOwning) {
                            columns = relation.joinColumns.map(function (joinColumn) { return joinColumn; });
                        }
                        else {
                            columns = relation.inverseRelation.inverseJoinColumns.map(function (joinColumn) { return joinColumn; });
                        }
                    }
                    return columns.reduce(function (data, column) {
                        data[column.databaseName] = relationIdRawResult[column.databaseName];
                        return data;
                    }, {});
                };
                return RawSqlResultsToEntityTransformer;
            }());
            exports_134("RawSqlResultsToEntityTransformer", RawSqlResultsToEntityTransformer);
        }
    };
});
System.register("typeorm/error/PessimisticLockTransactionRequiredError", [], function (exports_135, context_135) {
    "use strict";
    var __moduleName = context_135 && context_135.id;
    var PessimisticLockTransactionRequiredError;
    return {
        setters: [],
        execute: function () {
            /**
             * Thrown when a transaction is required for the current operation, but there is none open.
             */
            PessimisticLockTransactionRequiredError = /** @class */ (function (_super) {
                __extends(PessimisticLockTransactionRequiredError, _super);
                function PessimisticLockTransactionRequiredError() {
                    var _this = _super.call(this) || this;
                    _this.name = "PessimisticLockTransactionRequiredError";
                    Object.setPrototypeOf(_this, PessimisticLockTransactionRequiredError.prototype);
                    _this.message = "An open transaction is required for pessimistic lock.";
                    return _this;
                }
                return PessimisticLockTransactionRequiredError;
            }(Error));
            exports_135("PessimisticLockTransactionRequiredError", PessimisticLockTransactionRequiredError);
        }
    };
});
System.register("typeorm/error/NoVersionOrUpdateDateColumnError", [], function (exports_136, context_136) {
    "use strict";
    var __moduleName = context_136 && context_136.id;
    var NoVersionOrUpdateDateColumnError;
    return {
        setters: [],
        execute: function () {
            /**
             * Thrown when an entity does not have no version and no update date column.
             */
            NoVersionOrUpdateDateColumnError = /** @class */ (function (_super) {
                __extends(NoVersionOrUpdateDateColumnError, _super);
                function NoVersionOrUpdateDateColumnError(entity) {
                    var _this = _super.call(this) || this;
                    _this.name = "NoVersionOrUpdateDateColumnError";
                    Object.setPrototypeOf(_this, NoVersionOrUpdateDateColumnError.prototype);
                    _this.message = "Entity " + entity + " does not have version or update date columns.";
                    return _this;
                }
                return NoVersionOrUpdateDateColumnError;
            }(Error));
            exports_136("NoVersionOrUpdateDateColumnError", NoVersionOrUpdateDateColumnError);
        }
    };
});
System.register("typeorm/error/OptimisticLockVersionMismatchError", [], function (exports_137, context_137) {
    "use strict";
    var __moduleName = context_137 && context_137.id;
    var OptimisticLockVersionMismatchError;
    return {
        setters: [],
        execute: function () {
            /**
             * Thrown when a version check on an object that uses optimistic locking through a version field fails.
             */
            OptimisticLockVersionMismatchError = /** @class */ (function (_super) {
                __extends(OptimisticLockVersionMismatchError, _super);
                function OptimisticLockVersionMismatchError(entity, expectedVersion, actualVersion) {
                    var _this = _super.call(this) || this;
                    _this.name = "OptimisticLockVersionMismatchError";
                    Object.setPrototypeOf(_this, OptimisticLockVersionMismatchError.prototype);
                    _this.message = "The optimistic lock on entity " + entity + " failed, version " + expectedVersion + " was expected, but is actually " + actualVersion + ".";
                    return _this;
                }
                return OptimisticLockVersionMismatchError;
            }(Error));
            exports_137("OptimisticLockVersionMismatchError", OptimisticLockVersionMismatchError);
        }
    };
});
System.register("typeorm/error/OptimisticLockCanNotBeUsedError", [], function (exports_138, context_138) {
    "use strict";
    var __moduleName = context_138 && context_138.id;
    var OptimisticLockCanNotBeUsedError;
    return {
        setters: [],
        execute: function () {
            /**
             * Thrown when an optimistic lock cannot be used in query builder.
             */
            OptimisticLockCanNotBeUsedError = /** @class */ (function (_super) {
                __extends(OptimisticLockCanNotBeUsedError, _super);
                function OptimisticLockCanNotBeUsedError() {
                    var _this = _super.call(this) || this;
                    _this.name = "OptimisticLockCanNotBeUsedError";
                    Object.setPrototypeOf(_this, OptimisticLockCanNotBeUsedError.prototype);
                    _this.message = "The optimistic lock can be used only with getOne() method.";
                    return _this;
                }
                return OptimisticLockCanNotBeUsedError;
            }(Error));
            exports_138("OptimisticLockCanNotBeUsedError", OptimisticLockCanNotBeUsedError);
        }
    };
});
System.register("typeorm/query-builder/relation-id/RelationIdLoader", [], function (exports_139, context_139) {
    "use strict";
    var __moduleName = context_139 && context_139.id;
    var RelationIdLoader;
    return {
        setters: [],
        execute: function () {
            RelationIdLoader = /** @class */ (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function RelationIdLoader(connection, queryRunner, relationIdAttributes) {
                    this.connection = connection;
                    this.queryRunner = queryRunner;
                    this.relationIdAttributes = relationIdAttributes;
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                RelationIdLoader.prototype.load = function (rawEntities) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var promises;
                        return __generator(this, function (_a) {
                            promises = this.relationIdAttributes.map(function (relationIdAttr) { return __awaiter(_this, void 0, void 0, function () {
                                var results, relation, joinColumns_1, table, tableName, tableAlias_1, parameters_4, condition, qb_1, _a, relation, joinColumns_2, inverseJoinColumns, junctionAlias_1, inverseSideTableName, inverseSideTableAlias_1, junctionTableName, mappedColumns, parameters_5, joinColumnConditions, inverseJoinColumnCondition_1, condition, qb_2, _b;
                                return __generator(this, function (_c) {
                                    switch (_c.label) {
                                        case 0:
                                            if (!(relationIdAttr.relation.isManyToOne || relationIdAttr.relation.isOneToOneOwner)) return [3 /*break*/, 1];
                                            // example: Post and Tag
                                            // loadRelationIdAndMap("post.tagId", "post.tag")
                                            // we expect it to load id of tag
                                            if (relationIdAttr.queryBuilderFactory)
                                                throw new Error("Additional condition can not be used with ManyToOne or OneToOne owner relations.");
                                            results = rawEntities.map(function (rawEntity) {
                                                var result = {};
                                                relationIdAttr.relation.joinColumns.forEach(function (joinColumn) {
                                                    result[joinColumn.databaseName] = rawEntity[relationIdAttr.parentAlias + "_" + joinColumn.databaseName];
                                                });
                                                relationIdAttr.relation.entityMetadata.primaryColumns.forEach(function (primaryColumn) {
                                                    result[primaryColumn.databaseName] = rawEntity[relationIdAttr.parentAlias + "_" + primaryColumn.databaseName];
                                                });
                                                return result;
                                            });
                                            return [2 /*return*/, {
                                                    relationIdAttribute: relationIdAttr,
                                                    results: results
                                                }];
                                        case 1:
                                            if (!(relationIdAttr.relation.isOneToMany || relationIdAttr.relation.isOneToOneNotOwner)) return [3 /*break*/, 3];
                                            relation = relationIdAttr.relation;
                                            joinColumns_1 = relation.isOwning ? relation.joinColumns : relation.inverseRelation.joinColumns;
                                            table = relation.inverseEntityMetadata.target;
                                            tableName = relation.inverseEntityMetadata.tableName;
                                            tableAlias_1 = relationIdAttr.alias || tableName;
                                            parameters_4 = {};
                                            condition = rawEntities.map(function (rawEntity, index) {
                                                return joinColumns_1.map(function (joinColumn) {
                                                    var parameterName = joinColumn.databaseName + index;
                                                    parameters_4[parameterName] = rawEntity[relationIdAttr.parentAlias + "_" + joinColumn.referencedColumn.databaseName];
                                                    return tableAlias_1 + "." + joinColumn.propertyPath + " = :" + parameterName;
                                                }).join(" AND ");
                                            }).map(function (condition) { return "(" + condition + ")"; })
                                                .join(" OR ");
                                            // ensure we won't perform redundant queries for joined data which was not found in selection
                                            // example: if post.category was not found in db then no need to execute query for category.imageIds
                                            if (!condition)
                                                return [2 /*return*/, { relationIdAttribute: relationIdAttr, results: [] }];
                                            qb_1 = this.connection.createQueryBuilder(this.queryRunner);
                                            joinColumns_1.forEach(function (joinColumn) {
                                                qb_1.addSelect(tableAlias_1 + "." + joinColumn.propertyPath, joinColumn.databaseName);
                                            });
                                            relation.inverseRelation.entityMetadata.primaryColumns.forEach(function (primaryColumn) {
                                                qb_1.addSelect(tableAlias_1 + "." + primaryColumn.propertyPath, primaryColumn.databaseName);
                                            });
                                            qb_1.from(table, tableAlias_1)
                                                .where("(" + condition + ")") // need brackets because if we have additional condition and no brackets, it looks like (a = 1) OR (a = 2) AND b = 1, that is incorrect
                                                .setParameters(parameters_4);
                                            // apply condition (custom query builder factory)
                                            if (relationIdAttr.queryBuilderFactory)
                                                relationIdAttr.queryBuilderFactory(qb_1);
                                            _a = {
                                                relationIdAttribute: relationIdAttr
                                            };
                                            return [4 /*yield*/, qb_1.getRawMany()];
                                        case 2: return [2 /*return*/, (_a.results = _c.sent(),
                                                _a)];
                                        case 3:
                                            relation = relationIdAttr.relation;
                                            joinColumns_2 = relation.isOwning ? relation.joinColumns : relation.inverseRelation.inverseJoinColumns;
                                            inverseJoinColumns = relation.isOwning ? relation.inverseJoinColumns : relation.inverseRelation.joinColumns;
                                            junctionAlias_1 = relationIdAttr.junctionAlias;
                                            inverseSideTableName = relationIdAttr.joinInverseSideMetadata.tableName;
                                            inverseSideTableAlias_1 = relationIdAttr.alias || inverseSideTableName;
                                            junctionTableName = relation.isOwning ? relation.junctionEntityMetadata.tableName : relation.inverseRelation.junctionEntityMetadata.tableName;
                                            mappedColumns = rawEntities.map(function (rawEntity) {
                                                return joinColumns_2.reduce(function (map, joinColumn) {
                                                    map[joinColumn.propertyPath] = rawEntity[relationIdAttr.parentAlias + "_" + joinColumn.referencedColumn.databaseName];
                                                    return map;
                                                }, {});
                                            });
                                            // ensure we won't perform redundant queries for joined data which was not found in selection
                                            // example: if post.category was not found in db then no need to execute query for category.imageIds
                                            if (mappedColumns.length === 0)
                                                return [2 /*return*/, { relationIdAttribute: relationIdAttr, results: [] }];
                                            parameters_5 = {};
                                            joinColumnConditions = mappedColumns.map(function (mappedColumn, index) {
                                                return Object.keys(mappedColumn).map(function (key) {
                                                    var parameterName = key + index;
                                                    parameters_5[parameterName] = mappedColumn[key];
                                                    return junctionAlias_1 + "." + key + " = :" + parameterName;
                                                }).join(" AND ");
                                            });
                                            inverseJoinColumnCondition_1 = inverseJoinColumns.map(function (joinColumn) {
                                                return junctionAlias_1 + "." + joinColumn.propertyPath + " = " + inverseSideTableAlias_1 + "." + joinColumn.referencedColumn.propertyPath;
                                            }).join(" AND ");
                                            condition = joinColumnConditions.map(function (condition) {
                                                return "(" + condition + " AND " + inverseJoinColumnCondition_1 + ")";
                                            }).join(" OR ");
                                            qb_2 = this.connection.createQueryBuilder(this.queryRunner);
                                            inverseJoinColumns.forEach(function (joinColumn) {
                                                qb_2.addSelect(junctionAlias_1 + "." + joinColumn.propertyPath, joinColumn.databaseName)
                                                    .addOrderBy(junctionAlias_1 + "." + joinColumn.propertyPath);
                                            });
                                            joinColumns_2.forEach(function (joinColumn) {
                                                qb_2.addSelect(junctionAlias_1 + "." + joinColumn.propertyPath, joinColumn.databaseName)
                                                    .addOrderBy(junctionAlias_1 + "." + joinColumn.propertyPath);
                                            });
                                            qb_2.from(inverseSideTableName, inverseSideTableAlias_1)
                                                .innerJoin(junctionTableName, junctionAlias_1, condition)
                                                .setParameters(parameters_5);
                                            // apply condition (custom query builder factory)
                                            if (relationIdAttr.queryBuilderFactory)
                                                relationIdAttr.queryBuilderFactory(qb_2);
                                            _b = {
                                                relationIdAttribute: relationIdAttr
                                            };
                                            return [4 /*yield*/, qb_2.getRawMany()];
                                        case 4: return [2 /*return*/, (_b.results = _c.sent(),
                                                _b)];
                                    }
                                });
                            }); });
                            return [2 /*return*/, Promise.all(promises)];
                        });
                    });
                };
                return RelationIdLoader;
            }());
            exports_139("RelationIdLoader", RelationIdLoader);
        }
    };
});
System.register("typeorm/query-builder/relation-id/RelationIdMetadataToAttributeTransformer", ["typeorm/query-builder/relation-id/RelationIdAttribute"], function (exports_140, context_140) {
    "use strict";
    var __moduleName = context_140 && context_140.id;
    var RelationIdAttribute_2, RelationIdMetadataToAttributeTransformer;
    return {
        setters: [
            function (RelationIdAttribute_2_1) {
                RelationIdAttribute_2 = RelationIdAttribute_2_1;
            }
        ],
        execute: function () {
            RelationIdMetadataToAttributeTransformer = /** @class */ (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function RelationIdMetadataToAttributeTransformer(expressionMap) {
                    this.expressionMap = expressionMap;
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                RelationIdMetadataToAttributeTransformer.prototype.transform = function () {
                    // by example:
                    // post has relation id:
                    // @RelationId(post => post.categories) categoryIds
                    // category has relation id
                    // @RelationId(category => category.images) imageIds
                    // we load post and join category
                    // we expect post.categoryIds and post.category.imageIds to have relation ids
                    var _this = this;
                    // first create relation id attributes for all relation id metadatas of the main selected object (post from example)
                    if (this.expressionMap.mainAlias) {
                        this.expressionMap.mainAlias.metadata.relationIds.forEach(function (relationId) {
                            var attribute = _this.metadataToAttribute(_this.expressionMap.mainAlias.name, relationId);
                            _this.expressionMap.relationIdAttributes.push(attribute);
                        });
                    }
                    // second create relation id attributes for all relation id metadatas of all joined objects (category from example)
                    this.expressionMap.joinAttributes.forEach(function (join) {
                        // ensure this join has a metadata, because relation id can only work for real orm entities
                        if (!join.metadata || join.metadata.isJunction)
                            return;
                        join.metadata.relationIds.forEach(function (relationId) {
                            var attribute = _this.metadataToAttribute(join.alias.name, relationId);
                            _this.expressionMap.relationIdAttributes.push(attribute);
                        });
                    });
                };
                // -------------------------------------------------------------------------
                // Private Methods
                // -------------------------------------------------------------------------
                RelationIdMetadataToAttributeTransformer.prototype.metadataToAttribute = function (parentAliasName, relationId) {
                    return new RelationIdAttribute_2.RelationIdAttribute(this.expressionMap, {
                        relationName: parentAliasName + "." + relationId.relation.propertyName,
                        mapToProperty: parentAliasName + "." + relationId.propertyName,
                        alias: relationId.alias,
                        queryBuilderFactory: relationId.queryBuilderFactory
                    });
                };
                return RelationIdMetadataToAttributeTransformer;
            }());
            exports_140("RelationIdMetadataToAttributeTransformer", RelationIdMetadataToAttributeTransformer);
        }
    };
});
System.register("typeorm/query-builder/relation-count/RelationCountLoader", [], function (exports_141, context_141) {
    "use strict";
    var __moduleName = context_141 && context_141.id;
    var RelationCountLoader;
    return {
        setters: [],
        execute: function () {
            RelationCountLoader = /** @class */ (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function RelationCountLoader(connection, queryRunner, relationCountAttributes) {
                    this.connection = connection;
                    this.queryRunner = queryRunner;
                    this.relationCountAttributes = relationCountAttributes;
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                RelationCountLoader.prototype.load = function (rawEntities) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var promises;
                        return __generator(this, function (_a) {
                            promises = this.relationCountAttributes.map(function (relationCountAttr) { return __awaiter(_this, void 0, void 0, function () {
                                var relation, inverseRelation, referenceColumnName_1, inverseSideTable, inverseSideTableName, inverseSideTableAlias, inverseSidePropertyName, referenceColumnValues, qb, _a, joinTableColumnName_1, inverseJoinColumnName, firstJunctionColumn, secondJunctionColumn, referenceColumnValues, junctionAlias, inverseSideTableName, inverseSideTableAlias, junctionTableName, condition, qb, _b;
                                return __generator(this, function (_c) {
                                    switch (_c.label) {
                                        case 0:
                                            if (!relationCountAttr.relation.isOneToMany) return [3 /*break*/, 2];
                                            relation = relationCountAttr.relation;
                                            inverseRelation = relation.inverseRelation;
                                            referenceColumnName_1 = inverseRelation.joinColumns[0].referencedColumn.propertyName;
                                            inverseSideTable = relation.inverseEntityMetadata.target;
                                            inverseSideTableName = relation.inverseEntityMetadata.tableName;
                                            inverseSideTableAlias = relationCountAttr.alias || inverseSideTableName;
                                            inverseSidePropertyName = inverseRelation.propertyName;
                                            referenceColumnValues = rawEntities
                                                .map(function (rawEntity) { return rawEntity[relationCountAttr.parentAlias + "_" + referenceColumnName_1]; })
                                                .filter(function (value) { return !!value; });
                                            // ensure we won't perform redundant queries for joined data which was not found in selection
                                            // example: if post.category was not found in db then no need to execute query for category.imageIds
                                            if (referenceColumnValues.length === 0)
                                                return [2 /*return*/, { relationCountAttribute: relationCountAttr, results: [] }];
                                            qb = this.connection.createQueryBuilder(this.queryRunner);
                                            qb.select(inverseSideTableAlias + "." + inverseSidePropertyName, "parentId")
                                                .addSelect("COUNT(*)", "cnt")
                                                .from(inverseSideTable, inverseSideTableAlias)
                                                .where(inverseSideTableAlias + "." + inverseSidePropertyName + " IN (:ids)")
                                                .addGroupBy(inverseSideTableAlias + "." + inverseSidePropertyName)
                                                .setParameter("ids", referenceColumnValues);
                                            // apply condition (custom query builder factory)
                                            if (relationCountAttr.queryBuilderFactory)
                                                relationCountAttr.queryBuilderFactory(qb);
                                            _a = {
                                                relationCountAttribute: relationCountAttr
                                            };
                                            return [4 /*yield*/, qb.getRawMany()];
                                        case 1: return [2 /*return*/, (_a.results = _c.sent(),
                                                _a)];
                                        case 2:
                                            inverseJoinColumnName = void 0;
                                            firstJunctionColumn = void 0;
                                            secondJunctionColumn = void 0;
                                            if (relationCountAttr.relation.isOwning) { // todo fix joinColumns[0] and inverseJoinColumns[0].
                                                joinTableColumnName_1 = relationCountAttr.relation.joinColumns[0].referencedColumn.databaseName;
                                                inverseJoinColumnName = relationCountAttr.relation.inverseJoinColumns[0].referencedColumn.databaseName;
                                                firstJunctionColumn = relationCountAttr.relation.junctionEntityMetadata.columns[0];
                                                secondJunctionColumn = relationCountAttr.relation.junctionEntityMetadata.columns[1];
                                            }
                                            else {
                                                joinTableColumnName_1 = relationCountAttr.relation.inverseRelation.inverseJoinColumns[0].referencedColumn.databaseName;
                                                inverseJoinColumnName = relationCountAttr.relation.inverseRelation.joinColumns[0].referencedColumn.databaseName;
                                                firstJunctionColumn = relationCountAttr.relation.junctionEntityMetadata.columns[1];
                                                secondJunctionColumn = relationCountAttr.relation.junctionEntityMetadata.columns[0];
                                            }
                                            referenceColumnValues = rawEntities
                                                .map(function (rawEntity) { return rawEntity[relationCountAttr.parentAlias + "_" + joinTableColumnName_1]; })
                                                .filter(function (value) { return value; });
                                            // ensure we won't perform redundant queries for joined data which was not found in selection
                                            // example: if post.category was not found in db then no need to execute query for category.imageIds
                                            if (referenceColumnValues.length === 0)
                                                return [2 /*return*/, { relationCountAttribute: relationCountAttr, results: [] }];
                                            junctionAlias = relationCountAttr.junctionAlias;
                                            inverseSideTableName = relationCountAttr.joinInverseSideMetadata.tableName;
                                            inverseSideTableAlias = relationCountAttr.alias || inverseSideTableName;
                                            junctionTableName = relationCountAttr.relation.junctionEntityMetadata.tableName;
                                            condition = junctionAlias + "." + firstJunctionColumn.propertyName + " IN (" + referenceColumnValues + ")" +
                                                " AND " + junctionAlias + "." + secondJunctionColumn.propertyName + " = " + inverseSideTableAlias + "." + inverseJoinColumnName;
                                            qb = this.connection.createQueryBuilder(this.queryRunner);
                                            qb.select(junctionAlias + "." + firstJunctionColumn.propertyName, "parentId")
                                                .addSelect("COUNT(" + qb.escape(inverseSideTableAlias) + "." + qb.escape(inverseJoinColumnName) + ")", "cnt")
                                                .from(inverseSideTableName, inverseSideTableAlias)
                                                .innerJoin(junctionTableName, junctionAlias, condition)
                                                .addGroupBy(junctionAlias + "." + firstJunctionColumn.propertyName);
                                            // apply condition (custom query builder factory)
                                            if (relationCountAttr.queryBuilderFactory)
                                                relationCountAttr.queryBuilderFactory(qb);
                                            _b = {
                                                relationCountAttribute: relationCountAttr
                                            };
                                            return [4 /*yield*/, qb.getRawMany()];
                                        case 3: return [2 /*return*/, (_b.results = _c.sent(),
                                                _b)];
                                    }
                                });
                            }); });
                            return [2 /*return*/, Promise.all(promises)];
                        });
                    });
                };
                return RelationCountLoader;
            }());
            exports_141("RelationCountLoader", RelationCountLoader);
        }
    };
});
System.register("typeorm/metadata-args/RelationCountMetadataArgs", [], function (exports_142, context_142) {
    "use strict";
    var __moduleName = context_142 && context_142.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/metadata/RelationCountMetadata", [], function (exports_143, context_143) {
    "use strict";
    var __moduleName = context_143 && context_143.id;
    var RelationCountMetadata;
    return {
        setters: [],
        execute: function () {
            /**
             * Contains all information about entity's relation count.
             */
            RelationCountMetadata = /** @class */ (function () {
                // ---------------------------------------------------------------------
                // Constructor
                // ---------------------------------------------------------------------
                function RelationCountMetadata(options) {
                    this.entityMetadata = options.entityMetadata;
                    this.target = options.args.target;
                    this.propertyName = options.args.propertyName;
                    this.relationNameOrFactory = options.args.relation;
                    this.alias = options.args.alias;
                    this.queryBuilderFactory = options.args.queryBuilderFactory;
                }
                // ---------------------------------------------------------------------
                // Public Builder Methods
                // ---------------------------------------------------------------------
                /**
                 * Builds some depend relation count metadata properties.
                 * This builder method should be used only after entity metadata, its properties map and all relations are build.
                 */
                RelationCountMetadata.prototype.build = function () {
                    var propertyPath = this.relationNameOrFactory instanceof Function ? this.relationNameOrFactory(this.entityMetadata.propertiesMap) : this.relationNameOrFactory;
                    var relation = this.entityMetadata.findRelationWithPropertyPath(propertyPath);
                    if (!relation)
                        throw new Error("Cannot find relation " + propertyPath + ". Wrong relation specified for @RelationCount decorator.");
                    this.relation = relation;
                };
                return RelationCountMetadata;
            }());
            exports_143("RelationCountMetadata", RelationCountMetadata);
        }
    };
});
System.register("typeorm/query-builder/relation-count/RelationCountMetadataToAttributeTransformer", ["typeorm/query-builder/relation-count/RelationCountAttribute"], function (exports_144, context_144) {
    "use strict";
    var __moduleName = context_144 && context_144.id;
    var RelationCountAttribute_2, RelationCountMetadataToAttributeTransformer;
    return {
        setters: [
            function (RelationCountAttribute_2_1) {
                RelationCountAttribute_2 = RelationCountAttribute_2_1;
            }
        ],
        execute: function () {
            RelationCountMetadataToAttributeTransformer = /** @class */ (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function RelationCountMetadataToAttributeTransformer(expressionMap) {
                    this.expressionMap = expressionMap;
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                RelationCountMetadataToAttributeTransformer.prototype.transform = function () {
                    // by example:
                    // post has relation count:
                    // @RelationCount(post => post.categories) categoryCount
                    // category has relation count
                    // @RelationCount(category => category.images) imageCount
                    // we load post and join category
                    // we expect post.categoryCount and post.category.imageCount to have relation counts
                    var _this = this;
                    // first create relation count attributes for all relation count metadatas of the main selected object (post from example)
                    if (this.expressionMap.mainAlias) {
                        this.expressionMap.mainAlias.metadata.relationCounts.forEach(function (relationCount) {
                            var attribute = _this.metadataToAttribute(_this.expressionMap.mainAlias.name, relationCount);
                            _this.expressionMap.relationCountAttributes.push(attribute);
                        });
                    }
                    // second create relation count attributes for all relation count metadatas of all joined objects (category from example)
                    this.expressionMap.joinAttributes.forEach(function (join) {
                        // ensure this join has a metadata, because relation count can only work for real orm entities
                        if (!join.metadata || join.metadata.isJunction)
                            return;
                        join.metadata.relationCounts.forEach(function (relationCount) {
                            var attribute = _this.metadataToAttribute(join.alias.name, relationCount);
                            _this.expressionMap.relationCountAttributes.push(attribute);
                        });
                    });
                };
                // -------------------------------------------------------------------------
                // Private Methods
                // -------------------------------------------------------------------------
                RelationCountMetadataToAttributeTransformer.prototype.metadataToAttribute = function (parentAliasName, relationCount) {
                    return new RelationCountAttribute_2.RelationCountAttribute(this.expressionMap, {
                        relationName: parentAliasName + "." + relationCount.relation.propertyName,
                        mapToProperty: parentAliasName + "." + relationCount.propertyName,
                        alias: relationCount.alias,
                        queryBuilderFactory: relationCount.queryBuilderFactory
                    });
                };
                return RelationCountMetadataToAttributeTransformer;
            }());
            exports_144("RelationCountMetadataToAttributeTransformer", RelationCountMetadataToAttributeTransformer);
        }
    };
});
System.register("typeorm/error/LockNotSupportedOnGivenDriverError", [], function (exports_145, context_145) {
    "use strict";
    var __moduleName = context_145 && context_145.id;
    var LockNotSupportedOnGivenDriverError;
    return {
        setters: [],
        execute: function () {
            /**
             * Thrown when selected sql driver does not supports locking.
             */
            LockNotSupportedOnGivenDriverError = /** @class */ (function (_super) {
                __extends(LockNotSupportedOnGivenDriverError, _super);
                function LockNotSupportedOnGivenDriverError() {
                    var _this = _super.call(this) || this;
                    _this.name = "LockNotSupportedOnGivenDriverError";
                    Object.setPrototypeOf(_this, LockNotSupportedOnGivenDriverError.prototype);
                    _this.message = "Locking not supported on given driver.";
                    return _this;
                }
                return LockNotSupportedOnGivenDriverError;
            }(Error));
            exports_145("LockNotSupportedOnGivenDriverError", LockNotSupportedOnGivenDriverError);
        }
    };
});
System.register("typeorm/cache/QueryResultCacheOptions", [], function (exports_146, context_146) {
    "use strict";
    var __moduleName = context_146 && context_146.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/error/OffsetWithoutLimitNotSupportedError", [], function (exports_147, context_147) {
    "use strict";
    var __moduleName = context_147 && context_147.id;
    var OffsetWithoutLimitNotSupportedError;
    return {
        setters: [],
        execute: function () {
            /**
             * Thrown when user tries to build SELECT query using OFFSET without LIMIT applied but database does not support it.
            */
            OffsetWithoutLimitNotSupportedError = /** @class */ (function (_super) {
                __extends(OffsetWithoutLimitNotSupportedError, _super);
                function OffsetWithoutLimitNotSupportedError(driverName) {
                    var _this = _super.call(this, driverName + " does not support OFFSET without LIMIT in SELECT statements. You must use limit in conjunction with offset function (or take in conjunction with skip function if you are using pagination).") || this;
                    Object.setPrototypeOf(_this, OffsetWithoutLimitNotSupportedError.prototype);
                    _this.name = "OffsetWithoutLimitNotSupportedError";
                    return _this;
                }
                return OffsetWithoutLimitNotSupportedError;
            }(Error));
            exports_147("OffsetWithoutLimitNotSupportedError", OffsetWithoutLimitNotSupportedError);
        }
    };
});
System.register("typeorm/query-builder/SelectQueryBuilder", ["typeorm/query-builder/transformer/RawSqlResultsToEntityTransformer", "typeorm/driver/sqlserver/SqlServerDriver", "typeorm/error/PessimisticLockTransactionRequiredError", "typeorm/error/NoVersionOrUpdateDateColumnError", "typeorm/error/OptimisticLockVersionMismatchError", "typeorm/error/OptimisticLockCanNotBeUsedError", "typeorm/query-builder/JoinAttribute", "typeorm/query-builder/relation-id/RelationIdAttribute", "typeorm/query-builder/relation-count/RelationCountAttribute", "typeorm/query-builder/relation-id/RelationIdLoader", "typeorm/query-builder/relation-id/RelationIdMetadataToAttributeTransformer", "typeorm/query-builder/relation-count/RelationCountLoader", "typeorm/query-builder/relation-count/RelationCountMetadataToAttributeTransformer", "typeorm/subscriber/Broadcaster", "typeorm/query-builder/QueryBuilder", "typeorm/error/LockNotSupportedOnGivenDriverError", "typeorm/driver/mysql/MysqlDriver", "typeorm/driver/postgres/PostgresDriver", "typeorm/driver/oracle/OracleDriver", "typeorm/driver/sqlite-abstract/AbstractSqliteDriver", "typeorm/error/OffsetWithoutLimitNotSupportedError"], function (exports_148, context_148) {
    "use strict";
    var __moduleName = context_148 && context_148.id;
    var RawSqlResultsToEntityTransformer_1, SqlServerDriver_4, PessimisticLockTransactionRequiredError_1, NoVersionOrUpdateDateColumnError_1, OptimisticLockVersionMismatchError_1, OptimisticLockCanNotBeUsedError_1, JoinAttribute_2, RelationIdAttribute_3, RelationCountAttribute_3, RelationIdLoader_1, RelationIdMetadataToAttributeTransformer_1, RelationCountLoader_1, RelationCountMetadataToAttributeTransformer_1, Broadcaster_2, QueryBuilder_5, LockNotSupportedOnGivenDriverError_1, MysqlDriver_3, PostgresDriver_4, OracleDriver_2, AbstractSqliteDriver_4, OffsetWithoutLimitNotSupportedError_1, SelectQueryBuilder;
    return {
        setters: [
            function (RawSqlResultsToEntityTransformer_1_1) {
                RawSqlResultsToEntityTransformer_1 = RawSqlResultsToEntityTransformer_1_1;
            },
            function (SqlServerDriver_4_1) {
                SqlServerDriver_4 = SqlServerDriver_4_1;
            },
            function (PessimisticLockTransactionRequiredError_1_1) {
                PessimisticLockTransactionRequiredError_1 = PessimisticLockTransactionRequiredError_1_1;
            },
            function (NoVersionOrUpdateDateColumnError_1_1) {
                NoVersionOrUpdateDateColumnError_1 = NoVersionOrUpdateDateColumnError_1_1;
            },
            function (OptimisticLockVersionMismatchError_1_1) {
                OptimisticLockVersionMismatchError_1 = OptimisticLockVersionMismatchError_1_1;
            },
            function (OptimisticLockCanNotBeUsedError_1_1) {
                OptimisticLockCanNotBeUsedError_1 = OptimisticLockCanNotBeUsedError_1_1;
            },
            function (JoinAttribute_2_1) {
                JoinAttribute_2 = JoinAttribute_2_1;
            },
            function (RelationIdAttribute_3_1) {
                RelationIdAttribute_3 = RelationIdAttribute_3_1;
            },
            function (RelationCountAttribute_3_1) {
                RelationCountAttribute_3 = RelationCountAttribute_3_1;
            },
            function (RelationIdLoader_1_1) {
                RelationIdLoader_1 = RelationIdLoader_1_1;
            },
            function (RelationIdMetadataToAttributeTransformer_1_1) {
                RelationIdMetadataToAttributeTransformer_1 = RelationIdMetadataToAttributeTransformer_1_1;
            },
            function (RelationCountLoader_1_1) {
                RelationCountLoader_1 = RelationCountLoader_1_1;
            },
            function (RelationCountMetadataToAttributeTransformer_1_1) {
                RelationCountMetadataToAttributeTransformer_1 = RelationCountMetadataToAttributeTransformer_1_1;
            },
            function (Broadcaster_2_1) {
                Broadcaster_2 = Broadcaster_2_1;
            },
            function (QueryBuilder_5_1) {
                QueryBuilder_5 = QueryBuilder_5_1;
            },
            function (LockNotSupportedOnGivenDriverError_1_1) {
                LockNotSupportedOnGivenDriverError_1 = LockNotSupportedOnGivenDriverError_1_1;
            },
            function (MysqlDriver_3_1) {
                MysqlDriver_3 = MysqlDriver_3_1;
            },
            function (PostgresDriver_4_1) {
                PostgresDriver_4 = PostgresDriver_4_1;
            },
            function (OracleDriver_2_1) {
                OracleDriver_2 = OracleDriver_2_1;
            },
            function (AbstractSqliteDriver_4_1) {
                AbstractSqliteDriver_4 = AbstractSqliteDriver_4_1;
            },
            function (OffsetWithoutLimitNotSupportedError_1_1) {
                OffsetWithoutLimitNotSupportedError_1 = OffsetWithoutLimitNotSupportedError_1_1;
            }
        ],
        execute: function () {
            /**
             * Allows to build complex sql queries in a fashion way and execute those queries.
             */
            SelectQueryBuilder = /** @class */ (function (_super) {
                __extends(SelectQueryBuilder, _super);
                function SelectQueryBuilder() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                // -------------------------------------------------------------------------
                // Public Implemented Methods
                // -------------------------------------------------------------------------
                /**
                 * Gets generated sql query without parameters being replaced.
                 */
                SelectQueryBuilder.prototype.getQuery = function () {
                    var sql = this.createSelectExpression();
                    sql += this.createJoinExpression();
                    sql += this.createWhereExpression();
                    sql += this.createGroupByExpression();
                    sql += this.createHavingExpression();
                    sql += this.createOrderByExpression();
                    sql += this.createLimitOffsetExpression();
                    sql += this.createLockExpression();
                    sql = this.createLimitOffsetOracleSpecificExpression(sql);
                    sql = sql.trim();
                    if (this.expressionMap.subQuery)
                        sql = "(" + sql + ")";
                    return sql;
                };
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Creates a subquery - query that can be used inside other queries.
                 */
                SelectQueryBuilder.prototype.subQuery = function () {
                    var qb = this.createQueryBuilder();
                    qb.expressionMap.subQuery = true;
                    qb.expressionMap.parentQueryBuilder = this;
                    return qb;
                };
                /**
                 * Creates SELECT query and selects given data.
                 * Replaces all previous selections if they exist.
                 */
                SelectQueryBuilder.prototype.select = function (selection, selectionAliasName) {
                    this.expressionMap.queryType = "select";
                    if (selection instanceof Array) {
                        this.expressionMap.selects = selection.map(function (selection) { return ({ selection: selection }); });
                    }
                    else if (selection instanceof Function) {
                        var subQueryBuilder = selection(this.subQuery());
                        this.setParameters(subQueryBuilder.getParameters());
                        this.expressionMap.selects.push({ selection: subQueryBuilder.getQuery(), aliasName: selectionAliasName });
                    }
                    else if (selection) {
                        this.expressionMap.selects = [{ selection: selection, aliasName: selectionAliasName }];
                    }
                    return this;
                };
                /**
                 * Adds new selection to the SELECT query.
                 */
                SelectQueryBuilder.prototype.addSelect = function (selection, selectionAliasName) {
                    if (!selection)
                        return this;
                    if (selection instanceof Array) {
                        this.expressionMap.selects = this.expressionMap.selects.concat(selection.map(function (selection) { return ({ selection: selection }); }));
                    }
                    else if (selection instanceof Function) {
                        var subQueryBuilder = selection(this.subQuery());
                        this.setParameters(subQueryBuilder.getParameters());
                        this.expressionMap.selects.push({ selection: subQueryBuilder.getQuery(), aliasName: selectionAliasName });
                    }
                    else if (selection) {
                        this.expressionMap.selects.push({ selection: selection, aliasName: selectionAliasName });
                    }
                    return this;
                };
                /**
                 * Specifies FROM which entity's table select/update/delete will be executed.
                 * Also sets a main string alias of the selection data.
                 * Removes all previously set from-s.
                 */
                SelectQueryBuilder.prototype.from = function (entityTarget, aliasName) {
                    var mainAlias = this.createFromAlias(entityTarget, aliasName);
                    this.expressionMap.setMainAlias(mainAlias);
                    return this;
                };
                /**
                 * Specifies FROM which entity's table select/update/delete will be executed.
                 * Also sets a main string alias of the selection data.
                 */
                SelectQueryBuilder.prototype.addFrom = function (entityTarget, aliasName) {
                    var alias = this.createFromAlias(entityTarget, aliasName);
                    if (!this.expressionMap.mainAlias)
                        this.expressionMap.setMainAlias(alias);
                    return this;
                };
                /**
                 * INNER JOINs (without selection).
                 * You also need to specify an alias of the joined data.
                 * Optionally, you can add condition and parameters used in condition.
                 */
                SelectQueryBuilder.prototype.innerJoin = function (entityOrProperty, aliasName, condition, parameters) {
                    if (condition === void 0) { condition = ""; }
                    this.join("INNER", entityOrProperty, aliasName, condition, parameters);
                    return this;
                };
                /**
                 * LEFT JOINs (without selection).
                 * You also need to specify an alias of the joined data.
                 * Optionally, you can add condition and parameters used in condition.
                 */
                SelectQueryBuilder.prototype.leftJoin = function (entityOrProperty, aliasName, condition, parameters) {
                    if (condition === void 0) { condition = ""; }
                    this.join("LEFT", entityOrProperty, aliasName, condition, parameters);
                    return this;
                };
                /**
                 * INNER JOINs and adds all selection properties to SELECT.
                 * You also need to specify an alias of the joined data.
                 * Optionally, you can add condition and parameters used in condition.
                 */
                SelectQueryBuilder.prototype.innerJoinAndSelect = function (entityOrProperty, aliasName, condition, parameters) {
                    if (condition === void 0) { condition = ""; }
                    this.addSelect(aliasName);
                    this.innerJoin(entityOrProperty, aliasName, condition, parameters);
                    return this;
                };
                /**
                 * LEFT JOINs and adds all selection properties to SELECT.
                 * You also need to specify an alias of the joined data.
                 * Optionally, you can add condition and parameters used in condition.
                 */
                SelectQueryBuilder.prototype.leftJoinAndSelect = function (entityOrProperty, aliasName, condition, parameters) {
                    if (condition === void 0) { condition = ""; }
                    this.addSelect(aliasName);
                    this.leftJoin(entityOrProperty, aliasName, condition, parameters);
                    return this;
                };
                /**
                 * INNER JOINs, SELECTs the data returned by a join and MAPs all that data to some entity's property.
                 * This is extremely useful when you want to select some data and map it to some virtual property.
                 * It will assume that there are multiple rows of selecting data, and mapped result will be an array.
                 * You also need to specify an alias of the joined data.
                 * Optionally, you can add condition and parameters used in condition.
                 */
                SelectQueryBuilder.prototype.innerJoinAndMapMany = function (mapToProperty, entityOrProperty, aliasName, condition, parameters) {
                    if (condition === void 0) { condition = ""; }
                    this.addSelect(aliasName);
                    this.join("INNER", entityOrProperty, aliasName, condition, parameters, mapToProperty, true);
                    return this;
                };
                /**
                 * INNER JOINs, SELECTs the data returned by a join and MAPs all that data to some entity's property.
                 * This is extremely useful when you want to select some data and map it to some virtual property.
                 * It will assume that there is a single row of selecting data, and mapped result will be a single selected value.
                 * You also need to specify an alias of the joined data.
                 * Optionally, you can add condition and parameters used in condition.
                 */
                SelectQueryBuilder.prototype.innerJoinAndMapOne = function (mapToProperty, entityOrProperty, aliasName, condition, parameters) {
                    if (condition === void 0) { condition = ""; }
                    this.addSelect(aliasName);
                    this.join("INNER", entityOrProperty, aliasName, condition, parameters, mapToProperty, false);
                    return this;
                };
                /**
                 * LEFT JOINs, SELECTs the data returned by a join and MAPs all that data to some entity's property.
                 * This is extremely useful when you want to select some data and map it to some virtual property.
                 * It will assume that there are multiple rows of selecting data, and mapped result will be an array.
                 * You also need to specify an alias of the joined data.
                 * Optionally, you can add condition and parameters used in condition.
                 */
                SelectQueryBuilder.prototype.leftJoinAndMapMany = function (mapToProperty, entityOrProperty, aliasName, condition, parameters) {
                    if (condition === void 0) { condition = ""; }
                    this.addSelect(aliasName);
                    this.join("LEFT", entityOrProperty, aliasName, condition, parameters, mapToProperty, true);
                    return this;
                };
                /**
                 * LEFT JOINs, SELECTs the data returned by a join and MAPs all that data to some entity's property.
                 * This is extremely useful when you want to select some data and map it to some virtual property.
                 * It will assume that there is a single row of selecting data, and mapped result will be a single selected value.
                 * You also need to specify an alias of the joined data.
                 * Optionally, you can add condition and parameters used in condition.
                 */
                SelectQueryBuilder.prototype.leftJoinAndMapOne = function (mapToProperty, entityOrProperty, aliasName, condition, parameters) {
                    if (condition === void 0) { condition = ""; }
                    this.addSelect(aliasName);
                    this.join("LEFT", entityOrProperty, aliasName, condition, parameters, mapToProperty, false);
                    return this;
                };
                /**
                 * LEFT JOINs relation id and maps it into some entity's property.
                 * Optionally, you can add condition and parameters used in condition.
                 */
                SelectQueryBuilder.prototype.loadRelationIdAndMap = function (mapToProperty, relationName, aliasNameOrOptions, queryBuilderFactory) {
                    var relationIdAttribute = new RelationIdAttribute_3.RelationIdAttribute(this.expressionMap);
                    relationIdAttribute.mapToProperty = mapToProperty;
                    relationIdAttribute.relationName = relationName;
                    if (typeof aliasNameOrOptions === "string")
                        relationIdAttribute.alias = aliasNameOrOptions;
                    if (aliasNameOrOptions instanceof Object && aliasNameOrOptions.disableMixedMap)
                        relationIdAttribute.disableMixedMap = true;
                    relationIdAttribute.queryBuilderFactory = queryBuilderFactory;
                    this.expressionMap.relationIdAttributes.push(relationIdAttribute);
                    if (relationIdAttribute.relation.junctionEntityMetadata) {
                        this.expressionMap.createAlias({
                            type: "other",
                            name: relationIdAttribute.junctionAlias,
                            metadata: relationIdAttribute.relation.junctionEntityMetadata
                        });
                    }
                    return this;
                };
                /**
                 * Counts number of entities of entity's relation and maps the value into some entity's property.
                 * Optionally, you can add condition and parameters used in condition.
                 */
                SelectQueryBuilder.prototype.loadRelationCountAndMap = function (mapToProperty, relationName, aliasName, queryBuilderFactory) {
                    var relationCountAttribute = new RelationCountAttribute_3.RelationCountAttribute(this.expressionMap);
                    relationCountAttribute.mapToProperty = mapToProperty;
                    relationCountAttribute.relationName = relationName;
                    relationCountAttribute.alias = aliasName;
                    relationCountAttribute.queryBuilderFactory = queryBuilderFactory;
                    this.expressionMap.relationCountAttributes.push(relationCountAttribute);
                    this.expressionMap.createAlias({
                        type: "other",
                        name: relationCountAttribute.junctionAlias
                    });
                    if (relationCountAttribute.relation.junctionEntityMetadata) {
                        this.expressionMap.createAlias({
                            type: "other",
                            name: relationCountAttribute.junctionAlias,
                            metadata: relationCountAttribute.relation.junctionEntityMetadata
                        });
                    }
                    return this;
                };
                /**
                 * Loads all relation ids for all relations of the selected entity.
                 * All relation ids will be mapped to relation property themself.
                 */
                SelectQueryBuilder.prototype.loadAllRelationIds = function () {
                    var _this = this;
                    this.expressionMap.mainAlias.metadata.relations.forEach(function (relation) {
                        _this.loadRelationIdAndMap(_this.expressionMap.mainAlias.name + "." + relation.propertyPath, _this.expressionMap.mainAlias.name + "." + relation.propertyPath, { disableMixedMap: true });
                    });
                    return this;
                };
                /**
                 * Sets WHERE condition in the query builder.
                 * If you had previously WHERE expression defined,
                 * calling this function will override previously set WHERE conditions.
                 * Additionally you can add parameters used in where expression.
                 */
                SelectQueryBuilder.prototype.where = function (where, parameters) {
                    this.expressionMap.wheres = []; // don't move this block below since computeWhereParameter can add where expressions
                    var condition = this.computeWhereParameter(where);
                    if (condition)
                        this.expressionMap.wheres = [{ type: "simple", condition: condition }];
                    if (parameters)
                        this.setParameters(parameters);
                    return this;
                };
                /**
                 * Adds new AND WHERE condition in the query builder.
                 * Additionally you can add parameters used in where expression.
                 */
                SelectQueryBuilder.prototype.andWhere = function (where, parameters) {
                    this.expressionMap.wheres.push({ type: "and", condition: this.computeWhereParameter(where) });
                    if (parameters)
                        this.setParameters(parameters);
                    return this;
                };
                /**
                 * Adds new OR WHERE condition in the query builder.
                 * Additionally you can add parameters used in where expression.
                 */
                SelectQueryBuilder.prototype.orWhere = function (where, parameters) {
                    this.expressionMap.wheres.push({ type: "or", condition: this.computeWhereParameter(where) });
                    if (parameters)
                        this.setParameters(parameters);
                    return this;
                };
                /**
                 * Adds new AND WHERE with conditions for the given ids.
                 *
                 * Ids are mixed.
                 * It means if you have single primary key you can pass a simple id values, for example [1, 2, 3].
                 * If you have multiple primary keys you need to pass object with property names and values specified,
                 * for example [{ firstId: 1, secondId: 2 }, { firstId: 2, secondId: 3 }, ...]
                 */
                SelectQueryBuilder.prototype.whereInIds = function (ids) {
                    ids = ids instanceof Array ? ids : [ids];
                    var _a = this.createWhereIdsExpression(ids), whereExpression = _a[0], parameters = _a[1];
                    this.where(whereExpression, parameters);
                    return this;
                };
                /**
                 * Adds new AND WHERE with conditions for the given ids.
                 *
                 * Ids are mixed.
                 * It means if you have single primary key you can pass a simple id values, for example [1, 2, 3].
                 * If you have multiple primary keys you need to pass object with property names and values specified,
                 * for example [{ firstId: 1, secondId: 2 }, { firstId: 2, secondId: 3 }, ...]
                 */
                SelectQueryBuilder.prototype.andWhereInIds = function (ids) {
                    var _a = this.createWhereIdsExpression(ids), whereExpression = _a[0], parameters = _a[1];
                    this.andWhere(whereExpression, parameters);
                    return this;
                };
                /**
                 * Adds new OR WHERE with conditions for the given ids.
                 *
                 * Ids are mixed.
                 * It means if you have single primary key you can pass a simple id values, for example [1, 2, 3].
                 * If you have multiple primary keys you need to pass object with property names and values specified,
                 * for example [{ firstId: 1, secondId: 2 }, { firstId: 2, secondId: 3 }, ...]
                 */
                SelectQueryBuilder.prototype.orWhereInIds = function (ids) {
                    var _a = this.createWhereIdsExpression(ids), whereExpression = _a[0], parameters = _a[1];
                    this.orWhere(whereExpression, parameters);
                    return this;
                };
                /**
                 * Sets HAVING condition in the query builder.
                 * If you had previously HAVING expression defined,
                 * calling this function will override previously set HAVING conditions.
                 * Additionally you can add parameters used in where expression.
                 */
                SelectQueryBuilder.prototype.having = function (having, parameters) {
                    this.expressionMap.havings.push({ type: "simple", condition: having });
                    if (parameters)
                        this.setParameters(parameters);
                    return this;
                };
                /**
                 * Adds new AND HAVING condition in the query builder.
                 * Additionally you can add parameters used in where expression.
                 */
                SelectQueryBuilder.prototype.andHaving = function (having, parameters) {
                    this.expressionMap.havings.push({ type: "and", condition: having });
                    if (parameters)
                        this.setParameters(parameters);
                    return this;
                };
                /**
                 * Adds new OR HAVING condition in the query builder.
                 * Additionally you can add parameters used in where expression.
                 */
                SelectQueryBuilder.prototype.orHaving = function (having, parameters) {
                    this.expressionMap.havings.push({ type: "or", condition: having });
                    if (parameters)
                        this.setParameters(parameters);
                    return this;
                };
                /**
                 * Sets GROUP BY condition in the query builder.
                 * If you had previously GROUP BY expression defined,
                 * calling this function will override previously set GROUP BY conditions.
                 */
                SelectQueryBuilder.prototype.groupBy = function (groupBy) {
                    if (groupBy) {
                        this.expressionMap.groupBys = [groupBy];
                    }
                    else {
                        this.expressionMap.groupBys = [];
                    }
                    return this;
                };
                /**
                 * Adds GROUP BY condition in the query builder.
                 */
                SelectQueryBuilder.prototype.addGroupBy = function (groupBy) {
                    this.expressionMap.groupBys.push(groupBy);
                    return this;
                };
                /**
                 * Sets ORDER BY condition in the query builder.
                 * If you had previously ORDER BY expression defined,
                 * calling this function will override previously set ORDER BY conditions.
                 */
                SelectQueryBuilder.prototype.orderBy = function (sort, order, nulls) {
                    if (order === void 0) { order = "ASC"; }
                    if (order !== undefined && order !== "ASC" && order !== "DESC")
                        throw new Error("SelectQueryBuilder.addOrderBy \"order\" can accept only \"ASC\" and \"DESC\" values.");
                    if (nulls !== undefined && nulls !== "NULLS FIRST" && nulls !== "NULLS LAST")
                        throw new Error("SelectQueryBuilder.addOrderBy \"nulls\" can accept only \"NULLS FIRST\" and \"NULLS LAST\" values.");
                    if (sort) {
                        if (sort instanceof Object) {
                            this.expressionMap.orderBys = sort;
                        }
                        else {
                            if (nulls) {
                                this.expressionMap.orderBys = (_a = {}, _a[sort] = { order: order, nulls: nulls }, _a);
                            }
                            else {
                                this.expressionMap.orderBys = (_b = {}, _b[sort] = order, _b);
                            }
                        }
                    }
                    else {
                        this.expressionMap.orderBys = {};
                    }
                    return this;
                    var _a, _b;
                };
                /**
                 * Adds ORDER BY condition in the query builder.
                 */
                SelectQueryBuilder.prototype.addOrderBy = function (sort, order, nulls) {
                    if (order === void 0) { order = "ASC"; }
                    if (order !== undefined && order !== "ASC" && order !== "DESC")
                        throw new Error("SelectQueryBuilder.addOrderBy \"order\" can accept only \"ASC\" and \"DESC\" values.");
                    if (nulls !== undefined && nulls !== "NULLS FIRST" && nulls !== "NULLS LAST")
                        throw new Error("SelectQueryBuilder.addOrderBy \"nulls\" can accept only \"NULLS FIRST\" and \"NULLS LAST\" values.");
                    if (nulls) {
                        this.expressionMap.orderBys[sort] = { order: order, nulls: nulls };
                    }
                    else {
                        this.expressionMap.orderBys[sort] = order;
                    }
                    return this;
                };
                /**
                 * Set's LIMIT - maximum number of rows to be selected.
                 * NOTE that it may not work as you expect if you are using joins.
                 * If you want to implement pagination, and you are having join in your query,
                 * then use instead take method instead.
                 */
                SelectQueryBuilder.prototype.limit = function (limit) {
                    this.expressionMap.limit = this.normalizeNumber(limit);
                    if (this.expressionMap.limit !== undefined && isNaN(this.expressionMap.limit))
                        throw new Error("Provided \"limit\" value is not a number. Please provide a numeric value.");
                    return this;
                };
                /**
                 * Set's OFFSET - selection offset.
                 * NOTE that it may not work as you expect if you are using joins.
                 * If you want to implement pagination, and you are having join in your query,
                 * then use instead skip method instead.
                 */
                SelectQueryBuilder.prototype.offset = function (offset) {
                    this.expressionMap.offset = this.normalizeNumber(offset);
                    if (this.expressionMap.offset !== undefined && isNaN(this.expressionMap.offset))
                        throw new Error("Provided \"offset\" value is not a number. Please provide a numeric value.");
                    return this;
                };
                /**
                 * Sets maximal number of entities to take.
                 */
                SelectQueryBuilder.prototype.take = function (take) {
                    this.expressionMap.take = this.normalizeNumber(take);
                    if (this.expressionMap.take !== undefined && isNaN(this.expressionMap.take))
                        throw new Error("Provided \"take\" value is not a number. Please provide a numeric value.");
                    return this;
                };
                /**
                 * Sets number of entities to skip.
                 */
                SelectQueryBuilder.prototype.skip = function (skip) {
                    this.expressionMap.skip = this.normalizeNumber(skip);
                    if (this.expressionMap.skip !== undefined && isNaN(this.expressionMap.skip))
                        throw new Error("Provided \"skip\" value is not a number. Please provide a numeric value.");
                    return this;
                };
                /**
                 * Sets locking mode.
                 */
                SelectQueryBuilder.prototype.setLock = function (lockMode, lockVersion) {
                    this.expressionMap.lockMode = lockMode;
                    this.expressionMap.lockVersion = lockVersion;
                    return this;
                };
                /**
                 * Gets first raw result returned by execution of generated query builder sql.
                 */
                SelectQueryBuilder.prototype.getRawOne = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.getRawMany()];
                                case 1: return [2 /*return*/, (_a.sent())[0]];
                            }
                        });
                    });
                };
                /**
                 * Gets all raw results returned by execution of generated query builder sql.
                 */
                SelectQueryBuilder.prototype.getRawMany = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var queryRunner;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.expressionMap.lockMode === "optimistic")
                                        throw new OptimisticLockCanNotBeUsedError_1.OptimisticLockCanNotBeUsedError();
                                    this.expressionMap.queryEntity = false;
                                    queryRunner = this.obtainQueryRunner();
                                    _a.label = 1;
                                case 1:
                                    _a.trys.push([1, , 3, 6]);
                                    return [4 /*yield*/, this.loadRawResults(queryRunner)];
                                case 2: return [2 /*return*/, _a.sent()];
                                case 3:
                                    if (!(queryRunner !== this.queryRunner)) return [3 /*break*/, 5];
                                    return [4 /*yield*/, queryRunner.release()];
                                case 4:
                                    _a.sent();
                                    _a.label = 5;
                                case 5: return [7 /*endfinally*/];
                                case 6: return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Executes sql generated by query builder and returns object with raw results and entities created from them.
                 */
                SelectQueryBuilder.prototype.getRawAndEntities = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var queryRunner;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    queryRunner = this.obtainQueryRunner();
                                    _a.label = 1;
                                case 1:
                                    _a.trys.push([1, , 3, 6]);
                                    this.expressionMap.queryEntity = true;
                                    return [4 /*yield*/, this.executeEntitiesAndRawResults(queryRunner)];
                                case 2: return [2 /*return*/, _a.sent()];
                                case 3:
                                    if (!(queryRunner !== this.queryRunner)) return [3 /*break*/, 5];
                                    return [4 /*yield*/, queryRunner.release()];
                                case 4:
                                    _a.sent();
                                    _a.label = 5;
                                case 5: return [7 /*endfinally*/];
                                case 6: return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Gets single entity returned by execution of generated query builder sql.
                 */
                SelectQueryBuilder.prototype.getOne = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var results, result, metadata, actualVersion, actualVersion;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.getRawAndEntities()];
                                case 1:
                                    results = _a.sent();
                                    result = results.entities[0];
                                    if (result && this.expressionMap.lockMode === "optimistic" && this.expressionMap.lockVersion) {
                                        metadata = this.expressionMap.mainAlias.metadata;
                                        if (this.expressionMap.lockVersion instanceof Date) {
                                            actualVersion = result[metadata.updateDateColumn.propertyName];
                                            if (actualVersion.getTime() !== this.expressionMap.lockVersion.getTime())
                                                throw new OptimisticLockVersionMismatchError_1.OptimisticLockVersionMismatchError(metadata.name, this.expressionMap.lockVersion, actualVersion);
                                        }
                                        else {
                                            actualVersion = result[metadata.versionColumn.propertyName];
                                            if (actualVersion !== this.expressionMap.lockVersion)
                                                throw new OptimisticLockVersionMismatchError_1.OptimisticLockVersionMismatchError(metadata.name, this.expressionMap.lockVersion, actualVersion);
                                        }
                                    }
                                    return [2 /*return*/, result];
                            }
                        });
                    });
                };
                /**
                 * Gets entities returned by execution of generated query builder sql.
                 */
                SelectQueryBuilder.prototype.getMany = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var results;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.expressionMap.lockMode === "optimistic")
                                        throw new OptimisticLockCanNotBeUsedError_1.OptimisticLockCanNotBeUsedError();
                                    return [4 /*yield*/, this.getRawAndEntities()];
                                case 1:
                                    results = _a.sent();
                                    return [2 /*return*/, results.entities];
                            }
                        });
                    });
                };
                /**
                 * Gets count - number of entities selected by sql generated by this query builder.
                 * Count excludes all limitations set by setFirstResult and setMaxResults methods call.
                 */
                SelectQueryBuilder.prototype.getCount = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var queryRunner;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.expressionMap.lockMode === "optimistic")
                                        throw new OptimisticLockCanNotBeUsedError_1.OptimisticLockCanNotBeUsedError();
                                    queryRunner = this.obtainQueryRunner();
                                    _a.label = 1;
                                case 1:
                                    _a.trys.push([1, , 3, 6]);
                                    return [4 /*yield*/, this.executeCountQuery(queryRunner)];
                                case 2: return [2 /*return*/, _a.sent()];
                                case 3:
                                    if (!(queryRunner !== this.queryRunner)) return [3 /*break*/, 5];
                                    return [4 /*yield*/, queryRunner.release()];
                                case 4:
                                    _a.sent();
                                    _a.label = 5;
                                case 5: return [7 /*endfinally*/];
                                case 6: return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Executes built SQL query and returns entities and overall entities count (without limitation).
                 * This method is useful to build pagination.
                 */
                SelectQueryBuilder.prototype.getManyAndCount = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var queryRunner, entitiesAndRaw, count;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.expressionMap.lockMode === "optimistic")
                                        throw new OptimisticLockCanNotBeUsedError_1.OptimisticLockCanNotBeUsedError();
                                    queryRunner = this.obtainQueryRunner();
                                    _a.label = 1;
                                case 1:
                                    _a.trys.push([1, , 4, 7]);
                                    return [4 /*yield*/, this.executeEntitiesAndRawResults(queryRunner)];
                                case 2:
                                    entitiesAndRaw = _a.sent();
                                    return [4 /*yield*/, this.executeCountQuery(queryRunner)];
                                case 3:
                                    count = _a.sent();
                                    return [2 /*return*/, [entitiesAndRaw.entities, count]];
                                case 4:
                                    if (!(queryRunner !== this.queryRunner)) return [3 /*break*/, 6];
                                    return [4 /*yield*/, queryRunner.release()];
                                case 5:
                                    _a.sent();
                                    _a.label = 6;
                                case 6: return [7 /*endfinally*/];
                                case 7: return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Executes built SQL query and returns raw data stream.
                 */
                SelectQueryBuilder.prototype.stream = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var _a, sql, parameters, queryRunner, releaseFn;
                        return __generator(this, function (_b) {
                            switch (_b.label) {
                                case 0:
                                    this.expressionMap.queryEntity = false;
                                    _a = this.getQueryAndParameters(), sql = _a[0], parameters = _a[1];
                                    queryRunner = this.obtainQueryRunner();
                                    _b.label = 1;
                                case 1:
                                    _b.trys.push([1, , 2, 5]);
                                    releaseFn = function () {
                                        if (queryRunner !== _this.queryRunner) // means we created our own query runner
                                            return queryRunner.release();
                                        return;
                                    };
                                    return [2 /*return*/, queryRunner.stream(sql, parameters, releaseFn, releaseFn)];
                                case 2:
                                    if (!(queryRunner !== this.queryRunner)) return [3 /*break*/, 4];
                                    return [4 /*yield*/, queryRunner.release()];
                                case 3:
                                    _b.sent();
                                    _b.label = 4;
                                case 4: return [7 /*endfinally*/];
                                case 5: return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Enables or disables query result caching.
                 */
                SelectQueryBuilder.prototype.cache = function (enabledOrMillisecondsOrId, maybeMilliseconds) {
                    if (typeof enabledOrMillisecondsOrId === "boolean") {
                        this.expressionMap.cache = enabledOrMillisecondsOrId;
                    }
                    else if (typeof enabledOrMillisecondsOrId === "number") {
                        this.expressionMap.cache = true;
                        this.expressionMap.cacheDuration = enabledOrMillisecondsOrId;
                    }
                    else if (typeof enabledOrMillisecondsOrId === "string" || typeof enabledOrMillisecondsOrId === "number") {
                        this.expressionMap.cache = true;
                        this.expressionMap.cacheId = enabledOrMillisecondsOrId;
                    }
                    if (maybeMilliseconds) {
                        this.expressionMap.cacheDuration = maybeMilliseconds;
                    }
                    return this;
                };
                // -------------------------------------------------------------------------
                // Protected Methods
                // -------------------------------------------------------------------------
                SelectQueryBuilder.prototype.join = function (direction, entityOrProperty, aliasName, condition, parameters, mapToProperty, isMappingMany) {
                    this.setParameters(parameters || {});
                    var joinAttribute = new JoinAttribute_2.JoinAttribute(this.connection, this.expressionMap);
                    joinAttribute.direction = direction;
                    joinAttribute.mapToProperty = mapToProperty;
                    joinAttribute.isMappingMany = isMappingMany;
                    joinAttribute.entityOrProperty = entityOrProperty; // relationName
                    joinAttribute.condition = condition; // joinInverseSideCondition
                    // joinAttribute.junctionAlias = joinAttribute.relation.isOwning ? parentAlias + "_" + destinationTableAlias : destinationTableAlias + "_" + parentAlias;
                    this.expressionMap.joinAttributes.push(joinAttribute);
                    if (joinAttribute.metadata) {
                        // todo: find and set metadata right there?
                        joinAttribute.alias = this.expressionMap.createAlias({
                            type: "join",
                            name: aliasName,
                            metadata: joinAttribute.metadata
                        });
                        if (joinAttribute.relation && joinAttribute.relation.junctionEntityMetadata) {
                            this.expressionMap.createAlias({
                                type: "join",
                                name: joinAttribute.junctionAlias,
                                metadata: joinAttribute.relation.junctionEntityMetadata
                            });
                        }
                    }
                    else {
                        var subQuery = "";
                        if (entityOrProperty instanceof Function) {
                            var subQueryBuilder = entityOrProperty(this.subQuery());
                            this.setParameters(subQueryBuilder.getParameters());
                            subQuery = subQueryBuilder.getQuery();
                        }
                        else {
                            subQuery = entityOrProperty;
                        }
                        var isSubQuery = entityOrProperty instanceof Function || entityOrProperty.substr(0, 1) === "(" && entityOrProperty.substr(-1) === ")";
                        joinAttribute.alias = this.expressionMap.createAlias({
                            type: "join",
                            name: aliasName,
                            tablePath: isSubQuery === false ? entityOrProperty : undefined,
                            subQuery: isSubQuery === true ? subQuery : undefined,
                        });
                    }
                };
                /**
                 * Creates "SELECT FROM" part of SQL query.
                 */
                SelectQueryBuilder.prototype.createSelectExpression = function () {
                    var _this = this;
                    if (!this.expressionMap.mainAlias)
                        throw new Error("Cannot build query because main alias is not set (call qb#from method)");
                    // todo throw exception if selects or from is missing
                    var allSelects = [];
                    var excludedSelects = [];
                    if (this.expressionMap.mainAlias.hasMetadata) {
                        var metadata = this.expressionMap.mainAlias.metadata;
                        allSelects.push.apply(allSelects, this.buildEscapedEntityColumnSelects(this.expressionMap.mainAlias.name, metadata));
                        excludedSelects.push.apply(excludedSelects, this.findEntityColumnSelects(this.expressionMap.mainAlias.name, metadata));
                    }
                    // add selects from joins
                    this.expressionMap.joinAttributes
                        .forEach(function (join) {
                        if (join.metadata) {
                            allSelects.push.apply(allSelects, _this.buildEscapedEntityColumnSelects(join.alias.name, join.metadata));
                            excludedSelects.push.apply(excludedSelects, _this.findEntityColumnSelects(join.alias.name, join.metadata));
                        }
                        else {
                            var hasMainAlias = _this.expressionMap.selects.some(function (select) { return select.selection === join.alias.name; });
                            if (hasMainAlias) {
                                allSelects.push({ selection: _this.escape(join.alias.name) + ".*" });
                                var excludedSelect = _this.expressionMap.selects.find(function (select) { return select.selection === join.alias.name; });
                                excludedSelects.push(excludedSelect);
                            }
                        }
                    });
                    if (!this.expressionMap.ignoreParentTablesJoins && this.expressionMap.mainAlias.hasMetadata) {
                        var metadata = this.expressionMap.mainAlias.metadata;
                        if (metadata.parentEntityMetadata && metadata.parentEntityMetadata.inheritanceType === "class-table" && metadata.parentIdColumns) {
                            var alias_1 = "parentIdColumn_" + metadata.parentEntityMetadata.tableName;
                            metadata.parentEntityMetadata.columns.forEach(function (column) {
                                // TODO implement partial select
                                allSelects.push({ selection: _this.escape(alias_1) + "." + _this.escape(column.databaseName), aliasName: alias_1 + "_" + column.databaseName });
                            });
                        }
                    }
                    // add selects from relation id joins
                    // this.relationIdAttributes.forEach(relationIdAttr => {
                    // });
                    /*if (this.enableRelationIdValues) {
                     const parentMetadata = this.aliasMap.getEntityMetadataByAlias(this.aliasMap.mainAlias);
                     if (!parentMetadata)
                     throw new Error("Cannot get entity metadata for the given alias " + this.aliasMap.mainAlias.name);
            
                     const metadata = this.connection.entityMetadatas.findByTarget(this.aliasMap.mainAlias.target);
                     metadata.manyToManyRelations.forEach(relation => {
            
                     const junctionMetadata = relation.junctionEntityMetadata;
                     junctionMetadata.columns.forEach(column => {
                     const select = ea(this.aliasMap.mainAlias.name + "_" + junctionMetadata.table.name + "_ids") + "." +
                     ec(column.name) + " AS " +
                     ea(this.aliasMap.mainAlias.name + "_" + relation.name + "_ids_" + column.name);
                     allSelects.push(select);
                     });
                     });
                     }*/
                    // add all other selects
                    this.expressionMap.selects
                        .filter(function (select) { return excludedSelects.indexOf(select) === -1; })
                        .forEach(function (select) { return allSelects.push({ selection: _this.replacePropertyNames(select.selection), aliasName: select.aliasName }); });
                    // if still selection is empty, then simply set it to all (*)
                    if (allSelects.length === 0)
                        allSelects.push({ selection: "*" });
                    var lock = "";
                    if (this.connection.driver instanceof SqlServerDriver_4.SqlServerDriver) {
                        switch (this.expressionMap.lockMode) {
                            case "pessimistic_read":
                                lock = " WITH (HOLDLOCK, ROWLOCK)";
                                break;
                            case "pessimistic_write":
                                lock = " WITH (UPDLOCK, ROWLOCK)";
                                break;
                        }
                    }
                    // create a selection query
                    var froms = this.expressionMap.aliases
                        .filter(function (alias) { return alias.type === "from" && (alias.tablePath || alias.subQuery); })
                        .map(function (alias) {
                        if (alias.subQuery)
                            return alias.subQuery + " " + _this.escape(alias.name);
                        return _this.getTableName(alias.tablePath) + " " + _this.escape(alias.name);
                    });
                    var selection = allSelects.map(function (select) { return select.selection + (select.aliasName ? " AS " + _this.escape(select.aliasName) : ""); }).join(", ");
                    if ((this.expressionMap.limit || this.expressionMap.offset) && this.connection.driver instanceof OracleDriver_2.OracleDriver)
                        return "SELECT ROWNUM " + this.escape("RN") + "," + selection + " FROM " + froms.join(", ") + lock;
                    return "SELECT " + selection + " FROM " + froms.join(", ") + lock;
                };
                /**
                 * Creates "JOIN" part of SQL query.
                 */
                SelectQueryBuilder.prototype.createJoinExpression = function () {
                    // examples:
                    // select from owning side
                    // qb.select("post")
                    //     .leftJoinAndSelect("post.category", "category");
                    // select from non-owning side
                    // qb.select("category")
                    //     .leftJoinAndSelect("category.post", "post");
                    var _this = this;
                    var joins = this.expressionMap.joinAttributes.map(function (joinAttr) {
                        var relation = joinAttr.relation;
                        var destinationTableName = joinAttr.tablePath;
                        var destinationTableAlias = joinAttr.alias.name;
                        var appendedCondition = joinAttr.condition ? " AND (" + joinAttr.condition + ")" : "";
                        var parentAlias = joinAttr.parentAlias;
                        // if join was build without relation (e.g. without "post.category") then it means that we have direct
                        // table to join, without junction table involved. This means we simply join direct table.
                        if (!parentAlias || !relation) {
                            var destinationJoin = joinAttr.alias.subQuery ? joinAttr.alias.subQuery : _this.getTableName(destinationTableName);
                            return " " + joinAttr.direction + " JOIN " + destinationJoin + " " + _this.escape(destinationTableAlias) +
                                (joinAttr.condition ? " ON " + _this.replacePropertyNames(joinAttr.condition) : "");
                        }
                        // if real entity relation is involved
                        if (relation.isManyToOne || relation.isOneToOneOwner) {
                            // JOIN `category` `category` ON `category`.`id` = `post`.`categoryId`
                            var condition = relation.joinColumns.map(function (joinColumn) {
                                return destinationTableAlias + "." + joinColumn.referencedColumn.propertyPath + "=" +
                                    parentAlias + "." + relation.propertyPath + "." + joinColumn.referencedColumn.propertyPath;
                            }).join(" AND ");
                            return " " + joinAttr.direction + " JOIN " + _this.getTableName(destinationTableName) + " " + _this.escape(destinationTableAlias) + " ON " + _this.replacePropertyNames(condition + appendedCondition);
                        }
                        else if (relation.isOneToMany || relation.isOneToOneNotOwner) {
                            // JOIN `post` `post` ON `post`.`categoryId` = `category`.`id`
                            var condition = relation.inverseRelation.joinColumns.map(function (joinColumn) {
                                return destinationTableAlias + "." + relation.inverseRelation.propertyPath + "." + joinColumn.referencedColumn.propertyPath + "=" +
                                    parentAlias + "." + joinColumn.referencedColumn.propertyPath;
                            }).join(" AND ");
                            return " " + joinAttr.direction + " JOIN " + _this.getTableName(destinationTableName) + " " + _this.escape(destinationTableAlias) + " ON " + _this.replacePropertyNames(condition + appendedCondition);
                        }
                        else { // means many-to-many
                            var junctionTableName = relation.junctionEntityMetadata.tablePath;
                            var junctionAlias_2 = joinAttr.junctionAlias;
                            var junctionCondition = "", destinationCondition = "";
                            if (relation.isOwning) {
                                junctionCondition = relation.joinColumns.map(function (joinColumn) {
                                    // `post_category`.`postId` = `post`.`id`
                                    return junctionAlias_2 + "." + joinColumn.propertyPath + "=" + parentAlias + "." + joinColumn.referencedColumn.propertyPath;
                                }).join(" AND ");
                                destinationCondition = relation.inverseJoinColumns.map(function (joinColumn) {
                                    // `category`.`id` = `post_category`.`categoryId`
                                    return destinationTableAlias + "." + joinColumn.referencedColumn.propertyPath + "=" + junctionAlias_2 + "." + joinColumn.propertyPath;
                                }).join(" AND ");
                            }
                            else {
                                junctionCondition = relation.inverseRelation.inverseJoinColumns.map(function (joinColumn) {
                                    // `post_category`.`categoryId` = `category`.`id`
                                    return junctionAlias_2 + "." + joinColumn.propertyPath + "=" + parentAlias + "." + joinColumn.referencedColumn.propertyPath;
                                }).join(" AND ");
                                destinationCondition = relation.inverseRelation.joinColumns.map(function (joinColumn) {
                                    // `post`.`id` = `post_category`.`postId`
                                    return destinationTableAlias + "." + joinColumn.referencedColumn.propertyPath + "=" + junctionAlias_2 + "." + joinColumn.propertyPath;
                                }).join(" AND ");
                            }
                            return " " + joinAttr.direction + " JOIN " + _this.getTableName(junctionTableName) + " " + _this.escape(junctionAlias_2) + " ON " + _this.replacePropertyNames(junctionCondition) +
                                " " + joinAttr.direction + " JOIN " + _this.getTableName(destinationTableName) + " " + _this.escape(destinationTableAlias) + " ON " + _this.replacePropertyNames(destinationCondition + appendedCondition);
                        }
                    });
                    if (!this.expressionMap.ignoreParentTablesJoins && this.expressionMap.mainAlias.hasMetadata) {
                        var metadata = this.expressionMap.mainAlias.metadata;
                        if (metadata.parentEntityMetadata && metadata.parentEntityMetadata.inheritanceType === "class-table" && metadata.parentIdColumns) {
                            var alias_2 = "parentIdColumn_" + metadata.parentEntityMetadata.tableName;
                            var condition = metadata.parentIdColumns.map(function (parentIdColumn) {
                                return _this.expressionMap.mainAlias.name + "." + parentIdColumn.propertyPath + " = " + _this.escape(alias_2) + "." + _this.escape(parentIdColumn.referencedColumn.propertyPath);
                            }).join(" AND ");
                            var join = " JOIN " + this.getTableName(metadata.parentEntityMetadata.tablePath) + " " + this.escape(alias_2) + " ON " + this.replacePropertyNames(condition);
                            joins.push(join);
                        }
                    }
                    return joins.join(" ");
                };
                /**
                 * Creates "GROUP BY" part of SQL query.
                 */
                SelectQueryBuilder.prototype.createGroupByExpression = function () {
                    if (!this.expressionMap.groupBys || !this.expressionMap.groupBys.length)
                        return "";
                    return " GROUP BY " + this.replacePropertyNames(this.expressionMap.groupBys.join(", "));
                };
                /**
                 * Creates "ORDER BY" part of SQL query.
                 */
                SelectQueryBuilder.prototype.createOrderByExpression = function () {
                    var _this = this;
                    var orderBys = this.expressionMap.allOrderBys;
                    if (Object.keys(orderBys).length > 0)
                        return " ORDER BY " + Object.keys(orderBys)
                            .map(function (columnName) {
                            if (typeof orderBys[columnName] === "string") {
                                return _this.replacePropertyNames(columnName) + " " + orderBys[columnName];
                            }
                            else {
                                return _this.replacePropertyNames(columnName) + " " + orderBys[columnName].order + " " + orderBys[columnName].nulls;
                            }
                        })
                            .join(", ");
                    return "";
                };
                /**
                 * Creates "LIMIT" and "OFFSET" parts of SQL query for Oracle database.
                 */
                SelectQueryBuilder.prototype.createLimitOffsetOracleSpecificExpression = function (sql) {
                    if ((this.expressionMap.offset || this.expressionMap.limit) && this.connection.driver instanceof OracleDriver_2.OracleDriver) {
                        sql = "SELECT * FROM (" + sql + ") WHERE ";
                        if (this.expressionMap.offset) {
                            sql += this.escape("RN") + " >= " + this.expressionMap.offset;
                        }
                        if (this.expressionMap.limit) {
                            sql += (this.expressionMap.offset ? " AND " : "") + this.escape("RN") + " <= " + ((this.expressionMap.offset || 0) + this.expressionMap.limit);
                        }
                    }
                    return sql;
                };
                /**
                 * Creates "LIMIT" and "OFFSET" parts of SQL query.
                 */
                SelectQueryBuilder.prototype.createLimitOffsetExpression = function () {
                    if (this.connection.driver instanceof OracleDriver_2.OracleDriver)
                        return "";
                    // in the case if nothing is joined in the query builder we don't need to make two requests to get paginated results
                    // we can use regular limit / offset, that's why we add offset and limit construction here based on skip and take values
                    var offset = this.expressionMap.offset, limit = this.expressionMap.limit;
                    if (!offset && !limit && this.expressionMap.joinAttributes.length === 0) {
                        offset = this.expressionMap.skip;
                        limit = this.expressionMap.take;
                    }
                    if (this.connection.driver instanceof SqlServerDriver_4.SqlServerDriver) {
                        if (limit && offset)
                            return " OFFSET " + offset + " ROWS FETCH NEXT " + limit + " ROWS ONLY";
                        if (limit)
                            return " OFFSET 0 ROWS FETCH NEXT " + limit + " ROWS ONLY";
                        if (offset)
                            return " OFFSET " + offset + " ROWS";
                    }
                    else if (this.connection.driver instanceof MysqlDriver_3.MysqlDriver) {
                        if (limit && offset)
                            return " LIMIT " + limit + " OFFSET " + offset;
                        if (limit)
                            return " LIMIT " + limit;
                        if (offset)
                            throw new OffsetWithoutLimitNotSupportedError_1.OffsetWithoutLimitNotSupportedError("MySQL");
                    }
                    else if (this.connection.driver instanceof AbstractSqliteDriver_4.AbstractSqliteDriver) {
                        if (limit && offset)
                            return " LIMIT " + limit + " OFFSET " + offset;
                        if (limit)
                            return " LIMIT " + limit;
                        if (offset)
                            return " LIMIT -1 OFFSET " + offset;
                    }
                    else {
                        if (limit && offset)
                            return " LIMIT " + limit + " OFFSET " + offset;
                        if (limit)
                            return " LIMIT " + limit;
                        if (offset)
                            return " OFFSET " + offset;
                    }
                    return "";
                };
                /**
                 * Creates "LOCK" part of SQL query.
                 */
                SelectQueryBuilder.prototype.createLockExpression = function () {
                    switch (this.expressionMap.lockMode) {
                        case "pessimistic_read":
                            if (this.connection.driver instanceof MysqlDriver_3.MysqlDriver) {
                                return " LOCK IN SHARE MODE";
                            }
                            else if (this.connection.driver instanceof PostgresDriver_4.PostgresDriver) {
                                return " FOR SHARE";
                            }
                            else if (this.connection.driver instanceof SqlServerDriver_4.SqlServerDriver) {
                                return "";
                            }
                            else {
                                throw new LockNotSupportedOnGivenDriverError_1.LockNotSupportedOnGivenDriverError();
                            }
                        case "pessimistic_write":
                            if (this.connection.driver instanceof MysqlDriver_3.MysqlDriver || this.connection.driver instanceof PostgresDriver_4.PostgresDriver) {
                                return " FOR UPDATE";
                            }
                            else if (this.connection.driver instanceof SqlServerDriver_4.SqlServerDriver) {
                                return "";
                            }
                            else {
                                throw new LockNotSupportedOnGivenDriverError_1.LockNotSupportedOnGivenDriverError();
                            }
                        default:
                            return "";
                    }
                };
                /**
                 * Creates "HAVING" part of SQL query.
                 */
                SelectQueryBuilder.prototype.createHavingExpression = function () {
                    var _this = this;
                    if (!this.expressionMap.havings || !this.expressionMap.havings.length)
                        return "";
                    var conditions = this.expressionMap.havings.map(function (having, index) {
                        switch (having.type) {
                            case "and":
                                return (index > 0 ? "AND " : "") + _this.replacePropertyNames(having.condition);
                            case "or":
                                return (index > 0 ? "OR " : "") + _this.replacePropertyNames(having.condition);
                            default:
                                return _this.replacePropertyNames(having.condition);
                        }
                    }).join(" ");
                    if (!conditions.length)
                        return "";
                    return " HAVING " + conditions;
                };
                SelectQueryBuilder.prototype.buildEscapedEntityColumnSelects = function (aliasName, metadata) {
                    var _this = this;
                    var hasMainAlias = this.expressionMap.selects.some(function (select) { return select.selection === aliasName; });
                    var columns = [];
                    if (hasMainAlias) {
                        columns.push.apply(columns, metadata.columns.filter(function (column) { return column.isSelect === true; }));
                    }
                    columns.push.apply(columns, metadata.columns.filter(function (column) {
                        return _this.expressionMap.selects.some(function (select) { return select.selection === aliasName + "." + column.propertyName; });
                    }));
                    // if user used partial selection and did not select some primary columns which are required to be selected
                    // we select those primary columns and mark them as "virtual". Later virtual column values will be removed from final entity
                    // to make entity contain exactly what user selected
                    var nonSelectedPrimaryColumns = this.expressionMap.queryEntity ? metadata.primaryColumns.filter(function (primaryColumn) { return columns.indexOf(primaryColumn) === -1; }) : [];
                    var allColumns = columns.concat(nonSelectedPrimaryColumns);
                    return allColumns.map(function (column) {
                        var selection = _this.expressionMap.selects.find(function (select) { return select.selection === aliasName + "." + column.propertyName; });
                        return {
                            selection: _this.escape(aliasName) + "." + _this.escape(column.databaseName),
                            aliasName: selection && selection.aliasName ? selection.aliasName : aliasName + "_" + column.databaseName,
                            // todo: need to keep in mind that custom selection.aliasName breaks hydrator. fix it later!
                            virtual: selection ? selection.virtual === true : (hasMainAlias ? false : true),
                        };
                    });
                };
                SelectQueryBuilder.prototype.findEntityColumnSelects = function (aliasName, metadata) {
                    var mainSelect = this.expressionMap.selects.find(function (select) { return select.selection === aliasName; });
                    if (mainSelect)
                        return [mainSelect];
                    return this.expressionMap.selects.filter(function (select) {
                        return metadata.columns.some(function (column) { return select.selection === aliasName + "." + column.propertyName; });
                    });
                };
                SelectQueryBuilder.prototype.executeCountQuery = function (queryRunner) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var mainAlias, metadata, distinctAlias, countSql, results;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    this.expressionMap.queryEntity = false;
                                    mainAlias = this.expressionMap.mainAlias.name;
                                    metadata = this.expressionMap.mainAlias.metadata;
                                    distinctAlias = this.escape(mainAlias);
                                    countSql = "";
                                    if (metadata.hasMultiplePrimaryKeys) {
                                        if (this.connection.driver instanceof AbstractSqliteDriver_4.AbstractSqliteDriver) {
                                            countSql = "COUNT(DISTINCT(" + metadata.primaryColumns.map(function (primaryColumn, index) {
                                                var propertyName = _this.escape(primaryColumn.databaseName);
                                                return distinctAlias + "." + propertyName;
                                            }).join(" || ") + ")) as \"cnt\"";
                                        }
                                        else {
                                            countSql = "COUNT(DISTINCT(CONCAT(" + metadata.primaryColumns.map(function (primaryColumn, index) {
                                                var propertyName = _this.escape(primaryColumn.databaseName);
                                                return distinctAlias + "." + propertyName;
                                            }).join(", ") + "))) as \"cnt\"";
                                        }
                                    }
                                    else {
                                        countSql = "COUNT(DISTINCT(" + metadata.primaryColumns.map(function (primaryColumn, index) {
                                            var propertyName = _this.escape(primaryColumn.databaseName);
                                            return distinctAlias + "." + propertyName;
                                        }).join(", ") + ")) as \"cnt\"";
                                    }
                                    return [4 /*yield*/, this.clone()
                                            .mergeExpressionMap({ ignoreParentTablesJoins: true })
                                            .orderBy()
                                            .groupBy()
                                            .offset(undefined)
                                            .limit(undefined)
                                            .skip(undefined)
                                            .take(undefined)
                                            .select(countSql)
                                            .loadRawResults(queryRunner)];
                                case 1:
                                    results = _a.sent();
                                    if (!results || !results[0] || !results[0]["cnt"])
                                        return [2 /*return*/, 0];
                                    return [2 /*return*/, parseInt(results[0]["cnt"])];
                            }
                        });
                    });
                };
                /**
                 * Executes sql generated by query builder and returns object with raw results and entities created from them.
                 */
                SelectQueryBuilder.prototype.executeEntitiesAndRawResults = function (queryRunner) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var metadata, broadcaster, relationIdLoader, relationCountLoader, relationIdMetadataTransformer, relationCountMetadataTransformer, rawResults, entities, _a, selects, orderBys_1, metadata_1, mainAliasName_1, querySelects, condition, parameters_6, ids, areAllNumbers, rawRelationIdResults, rawRelationCountResults, transformer;
                        return __generator(this, function (_b) {
                            switch (_b.label) {
                                case 0:
                                    if (!this.expressionMap.mainAlias)
                                        throw new Error("Alias is not set. Use \"from\" method to set an alias.");
                                    if ((this.expressionMap.lockMode === "pessimistic_read" || this.expressionMap.lockMode === "pessimistic_write") && !queryRunner.isTransactionActive)
                                        throw new PessimisticLockTransactionRequiredError_1.PessimisticLockTransactionRequiredError();
                                    if (this.expressionMap.lockMode === "optimistic") {
                                        metadata = this.expressionMap.mainAlias.metadata;
                                        if (!metadata.versionColumn && !metadata.updateDateColumn)
                                            throw new NoVersionOrUpdateDateColumnError_1.NoVersionOrUpdateDateColumnError(metadata.name);
                                    }
                                    broadcaster = new Broadcaster_2.Broadcaster(this.connection);
                                    relationIdLoader = new RelationIdLoader_1.RelationIdLoader(this.connection, queryRunner, this.expressionMap.relationIdAttributes);
                                    relationCountLoader = new RelationCountLoader_1.RelationCountLoader(this.connection, queryRunner, this.expressionMap.relationCountAttributes);
                                    relationIdMetadataTransformer = new RelationIdMetadataToAttributeTransformer_1.RelationIdMetadataToAttributeTransformer(this.expressionMap);
                                    relationIdMetadataTransformer.transform();
                                    relationCountMetadataTransformer = new RelationCountMetadataToAttributeTransformer_1.RelationCountMetadataToAttributeTransformer(this.expressionMap);
                                    relationCountMetadataTransformer.transform();
                                    rawResults = [], entities = [];
                                    if (!((this.expressionMap.skip || this.expressionMap.take) && this.expressionMap.joinAttributes.length > 0)) return [3 /*break*/, 4];
                                    _a = this.createOrderByCombinedWithSelectExpression("distinctAlias"), selects = _a[0], orderBys_1 = _a[1];
                                    metadata_1 = this.expressionMap.mainAlias.metadata;
                                    mainAliasName_1 = this.expressionMap.mainAlias.name;
                                    querySelects = metadata_1.primaryColumns.map(function (primaryColumn) {
                                        var distinctAlias = _this.escape("distinctAlias");
                                        var columnAlias = _this.escape(mainAliasName_1 + "_" + primaryColumn.databaseName);
                                        if (!orderBys_1[columnAlias]) // make sure we aren't overriding user-defined order in inverse direction
                                            orderBys_1[columnAlias] = "ASC";
                                        return distinctAlias + "." + columnAlias + " as \"ids_" + (mainAliasName_1 + "_" + primaryColumn.databaseName) + "\"";
                                    });
                                    return [4 /*yield*/, new SelectQueryBuilder(this.connection, queryRunner)
                                            .select("DISTINCT " + querySelects.join(", "))
                                            .addSelect(selects)
                                            .from("(" + this.clone().orderBy().groupBy().getQuery() + ")", "distinctAlias")
                                            .offset(this.expressionMap.skip)
                                            .limit(this.expressionMap.take)
                                            .orderBy(orderBys_1)
                                            .cache(this.expressionMap.cache ? this.expressionMap.cache : this.expressionMap.cacheId, this.expressionMap.cacheDuration)
                                            .setParameters(this.getParameters())
                                            .getRawMany()];
                                case 1:
                                    rawResults = _b.sent();
                                    if (!(rawResults.length > 0)) return [3 /*break*/, 3];
                                    condition = "";
                                    parameters_6 = {};
                                    if (metadata_1.hasMultiplePrimaryKeys) {
                                        condition = rawResults.map(function (result, index) {
                                            return metadata_1.primaryColumns.map(function (primaryColumn) {
                                                parameters_6["ids_" + index + "_" + primaryColumn.propertyName] = result["ids_" + mainAliasName_1 + "_" + primaryColumn.databaseName];
                                                return mainAliasName_1 + "." + primaryColumn.propertyName + "=:ids_" + index + "_" + primaryColumn.databaseName;
                                            }).join(" AND ");
                                        }).join(" OR ");
                                    }
                                    else {
                                        ids = rawResults.map(function (result) { return result["ids_" + mainAliasName_1 + "_" + metadata_1.primaryColumns[0].databaseName]; });
                                        areAllNumbers = ids.every(function (id) { return typeof id === "number"; });
                                        if (areAllNumbers) {
                                            // fixes #190. if all numbers then its safe to perform query without parameter
                                            condition = mainAliasName_1 + "." + metadata_1.primaryColumns[0].propertyName + " IN (" + ids.join(", ") + ")";
                                        }
                                        else {
                                            parameters_6["ids"] = ids;
                                            condition = mainAliasName_1 + "." + metadata_1.primaryColumns[0].propertyName + " IN (:ids)";
                                        }
                                    }
                                    return [4 /*yield*/, this.clone()
                                            .mergeExpressionMap({ extraAppendedAndWhereCondition: condition })
                                            .setParameters(parameters_6)
                                            .loadRawResults(queryRunner)];
                                case 2:
                                    rawResults = _b.sent();
                                    _b.label = 3;
                                case 3: return [3 /*break*/, 6];
                                case 4: return [4 /*yield*/, this.loadRawResults(queryRunner)];
                                case 5:
                                    rawResults = _b.sent();
                                    _b.label = 6;
                                case 6:
                                    if (!(rawResults.length > 0)) return [3 /*break*/, 10];
                                    return [4 /*yield*/, relationIdLoader.load(rawResults)];
                                case 7:
                                    rawRelationIdResults = _b.sent();
                                    return [4 /*yield*/, relationCountLoader.load(rawResults)];
                                case 8:
                                    rawRelationCountResults = _b.sent();
                                    transformer = new RawSqlResultsToEntityTransformer_1.RawSqlResultsToEntityTransformer(this.expressionMap, this.connection.driver, rawRelationIdResults, rawRelationCountResults);
                                    entities = transformer.transform(rawResults, this.expressionMap.mainAlias);
                                    if (!this.expressionMap.mainAlias.hasMetadata) return [3 /*break*/, 10];
                                    return [4 /*yield*/, broadcaster.broadcastLoadEventsForAll(this.expressionMap.mainAlias.target, entities)];
                                case 9:
                                    _b.sent();
                                    _b.label = 10;
                                case 10: return [2 /*return*/, {
                                        raw: rawResults,
                                        entities: entities,
                                    }];
                            }
                        });
                    });
                };
                SelectQueryBuilder.prototype.createOrderByCombinedWithSelectExpression = function (parentAlias) {
                    var _this = this;
                    // if table has a default order then apply it
                    var orderBys = this.expressionMap.allOrderBys;
                    var selectString = Object.keys(orderBys)
                        .map(function (orderCriteria) {
                        if (orderCriteria.indexOf(".") !== -1) {
                            var _a = orderCriteria.split("."), aliasName = _a[0], propertyPath = _a[1];
                            var alias = _this.expressionMap.findAliasByName(aliasName);
                            var column = alias.metadata.findColumnWithPropertyName(propertyPath);
                            return _this.escape(parentAlias) + "." + _this.escape(aliasName + "_" + column.databaseName);
                        }
                        else {
                            if (_this.expressionMap.selects.find(function (select) { return select.selection === orderCriteria || select.aliasName === orderCriteria; }))
                                return _this.escape(parentAlias) + "." + orderCriteria;
                            return "";
                        }
                    })
                        .join(", ");
                    var orderByObject = {};
                    Object.keys(orderBys).forEach(function (orderCriteria) {
                        if (orderCriteria.indexOf(".") !== -1) {
                            var _a = orderCriteria.split("."), aliasName = _a[0], propertyPath = _a[1];
                            var alias = _this.expressionMap.findAliasByName(aliasName);
                            var column = alias.metadata.findColumnWithPropertyName(propertyPath);
                            orderByObject[_this.escape(parentAlias) + "." + _this.escape(aliasName + "_" + column.databaseName)] = orderBys[orderCriteria];
                        }
                        else {
                            if (_this.expressionMap.selects.find(function (select) { return select.selection === orderCriteria || select.aliasName === orderCriteria; })) {
                                orderByObject[_this.escape(parentAlias) + "." + orderCriteria] = orderBys[orderCriteria];
                            }
                            else {
                                orderByObject[orderCriteria] = orderBys[orderCriteria];
                            }
                        }
                    });
                    return [selectString, orderByObject];
                };
                /**
                 * Loads raw results from the database.
                 */
                SelectQueryBuilder.prototype.loadRawResults = function (queryRunner) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _a, sql, parameters, cacheOptions, savedQueryResultCacheOptions, results;
                        return __generator(this, function (_b) {
                            switch (_b.label) {
                                case 0:
                                    _a = this.getQueryAndParameters(), sql = _a[0], parameters = _a[1];
                                    cacheOptions = typeof this.connection.options.cache === "object" ? this.connection.options.cache : {};
                                    savedQueryResultCacheOptions = undefined;
                                    if (!(this.connection.queryResultCache && (this.expressionMap.cache || cacheOptions.alwaysEnabled))) return [3 /*break*/, 2];
                                    return [4 /*yield*/, this.connection.queryResultCache.getFromCache({
                                            identifier: this.expressionMap.cacheId,
                                            query: this.getSql(),
                                            duration: this.expressionMap.cacheDuration || cacheOptions.duration || 1000
                                        }, queryRunner)];
                                case 1:
                                    savedQueryResultCacheOptions = _b.sent();
                                    if (savedQueryResultCacheOptions && !this.connection.queryResultCache.isExpired(savedQueryResultCacheOptions))
                                        return [2 /*return*/, JSON.parse(savedQueryResultCacheOptions.result)];
                                    _b.label = 2;
                                case 2: return [4 /*yield*/, queryRunner.query(sql, parameters)];
                                case 3:
                                    results = _b.sent();
                                    if (!(this.connection.queryResultCache && (this.expressionMap.cache || cacheOptions.alwaysEnabled))) return [3 /*break*/, 5];
                                    return [4 /*yield*/, this.connection.queryResultCache.storeInCache({
                                            identifier: this.expressionMap.cacheId,
                                            query: this.getSql(),
                                            time: new Date().getTime(),
                                            duration: this.expressionMap.cacheDuration || cacheOptions.duration || 1000,
                                            result: JSON.stringify(results)
                                        }, savedQueryResultCacheOptions, queryRunner)];
                                case 4:
                                    _b.sent();
                                    _b.label = 5;
                                case 5: return [2 /*return*/, results];
                            }
                        });
                    });
                };
                /**
                 * Merges into expression map given expression map properties.
                 */
                SelectQueryBuilder.prototype.mergeExpressionMap = function (expressionMap) {
                    Object.assign(this.expressionMap, expressionMap);
                    return this;
                };
                /**
                 * Normalizes a give number - converts to int if possible.
                 */
                SelectQueryBuilder.prototype.normalizeNumber = function (num) {
                    if (typeof num === "number" || num === undefined || num === null)
                        return num;
                    return Number(num);
                };
                /**
                 * Creates a query builder used to execute sql queries inside this query builder.
                 */
                SelectQueryBuilder.prototype.obtainQueryRunner = function () {
                    return this.queryRunner || this.connection.createQueryRunner("slave");
                };
                return SelectQueryBuilder;
            }(QueryBuilder_5.QueryBuilder));
            exports_148("SelectQueryBuilder", SelectQueryBuilder);
        }
    };
});
System.register("typeorm/metadata-args/RelationIdMetadataArgs", [], function (exports_149, context_149) {
    "use strict";
    var __moduleName = context_149 && context_149.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/metadata/RelationIdMetadata", [], function (exports_150, context_150) {
    "use strict";
    var __moduleName = context_150 && context_150.id;
    var RelationIdMetadata;
    return {
        setters: [],
        execute: function () {
            /**
             * Contains all information about entity's relation count.
             */
            RelationIdMetadata = /** @class */ (function () {
                // ---------------------------------------------------------------------
                // Constructor
                // ---------------------------------------------------------------------
                function RelationIdMetadata(options) {
                    this.entityMetadata = options.entityMetadata;
                    this.target = options.args.target;
                    this.propertyName = options.args.propertyName;
                    this.relationNameOrFactory = options.args.relation;
                    this.alias = options.args.alias;
                    this.queryBuilderFactory = options.args.queryBuilderFactory;
                }
                // ---------------------------------------------------------------------
                // Public Methods
                // ---------------------------------------------------------------------
                /**
                 * Sets relation id value from the given entity.
                 *
                 * todo: make it to work in embeds as well.
                 */
                RelationIdMetadata.prototype.setValue = function (entity) {
                    var _this = this;
                    var inverseEntity = this.relation.getEntityValue(entity);
                    if (inverseEntity instanceof Array) {
                        entity[this.propertyName] = inverseEntity.map(function (item) {
                            return _this.relation.inverseEntityMetadata.getEntityIdMixedMap(item);
                        }).filter(function (item) { return item !== null && item !== undefined; });
                    }
                    else {
                        var value = this.relation.inverseEntityMetadata.getEntityIdMixedMap(inverseEntity);
                        if (value !== undefined)
                            entity[this.propertyName] = value;
                    }
                };
                // ---------------------------------------------------------------------
                // Public Builder Methods
                // ---------------------------------------------------------------------
                /**
                 * Builds some depend relation id properties.
                 * This builder method should be used only after entity metadata, its properties map and all relations are build.
                 */
                RelationIdMetadata.prototype.build = function () {
                    var propertyPath = this.relationNameOrFactory instanceof Function ? this.relationNameOrFactory(this.entityMetadata.propertiesMap) : this.relationNameOrFactory;
                    var relation = this.entityMetadata.findRelationWithPropertyPath(propertyPath);
                    if (!relation)
                        throw new Error("Cannot find relation " + propertyPath + ". Wrong relation specified for @RelationId decorator.");
                    this.relation = relation;
                };
                return RelationIdMetadata;
            }());
            exports_150("RelationIdMetadata", RelationIdMetadata);
        }
    };
});
System.register("typeorm/metadata-args/EntityListenerMetadataArgs", [], function (exports_151, context_151) {
    "use strict";
    var __moduleName = context_151 && context_151.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/metadata/EntityListenerMetadata", [], function (exports_152, context_152) {
    "use strict";
    var __moduleName = context_152 && context_152.id;
    var EntityListenerMetadata;
    return {
        setters: [],
        execute: function () {
            /**
             * This metadata contains all information about entity's listeners.
             */
            EntityListenerMetadata = /** @class */ (function () {
                // ---------------------------------------------------------------------
                // Constructor
                // ---------------------------------------------------------------------
                function EntityListenerMetadata(options) {
                    this.entityMetadata = options.entityMetadata;
                    this.embeddedMetadata = options.embeddedMetadata;
                    this.target = options.args.target;
                    this.propertyName = options.args.propertyName;
                    this.type = options.args.type;
                }
                // ---------------------------------------------------------------------
                // Public Methods
                // ---------------------------------------------------------------------
                /**
                 * Checks if entity listener is allowed to be executed on the given entity.
                 */
                EntityListenerMetadata.prototype.isAllowed = function (entity) {
                    return this.entityMetadata.target === entity.constructor || // todo: .constructor won't work for entity schemas, but there are no entity listeners in schemas since there are no objects, right?
                        (this.entityMetadata.target instanceof Function && entity.constructor.prototype instanceof this.entityMetadata.target); // todo: also need to implement entity schema inheritance
                };
                /**
                 * Executes listener method of the given entity.
                 */
                EntityListenerMetadata.prototype.execute = function (entity) {
                    if (!this.embeddedMetadata)
                        return entity[this.propertyName]();
                    this.callEntityEmbeddedMethod(entity, this.embeddedMetadata.propertyPath.split("."));
                };
                // ---------------------------------------------------------------------
                // Protected Methods
                // ---------------------------------------------------------------------
                /**
                 * Calls embedded entity listener method no matter how nested it is.
                 */
                EntityListenerMetadata.prototype.callEntityEmbeddedMethod = function (entity, propertyPaths) {
                    var propertyPath = propertyPaths.shift();
                    if (!propertyPath)
                        return;
                    if (propertyPaths.length === 0) {
                        entity[propertyPath][this.propertyName]();
                    }
                    else {
                        if (entity[propertyPath])
                            this.callEntityEmbeddedMethod(entity[propertyPath], propertyPaths);
                    }
                };
                return EntityListenerMetadata;
            }());
            exports_152("EntityListenerMetadata", EntityListenerMetadata);
        }
    };
});
System.register("typeorm/metadata/EmbeddedMetadata", ["typeorm/driver/mongodb/MongoDriver"], function (exports_153, context_153) {
    "use strict";
    var __moduleName = context_153 && context_153.id;
    var MongoDriver_5, EmbeddedMetadata;
    return {
        setters: [
            function (MongoDriver_5_1) {
                MongoDriver_5 = MongoDriver_5_1;
            }
        ],
        execute: function () {
            /**
             * Contains all information about entity's embedded property.
             */
            EmbeddedMetadata = /** @class */ (function () {
                // ---------------------------------------------------------------------
                // Constructor
                // ---------------------------------------------------------------------
                function EmbeddedMetadata(options) {
                    /**
                     * Columns inside this embed.
                     */
                    this.columns = [];
                    /**
                     * Relations inside this embed.
                     */
                    this.relations = [];
                    /**
                     * Entity listeners inside this embed.
                     */
                    this.listeners = [];
                    /**
                     * Indices applied to the embed columns.
                     */
                    this.indices = [];
                    /**
                     * Relation ids inside this embed.
                     */
                    this.relationIds = [];
                    /**
                     * Relation counts inside this embed.
                     */
                    this.relationCounts = [];
                    /**
                     * Nested embeddable in this embeddable (which has current embedded as parent embedded).
                     */
                    this.embeddeds = [];
                    /**
                     * Indicates if this embedded is in array mode.
                     *
                     * This option works only in monogodb.
                     */
                    this.isArray = false;
                    /**
                     * Returns array of property names of current embed and all its parent embeds.
                     *
                     * example: post[data][information][counters].id where "data", "information" and "counters" are embeds
                     * we need to get value of "id" column from the post real entity object.
                     * this method will return ["data", "information", "counters"]
                     */
                    this.parentPropertyNames = [];
                    /**
                     * Returns array of prefixes of current embed and all its parent embeds.
                     */
                    this.parentPrefixes = [];
                    /**
                     * Returns embed metadatas from all levels of the parent tree.
                     *
                     * example: post[data][information][counters].id where "data", "information" and "counters" are embeds
                     * this method will return [embed metadata of data, embed metadata of information, embed metadata of counters]
                     */
                    this.embeddedMetadataTree = [];
                    /**
                     * Embed metadatas from all levels of the parent tree.
                     *
                     * example: post[data][information][counters].id where "data", "information" and "counters" are embeds
                     * this method will return [embed metadata of data, embed metadata of information, embed metadata of counters]
                     */
                    this.columnsFromTree = [];
                    /**
                     * Relations of this embed and all relations from its child embeds.
                     */
                    this.relationsFromTree = [];
                    /**
                     * Relations of this embed and all relations from its child embeds.
                     */
                    this.listenersFromTree = [];
                    /**
                     * Indices of this embed and all indices from its child embeds.
                     */
                    this.indicesFromTree = [];
                    /**
                     * Relation ids of this embed and all relation ids from its child embeds.
                     */
                    this.relationIdsFromTree = [];
                    /**
                     * Relation counts of this embed and all relation counts from its child embeds.
                     */
                    this.relationCountsFromTree = [];
                    this.entityMetadata = options.entityMetadata;
                    this.type = options.args.type();
                    this.propertyName = options.args.propertyName;
                    this.customPrefix = options.args.prefix;
                    this.isArray = options.args.isArray;
                }
                // ---------------------------------------------------------------------
                // Public Methods
                // ---------------------------------------------------------------------
                /**
                 * Creates a new embedded object.
                 */
                EmbeddedMetadata.prototype.create = function () {
                    return new this.type;
                };
                // ---------------------------------------------------------------------
                // Builder Methods
                // ---------------------------------------------------------------------
                EmbeddedMetadata.prototype.build = function (connection) {
                    this.embeddeds.forEach(function (embedded) { return embedded.build(connection); });
                    this.prefix = this.buildPrefix(connection);
                    this.parentPropertyNames = this.buildParentPropertyNames();
                    this.parentPrefixes = this.buildParentPrefixes();
                    this.propertyPath = this.parentPropertyNames.join(".");
                    this.embeddedMetadataTree = this.buildEmbeddedMetadataTree();
                    this.columnsFromTree = this.buildColumnsFromTree();
                    this.relationsFromTree = this.buildRelationsFromTree();
                    this.listenersFromTree = this.buildListenersFromTree();
                    this.indicesFromTree = this.buildIndicesFromTree();
                    this.relationIdsFromTree = this.buildRelationIdsFromTree();
                    this.relationCountsFromTree = this.buildRelationCountsFromTree();
                    return this;
                };
                // ---------------------------------------------------------------------
                // Protected Methods
                // ---------------------------------------------------------------------
                EmbeddedMetadata.prototype.buildPrefix = function (connection) {
                    if (connection.driver instanceof MongoDriver_5.MongoDriver)
                        return this.propertyName;
                    var prefixes = [];
                    if (this.parentEmbeddedMetadata)
                        prefixes.push(this.parentEmbeddedMetadata.buildPrefix(connection));
                    if (this.customPrefix === undefined) {
                        prefixes.push(this.propertyName);
                    }
                    else if (typeof this.customPrefix === "string") {
                        prefixes.push(this.customPrefix);
                    }
                    return prefixes.join("_"); // todo: use naming strategy instead of "_"  !!!
                };
                EmbeddedMetadata.prototype.buildParentPropertyNames = function () {
                    return this.parentEmbeddedMetadata ? this.parentEmbeddedMetadata.buildParentPropertyNames().concat(this.propertyName) : [this.propertyName];
                };
                EmbeddedMetadata.prototype.buildParentPrefixes = function () {
                    return [this.prefix || this.propertyName];
                };
                EmbeddedMetadata.prototype.buildEmbeddedMetadataTree = function () {
                    return this.parentEmbeddedMetadata ? this.parentEmbeddedMetadata.buildEmbeddedMetadataTree().concat(this) : [this];
                };
                EmbeddedMetadata.prototype.buildColumnsFromTree = function () {
                    return this.embeddeds.reduce(function (columns, embedded) { return columns.concat(embedded.buildColumnsFromTree()); }, this.columns);
                };
                EmbeddedMetadata.prototype.buildRelationsFromTree = function () {
                    return this.embeddeds.reduce(function (relations, embedded) { return relations.concat(embedded.buildRelationsFromTree()); }, this.relations);
                };
                EmbeddedMetadata.prototype.buildListenersFromTree = function () {
                    return this.embeddeds.reduce(function (relations, embedded) { return relations.concat(embedded.buildListenersFromTree()); }, this.listeners);
                };
                EmbeddedMetadata.prototype.buildIndicesFromTree = function () {
                    return this.embeddeds.reduce(function (relations, embedded) { return relations.concat(embedded.buildIndicesFromTree()); }, this.indices);
                };
                EmbeddedMetadata.prototype.buildRelationIdsFromTree = function () {
                    return this.embeddeds.reduce(function (relations, embedded) { return relations.concat(embedded.buildRelationIdsFromTree()); }, this.relationIds);
                };
                EmbeddedMetadata.prototype.buildRelationCountsFromTree = function () {
                    return this.embeddeds.reduce(function (relations, embedded) { return relations.concat(embedded.buildRelationCountsFromTree()); }, this.relationCounts);
                };
                return EmbeddedMetadata;
            }());
            exports_153("EmbeddedMetadata", EmbeddedMetadata);
        }
    };
});
System.register("typeorm/decorator/options/RelationOptions", [], function (exports_154, context_154) {
    "use strict";
    var __moduleName = context_154 && context_154.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/metadata/types/PropertyTypeInFunction", [], function (exports_155, context_155) {
    "use strict";
    var __moduleName = context_155 && context_155.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/metadata/types/RelationTypeInFunction", [], function (exports_156, context_156) {
    "use strict";
    var __moduleName = context_156 && context_156.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/metadata-args/RelationMetadataArgs", [], function (exports_157, context_157) {
    "use strict";
    var __moduleName = context_157 && context_157.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/metadata/RelationMetadata", [], function (exports_158, context_158) {
    "use strict";
    var __moduleName = context_158 && context_158.id;
    var RelationMetadata;
    return {
        setters: [],
        execute: function () {
            /**
             * Contains all information about some entity's relation.
             */
            RelationMetadata = /** @class */ (function () {
                // ---------------------------------------------------------------------
                // Constructor
                // ---------------------------------------------------------------------
                function RelationMetadata(options) {
                    /**
                     * Indicates if this is a parent (can be only many-to-one relation) relation in the tree tables.
                     */
                    this.isTreeParent = false;
                    /**
                     * Indicates if this is a children (can be only one-to-many relation) relation in the tree tables.
                     */
                    this.isTreeChildren = false;
                    /**
                     * Indicates if this relation's column is a primary key.
                     * Can be used only for many-to-one and owner one-to-one relations.
                     */
                    this.isPrimary = false;
                    /**
                     * Indicates if this relation is lazily loaded.
                     */
                    this.isLazy = false;
                    /**
                     * Indicates if this relation is eagerly loaded.
                     */
                    this.isEager = false;
                    /**
                     * If set to true then related objects are allowed to be inserted to the database.
                     */
                    this.isCascadeInsert = false;
                    /**
                     * If set to true then related objects are allowed to be updated in the database.
                     */
                    this.isCascadeUpdate = false;
                    /**
                     * If set to true then related objects are allowed to be remove from the database.
                     */
                    this.isCascadeRemove = false;
                    /**
                     * Indicates if relation column value can be nullable or not.
                     */
                    this.isNullable = true;
                    /**
                     * Indicates if this side is an owner of this relation.
                     */
                    this.isOwning = false;
                    /**
                     * Checks if this relation's type is "one-to-one".
                     */
                    this.isOneToOne = false;
                    /**
                     * Checks if this relation is owner side of the "one-to-one" relation.
                     * Owner side means this side of relation has a join column in the table.
                     */
                    this.isOneToOneOwner = false;
                    /**
                     * Checks if this relation has a join column (e.g. is it many-to-one or one-to-one owner side).
                     */
                    this.isWithJoinColumn = false;
                    /**
                     * Checks if this relation is NOT owner side of the "one-to-one" relation.
                     * NOT owner side means this side of relation does not have a join column in the table.
                     */
                    this.isOneToOneNotOwner = false;
                    /**
                     * Checks if this relation's type is "one-to-many".
                     */
                    this.isOneToMany = false;
                    /**
                     * Checks if this relation's type is "many-to-one".
                     */
                    this.isManyToOne = false;
                    /**
                     * Checks if this relation's type is "many-to-many".
                     */
                    this.isManyToMany = false;
                    /**
                     * Checks if this relation's type is "many-to-many", and is owner side of the relationship.
                     * Owner side means this side of relation has a join table.
                     */
                    this.isManyToManyOwner = false;
                    /**
                     * Checks if this relation's type is "many-to-many", and is NOT owner side of the relationship.
                     * Not owner side means this side of relation does not have a join table.
                     */
                    this.isManyToManyNotOwner = false;
                    /**
                     * Foreign keys created for this relation.
                     */
                    this.foreignKeys = [];
                    /**
                     * Join table columns.
                     * Join columns can be obtained only from owner side of the relation.
                     * From non-owner side of the relation join columns will be empty.
                     * If this relation is a many-to-one/one-to-one then it takes join columns from the current entity.
                     * If this relation is many-to-many then it takes all owner join columns from the junction entity.
                     */
                    this.joinColumns = [];
                    /**
                     * Inverse join table columns.
                     * Inverse join columns are supported only for many-to-many relations
                     * and can be obtained only from owner side of the relation.
                     * From non-owner side of the relation join columns will be undefined.
                     */
                    this.inverseJoinColumns = [];
                    this.entityMetadata = options.entityMetadata;
                    this.embeddedMetadata = options.embeddedMetadata;
                    var args = options.args;
                    this.target = args.target;
                    this.propertyName = args.propertyName;
                    this.relationType = args.relationType;
                    if (args.inverseSideProperty)
                        this.givenInverseSidePropertyFactory = args.inverseSideProperty;
                    this.isLazy = args.isLazy || false;
                    this.isCascadeInsert = args.options.cascadeInsert || args.options.cascadeAll || false;
                    this.isCascadeUpdate = args.options.cascadeUpdate || args.options.cascadeAll || false;
                    this.isCascadeRemove = args.options.cascadeRemove || args.options.cascadeAll || false;
                    this.isNullable = args.options.nullable === false || this.isPrimary ? false : true;
                    this.onDelete = args.options.onDelete;
                    this.isPrimary = args.options.primary || false;
                    this.isEager = args.options.eager || false;
                    this.isTreeParent = args.isTreeParent || false;
                    this.isTreeChildren = args.isTreeChildren || false;
                    this.type = args.type instanceof Function ? args.type() : args.type;
                    this.isOneToOne = this.relationType === "one-to-one";
                    this.isOneToMany = this.relationType === "one-to-many";
                    this.isManyToOne = this.relationType === "many-to-one";
                    this.isManyToMany = this.relationType === "many-to-many";
                    this.isOneToOneNotOwner = this.isOneToOne ? true : false;
                    this.isManyToManyNotOwner = this.isManyToMany ? true : false;
                }
                // ---------------------------------------------------------------------
                // Public Methods
                // ---------------------------------------------------------------------
                /**
                 * Extracts column value from the given entity.
                 * If column is in embedded (or recursive embedded) it extracts its value from there.
                 */
                RelationMetadata.prototype.getEntityValue = function (entity) {
                    // extract column value from embeddeds of entity if column is in embedded
                    if (this.embeddedMetadata) {
                        // example: post[data][information][counters].id where "data", "information" and "counters" are embeddeds
                        // we need to get value of "id" column from the post real entity object
                        // first step - we extract all parent properties of the entity relative to this column, e.g. [data, information, counters]
                        var propertyNames = this.embeddedMetadata.parentPropertyNames.slice();
                        // next we need to access post[data][information][counters][this.propertyName] to get column value from the counters
                        // this recursive function takes array of generated property names and gets the post[data][information][counters] embed
                        var extractEmbeddedColumnValue_1 = function (propertyNames, value) {
                            var propertyName = propertyNames.shift();
                            return propertyName ? extractEmbeddedColumnValue_1(propertyNames, value[propertyName]) : value;
                        };
                        // once we get nested embed object we get its column, e.g. post[data][information][counters][this.propertyName]
                        var embeddedObject = extractEmbeddedColumnValue_1(propertyNames, entity);
                        return embeddedObject ? embeddedObject[this.isLazy ? "__" + this.propertyName + "__" : this.propertyName] : undefined;
                    }
                    else { // no embeds - no problems. Simply return column name by property name of the entity
                        return entity[this.isLazy ? "__" + this.propertyName + "__" : this.propertyName];
                    }
                };
                /**
                 * Sets given entity's relation's value.
                 * Using of this method helps to set entity relation's value of the lazy and non-lazy relations.
                 */
                RelationMetadata.prototype.setEntityValue = function (entity, value) {
                    var _this = this;
                    if (this.embeddedMetadata) {
                        // first step - we extract all parent properties of the entity relative to this column, e.g. [data, information, counters]
                        var extractEmbeddedColumnValue_2 = function (embeddedMetadatas, map) {
                            // if (!object[embeddedMetadata.propertyName])
                            //     object[embeddedMetadata.propertyName] = embeddedMetadata.create();
                            var embeddedMetadata = embeddedMetadatas.shift();
                            if (embeddedMetadata) {
                                if (!map[embeddedMetadata.propertyName])
                                    map[embeddedMetadata.propertyName] = embeddedMetadata.create();
                                extractEmbeddedColumnValue_2(embeddedMetadatas, map[embeddedMetadata.propertyName]);
                                return map;
                            }
                            map[_this.propertyName] = value;
                            return map;
                        };
                        return extractEmbeddedColumnValue_2(this.embeddedMetadata.embeddedMetadataTree.slice(), entity);
                    }
                    else {
                        entity[this.propertyName] = value;
                    }
                };
                /**
                 * Creates entity id map from the given entity ids array.
                 */
                RelationMetadata.prototype.createValueMap = function (value) {
                    var _this = this;
                    // extract column value from embeds of entity if column is in embedded
                    if (this.embeddedMetadata) {
                        // example: post[data][information][counters].id where "data", "information" and "counters" are embeddeds
                        // we need to get value of "id" column from the post real entity object and return it in a
                        // { data: { information: { counters: { id: ... } } } } format
                        // first step - we extract all parent properties of the entity relative to this column, e.g. [data, information, counters]
                        var propertyNames = this.embeddedMetadata.parentPropertyNames.slice();
                        // now need to access post[data][information][counters] to get column value from the counters
                        // and on each step we need to create complex literal object, e.g. first { data },
                        // then { data: { information } }, then { data: { information: { counters } } },
                        // then { data: { information: { counters: [this.propertyName]: entity[data][information][counters][this.propertyName] } } }
                        // this recursive function helps doing that
                        var extractEmbeddedColumnValue_3 = function (propertyNames, map) {
                            var propertyName = propertyNames.shift();
                            if (propertyName) {
                                map[propertyName] = {};
                                extractEmbeddedColumnValue_3(propertyNames, map[propertyName]);
                                return map;
                            }
                            map[_this.propertyName] = value;
                            return map;
                        };
                        return extractEmbeddedColumnValue_3(propertyNames, {});
                    }
                    else { // no embeds - no problems. Simply return column property name and its value of the entity
                        return _a = {}, _a[this.propertyName] = value, _a;
                    }
                    var _a;
                };
                // ---------------------------------------------------------------------
                // Builder Methods
                // ---------------------------------------------------------------------
                /**
                 * Builds some depend relation metadata properties.
                 * This builder method should be used only after embedded metadata tree was build.
                 */
                RelationMetadata.prototype.build = function () {
                    this.propertyPath = this.buildPropertyPath();
                };
                /**
                 * Registers given foreign keys in the relation.
                 * This builder method should be used to register foreign key in the relation.
                 */
                RelationMetadata.prototype.registerForeignKeys = function () {
                    var foreignKeys = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        foreignKeys[_i] = arguments[_i];
                    }
                    (_a = this.foreignKeys).push.apply(_a, foreignKeys);
                    this.joinColumns = this.foreignKeys[0] ? this.foreignKeys[0].columns : [];
                    this.inverseJoinColumns = this.foreignKeys[1] ? this.foreignKeys[1].columns : [];
                    this.isOwning = this.isManyToOne || ((this.isManyToMany || this.isOneToOne) && this.joinColumns.length > 0);
                    this.isOneToOneOwner = this.isOneToOne && this.isOwning;
                    this.isOneToOneNotOwner = this.isOneToOne && !this.isOwning;
                    this.isManyToManyOwner = this.isManyToMany && this.isOwning;
                    this.isManyToManyNotOwner = this.isManyToMany && !this.isOwning;
                    this.isWithJoinColumn = this.isManyToOne || this.isOneToOneOwner;
                    var _a;
                };
                /**
                 * Registers a given junction entity metadata.
                 * This builder method can be called after junction entity metadata for the many-to-many relation was created.
                 */
                RelationMetadata.prototype.registerJunctionEntityMetadata = function (junctionEntityMetadata) {
                    this.junctionEntityMetadata = junctionEntityMetadata;
                    this.joinTableName = junctionEntityMetadata.tableName;
                    if (this.inverseRelation) {
                        this.inverseRelation.junctionEntityMetadata = junctionEntityMetadata;
                        this.joinTableName = junctionEntityMetadata.tableName;
                    }
                };
                /**
                 * Builds inverse side property path based on given inverse side property factory.
                 * This builder method should be used only after properties map of the inverse entity metadata was build.
                 */
                RelationMetadata.prototype.buildInverseSidePropertyPath = function () {
                    if (this.givenInverseSidePropertyFactory) {
                        var ownerEntityPropertiesMap = this.inverseEntityMetadata.propertiesMap;
                        if (typeof this.givenInverseSidePropertyFactory === "function")
                            return this.givenInverseSidePropertyFactory(ownerEntityPropertiesMap);
                        if (typeof this.givenInverseSidePropertyFactory === "string")
                            return this.givenInverseSidePropertyFactory;
                    }
                    else if (this.isTreeParent && this.entityMetadata.treeChildrenRelation) {
                        return this.entityMetadata.treeChildrenRelation.propertyName;
                    }
                    else if (this.isTreeChildren && this.entityMetadata.treeParentRelation) {
                        return this.entityMetadata.treeParentRelation.propertyName;
                    }
                    return "";
                };
                /**
                 * Builds relation's property path based on its embedded tree.
                 */
                RelationMetadata.prototype.buildPropertyPath = function () {
                    if (!this.embeddedMetadata || !this.embeddedMetadata.parentPropertyNames.length)
                        return this.propertyName;
                    return this.embeddedMetadata.parentPropertyNames.join(".") + "." + this.propertyName;
                };
                return RelationMetadata;
            }());
            exports_158("RelationMetadata", RelationMetadata);
        }
    };
});
System.register("typeorm/lazy-loading/LazyRelationsWrapper", ["typeorm/query-builder/RelationLoader"], function (exports_159, context_159) {
    "use strict";
    var __moduleName = context_159 && context_159.id;
    var RelationLoader_2, LazyRelationsWrapper;
    return {
        setters: [
            function (RelationLoader_2_1) {
                RelationLoader_2 = RelationLoader_2_1;
            }
        ],
        execute: function () {
            /**
             * Wraps entities and creates getters/setters for their relations
             * to be able to lazily load relations when accessing these relations.
             */
            LazyRelationsWrapper = /** @class */ (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function LazyRelationsWrapper(connection) {
                    this.connection = connection;
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Wraps given entity and creates getters/setters for its given relation
                 * to be able to lazily load data when accessing these relation.
                 */
                LazyRelationsWrapper.prototype.wrap = function (object, relation) {
                    var relationLoader = new RelationLoader_2.RelationLoader(this.connection);
                    var dataIndex = "__" + relation.propertyName + "__"; // in what property of the entity loaded data will be stored
                    var promiseIndex = "__promise_" + relation.propertyName + "__"; // in what property of the entity loading promise will be stored
                    var resolveIndex = "__has_" + relation.propertyName + "__"; // indicates if relation data already was loaded or not, we need this flag if loaded data is empty
                    Object.defineProperty(object, relation.propertyName, {
                        get: function () {
                            var _this = this;
                            if (this[resolveIndex] === true) // if related data already was loaded then simply return it
                                return Promise.resolve(this[dataIndex]);
                            if (this[promiseIndex]) // if related data is loading then return a promise relationLoader loads it
                                return this[promiseIndex];
                            // nothing is loaded yet, load relation data and save it in the model once they are loaded
                            this[promiseIndex] = relationLoader.load(relation, this).then(function (result) {
                                _this[dataIndex] = result;
                                _this[resolveIndex] = true;
                                delete _this[promiseIndex];
                                return _this[dataIndex];
                            }); // .catch((err: any) => { throw err; });
                            return this[promiseIndex];
                        },
                        set: function (promise) {
                            var _this = this;
                            if (promise instanceof Promise) { // if set data is a promise then wait for its resolve and save in the object
                                promise.then(function (result) {
                                    _this[dataIndex] = result;
                                    _this[resolveIndex] = true;
                                });
                            }
                            else { // if its direct data set (non promise, probably not safe-typed)
                                this[dataIndex] = promise;
                                this[resolveIndex] = true;
                            }
                        },
                        configurable: true
                    });
                };
                return LazyRelationsWrapper;
            }());
            exports_159("LazyRelationsWrapper", LazyRelationsWrapper);
        }
    };
});
System.register("typeorm/metadata-args/TableMetadataArgs", [], function (exports_160, context_160) {
    "use strict";
    var __moduleName = context_160 && context_160.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/metadata/EntityMetadata", ["typeorm/lazy-loading/LazyRelationsWrapper", "typeorm/util/OrmUtils", "typeorm/driver/postgres/PostgresDriver", "typeorm/driver/sqlserver/SqlServerDriver"], function (exports_161, context_161) {
    "use strict";
    var __moduleName = context_161 && context_161.id;
    var LazyRelationsWrapper_1, OrmUtils_8, PostgresDriver_5, SqlServerDriver_5, EntityMetadata;
    return {
        setters: [
            function (LazyRelationsWrapper_1_1) {
                LazyRelationsWrapper_1 = LazyRelationsWrapper_1_1;
            },
            function (OrmUtils_8_1) {
                OrmUtils_8 = OrmUtils_8_1;
            },
            function (PostgresDriver_5_1) {
                PostgresDriver_5 = PostgresDriver_5_1;
            },
            function (SqlServerDriver_5_1) {
                SqlServerDriver_5 = SqlServerDriver_5_1;
            }
        ],
        execute: function () {
            /**
             * Contains all entity metadata.
             */
            EntityMetadata = /** @class */ (function () {
                // ---------------------------------------------------------------------
                // Constructor
                // ---------------------------------------------------------------------
                function EntityMetadata(options) {
                    /**
                     * Children entity metadatas. Used in inheritance patterns.
                     */
                    this.childEntityMetadatas = [];
                    /**
                     * Table type. Tables can be abstract, closure, junction, embedded, etc.
                     */
                    this.tableType = "regular";
                    /**
                     * Indicates if this entity metadata of a junction table, or not.
                     * Junction table is a table created by many-to-many relationship.
                     *
                     * Its also possible to understand if entity is junction via tableType.
                     */
                    this.isJunction = false;
                    /**
                     * Entity's column metadatas defined by user.
                     */
                    this.ownColumns = [];
                    /**
                     * Entity's relation metadatas.
                     */
                    this.ownRelations = [];
                    /**
                     * Entity's own listener metadatas.
                     */
                    this.ownListeners = [];
                    /**
                     * Entity's own indices.
                     */
                    this.ownIndices = [];
                    /**
                     * Relations of the entity, including relations that are coming from the embeddeds of this entity.
                     */
                    this.relations = [];
                    /**
                     * List of eager relations this metadata has.
                     */
                    this.eagerRelations = [];
                    /**
                     * List of eager relations this metadata has.
                     */
                    this.lazyRelations = [];
                    /**
                     * Columns of the entity, including columns that are coming from the embeddeds of this entity.
                     */
                    this.columns = [];
                    /**
                     * In the case if this entity metadata is junction table's entity metadata,
                     * this will contain all referenced columns of owner entity.
                     */
                    this.ownerColumns = [];
                    /**
                     * In the case if this entity metadata is junction table's entity metadata,
                     * this will contain all referenced columns of inverse entity.
                     */
                    this.inverseColumns = [];
                    /**
                     * Entity's relation id metadatas.
                     */
                    this.relationIds = [];
                    /**
                     * Entity's relation id metadatas.
                     */
                    this.relationCounts = [];
                    /**
                     * Entity's index metadatas.
                     */
                    this.indices = [];
                    /**
                     * Entity's foreign key metadatas.
                     */
                    this.foreignKeys = [];
                    /**
                     * Entity's embedded metadatas.
                     */
                    this.embeddeds = [];
                    /**
                     * Entity listener metadatas.
                     */
                    this.listeners = [];
                    /**
                     * Gets the column with generated flag.
                     */
                    this.generatedColumns = [];
                    /**
                     * Gets the primary columns.
                     */
                    this.primaryColumns = [];
                    /**
                     * Id columns in the parent table (used in table inheritance).
                     */
                    this.parentIdColumns = [];
                    /**
                     * Gets only one-to-one relations of the entity.
                     */
                    this.oneToOneRelations = [];
                    /**
                     * Gets only owner one-to-one relations of the entity.
                     */
                    this.ownerOneToOneRelations = [];
                    /**
                     * Gets only one-to-many relations of the entity.
                     */
                    this.oneToManyRelations = [];
                    /**
                     * Gets only many-to-one relations of the entity.
                     */
                    this.manyToOneRelations = [];
                    /**
                     * Gets only many-to-many relations of the entity.
                     */
                    this.manyToManyRelations = [];
                    /**
                     * Gets only owner many-to-many relations of the entity.
                     */
                    this.ownerManyToManyRelations = [];
                    /**
                     * Gets only owner one-to-one and many-to-one relations.
                     */
                    this.relationsWithJoinColumns = [];
                    var namingStrategy = options.connection.namingStrategy;
                    var entityPrefix = options.connection.options.entityPrefix;
                    this.lazyRelationsWrapper = new LazyRelationsWrapper_1.LazyRelationsWrapper(options.connection);
                    this.parentClosureEntityMetadata = options.parentClosureEntityMetadata;
                    this.target = options.args.target;
                    this.tableType = options.args.type;
                    this.engine = options.args.engine;
                    this.database = options.args.database;
                    this.schema = options.args.schema || options.connection.options.schema;
                    this.givenTableName = options.args.name;
                    this.skipSync = options.args.skipSync || false;
                    this.targetName = options.args.target instanceof Function ? options.args.target.name : options.args.target;
                    this.tableNameWithoutPrefix = this.tableType === "closure-junction" ? namingStrategy.closureJunctionTableName(this.givenTableName) : namingStrategy.tableName(this.targetName, this.givenTableName);
                    this.tableName = entityPrefix ? namingStrategy.prefixTableName(entityPrefix, this.tableNameWithoutPrefix) : this.tableNameWithoutPrefix;
                    this.target = this.target ? this.target : this.tableName;
                    this.name = this.targetName ? this.targetName : this.tableName;
                    this.tablePath = this.buildTablePath(options.connection.driver);
                    this.schemaPath = this.buildSchemaPath(options.connection.driver);
                    this.isClassTableChild = this.tableType === "class-table-child";
                    this.isSingleTableChild = this.tableType === "single-table-child";
                    this.isEmbeddable = this.tableType === "embeddable";
                    this.isJunction = this.tableType === "closure-junction" || this.tableType === "junction";
                    this.isClosureJunction = this.tableType === "closure-junction";
                    this.isClosure = this.tableType === "closure";
                    this.isAbstract = this.tableType === "abstract";
                    this.isRegular = this.tableType === "regular";
                    this.orderBy = (options.args.orderBy instanceof Function) ? options.args.orderBy(this.propertiesMap) : options.args.orderBy;
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Creates a new entity.
                 */
                EntityMetadata.prototype.create = function () {
                    var _this = this;
                    // if target is set to a function (e.g. class) that can be created then create it
                    if (this.target instanceof Function)
                        return new this.target();
                    // otherwise simply return a new empty object
                    var newObject = {};
                    this.relations
                        .filter(function (relation) { return relation.isLazy; })
                        .forEach(function (relation) { return _this.lazyRelationsWrapper.wrap(newObject, relation); });
                    return newObject;
                };
                /**
                 * Checks if given entity has an id.
                 */
                EntityMetadata.prototype.hasId = function (entity) {
                    if (!entity)
                        return false;
                    return this.primaryColumns.every(function (primaryColumn) {
                        var value = primaryColumn.getEntityValue(entity);
                        return value !== null && value !== undefined && value !== "";
                    });
                };
                /**
                 * Compares ids of the two entities.
                 * Returns true if they match, false otherwise.
                 */
                EntityMetadata.prototype.compareIds = function (firstId, secondId) {
                    if (firstId === undefined || firstId === null || secondId === undefined || secondId === null)
                        return false;
                    return OrmUtils_8.OrmUtils.deepCompare(firstId, secondId);
                };
                /**
                 * Compares two different entity instances by their ids.
                 * Returns true if they match, false otherwise.
                 */
                EntityMetadata.prototype.compareEntities = function (firstEntity, secondEntity) {
                    // if any entity ids are empty then they aren't equal
                    var isFirstEntityEmpty = this.isEntityMapEmpty(firstEntity);
                    var isSecondEntityEmpty = this.isEntityMapEmpty(secondEntity);
                    if (isFirstEntityEmpty || isSecondEntityEmpty)
                        return false;
                    var firstEntityIds = this.getEntityIdMap(firstEntity);
                    var secondEntityIds = this.getEntityIdMap(secondEntity);
                    return this.compareIds(firstEntityIds, secondEntityIds);
                };
                /**
                 * Checks if there is an embedded with a given property path.
                 */
                EntityMetadata.prototype.hasEmbeddedWithPropertyPath = function (propertyPath) {
                    return !!this.findEmbeddedWithPropertyPath(propertyPath);
                };
                /**
                 * Finds embedded with a given property path.
                 */
                EntityMetadata.prototype.findEmbeddedWithPropertyPath = function (propertyPath) {
                    return this.embeddeds.find(function (embedded) {
                        return embedded.propertyPath === propertyPath;
                    });
                };
                /**
                 * Finds column with a given property name.
                 */
                EntityMetadata.prototype.findColumnWithPropertyName = function (propertyName) {
                    return this.columns.find(function (column) { return column.propertyName === propertyName; });
                };
                /**
                 * Finds column with a given property path.
                 */
                EntityMetadata.prototype.findColumnWithPropertyPath = function (propertyPath) {
                    var column = this.columns.find(function (column) { return column.propertyPath === propertyPath; });
                    if (column)
                        return column;
                    // in the case if column with property path was not found, try to find a relation with such property path
                    // if we find relation and it has a single join column then its the column user was seeking
                    var relation = this.relations.find(function (relation) { return relation.propertyPath === propertyPath; });
                    if (relation && relation.joinColumns.length === 1)
                        return relation.joinColumns[0];
                    return undefined;
                };
                /**
                 * Finds columns with a given property path.
                 * Property path can match a relation, and relations can contain multiple columns.
                 */
                EntityMetadata.prototype.findColumnsWithPropertyPath = function (propertyPath) {
                    var column = this.columns.find(function (column) { return column.propertyPath === propertyPath; });
                    if (column)
                        return [column];
                    // in the case if column with property path was not found, try to find a relation with such property path
                    // if we find relation and it has a single join column then its the column user was seeking
                    var relation = this.relations.find(function (relation) { return relation.propertyPath === propertyPath; });
                    if (relation && relation.joinColumns)
                        return relation.joinColumns;
                    return [];
                };
                /**
                 * Finds column with a given database name.
                 */
                EntityMetadata.prototype.findColumnWithDatabaseName = function (databaseName) {
                    return this.columns.find(function (column) { return column.databaseName === databaseName; });
                };
                /**
                 * Finds relation with the given name.
                 */
                EntityMetadata.prototype.findRelationWithDbName = function (dbName) {
                    return this.relationsWithJoinColumns.find(function (relation) {
                        return !!relation.joinColumns.find(function (column) { return column.databaseName === dbName; });
                    });
                };
                /**
                 * Finds relation with the given property path.
                 */
                EntityMetadata.prototype.findRelationWithPropertyPath = function (propertyPath) {
                    return this.relations.find(function (relation) { return relation.propertyPath === propertyPath; });
                };
                /**
                 * Computes property name of the entity using given PropertyTypeInFunction.
                 */
                EntityMetadata.prototype.computePropertyPath = function (nameOrFn) {
                    return typeof nameOrFn === "string" ? nameOrFn : nameOrFn(this.propertiesMap);
                };
                /**
                 * Creates entity id map from the given entity ids array.
                 */
                EntityMetadata.prototype.createEntityIdMap = function (ids) {
                    if (!(ids instanceof Array))
                        ids = [ids];
                    return this.primaryColumns.reduce(function (map, column, index) {
                        return OrmUtils_8.OrmUtils.mergeDeep(map, column.createValueMap(ids[index]));
                    }, {});
                };
                /**
                 * Checks each id in the given entity id map if they all aren't empty.
                 * If they all aren't empty it returns true.
                 * If at least one id in the given map is empty it returns false.
                 */
                EntityMetadata.prototype.isEntityMapEmpty = function (entity) {
                    return !this.primaryColumns.every(function (column) {
                        var value = column.getEntityValue(entity);
                        return value !== null && value !== undefined;
                    });
                };
                /**
                 * Gets primary keys of the entity and returns them in a literal object.
                 * For example, for Post{ id: 1, title: "hello" } where id is primary it will return { id: 1 }
                 * For multiple primary keys it returns multiple keys in object.
                 * For primary keys inside embeds it returns complex object literal with keys in them.
                 */
                EntityMetadata.prototype.getEntityIdMap = function (entity) {
                    if (!entity) // todo: shall it accept an empty entity? try to remove this
                        return undefined;
                    var map = this.primaryColumns.reduce(function (map, column) {
                        if (column.isObjectId)
                            return Object.assign(map, column.getEntityValueMap(entity));
                        return OrmUtils_8.OrmUtils.mergeDeep(map, column.getEntityValueMap(entity));
                    }, {});
                    return Object.keys(map).length > 0 ? map : undefined;
                };
                /**
                 * Same as getEntityIdMap, but instead of id column property names it returns database column names.
                 */
                EntityMetadata.prototype.getDatabaseEntityIdMap = function (entity) {
                    var map = {};
                    this.primaryColumns.forEach(function (column) {
                        var entityValue = column.getEntityValue(entity);
                        if (entityValue === null || entityValue === undefined)
                            return;
                        map[column.databaseName] = entityValue;
                    });
                    var hasAllIds = Object.keys(map).every(function (key) {
                        return map[key] !== undefined && map[key] !== null;
                    });
                    return hasAllIds ? map : undefined;
                };
                /**
                 * Creates a "mixed id map".
                 * If entity has multiple primary keys (ids) then it will return just regular id map, like what getEntityIdMap returns.
                 * But if entity has a single primary key then it will return just value of the id column of the entity, just value.
                 * This is called mixed id map.
                 */
                EntityMetadata.prototype.getEntityIdMixedMap = function (entity) {
                    if (!entity) // todo: undefined entities should not go there??
                        return entity;
                    var idMap = this.getEntityIdMap(entity);
                    if (this.hasMultiplePrimaryKeys) {
                        return idMap;
                    }
                    else if (idMap) {
                        return idMap[this.primaryColumns[0].propertyName]; // todo: what about parent primary column?
                    }
                    return idMap;
                };
                /**
                 * Checks if given object contains ALL primary keys entity must have.
                 * Returns true if it contains all of them, false if at least one of them is not defined.
                 */
                EntityMetadata.prototype.checkIfObjectContainsAllPrimaryKeys = function (object) {
                    return this.primaryColumns.every(function (primaryColumn) {
                        return object.hasOwnProperty(primaryColumn.propertyName);
                    });
                };
                /**
                 * Iterates throw entity and finds and extracts all values from relations in the entity.
                 * If relation value is an array its being flattened.
                 */
                EntityMetadata.prototype.extractRelationValuesFromEntity = function (entity, relations) {
                    var relationsAndValues = [];
                    relations.forEach(function (relation) {
                        var value = relation.getEntityValue(entity);
                        if (value instanceof Array) {
                            value.forEach(function (subValue) { return relationsAndValues.push([relation, subValue, relation.inverseEntityMetadata]); });
                        }
                        else if (value) {
                            relationsAndValues.push([relation, value, relation.inverseEntityMetadata]);
                        }
                    });
                    return relationsAndValues;
                };
                // ---------------------------------------------------------------------
                // Public Builder Methods
                // ---------------------------------------------------------------------
                /**
                 * Registers a new column in the entity and recomputes all depend properties.
                 */
                EntityMetadata.prototype.registerColumn = function (column) {
                    this.ownColumns.push(column);
                    this.columns = this.embeddeds.reduce(function (columns, embedded) { return columns.concat(embedded.columnsFromTree); }, this.ownColumns);
                    this.parentIdColumns = this.columns.filter(function (column) { return column.isParentId; });
                    this.primaryColumns = this.columns.filter(function (column) { return column.isPrimary; });
                    this.hasMultiplePrimaryKeys = this.primaryColumns.length > 1;
                    this.propertiesMap = this.createPropertiesMap();
                };
                /**
                 * Creates a special object - all columns and relations of the object (plus columns and relations from embeds)
                 * in a special format - { propertyName: propertyName }.
                 *
                 * example: Post{ id: number, name: string, counterEmbed: { count: number }, category: Category }.
                 * This method will create following object:
                 * { id: "id", counterEmbed: { count: "counterEmbed.count" }, category: "category" }
                 */
                EntityMetadata.prototype.createPropertiesMap = function () {
                    var map = {};
                    this.columns.forEach(function (column) { return OrmUtils_8.OrmUtils.mergeDeep(map, column.createValueMap(column.propertyPath)); });
                    this.relations.forEach(function (relation) { return OrmUtils_8.OrmUtils.mergeDeep(map, relation.createValueMap(relation.propertyPath)); });
                    return map;
                };
                // ---------------------------------------------------------------------
                // Protected Methods
                // ---------------------------------------------------------------------
                /**
                 * Builds table path using database name and schema name and table name.
                 */
                EntityMetadata.prototype.buildTablePath = function (driver) {
                    var tablePath = this.tableName;
                    if (this.schema)
                        tablePath = this.schema + "." + tablePath;
                    if (this.database && !(driver instanceof PostgresDriver_5.PostgresDriver)) {
                        if (!this.schema && driver instanceof SqlServerDriver_5.SqlServerDriver) {
                            tablePath = this.database + ".." + tablePath;
                        }
                        else {
                            tablePath = this.database + "." + tablePath;
                        }
                    }
                    return tablePath;
                };
                /**
                 * Builds table path using schema name and database name.
                 */
                EntityMetadata.prototype.buildSchemaPath = function (driver) {
                    if (!this.schema)
                        return undefined;
                    return this.database && !(driver instanceof PostgresDriver_5.PostgresDriver) ? this.database + "." + this.schema : this.schema;
                };
                return EntityMetadata;
            }());
            exports_161("EntityMetadata", EntityMetadata);
        }
    };
});
System.register("typeorm/decorator/options/ValueTransformer", [], function (exports_162, context_162) {
    "use strict";
    var __moduleName = context_162 && context_162.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/options/ColumnOptions", [], function (exports_163, context_163) {
    "use strict";
    var __moduleName = context_163 && context_163.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/metadata-args/types/ColumnMode", [], function (exports_164, context_164) {
    "use strict";
    var __moduleName = context_164 && context_164.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/metadata-args/ColumnMetadataArgs", [], function (exports_165, context_165) {
    "use strict";
    var __moduleName = context_165 && context_165.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/metadata/ColumnMetadata", ["typeorm/util/OrmUtils"], function (exports_166, context_166) {
    "use strict";
    var __moduleName = context_166 && context_166.id;
    var OrmUtils_9, ColumnMetadata;
    return {
        setters: [
            function (OrmUtils_9_1) {
                OrmUtils_9 = OrmUtils_9_1;
            }
        ],
        execute: function () {
            /**
             * This metadata contains all information about entity's column.
             */
            ColumnMetadata = /** @class */ (function () {
                // ---------------------------------------------------------------------
                // Constructor
                // ---------------------------------------------------------------------
                function ColumnMetadata(options) {
                    /**
                     * Type's length in the database.
                     */
                    this.length = "";
                    /**
                     * Indicates if this column is a primary key.
                     */
                    this.isPrimary = false;
                    /**
                     * Indicates if this column is generated (auto increment or generated other way).
                     */
                    this.isGenerated = false;
                    /**
                     * Indicates if column value in the database should be unique or not.
                     */
                    this.isUnique = false;
                    /**
                     * Indicates if column can contain nulls or not.
                     */
                    this.isNullable = false;
                    /**
                     * Indicates if column is selected by query builder or not.
                     */
                    this.isSelect = true;
                    /**
                     * Indicates if column is protected from updates or not.
                     */
                    this.isReadonly = false;
                    /**
                     * Column comment.
                     * This feature is not supported by all databases.
                     */
                    this.comment = "";
                    /**
                     * Indicates if column is virtual. Virtual columns are not mapped to the entity.
                     */
                    this.isVirtual = false;
                    /**
                     * Indicates if column is a parent id. Parent id columns are not mapped to the entity.
                     */
                    this.isParentId = false;
                    /**
                     * Indicates if column is discriminator. Discriminator columns are not mapped to the entity.
                     */
                    this.isDiscriminator = false;
                    /**
                     * Indicates if column is tree-level column. Tree-level columns are used in closure entities.
                     */
                    this.isTreeLevel = false;
                    /**
                     * Indicates if this column contains an entity creation date.
                     */
                    this.isCreateDate = false;
                    /**
                     * Indicates if this column contains an entity update date.
                     */
                    this.isUpdateDate = false;
                    /**
                     * Indicates if this column contains an entity version.
                     */
                    this.isVersion = false;
                    /**
                     * Indicates if this column contains an object id.
                     */
                    this.isObjectId = false;
                    this.entityMetadata = options.entityMetadata;
                    this.embeddedMetadata = options.embeddedMetadata;
                    this.referencedColumn = options.referencedColumn;
                    if (options.args.target)
                        this.target = options.args.target;
                    if (options.args.propertyName)
                        this.propertyName = options.args.propertyName;
                    if (options.args.options.name)
                        this.givenDatabaseName = options.args.options.name;
                    if (options.args.options.type)
                        this.type = options.args.options.type;
                    if (options.args.options.length)
                        this.length = options.args.options.length ? options.args.options.length.toString() : "";
                    if (options.args.options.charset)
                        this.charset = options.args.options.charset;
                    if (options.args.options.collation)
                        this.collation = options.args.options.collation;
                    if (options.args.options.primary)
                        this.isPrimary = options.args.options.primary;
                    if (options.args.options.unique)
                        this.isUnique = options.args.options.unique;
                    if (options.args.options.default === null) // to make sure default: null is the same as nullable: true
                        this.isNullable = true;
                    if (options.args.options.nullable !== undefined)
                        this.isNullable = options.args.options.nullable;
                    if (options.args.options.select !== undefined)
                        this.isSelect = options.args.options.select;
                    if (options.args.options.readonly !== undefined)
                        this.isReadonly = options.args.options.readonly;
                    if (options.args.options.comment)
                        this.comment = options.args.options.comment;
                    if (options.args.options.default !== undefined)
                        this.default = options.args.options.default;
                    if (options.args.options.scale)
                        this.scale = options.args.options.scale;
                    if (options.args.options.precision)
                        this.precision = options.args.options.precision;
                    if (options.args.options.enum) {
                        if (options.args.options.enum instanceof Object) {
                            this.enum = Object.keys(options.args.options.enum).map(function (key) {
                                return options.args.options.enum[key];
                            });
                        }
                        else {
                            this.enum = options.args.options.enum;
                        }
                    }
                    if (options.args.options.isArray)
                        this.isArray = options.args.options.isArray;
                    if (options.args.options.array)
                        this.isArray = options.args.options.array;
                    if (options.args.mode) {
                        this.isVirtual = options.args.mode === "virtual";
                        this.isParentId = options.args.mode === "parentId";
                        this.isDiscriminator = options.args.mode === "discriminator";
                        this.isTreeLevel = options.args.mode === "treeLevel";
                        this.isCreateDate = options.args.mode === "createDate";
                        this.isUpdateDate = options.args.mode === "updateDate";
                        this.isVersion = options.args.mode === "version";
                        this.isObjectId = options.args.mode === "objectId";
                    }
                    if (options.args.options.transformer)
                        this.transformer = options.args.options.transformer;
                    if (this.isTreeLevel)
                        this.type = options.connection.driver.mappedDataTypes.treeLevel;
                    if (this.isCreateDate) {
                        this.type = options.connection.driver.mappedDataTypes.createDate;
                        if (!this.default)
                            this.default = function () { return options.connection.driver.mappedDataTypes.createDateDefault; };
                        if (!this.precision && options.connection.driver.mappedDataTypes.createDatePrecision)
                            this.precision = options.connection.driver.mappedDataTypes.createDatePrecision;
                    }
                    if (this.isUpdateDate) {
                        this.type = options.connection.driver.mappedDataTypes.updateDate;
                        if (!this.default)
                            this.default = function () { return options.connection.driver.mappedDataTypes.updateDateDefault; };
                        if (!this.precision && options.connection.driver.mappedDataTypes.updateDatePrecision)
                            this.precision = options.connection.driver.mappedDataTypes.updateDatePrecision;
                    }
                    if (this.isVersion)
                        this.type = options.connection.driver.mappedDataTypes.version;
                }
                // ---------------------------------------------------------------------
                // Public Methods
                // ---------------------------------------------------------------------
                /**
                 * Creates entity id map from the given entity ids array.
                 */
                ColumnMetadata.prototype.createValueMap = function (value) {
                    var _this = this;
                    // extract column value from embeds of entity if column is in embedded
                    if (this.embeddedMetadata) {
                        // example: post[data][information][counters].id where "data", "information" and "counters" are embeddeds
                        // we need to get value of "id" column from the post real entity object and return it in a
                        // { data: { information: { counters: { id: ... } } } } format
                        // first step - we extract all parent properties of the entity relative to this column, e.g. [data, information, counters]
                        var propertyNames = this.embeddedMetadata.parentPropertyNames.slice();
                        // now need to access post[data][information][counters] to get column value from the counters
                        // and on each step we need to create complex literal object, e.g. first { data },
                        // then { data: { information } }, then { data: { information: { counters } } },
                        // then { data: { information: { counters: [this.propertyName]: entity[data][information][counters][this.propertyName] } } }
                        // this recursive function helps doing that
                        var extractEmbeddedColumnValue_4 = function (propertyNames, map) {
                            var propertyName = propertyNames.shift();
                            if (propertyName) {
                                map[propertyName] = {};
                                extractEmbeddedColumnValue_4(propertyNames, map[propertyName]);
                                return map;
                            }
                            // this is bugfix for #720 when increment number is bigint we need to make sure its a string
                            if (_this.generationStrategy === "increment" && _this.type === "bigint")
                                value = String(value);
                            map[_this.propertyName] = value;
                            return map;
                        };
                        return extractEmbeddedColumnValue_4(propertyNames, {});
                    }
                    else { // no embeds - no problems. Simply return column property name and its value of the entity
                        // this is bugfix for #720 when increment number is bigint we need to make sure its a string
                        if (this.generationStrategy === "increment" && this.type === "bigint")
                            value = String(value);
                        return _a = {}, _a[this.propertyName] = value, _a;
                    }
                    var _a;
                };
                /**
                 * Extracts column value and returns its column name with this value in a literal object.
                 * If column is in embedded (or recursive embedded) it returns complex literal object.
                 *
                 * Examples what this method can return depend if this column is in embeds.
                 * { id: 1 } or { title: "hello" }, { counters: { code: 1 } }, { data: { information: { counters: { code: 1 } } } }
                 */
                ColumnMetadata.prototype.getEntityValueMap = function (entity) {
                    var _this = this;
                    // extract column value from embeds of entity if column is in embedded
                    if (this.embeddedMetadata) {
                        // example: post[data][information][counters].id where "data", "information" and "counters" are embeddeds
                        // we need to get value of "id" column from the post real entity object and return it in a
                        // { data: { information: { counters: { id: ... } } } } format
                        // first step - we extract all parent properties of the entity relative to this column, e.g. [data, information, counters]
                        var propertyNames = this.embeddedMetadata.parentPropertyNames.slice();
                        // now need to access post[data][information][counters] to get column value from the counters
                        // and on each step we need to create complex literal object, e.g. first { data },
                        // then { data: { information } }, then { data: { information: { counters } } },
                        // then { data: { information: { counters: [this.propertyName]: entity[data][information][counters][this.propertyName] } } }
                        // this recursive function helps doing that
                        var extractEmbeddedColumnValue_5 = function (propertyNames, value, map) {
                            var propertyName = propertyNames.shift();
                            if (propertyName) {
                                map[propertyName] = {};
                                extractEmbeddedColumnValue_5(propertyNames, value ? value[propertyName] : undefined, map[propertyName]);
                                return map;
                            }
                            map[_this.propertyName] = value ? value[_this.propertyName] : undefined;
                            return map;
                        };
                        return extractEmbeddedColumnValue_5(propertyNames, entity, {});
                    }
                    else { // no embeds - no problems. Simply return column property name and its value of the entity
                        if (this.relationMetadata && entity[this.propertyName] && entity[this.propertyName] instanceof Object) {
                            var map = this.relationMetadata.joinColumns.reduce(function (map, joinColumn) {
                                return OrmUtils_9.OrmUtils.mergeDeep(map, joinColumn.referencedColumn.getEntityValueMap(entity[_this.propertyName]));
                            }, {});
                            return _a = {}, _a[this.propertyName] = map, _a;
                        }
                        else {
                            return _b = {}, _b[this.propertyName] = entity[this.propertyName], _b;
                        }
                    }
                    var _a, _b;
                };
                /**
                 * Extracts column value from the given entity.
                 * If column is in embedded (or recursive embedded) it extracts its value from there.
                 */
                ColumnMetadata.prototype.getEntityValue = function (entity) {
                    // if (entity === undefined || entity === null) return undefined; // uncomment if needed
                    // extract column value from embeddeds of entity if column is in embedded
                    if (this.embeddedMetadata) {
                        // example: post[data][information][counters].id where "data", "information" and "counters" are embeddeds
                        // we need to get value of "id" column from the post real entity object
                        // first step - we extract all parent properties of the entity relative to this column, e.g. [data, information, counters]
                        var propertyNames = this.embeddedMetadata.parentPropertyNames.slice();
                        // next we need to access post[data][information][counters][this.propertyName] to get column value from the counters
                        // this recursive function takes array of generated property names and gets the post[data][information][counters] embed
                        var extractEmbeddedColumnValue_6 = function (propertyNames, value) {
                            var propertyName = propertyNames.shift();
                            return propertyName && value ? extractEmbeddedColumnValue_6(propertyNames, value[propertyName]) : value;
                        };
                        // once we get nested embed object we get its column, e.g. post[data][information][counters][this.propertyName]
                        var embeddedObject = extractEmbeddedColumnValue_6(propertyNames, entity);
                        if (embeddedObject) {
                            if (this.relationMetadata && this.referencedColumn && this.isVirtual) {
                                var relatedEntity = this.relationMetadata.getEntityValue(embeddedObject);
                                if (relatedEntity && relatedEntity instanceof Object)
                                    return this.referencedColumn.getEntityValue(relatedEntity);
                            }
                            return embeddedObject[this.propertyName];
                        }
                        return undefined;
                    }
                    else { // no embeds - no problems. Simply return column name by property name of the entity
                        if (this.relationMetadata && this.referencedColumn && this.isVirtual) {
                            var relatedEntity = this.relationMetadata.getEntityValue(entity);
                            if (relatedEntity && relatedEntity instanceof Object)
                                return this.referencedColumn.getEntityValue(relatedEntity);
                        }
                        return entity[this.propertyName];
                    }
                };
                /**
                 * Sets given entity's column value.
                 * Using of this method helps to set entity relation's value of the lazy and non-lazy relations.
                 */
                ColumnMetadata.prototype.setEntityValue = function (entity, value) {
                    var _this = this;
                    if (this.embeddedMetadata) {
                        // first step - we extract all parent properties of the entity relative to this column, e.g. [data, information, counters]
                        var extractEmbeddedColumnValue_7 = function (embeddedMetadatas, map) {
                            // if (!object[embeddedMetadata.propertyName])
                            //     object[embeddedMetadata.propertyName] = embeddedMetadata.create();
                            var embeddedMetadata = embeddedMetadatas.shift();
                            if (embeddedMetadata) {
                                if (!map[embeddedMetadata.propertyName])
                                    map[embeddedMetadata.propertyName] = embeddedMetadata.create();
                                extractEmbeddedColumnValue_7(embeddedMetadatas, map[embeddedMetadata.propertyName]);
                                return map;
                            }
                            map[_this.propertyName] = value;
                            return map;
                        };
                        return extractEmbeddedColumnValue_7(this.embeddedMetadata.embeddedMetadataTree.slice(), entity);
                    }
                    else {
                        entity[this.propertyName] = value;
                    }
                };
                // ---------------------------------------------------------------------
                // Builder Methods
                // ---------------------------------------------------------------------
                ColumnMetadata.prototype.build = function (connection) {
                    this.propertyPath = this.buildPropertyPath();
                    this.databaseName = this.buildDatabaseName(connection);
                    this.databaseNameWithoutPrefixes = connection.namingStrategy.columnName(this.propertyName, this.givenDatabaseName, []);
                    return this;
                };
                // ---------------------------------------------------------------------
                // Protected Methods
                // ---------------------------------------------------------------------
                ColumnMetadata.prototype.buildPropertyPath = function () {
                    var path = "";
                    if (this.embeddedMetadata && this.embeddedMetadata.parentPropertyNames.length)
                        path = this.embeddedMetadata.parentPropertyNames.join(".") + ".";
                    path += this.propertyName;
                    // we add reference column to property path only if this column is virtual
                    // because if its not virtual it means user defined a real column for this relation
                    if (this.isVirtual && this.referencedColumn && this.referencedColumn.propertyName !== this.propertyName)
                        path += "." + this.referencedColumn.propertyName;
                    return path;
                };
                ColumnMetadata.prototype.buildDatabaseName = function (connection) {
                    var propertyNames = this.embeddedMetadata ? this.embeddedMetadata.parentPrefixes : [];
                    return connection.namingStrategy.columnName(this.propertyName, this.givenDatabaseName, propertyNames);
                };
                return ColumnMetadata;
            }());
            exports_166("ColumnMetadata", ColumnMetadata);
        }
    };
});
System.register("typeorm/schema-builder/schema/TableColumn", [], function (exports_167, context_167) {
    "use strict";
    var __moduleName = context_167 && context_167.id;
    var TableColumn;
    return {
        setters: [],
        execute: function () {
            /**
             * Table's columns in the database represented in this class.
             */
            TableColumn = /** @class */ (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function TableColumn(options) {
                    /**
                     * Indicates if column is NULL, or is NOT NULL in the database.
                     */
                    this.isNullable = false;
                    /**
                     * Indicates if column is auto-generated sequence.
                     */
                    this.isGenerated = false;
                    /**
                     * Indicates if column is a primary key.
                     */
                    this.isPrimary = false;
                    /**
                     * Indicates if column has unique value.
                     */
                    this.isUnique = false;
                    /**
                     * Indicates if column stores array.
                     */
                    this.isArray = false;
                    /**
                     * Column type's length. Used only on some column types.
                     * For example type = "string" and length = "100" means that ORM will create a column with type varchar(100).
                     */
                    this.length = "";
                    if (options) {
                        this.name = options.name || "";
                        this.type = options.type || "";
                        this.length = options.length || "";
                        this.charset = options.charset;
                        this.collation = options.collation;
                        this.precision = options.precision;
                        this.scale = options.scale;
                        this.default = options.default;
                        this.isNullable = options.isNullable || false;
                        this.isGenerated = options.isGenerated || false;
                        this.generationStrategy = options.generationStrategy;
                        this.isPrimary = options.isPrimary || false;
                        this.isUnique = options.isUnique || false;
                        this.comment = options.comment;
                        this.enum = options.enum;
                    }
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Clones this column to a new column with exact same properties as this column has.
                 */
                TableColumn.prototype.clone = function () {
                    var newTableColumn = new TableColumn();
                    newTableColumn.name = this.name;
                    newTableColumn.type = this.type;
                    newTableColumn.length = this.length;
                    newTableColumn.charset = this.charset;
                    newTableColumn.collation = this.collation;
                    newTableColumn.precision = this.precision;
                    newTableColumn.scale = this.scale;
                    newTableColumn.enum = this.enum;
                    newTableColumn.default = this.default;
                    newTableColumn.isNullable = this.isNullable;
                    newTableColumn.isGenerated = this.isGenerated;
                    newTableColumn.generationStrategy = this.generationStrategy;
                    newTableColumn.isPrimary = this.isPrimary;
                    newTableColumn.isUnique = this.isUnique;
                    newTableColumn.isArray = this.isArray;
                    newTableColumn.comment = this.comment;
                    return newTableColumn;
                };
                // -------------------------------------------------------------------------
                // Static Methods
                // -------------------------------------------------------------------------
                /**
                 * Creates a new column based on the given column metadata.
                 */
                TableColumn.create = function (columnMetadata, normalizedType, normalizedDefault, normalizedLength) {
                    var tableColumn = new TableColumn();
                    tableColumn.name = columnMetadata.databaseName;
                    tableColumn.length = normalizedLength;
                    tableColumn.charset = columnMetadata.charset;
                    tableColumn.collation = columnMetadata.collation;
                    tableColumn.precision = columnMetadata.precision;
                    tableColumn.scale = columnMetadata.scale;
                    tableColumn.default = normalizedDefault;
                    tableColumn.comment = columnMetadata.comment;
                    tableColumn.isGenerated = columnMetadata.isGenerated;
                    tableColumn.generationStrategy = columnMetadata.generationStrategy;
                    tableColumn.isNullable = columnMetadata.isNullable;
                    tableColumn.type = normalizedType;
                    tableColumn.isPrimary = columnMetadata.isPrimary;
                    tableColumn.isUnique = columnMetadata.isUnique;
                    tableColumn.isArray = columnMetadata.isArray || false;
                    tableColumn.enum = columnMetadata.enum;
                    return tableColumn;
                };
                return TableColumn;
            }());
            exports_167("TableColumn", TableColumn);
        }
    };
});
System.register("typeorm/query-runner/QueryRunner", [], function (exports_168, context_168) {
    "use strict";
    var __moduleName = context_168 && context_168.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/driver/Driver", [], function (exports_169, context_169) {
    "use strict";
    var __moduleName = context_169 && context_169.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/util/StringUtils", [], function (exports_170, context_170) {
    "use strict";
    var __moduleName = context_170 && context_170.id;
    /**
     * Converts string into camelCase.
     *
     * @see http://stackoverflow.com/questions/2970525/converting-any-string-into-camel-case
     */
    function camelCase(str) {
        return str.replace(/^([A-Z])|[\s-_](\w)/g, function (match, p1, p2, offset) {
            if (p2)
                return p2.toUpperCase();
            return p1.toLowerCase();
        });
    }
    exports_170("camelCase", camelCase);
    /**
     * Converts string into snake-case.
     *
     * @see http://stackoverflow.com/questions/30521224/javascript-convert-pascalcase-to-underscore-case
     */
    function snakeCase(str) {
        return str.replace(/(?:^|\.?)([A-Z])/g, function (x, y) { return "_" + y.toLowerCase(); }).replace(/^_/, "");
    }
    exports_170("snakeCase", snakeCase);
    /**
     * Converts string into title-case.
     *
     * @see http://stackoverflow.com/questions/196972/convert-string-to-title-case-with-javascript
     */
    function titleCase(str) {
        return str.replace(/\w\S*/g, function (txt) { return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase(); });
    }
    exports_170("titleCase", titleCase);
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/naming-strategy/DefaultNamingStrategy", ["typeorm/util/RandomGenerator", "typeorm/util/StringUtils"], function (exports_171, context_171) {
    "use strict";
    var __moduleName = context_171 && context_171.id;
    var RandomGenerator_4, StringUtils_1, DefaultNamingStrategy;
    return {
        setters: [
            function (RandomGenerator_4_1) {
                RandomGenerator_4 = RandomGenerator_4_1;
            },
            function (StringUtils_1_1) {
                StringUtils_1 = StringUtils_1_1;
            }
        ],
        execute: function () {
            /**
             * Naming strategy that is used by default.
             */
            DefaultNamingStrategy = /** @class */ (function () {
                function DefaultNamingStrategy() {
                }
                /**
                 * Normalizes table name.
                 *
                 * @param targetName Name of the target entity that can be used to generate a table name.
                 * @param userSpecifiedName For example if user specified a table name in a decorator, e.g. @Entity("name")
                 */
                DefaultNamingStrategy.prototype.tableName = function (targetName, userSpecifiedName) {
                    return userSpecifiedName ? userSpecifiedName : StringUtils_1.snakeCase(targetName);
                };
                /**
                 * Creates a table name for a junction table of a closure table.
                 *
                 * @param originalClosureTableName Name of the closure table which owns this junction table.
                 */
                DefaultNamingStrategy.prototype.closureJunctionTableName = function (originalClosureTableName) {
                    return originalClosureTableName + "_closure";
                };
                DefaultNamingStrategy.prototype.columnName = function (propertyName, customName, embeddedPrefixes) {
                    if (embeddedPrefixes.length)
                        return StringUtils_1.camelCase(embeddedPrefixes.join("_")) + (customName ? StringUtils_1.titleCase(customName) : StringUtils_1.titleCase(propertyName));
                    return customName ? customName : propertyName;
                };
                DefaultNamingStrategy.prototype.relationName = function (propertyName) {
                    return propertyName;
                };
                DefaultNamingStrategy.prototype.indexName = function (customName, tableName, columns) {
                    if (customName)
                        return customName;
                    var key = "ind_" + tableName + "_" + columns.join("_");
                    return "ind_" + RandomGenerator_4.RandomGenerator.sha1(key).substr(0, 26);
                };
                DefaultNamingStrategy.prototype.joinColumnName = function (relationName, referencedColumnName) {
                    return StringUtils_1.camelCase(relationName + "_" + referencedColumnName);
                };
                DefaultNamingStrategy.prototype.joinTableName = function (firstTableName, secondTableName, firstPropertyName, secondPropertyName) {
                    return StringUtils_1.snakeCase(firstTableName + "_" + firstPropertyName.replace(/\./gi, "_") + "_" + secondTableName);
                };
                DefaultNamingStrategy.prototype.joinTableColumnDuplicationPrefix = function (columnName, index) {
                    return columnName + "_" + index;
                };
                DefaultNamingStrategy.prototype.joinTableColumnName = function (tableName, propertyName, columnName) {
                    return StringUtils_1.camelCase(tableName + "_" + (columnName ? columnName : propertyName));
                };
                DefaultNamingStrategy.prototype.joinTableInverseColumnName = function (tableName, propertyName, columnName) {
                    return this.joinTableColumnName(tableName, propertyName, columnName);
                };
                DefaultNamingStrategy.prototype.foreignKeyName = function (tableName, columnNames, referencedTableName, referencedColumnNames) {
                    var key = tableName + "_" + columnNames.join("_") + "_" + referencedTableName + "_" + referencedColumnNames.join("_");
                    return "fk_" + RandomGenerator_4.RandomGenerator.sha1(key).substr(0, 27); // todo: use crypto instead?
                };
                DefaultNamingStrategy.prototype.classTableInheritanceParentColumnName = function (parentTableName, parentTableIdPropertyName) {
                    return StringUtils_1.camelCase(parentTableName + "_" + parentTableIdPropertyName);
                };
                /**
                 * Adds globally set prefix to the table name.
                 * This method is executed no matter if prefix was set or not.
                 * Table name is either user's given table name, either name generated from entity target.
                 * Note that table name comes here already normalized by #tableName method.
                 */
                DefaultNamingStrategy.prototype.prefixTableName = function (prefix, tableName) {
                    return prefix + tableName;
                };
                return DefaultNamingStrategy;
            }());
            exports_171("DefaultNamingStrategy", DefaultNamingStrategy);
        }
    };
});
System.register("typeorm/error/CannotExecuteNotConnectedError", [], function (exports_172, context_172) {
    "use strict";
    var __moduleName = context_172 && context_172.id;
    var CannotExecuteNotConnectedError;
    return {
        setters: [],
        execute: function () {
            /**
             * Thrown when consumer tries to execute operation allowed only if connection is opened.
             */
            CannotExecuteNotConnectedError = /** @class */ (function (_super) {
                __extends(CannotExecuteNotConnectedError, _super);
                function CannotExecuteNotConnectedError(connectionName) {
                    var _this = _super.call(this) || this;
                    _this.name = "CannotExecuteNotConnectedError";
                    _this.message = "Cannot execute operation on \"" + connectionName + "\" connection because connection is not yet established.";
                    _this.stack = new Error().stack;
                    return _this;
                }
                return CannotExecuteNotConnectedError;
            }(Error));
            exports_172("CannotExecuteNotConnectedError", CannotExecuteNotConnectedError);
        }
    };
});
System.register("typeorm/error/CannotConnectAlreadyConnectedError", [], function (exports_173, context_173) {
    "use strict";
    var __moduleName = context_173 && context_173.id;
    var CannotConnectAlreadyConnectedError;
    return {
        setters: [],
        execute: function () {
            /**
             * Thrown when consumer tries to connect when he already connected.
             */
            CannotConnectAlreadyConnectedError = /** @class */ (function (_super) {
                __extends(CannotConnectAlreadyConnectedError, _super);
                function CannotConnectAlreadyConnectedError(connectionName) {
                    var _this = _super.call(this) || this;
                    _this.name = "CannotConnectAlreadyConnectedError";
                    _this.message = "Cannot create a \"" + connectionName + "\" connection because connection to the database already established.";
                    _this.stack = new Error().stack;
                    return _this;
                }
                return CannotConnectAlreadyConnectedError;
            }(Error));
            exports_173("CannotConnectAlreadyConnectedError", CannotConnectAlreadyConnectedError);
        }
    };
});
System.register("typeorm/error/EntityMetadataNotFound", [], function (exports_174, context_174) {
    "use strict";
    var __moduleName = context_174 && context_174.id;
    var EntityMetadataNotFound;
    return {
        setters: [],
        execute: function () {
            /**
             */
            EntityMetadataNotFound = /** @class */ (function (_super) {
                __extends(EntityMetadataNotFound, _super);
                function EntityMetadataNotFound(target) {
                    var _this = _super.call(this) || this;
                    _this.name = "EntityMetadataNotFound";
                    var targetName = typeof target === "function" && target.name ? target.name : target;
                    _this.message = "No metadata for \"" + targetName + "\" was found.";
                    return _this;
                }
                return EntityMetadataNotFound;
            }(Error));
            exports_174("EntityMetadataNotFound", EntityMetadataNotFound);
        }
    };
});
System.register("typeorm/migration/MigrationInterface", [], function (exports_175, context_175) {
    "use strict";
    var __moduleName = context_175 && context_175.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/migration/Migration", [], function (exports_176, context_176) {
    "use strict";
    var __moduleName = context_176 && context_176.id;
    var Migration;
    return {
        setters: [],
        execute: function () {
            /**
             * Represents entity of the migration in the database.
             */
            Migration = /** @class */ (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function Migration(timestamp, name, instance) {
                    this.timestamp = timestamp;
                    this.name = name;
                    this.instance = instance;
                }
                return Migration;
            }());
            exports_176("Migration", Migration);
        }
    };
});
System.register("typeorm/migration/MigrationExecutor", ["typeorm/schema-builder/schema/Table", "typeorm/schema-builder/schema/TableColumn", "typeorm/migration/Migration", "typeorm/util/PromiseUtils", "typeorm/driver/sqlserver/SqlServerDriver", "typeorm/driver/sqlserver/MssqlParameter"], function (exports_177, context_177) {
    "use strict";
    var __moduleName = context_177 && context_177.id;
    var Table_7, TableColumn_8, Migration_1, PromiseUtils_4, SqlServerDriver_6, MssqlParameter_3, MigrationExecutor;
    return {
        setters: [
            function (Table_7_1) {
                Table_7 = Table_7_1;
            },
            function (TableColumn_8_1) {
                TableColumn_8 = TableColumn_8_1;
            },
            function (Migration_1_1) {
                Migration_1 = Migration_1_1;
            },
            function (PromiseUtils_4_1) {
                PromiseUtils_4 = PromiseUtils_4_1;
            },
            function (SqlServerDriver_6_1) {
                SqlServerDriver_6 = SqlServerDriver_6_1;
            },
            function (MssqlParameter_3_1) {
                MssqlParameter_3 = MssqlParameter_3_1;
            }
        ],
        execute: function () {
            /**
             * Executes migrations: runs pending and reverts previously executed migrations.
             */
            MigrationExecutor = /** @class */ (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function MigrationExecutor(connection, queryRunner) {
                    this.connection = connection;
                    this.queryRunner = queryRunner;
                    this.migrationsTableName = "migrations";
                    if (connection.options.migrationsTableName) {
                        this.migrationsTableName = connection.options.migrationsTableName;
                    }
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Executes all pending migrations. Pending migrations are migrations that are not yet executed,
                 * thus not saved in the database.
                 */
                MigrationExecutor.prototype.executePendingMigrations = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var queryRunner, executedMigrations, lastTimeExecutedMigration, allMigrations, pendingMigrations, transactionStartedByUs, err_7, rollbackError_10;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    queryRunner = this.queryRunner || this.connection.createQueryRunner("master");
                                    // create migrations table if its not created yet
                                    return [4 /*yield*/, this.createMigrationsTableIfNotExist(queryRunner)];
                                case 1:
                                    // create migrations table if its not created yet
                                    _a.sent();
                                    return [4 /*yield*/, this.loadExecutedMigrations(queryRunner)];
                                case 2:
                                    executedMigrations = _a.sent();
                                    lastTimeExecutedMigration = this.getLatestMigration(executedMigrations);
                                    allMigrations = this.getMigrations();
                                    pendingMigrations = allMigrations.filter(function (migration) {
                                        // check if we already have executed migration
                                        var executedMigration = executedMigrations.find(function (executedMigration) { return executedMigration.name === migration.name; });
                                        if (executedMigration)
                                            return false;
                                        // migration is new and not executed. now check if its timestamp is correct
                                        if (lastTimeExecutedMigration && migration.timestamp < lastTimeExecutedMigration.timestamp)
                                            throw new Error("New migration found: " + migration.name + ", however this migration's timestamp is not valid. Migration's timestamp should not be older then migrations already executed in the database.");
                                        // every check is passed means that migration was not run yet and we need to run it
                                        return true;
                                    });
                                    // if no migrations are pending then nothing to do here
                                    if (!pendingMigrations.length) {
                                        this.connection.logger.logSchemaBuild("No migrations are pending");
                                        return [2 /*return*/];
                                    }
                                    // log information about migration execution
                                    this.connection.logger.logSchemaBuild(executedMigrations.length + " migrations are already loaded in the database.");
                                    this.connection.logger.logSchemaBuild(allMigrations.length + " migrations were found in the source code.");
                                    if (lastTimeExecutedMigration)
                                        this.connection.logger.logSchemaBuild(lastTimeExecutedMigration.name + " is the last executed migration. It was executed on " + new Date(lastTimeExecutedMigration.timestamp * 1000).toString() + ".");
                                    this.connection.logger.logSchemaBuild(pendingMigrations.length + " migrations are new migrations that needs to be executed.");
                                    transactionStartedByUs = false;
                                    if (!!queryRunner.isTransactionActive) return [3 /*break*/, 4];
                                    return [4 /*yield*/, queryRunner.startTransaction()];
                                case 3:
                                    _a.sent();
                                    transactionStartedByUs = true;
                                    _a.label = 4;
                                case 4:
                                    _a.trys.push([4, 8, 13, 16]);
                                    return [4 /*yield*/, PromiseUtils_4.PromiseUtils.runInSequence(pendingMigrations, function (migration) {
                                            return migration.instance.up(queryRunner)
                                                .then(function () {
                                                return _this.insertExecutedMigration(queryRunner, migration);
                                            })
                                                .then(function () {
                                                _this.connection.logger.logSchemaBuild("Migration " + migration.name + " has been executed successfully.");
                                            });
                                        })];
                                case 5:
                                    _a.sent();
                                    if (!transactionStartedByUs) return [3 /*break*/, 7];
                                    return [4 /*yield*/, queryRunner.commitTransaction()];
                                case 6:
                                    _a.sent();
                                    _a.label = 7;
                                case 7: return [3 /*break*/, 16];
                                case 8:
                                    err_7 = _a.sent();
                                    if (!transactionStartedByUs) return [3 /*break*/, 12];
                                    _a.label = 9;
                                case 9:
                                    _a.trys.push([9, 11, , 12]);
                                    return [4 /*yield*/, queryRunner.rollbackTransaction()];
                                case 10:
                                    _a.sent();
                                    return [3 /*break*/, 12];
                                case 11:
                                    rollbackError_10 = _a.sent();
                                    return [3 /*break*/, 12];
                                case 12: throw err_7;
                                case 13:
                                    if (!!this.queryRunner) return [3 /*break*/, 15];
                                    return [4 /*yield*/, queryRunner.release()];
                                case 14:
                                    _a.sent();
                                    _a.label = 15;
                                case 15: return [7 /*endfinally*/];
                                case 16: return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Reverts last migration that were run.
                 */
                MigrationExecutor.prototype.undoLastMigration = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var queryRunner, executedMigrations, lastTimeExecutedMigration, allMigrations, migrationToRevert, transactionStartedByUs, err_8, rollbackError_11;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    queryRunner = this.queryRunner || this.connection.createQueryRunner("master");
                                    // create migrations table if its not created yet
                                    return [4 /*yield*/, this.createMigrationsTableIfNotExist(queryRunner)];
                                case 1:
                                    // create migrations table if its not created yet
                                    _a.sent();
                                    return [4 /*yield*/, this.loadExecutedMigrations(queryRunner)];
                                case 2:
                                    executedMigrations = _a.sent();
                                    lastTimeExecutedMigration = this.getLatestMigration(executedMigrations);
                                    // if no migrations found in the database then nothing to revert
                                    if (!lastTimeExecutedMigration) {
                                        this.connection.logger.logSchemaBuild("No migrations was found in the database. Nothing to revert!");
                                        return [2 /*return*/];
                                    }
                                    allMigrations = this.getMigrations();
                                    migrationToRevert = allMigrations.find(function (migration) { return migration.name === lastTimeExecutedMigration.name; });
                                    // if no migrations found in the database then nothing to revert
                                    if (!migrationToRevert)
                                        throw new Error("No migration " + lastTimeExecutedMigration.name + " was found in the source code. Make sure you have this migration in your codebase and its included in the connection options.");
                                    // log information about migration execution
                                    this.connection.logger.logSchemaBuild(executedMigrations.length + " migrations are already loaded in the database.");
                                    this.connection.logger.logSchemaBuild(lastTimeExecutedMigration.name + " is the last executed migration. It was executed on " + new Date(lastTimeExecutedMigration.timestamp * 1000).toString() + ".");
                                    this.connection.logger.logSchemaBuild("Now reverting it...");
                                    transactionStartedByUs = false;
                                    if (!!queryRunner.isTransactionActive) return [3 /*break*/, 4];
                                    return [4 /*yield*/, queryRunner.startTransaction()];
                                case 3:
                                    _a.sent();
                                    transactionStartedByUs = true;
                                    _a.label = 4;
                                case 4:
                                    _a.trys.push([4, 9, 14, 17]);
                                    return [4 /*yield*/, migrationToRevert.instance.down(queryRunner)];
                                case 5:
                                    _a.sent();
                                    return [4 /*yield*/, this.deleteExecutedMigration(queryRunner, migrationToRevert)];
                                case 6:
                                    _a.sent();
                                    this.connection.logger.logSchemaBuild("Migration " + migrationToRevert.name + " has been reverted successfully.");
                                    if (!transactionStartedByUs) return [3 /*break*/, 8];
                                    return [4 /*yield*/, queryRunner.commitTransaction()];
                                case 7:
                                    _a.sent();
                                    _a.label = 8;
                                case 8: return [3 /*break*/, 17];
                                case 9:
                                    err_8 = _a.sent();
                                    if (!transactionStartedByUs) return [3 /*break*/, 13];
                                    _a.label = 10;
                                case 10:
                                    _a.trys.push([10, 12, , 13]);
                                    return [4 /*yield*/, queryRunner.rollbackTransaction()];
                                case 11:
                                    _a.sent();
                                    return [3 /*break*/, 13];
                                case 12:
                                    rollbackError_11 = _a.sent();
                                    return [3 /*break*/, 13];
                                case 13: throw err_8;
                                case 14:
                                    if (!!this.queryRunner) return [3 /*break*/, 16];
                                    return [4 /*yield*/, queryRunner.release()];
                                case 15:
                                    _a.sent();
                                    _a.label = 16;
                                case 16: return [7 /*endfinally*/];
                                case 17: return [2 /*return*/];
                            }
                        });
                    });
                };
                // -------------------------------------------------------------------------
                // Protected Methods
                // -------------------------------------------------------------------------
                /**
                 * Creates table "migrations" that will store information about executed migrations.
                 */
                MigrationExecutor.prototype.createMigrationsTableIfNotExist = function (queryRunner) {
                    return __awaiter(this, void 0, void 0, function () {
                        var tableExist;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, queryRunner.hasTable(this.migrationsTableName)];
                                case 1:
                                    tableExist = _a.sent();
                                    if (!!tableExist) return [3 /*break*/, 3];
                                    return [4 /*yield*/, queryRunner.createTable(new Table_7.Table(this.migrationsTableName, [
                                            new TableColumn_8.TableColumn({
                                                name: "timestamp",
                                                type: this.connection.driver.normalizeType({ type: this.connection.driver.mappedDataTypes.migrationTimestamp }),
                                                isPrimary: true,
                                                isNullable: false
                                            }),
                                            new TableColumn_8.TableColumn({
                                                name: "name",
                                                type: this.connection.driver.normalizeType({ type: this.connection.driver.mappedDataTypes.migrationName }),
                                                isNullable: false
                                            }),
                                        ]))];
                                case 2:
                                    _a.sent();
                                    _a.label = 3;
                                case 3: return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Loads all migrations that were executed and saved into the database.
                 */
                MigrationExecutor.prototype.loadExecutedMigrations = function (queryRunner) {
                    return __awaiter(this, void 0, void 0, function () {
                        var migrationsRaw;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.connection.manager
                                        .createQueryBuilder(queryRunner)
                                        .select()
                                        .from(this.migrationsTableName, "migrations")
                                        .getRawMany()];
                                case 1:
                                    migrationsRaw = _a.sent();
                                    return [2 /*return*/, migrationsRaw.map(function (migrationRaw) {
                                            return new Migration_1.Migration(parseInt(migrationRaw["timestamp"]), migrationRaw["name"]);
                                        })];
                            }
                        });
                    });
                };
                /**
                 * Gets all migrations that setup for this connection.
                 */
                MigrationExecutor.prototype.getMigrations = function () {
                    var migrations = this.connection.migrations.map(function (migration) {
                        var migrationClassName = migration.constructor.name;
                        var migrationTimestamp = parseInt(migrationClassName.substr(-13));
                        if (!migrationTimestamp)
                            throw new Error(migrationClassName + " migration name is wrong. Migration class name should have a UNIX timestamp appended. ");
                        return new Migration_1.Migration(migrationTimestamp, migrationClassName, migration);
                    });
                    // sort them by timestamp
                    return migrations.sort(function (a, b) { return a.timestamp - b.timestamp; });
                };
                /**
                 * Finds the latest migration (sorts by timestamp) in the given array of migrations.
                 */
                MigrationExecutor.prototype.getLatestMigration = function (migrations) {
                    var sortedMigrations = migrations.map(function (migration) { return migration; }).sort(function (a, b) { return (a.timestamp - b.timestamp) * -1; });
                    return sortedMigrations.length > 0 ? sortedMigrations[0] : undefined;
                };
                /**
                 * Inserts new executed migration's data into migrations table.
                 */
                MigrationExecutor.prototype.insertExecutedMigration = function (queryRunner, migration) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (!(this.connection.driver instanceof SqlServerDriver_6.SqlServerDriver)) return [3 /*break*/, 2];
                                    return [4 /*yield*/, queryRunner.insert(this.migrationsTableName, {
                                            timestamp: new MssqlParameter_3.MssqlParameter(migration.timestamp, this.connection.driver.normalizeType({ type: this.connection.driver.mappedDataTypes.migrationTimestamp })),
                                            name: new MssqlParameter_3.MssqlParameter(migration.name, this.connection.driver.normalizeType({ type: this.connection.driver.mappedDataTypes.migrationName })),
                                        })];
                                case 1:
                                    _a.sent();
                                    return [3 /*break*/, 4];
                                case 2: return [4 /*yield*/, queryRunner.insert(this.migrationsTableName, {
                                        timestamp: migration.timestamp,
                                        name: migration.name,
                                    })];
                                case 3:
                                    _a.sent();
                                    _a.label = 4;
                                case 4: return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Delete previously executed migration's data from the migrations table.
                 */
                MigrationExecutor.prototype.deleteExecutedMigration = function (queryRunner, migration) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (!(this.connection.driver instanceof SqlServerDriver_6.SqlServerDriver)) return [3 /*break*/, 2];
                                    return [4 /*yield*/, queryRunner.delete(this.migrationsTableName, {
                                            timestamp: new MssqlParameter_3.MssqlParameter(migration.timestamp, this.connection.driver.normalizeType({ type: this.connection.driver.mappedDataTypes.migrationTimestamp })),
                                            name: new MssqlParameter_3.MssqlParameter(migration.name, this.connection.driver.normalizeType({ type: this.connection.driver.mappedDataTypes.migrationName })),
                                        })];
                                case 1:
                                    _a.sent();
                                    return [3 /*break*/, 4];
                                case 2: return [4 /*yield*/, queryRunner.delete(this.migrationsTableName, {
                                        timestamp: migration.timestamp,
                                        name: migration.name,
                                    })];
                                case 3:
                                    _a.sent();
                                    _a.label = 4;
                                case 4: return [2 /*return*/];
                            }
                        });
                    });
                };
                return MigrationExecutor;
            }());
            exports_177("MigrationExecutor", MigrationExecutor);
        }
    };
});
System.register("typeorm/error/MissingPrimaryColumnError", [], function (exports_178, context_178) {
    "use strict";
    var __moduleName = context_178 && context_178.id;
    var MissingPrimaryColumnError;
    return {
        setters: [],
        execute: function () {
            /**
             */
            MissingPrimaryColumnError = /** @class */ (function (_super) {
                __extends(MissingPrimaryColumnError, _super);
                function MissingPrimaryColumnError(entityMetadata) {
                    var _this = _super.call(this) || this;
                    _this.name = "MissingPrimaryColumnError";
                    _this.message = "Entity \"" + entityMetadata.name + "\" does not have a primary column. Primary column is required to " +
                        "have in all your entities. Use @PrimaryColumn decorator to add a primary column to your entity.";
                    return _this;
                }
                return MissingPrimaryColumnError;
            }(Error));
            exports_178("MissingPrimaryColumnError", MissingPrimaryColumnError);
        }
    };
});
System.register("typeorm/error/CircularRelationsError", [], function (exports_179, context_179) {
    "use strict";
    var __moduleName = context_179 && context_179.id;
    var CircularRelationsError;
    return {
        setters: [],
        execute: function () {
            /**
             * Thrown when circular relations detected with nullable set to false.
             */
            CircularRelationsError = /** @class */ (function (_super) {
                __extends(CircularRelationsError, _super);
                function CircularRelationsError(path) {
                    var _this = _super.call(this, "Circular relations detected: " + path + ". To resolve this issue you need to set nullable: false somewhere in this dependency structure.") || this;
                    _this.name = "CircularRelationsError";
                    return _this;
                }
                return CircularRelationsError;
            }(Error));
            exports_179("CircularRelationsError", CircularRelationsError);
        }
    };
});
/**
 * This source code is from https://github.com/jriecken/dependency-graph
 * Just added "any" types here, wrapper everything into exported class.
 * We cant use a package itself because we want to package "everything-in-it" for the frontend users of TypeORM.
 */
System.register("typeorm/util/DepGraph", [], function (exports_180, context_180) {
    "use strict";
    var __moduleName = context_180 && context_180.id;
    /**
     * A simple dependency graph
     */
    /**
     * Helper for creating a Depth-First-Search on
     * a set of edges.
     *
     * Detects cycles and throws an Error if one is detected.
     *
     * @param edges The set of edges to DFS through
     * @param leavesOnly Whether to only return "leaf" nodes (ones who have no edges)
     * @param result An array in which the results will be populated
     */
    function createDFS(edges, leavesOnly, result) {
        var currentPath = [];
        var visited = {};
        return function DFS(currentNode) {
            visited[currentNode] = true;
            currentPath.push(currentNode);
            edges[currentNode].forEach(function (node) {
                if (!visited[node]) {
                    DFS(node);
                }
                else if (currentPath.indexOf(node) >= 0) {
                    currentPath.push(node);
                    throw new Error("Dependency Cycle Found: " + currentPath.join(" -> "));
                }
            });
            currentPath.pop();
            if ((!leavesOnly || edges[currentNode].length === 0) && result.indexOf(currentNode) === -1) {
                result.push(currentNode);
            }
        };
    }
    var DepGraph;
    return {
        setters: [],
        execute: function () {/**
             * This source code is from https://github.com/jriecken/dependency-graph
             * Just added "any" types here, wrapper everything into exported class.
             * We cant use a package itself because we want to package "everything-in-it" for the frontend users of TypeORM.
             */
            DepGraph = /** @class */ (function () {
                function DepGraph() {
                    this.nodes = {};
                    this.outgoingEdges = {}; // Node -> [Dependency Node]
                    this.incomingEdges = {}; // Node -> [Dependant Node]
                }
                /**
                 * Add a node to the dependency graph. If a node already exists, this method will do nothing.
                 */
                DepGraph.prototype.addNode = function (node, data) {
                    if (!this.hasNode(node)) {
                        // Checking the arguments length allows the user to add a node with undefined data
                        if (arguments.length === 2) {
                            this.nodes[node] = data;
                        }
                        else {
                            this.nodes[node] = node;
                        }
                        this.outgoingEdges[node] = [];
                        this.incomingEdges[node] = [];
                    }
                };
                /**
                 * Remove a node from the dependency graph. If a node does not exist, this method will do nothing.
                 */
                DepGraph.prototype.removeNode = function (node) {
                    if (this.hasNode(node)) {
                        delete this.nodes[node];
                        delete this.outgoingEdges[node];
                        delete this.incomingEdges[node];
                        [this.incomingEdges, this.outgoingEdges].forEach(function (edgeList) {
                            Object.keys(edgeList).forEach(function (key) {
                                var idx = edgeList[key].indexOf(node);
                                if (idx >= 0) {
                                    edgeList[key].splice(idx, 1);
                                }
                            }, this);
                        });
                    }
                };
                /**
                 * Check if a node exists in the graph
                 */
                DepGraph.prototype.hasNode = function (node) {
                    return this.nodes.hasOwnProperty(node);
                };
                /**
                 * Get the data associated with a node name
                 */
                DepGraph.prototype.getNodeData = function (node) {
                    if (this.hasNode(node)) {
                        return this.nodes[node];
                    }
                    else {
                        throw new Error("Node does not exist: " + node);
                    }
                };
                /**
                 * Set the associated data for a given node name. If the node does not exist, this method will throw an error
                 */
                DepGraph.prototype.setNodeData = function (node, data) {
                    if (this.hasNode(node)) {
                        this.nodes[node] = data;
                    }
                    else {
                        throw new Error("Node does not exist: " + node);
                    }
                };
                /**
                 * Add a dependency between two nodes. If either of the nodes does not exist,
                 * an Error will be thrown.
                 */
                DepGraph.prototype.addDependency = function (from, to) {
                    if (!this.hasNode(from)) {
                        throw new Error("Node does not exist: " + from);
                    }
                    if (!this.hasNode(to)) {
                        throw new Error("Node does not exist: " + to);
                    }
                    if (this.outgoingEdges[from].indexOf(to) === -1) {
                        this.outgoingEdges[from].push(to);
                    }
                    if (this.incomingEdges[to].indexOf(from) === -1) {
                        this.incomingEdges[to].push(from);
                    }
                    return true;
                };
                /**
                 * Remove a dependency between two nodes.
                 */
                DepGraph.prototype.removeDependency = function (from, to) {
                    var idx;
                    if (this.hasNode(from)) {
                        idx = this.outgoingEdges[from].indexOf(to);
                        if (idx >= 0) {
                            this.outgoingEdges[from].splice(idx, 1);
                        }
                    }
                    if (this.hasNode(to)) {
                        idx = this.incomingEdges[to].indexOf(from);
                        if (idx >= 0) {
                            this.incomingEdges[to].splice(idx, 1);
                        }
                    }
                };
                /**
                 * Get an array containing the nodes that the specified node depends on (transitively).
                 *
                 * Throws an Error if the graph has a cycle, or the specified node does not exist.
                 *
                 * If `leavesOnly` is true, only nodes that do not depend on any other nodes will be returned
                 * in the array.
                 */
                DepGraph.prototype.dependenciesOf = function (node, leavesOnly) {
                    if (this.hasNode(node)) {
                        var result = [];
                        var DFS = createDFS(this.outgoingEdges, leavesOnly, result);
                        DFS(node);
                        var idx = result.indexOf(node);
                        if (idx >= 0) {
                            result.splice(idx, 1);
                        }
                        return result;
                    }
                    else {
                        throw new Error("Node does not exist: " + node);
                    }
                };
                /**
                 * get an array containing the nodes that depend on the specified node (transitively).
                 *
                 * Throws an Error if the graph has a cycle, or the specified node does not exist.
                 *
                 * If `leavesOnly` is true, only nodes that do not have any dependants will be returned in the array.
                 */
                DepGraph.prototype.dependantsOf = function (node, leavesOnly) {
                    if (this.hasNode(node)) {
                        var result = [];
                        var DFS = createDFS(this.incomingEdges, leavesOnly, result);
                        DFS(node);
                        var idx = result.indexOf(node);
                        if (idx >= 0) {
                            result.splice(idx, 1);
                        }
                        return result;
                    }
                    else {
                        throw new Error("Node does not exist: " + node);
                    }
                };
                /**
                 * Construct the overall processing order for the dependency graph.
                 *
                 * Throws an Error if the graph has a cycle.
                 *
                 * If `leavesOnly` is true, only nodes that do not depend on any other nodes will be returned.
                 */
                DepGraph.prototype.overallOrder = function (leavesOnly) {
                    var self = this;
                    var result = [];
                    var keys = Object.keys(this.nodes);
                    if (keys.length === 0) {
                        return result; // Empty graph
                    }
                    else {
                        // Look for cycles - we run the DFS starting at all the nodes in case there
                        // are several disconnected subgraphs inside this dependency graph.
                        var CycleDFS_1 = createDFS(this.outgoingEdges, false, []);
                        keys.forEach(function (n) {
                            CycleDFS_1(n);
                        });
                        var DFS_1 = createDFS(this.outgoingEdges, leavesOnly, result);
                        // Find all potential starting points (nodes with nothing depending on them) an
                        // run a DFS starting at these points to get the order
                        keys.filter(function (node) {
                            return self.incomingEdges[node].length === 0;
                        }).forEach(function (n) {
                            DFS_1(n);
                        });
                        return result;
                    }
                };
                return DepGraph;
            }());
            exports_180("DepGraph", DepGraph);
        }
    };
});
System.register("typeorm/error/DataTypeNotSupportedError", [], function (exports_181, context_181) {
    "use strict";
    var __moduleName = context_181 && context_181.id;
    var DataTypeNotSupportedError;
    return {
        setters: [],
        execute: function () {
            DataTypeNotSupportedError = /** @class */ (function (_super) {
                __extends(DataTypeNotSupportedError, _super);
                function DataTypeNotSupportedError(column, dataType, database) {
                    var _this = _super.call(this) || this;
                    _this.name = "DataTypeNotSupportedError";
                    var type = typeof dataType === "string" ? dataType : dataType.name;
                    _this.message = "Data type \"" + type + "\" in \"" + column.entityMetadata.targetName + "." + column.propertyName + "\" is not supported by \"" + database + "\" database.";
                    return _this;
                }
                return DataTypeNotSupportedError;
            }(Error));
            exports_181("DataTypeNotSupportedError", DataTypeNotSupportedError);
        }
    };
});
System.register("typeorm/metadata-builder/EntityMetadataValidator", ["typeorm/error/MissingPrimaryColumnError", "typeorm/error/CircularRelationsError", "typeorm/util/DepGraph", "typeorm/error/DataTypeNotSupportedError", "typeorm/driver/mongodb/MongoDriver", "typeorm/driver/sqlserver/SqlServerDriver", "typeorm/driver/mysql/MysqlDriver"], function (exports_182, context_182) {
    "use strict";
    var __moduleName = context_182 && context_182.id;
    var MissingPrimaryColumnError_1, CircularRelationsError_1, DepGraph_1, DataTypeNotSupportedError_1, MongoDriver_6, SqlServerDriver_7, MysqlDriver_4, EntityMetadataValidator;
    return {
        setters: [
            function (MissingPrimaryColumnError_1_1) {
                MissingPrimaryColumnError_1 = MissingPrimaryColumnError_1_1;
            },
            function (CircularRelationsError_1_1) {
                CircularRelationsError_1 = CircularRelationsError_1_1;
            },
            function (DepGraph_1_1) {
                DepGraph_1 = DepGraph_1_1;
            },
            function (DataTypeNotSupportedError_1_1) {
                DataTypeNotSupportedError_1 = DataTypeNotSupportedError_1_1;
            },
            function (MongoDriver_6_1) {
                MongoDriver_6 = MongoDriver_6_1;
            },
            function (SqlServerDriver_7_1) {
                SqlServerDriver_7 = SqlServerDriver_7_1;
            },
            function (MysqlDriver_4_1) {
                MysqlDriver_4 = MysqlDriver_4_1;
            }
        ],
        execute: function () {
            /// todo: add check if there are multiple tables with the same name
            /// todo: add checks when generated column / table names are too long for the specific driver
            // todo: type in function validation, inverse side function validation
            // todo: check on build for duplicate names, since naming checking was removed from MetadataStorage
            // todo: duplicate name checking for: table, relation, column, index, naming strategy, join tables/columns?
            // todo: check if multiple tree parent metadatas in validator
            // todo: tree decorators can be used only on closure table (validation)
            // todo: throw error if parent tree metadata was not specified in a closure table
            // todo: MetadataArgsStorage: type in function validation, inverse side function validation
            // todo: MetadataArgsStorage: check on build for duplicate names, since naming checking was removed from MetadataStorage
            // todo: MetadataArgsStorage: duplicate name checking for: table, relation, column, index, naming strategy, join tables/columns?
            // todo: MetadataArgsStorage: check for duplicate targets too since this check has been removed too
            /**
             * Validates built entity metadatas.
             */
            EntityMetadataValidator = /** @class */ (function () {
                function EntityMetadataValidator() {
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Validates all given entity metadatas.
                 */
                EntityMetadataValidator.prototype.validateMany = function (entityMetadatas, driver) {
                    var _this = this;
                    entityMetadatas.forEach(function (entityMetadata) { return _this.validate(entityMetadata, entityMetadatas, driver); });
                    this.validateDependencies(entityMetadatas);
                    this.validateEagerRelations(entityMetadatas);
                };
                /**
                 * Validates given entity metadata.
                 */
                EntityMetadataValidator.prototype.validate = function (entityMetadata, allEntityMetadatas, driver) {
                    // check if table metadata has an id
                    if (!entityMetadata.isClassTableChild && !entityMetadata.primaryColumns.length && !entityMetadata.isJunction)
                        throw new MissingPrimaryColumnError_1.MissingPrimaryColumnError(entityMetadata);
                    // validate if table is using inheritance it has a discriminator
                    // also validate if discriminator values are not empty and not repeated
                    if (entityMetadata.inheritanceType === "single-table") {
                        if (!entityMetadata.discriminatorColumn)
                            throw new Error("Entity " + entityMetadata.name + " using single-table inheritance, it should also have a discriminator column. Did you forget to put @DiscriminatorColumn decorator?");
                        if (["", undefined, null].indexOf(entityMetadata.discriminatorValue) !== -1)
                            throw new Error("Entity " + entityMetadata.name + " has empty discriminator value. Discriminator value should not be empty.");
                        var sameDiscriminatorValueEntityMetadata = allEntityMetadatas.find(function (metadata) {
                            return metadata !== entityMetadata && metadata.discriminatorValue === entityMetadata.discriminatorValue;
                        });
                        if (sameDiscriminatorValueEntityMetadata)
                            throw new Error("Entities " + entityMetadata.name + " and " + sameDiscriminatorValueEntityMetadata.name + " as equal discriminator values. Make sure their discriminator values are not equal using @DiscriminatorValue decorator.");
                    }
                    entityMetadata.relationCounts.forEach(function (relationCount) {
                        if (relationCount.relation.isManyToOne || relationCount.relation.isOneToOne)
                            throw new Error("Relation count can not be implemented on ManyToOne or OneToOne relations.");
                    });
                    if (!(driver instanceof MongoDriver_6.MongoDriver)) {
                        entityMetadata.columns.forEach(function (column) {
                            var normalizedColumn = driver.normalizeType(column);
                            if (driver.supportedDataTypes.indexOf(normalizedColumn) === -1)
                                throw new DataTypeNotSupportedError_1.DataTypeNotSupportedError(column, normalizedColumn, driver.options.type);
                            if (column.length && driver.withLengthColumnTypes.indexOf(normalizedColumn) === -1)
                                throw new Error("Column " + column.propertyName + " of Entity " + entityMetadata.name + " does not support length property.");
                        });
                    }
                    /* if (driver instanceof MysqlDriver) {
                         const generatedColumns = entityMetadata.columns.filter(column => column.isGenerated && column.generationStrategy !== "uuid");
                         if (generatedColumns.length > 1)
                             throw new Error(`Error in ${entityMetadata.name} entity. There can be only one auto-increment column in MySql table.`);
                     }*/
                    if (driver instanceof MysqlDriver_4.MysqlDriver) {
                        var metadatasWithDatabase = allEntityMetadatas.filter(function (metadata) { return metadata.database; });
                        if (metadatasWithDatabase.length === 0 && !driver.database)
                            throw new Error("Database not specified");
                    }
                    if (driver instanceof SqlServerDriver_7.SqlServerDriver) {
                        var charsetColumns = entityMetadata.columns.filter(function (column) { return column.charset; });
                        if (charsetColumns.length > 1)
                            throw new Error("Character set specifying is not supported in Sql Server");
                    }
                    // validate relations
                    entityMetadata.relations.forEach(function (relation) {
                        // check join tables:
                        // using JoinTable is possible only on one side of the many-to-many relation
                        // todo(dima): fix
                        // if (relation.joinTable) {
                        //     if (!relation.isManyToMany)
                        //         throw new UsingJoinTableIsNotAllowedError(entityMetadata, relation);
                        //     // if there is inverse side of the relation, then check if it does not have join table too
                        //     if (relation.hasInverseSide && relation.inverseRelation.joinTable)
                        //         throw new UsingJoinTableOnlyOnOneSideAllowedError(entityMetadata, relation);
                        // }
                        // check join columns:
                        // using JoinColumn is possible only on one side of the relation and on one-to-one, many-to-one relation types
                        // first check if relation is one-to-one or many-to-one
                        // todo(dima): fix
                        /*if (relation.joinColumn) {
            
                            // join column can be applied only on one-to-one and many-to-one relations
                            if (!relation.isOneToOne && !relation.isManyToOne)
                                throw new UsingJoinColumnIsNotAllowedError(entityMetadata, relation);
            
                            // if there is inverse side of the relation, then check if it does not have join table too
                            if (relation.hasInverseSide && relation.inverseRelation.joinColumn && relation.isOneToOne)
                                throw new UsingJoinColumnOnlyOnOneSideAllowedError(entityMetadata, relation);
            
                            // check if join column really has referenced column
                            if (relation.joinColumn && !relation.joinColumn.referencedColumn)
                                throw new Error(`Join column does not have referenced column set`);
            
                        }
            
                        // if its a one-to-one relation and JoinColumn is missing on both sides of the relation
                        // or its one-side relation without JoinColumn we should give an error
                        if (!relation.joinColumn && relation.isOneToOne && (!relation.hasInverseSide || !relation.inverseRelation.joinColumn))
                            throw new MissingJoinColumnError(entityMetadata, relation);*/
                        // if its a many-to-many relation and JoinTable is missing on both sides of the relation
                        // or its one-side relation without JoinTable we should give an error
                        // todo(dima): fix it
                        // if (!relation.joinTable && relation.isManyToMany && (!relation.hasInverseSide || !relation.inverseRelation.joinTable))
                        //     throw new MissingJoinTableError(entityMetadata, relation);
                        // todo: validate if its one-to-one and side which does not have join column MUST have inverse side
                        // todo: validate if its many-to-many and side which does not have join table MUST have inverse side
                        // todo: if there is a relation, and inverse side is specified only on one side, shall we give error
                        // todo: with message like: "Inverse side is specified only on one side of the relationship. Specify on other side too to prevent confusion".
                        // todo: add validation if there two entities with the same target, and show error message with description of the problem (maybe file was renamed/moved but left in output directory)
                        // todo: check if there are multiple columns on the same column applied.
                        // todo: check column type if is missing in relational databases (throw new Error(`Column type of ${type} cannot be determined.`);)
                        // todo: include driver-specific checks. for example in mongodb empty prefixes are not allowed
                        // todo: if multiple columns with same name - throw exception, including cases when columns are in embeds with same prefixes or without prefix at all
                        // todo: if multiple primary key used, at least one of them must be unique or @Index decorator must be set on entity
                        // todo: check if entity with duplicate names, some decorators exist
                    });
                    // make sure cascade remove is not set for both sides of relationships (can be set in OneToOne decorators)
                    entityMetadata.relations.forEach(function (relation) {
                        var isCircularCascadeRemove = relation.isCascadeRemove && relation.inverseRelation && relation.inverseRelation.isCascadeRemove;
                        if (isCircularCascadeRemove)
                            throw new Error("Relation " + entityMetadata.name + "#" + relation.propertyName + " and " + relation.inverseRelation.entityMetadata.name + "#" + relation.inverseRelation.propertyName + " both has cascade remove set. " +
                                "This may lead to unexpected circular removals. Please set cascade remove only from one side of relationship.");
                    }); // todo: maybe better just deny removal from one to one relation without join column?
                    entityMetadata.eagerRelations.forEach(function (relation) {
                    });
                };
                /**
                 * Validates dependencies of the entity metadatas.
                 */
                EntityMetadataValidator.prototype.validateDependencies = function (entityMetadatas) {
                    var graph = new DepGraph_1.DepGraph();
                    entityMetadatas.forEach(function (entityMetadata) {
                        graph.addNode(entityMetadata.name);
                    });
                    entityMetadatas.forEach(function (entityMetadata) {
                        entityMetadata.relationsWithJoinColumns
                            .filter(function (relation) { return !relation.isNullable; })
                            .forEach(function (relation) {
                            graph.addDependency(entityMetadata.name, relation.inverseEntityMetadata.name);
                        });
                    });
                    try {
                        graph.overallOrder();
                    }
                    catch (err) {
                        throw new CircularRelationsError_1.CircularRelationsError(err.toString().replace("Error: Dependency Cycle Found: ", ""));
                    }
                };
                /**
                 * Validates eager relations to prevent circular dependency in them.
                 */
                EntityMetadataValidator.prototype.validateEagerRelations = function (entityMetadatas) {
                    entityMetadatas.forEach(function (entityMetadata) {
                        entityMetadata.eagerRelations.forEach(function (relation) {
                            if (relation.inverseRelation && relation.inverseRelation.isEager)
                                throw new Error("Circular eager relations are disallowed. " +
                                    (entityMetadata.targetName + "#" + relation.propertyPath + " contains \"eager: true\", and its inverse side ") +
                                    (relation.inverseEntityMetadata.targetName + "#" + relation.inverseRelation.propertyPath + " contains \"eager: true\" as well.") +
                                    " Remove \"eager: true\" from one side of the relation.");
                        });
                    });
                };
                return EntityMetadataValidator;
            }());
            exports_182("EntityMetadataValidator", EntityMetadataValidator);
        }
    };
});
System.register("typeorm/entity-manager/SqljsEntityManager", ["typeorm/entity-manager/EntityManager"], function (exports_183, context_183) {
    "use strict";
    var __moduleName = context_183 && context_183.id;
    var EntityManager_2, SqljsEntityManager;
    return {
        setters: [
            function (EntityManager_2_1) {
                EntityManager_2 = EntityManager_2_1;
            }
        ],
        execute: function () {
            /**
             * A special EntityManager that includes import/export and load/save function
             * that are unique to Sql.js.
             */
            SqljsEntityManager = /** @class */ (function (_super) {
                __extends(SqljsEntityManager, _super);
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function SqljsEntityManager(connection, queryRunner) {
                    var _this = _super.call(this, connection, queryRunner) || this;
                    _this.driver = connection.driver;
                    return _this;
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Loads either the definition from a file (Node.js) or localstorage (browser)
                 * or uses the given definition to open a new database.
                 */
                SqljsEntityManager.prototype.loadDatabase = function (fileNameOrLocalStorageOrData) {
                    this.driver.load(fileNameOrLocalStorageOrData);
                };
                /**
                 * Saves the current database to a file (Node.js) or localstorage (browser)
                 * if fileNameOrLocalStorage is not set options.location is used.
                 */
                SqljsEntityManager.prototype.saveDatabase = function (fileNameOrLocalStorage) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.driver.save(fileNameOrLocalStorage)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Returns the current database definition.
                 */
                SqljsEntityManager.prototype.exportDatabase = function () {
                    return this.driver.export();
                };
                return SqljsEntityManager;
            }(EntityManager_2.EntityManager));
            exports_183("SqljsEntityManager", SqljsEntityManager);
        }
    };
});
System.register("typeorm/entity-manager/EntityManagerFactory", ["typeorm/entity-manager/EntityManager", "typeorm/entity-manager/MongoEntityManager", "typeorm/driver/mongodb/MongoDriver", "typeorm/entity-manager/SqljsEntityManager", "typeorm/driver/sqljs/SqljsDriver"], function (exports_184, context_184) {
    "use strict";
    var __moduleName = context_184 && context_184.id;
    var EntityManager_3, MongoEntityManager_1, MongoDriver_7, SqljsEntityManager_1, SqljsDriver_2, EntityManagerFactory;
    return {
        setters: [
            function (EntityManager_3_1) {
                EntityManager_3 = EntityManager_3_1;
            },
            function (MongoEntityManager_1_1) {
                MongoEntityManager_1 = MongoEntityManager_1_1;
            },
            function (MongoDriver_7_1) {
                MongoDriver_7 = MongoDriver_7_1;
            },
            function (SqljsEntityManager_1_1) {
                SqljsEntityManager_1 = SqljsEntityManager_1_1;
            },
            function (SqljsDriver_2_1) {
                SqljsDriver_2 = SqljsDriver_2_1;
            }
        ],
        execute: function () {
            /**
             * Helps to create entity managers.
             */
            EntityManagerFactory = /** @class */ (function () {
                function EntityManagerFactory() {
                }
                /**
                 * Creates a new entity manager depend on a given connection's driver.
                 */
                EntityManagerFactory.prototype.create = function (connection, queryRunner) {
                    if (connection.driver instanceof MongoDriver_7.MongoDriver)
                        return new MongoEntityManager_1.MongoEntityManager(connection);
                    if (connection.driver instanceof SqljsDriver_2.SqljsDriver)
                        return new SqljsEntityManager_1.SqljsEntityManager(connection, queryRunner);
                    return new EntityManager_3.EntityManager(connection, queryRunner);
                };
                return EntityManagerFactory;
            }());
            exports_184("EntityManagerFactory", EntityManagerFactory);
        }
    };
});
System.register("typeorm/error/MissingDriverError", [], function (exports_185, context_185) {
    "use strict";
    var __moduleName = context_185 && context_185.id;
    var MissingDriverError;
    return {
        setters: [],
        execute: function () {
            /**
             * Thrown when consumer specifies driver type that does not exist or supported.
             */
            MissingDriverError = /** @class */ (function (_super) {
                __extends(MissingDriverError, _super);
                function MissingDriverError(driverType) {
                    var _this = _super.call(this) || this;
                    _this.name = "MissingDriverError";
                    _this.message = "Wrong driver " + driverType + " given. Supported drivers are: \"cordova\", \"mysql\", \"postgres\", \"mssql\", \"oracle\", \"mariadb\", \"sqlite\".";
                    _this.stack = new Error().stack;
                    return _this;
                }
                return MissingDriverError;
            }(Error));
            exports_185("MissingDriverError", MissingDriverError);
        }
    };
});
System.register("typeorm/driver/websql/WebsqlQueryRunner", ["typeorm/error/TransactionAlreadyStartedError", "typeorm/error/TransactionNotStartedError", "typeorm/schema-builder/schema/Table", "typeorm/error/QueryRunnerAlreadyReleasedError", "typeorm/util/OrmUtils", "typeorm/error/QueryFailedError", "typeorm/driver/sqlite-abstract/AbstractSqliteQueryRunner"], function (exports_186, context_186) {
    "use strict";
    var __moduleName = context_186 && context_186.id;
    var TransactionAlreadyStartedError_6, TransactionNotStartedError_6, Table_8, QueryRunnerAlreadyReleasedError_6, OrmUtils_10, QueryFailedError_5, AbstractSqliteQueryRunner_3, WebsqlQueryRunner;
    return {
        setters: [
            function (TransactionAlreadyStartedError_6_1) {
                TransactionAlreadyStartedError_6 = TransactionAlreadyStartedError_6_1;
            },
            function (TransactionNotStartedError_6_1) {
                TransactionNotStartedError_6 = TransactionNotStartedError_6_1;
            },
            function (Table_8_1) {
                Table_8 = Table_8_1;
            },
            function (QueryRunnerAlreadyReleasedError_6_1) {
                QueryRunnerAlreadyReleasedError_6 = QueryRunnerAlreadyReleasedError_6_1;
            },
            function (OrmUtils_10_1) {
                OrmUtils_10 = OrmUtils_10_1;
            },
            function (QueryFailedError_5_1) {
                QueryFailedError_5 = QueryFailedError_5_1;
            },
            function (AbstractSqliteQueryRunner_3_1) {
                AbstractSqliteQueryRunner_3 = AbstractSqliteQueryRunner_3_1;
            }
        ],
        execute: function () {
            /**
             * Runs queries on a single websql database connection.
             */
            WebsqlQueryRunner = /** @class */ (function (_super) {
                __extends(WebsqlQueryRunner, _super);
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function WebsqlQueryRunner(driver) {
                    var _this = _super.call(this, driver) || this;
                    _this.driver = driver;
                    _this.connection = driver.connection;
                    return _this;
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Creates/uses database connection from the connection pool to perform further operations.
                 * Returns obtained database connection.
                 */
                WebsqlQueryRunner.prototype.connect = function () {
                    var _this = this;
                    if (this.databaseConnection)
                        return Promise.resolve(this.databaseConnection);
                    if (this.databaseConnectionPromise)
                        return this.databaseConnectionPromise;
                    var options = Object.assign({}, {
                        database: this.driver.options.database,
                        version: this.driver.options.version,
                        description: this.driver.options.description,
                        size: this.driver.options.size,
                    }, this.driver.options.extra || {});
                    this.databaseConnectionPromise = new Promise(function (ok, fail) {
                        _this.databaseConnection = openDatabase(options.database, options.version, options.description, options.size);
                        ok(_this.databaseConnection);
                    });
                    return this.databaseConnectionPromise;
                };
                /**
                 * Starts transaction.
                 */
                WebsqlQueryRunner.prototype.startTransaction = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            if (this.isReleased)
                                throw new QueryRunnerAlreadyReleasedError_6.QueryRunnerAlreadyReleasedError();
                            if (this.isTransactionActive)
                                throw new TransactionAlreadyStartedError_6.TransactionAlreadyStartedError();
                            this.isTransactionActive = true;
                            return [2 /*return*/];
                        });
                    });
                };
                /**
                 * Commits transaction.
                 * Error will be thrown if transaction was not started.
                 */
                WebsqlQueryRunner.prototype.commitTransaction = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            if (this.isReleased)
                                throw new QueryRunnerAlreadyReleasedError_6.QueryRunnerAlreadyReleasedError();
                            if (!this.isTransactionActive)
                                throw new TransactionNotStartedError_6.TransactionNotStartedError();
                            // await this.query("COMMIT");
                            this.isTransactionActive = false;
                            return [2 /*return*/];
                        });
                    });
                };
                /**
                 * Rollbacks transaction.
                 * Error will be thrown if transaction was not started.
                 */
                WebsqlQueryRunner.prototype.rollbackTransaction = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            if (this.isReleased)
                                throw new QueryRunnerAlreadyReleasedError_6.QueryRunnerAlreadyReleasedError();
                            if (!this.isTransactionActive)
                                throw new TransactionNotStartedError_6.TransactionNotStartedError();
                            // await this.query("ROLLBACK");
                            this.isTransactionActive = false;
                            return [2 /*return*/];
                        });
                    });
                };
                /**
                 * Executes a given SQL query.
                 */
                WebsqlQueryRunner.prototype.query = function (query, parameters) {
                    var _this = this;
                    if (this.isReleased)
                        throw new QueryRunnerAlreadyReleasedError_6.QueryRunnerAlreadyReleasedError();
                    return new Promise(function (ok, fail) { return __awaiter(_this, void 0, void 0, function () {
                        var _this = this;
                        var db, queryStartTime_4, err_9;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    _a.trys.push([0, 2, , 3]);
                                    return [4 /*yield*/, this.connect()];
                                case 1:
                                    db = _a.sent();
                                    // todo(dima): check if transaction is not active
                                    this.driver.connection.logger.logQuery(query, parameters, this);
                                    queryStartTime_4 = +new Date();
                                    db.transaction(function (tx) {
                                        tx.executeSql(query, parameters, function (tx, result) {
                                            // log slow queries if maxQueryExecution time is set
                                            var maxQueryExecutionTime = _this.driver.connection.options.maxQueryExecutionTime;
                                            var queryEndTime = +new Date();
                                            var queryExecutionTime = queryEndTime - queryStartTime_4;
                                            if (maxQueryExecutionTime && queryExecutionTime > maxQueryExecutionTime)
                                                _this.driver.connection.logger.logQuerySlow(queryExecutionTime, query, parameters, _this);
                                            var rows = Object
                                                .keys(result.rows)
                                                .filter(function (key) { return key !== "length"; })
                                                .map(function (key) { return result.rows[key]; });
                                            ok(rows);
                                        }, function (tx, err) {
                                            _this.driver.connection.logger.logQueryError(err, query, parameters, _this);
                                            return fail(new QueryFailedError_5.QueryFailedError(query, parameters, err));
                                        });
                                    });
                                    return [3 /*break*/, 3];
                                case 2:
                                    err_9 = _a.sent();
                                    fail(err_9);
                                    return [3 /*break*/, 3];
                                case 3: return [2 /*return*/];
                            }
                        });
                    }); });
                };
                /**
                 * Insert a new row with given values into the given table.
                 * Returns value of the generated column if given and generate column exist in the table.
                 */
                WebsqlQueryRunner.prototype.insert = function (tableName, keyValues) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var keys, columns, values, generatedColumns, sql, parameters;
                        return __generator(this, function (_a) {
                            keys = Object.keys(keyValues);
                            columns = keys.map(function (key) { return "\"" + key + "\""; }).join(", ");
                            values = keys.map(function (key, index) { return "$" + (index + 1); }).join(",");
                            generatedColumns = this.connection.hasMetadata(tableName) ? this.connection.getMetadata(tableName).generatedColumns : [];
                            sql = columns.length > 0 ? ("INSERT INTO \"" + tableName + "\"(" + columns + ") VALUES (" + values + ")") : "INSERT INTO \"" + tableName + "\" DEFAULT VALUES";
                            parameters = keys.map(function (key) { return keyValues[key]; });
                            return [2 /*return*/, new Promise(function (ok, fail) { return __awaiter(_this, void 0, void 0, function () {
                                    var _this = this;
                                    var db;
                                    return __generator(this, function (_a) {
                                        switch (_a.label) {
                                            case 0:
                                                this.driver.connection.logger.logQuery(sql, parameters, this);
                                                return [4 /*yield*/, this.connect()];
                                            case 1:
                                                db = _a.sent();
                                                // todo: check if transaction is not active
                                                db.transaction(function (tx) {
                                                    tx.executeSql(sql, parameters, function (tx, result) {
                                                        var generatedMap = generatedColumns.reduce(function (map, generatedColumn) {
                                                            var value = generatedColumn.isPrimary && generatedColumn.generationStrategy === "increment" && result["insertId"] ? result["insertId"] : keyValues[generatedColumn.databaseName];
                                                            if (!value)
                                                                return map;
                                                            return OrmUtils_10.OrmUtils.mergeDeep(map, generatedColumn.createValueMap(value));
                                                        }, {});
                                                        ok({
                                                            result: undefined,
                                                            generatedMap: Object.keys(generatedMap).length > 0 ? generatedMap : undefined
                                                        });
                                                    }, function (tx, err) {
                                                        _this.driver.connection.logger.logQueryError(err, sql, parameters, _this);
                                                        return fail(err);
                                                    });
                                                });
                                                return [2 /*return*/];
                                        }
                                    });
                                }); })];
                        });
                    });
                };
                // TODO: finish the table schema loading
                /**
                 * Loads all tables (with given names) from the database and creates a Table from them.
                 */
                WebsqlQueryRunner.prototype.getTables = function (tableNames) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var tableNamesString, dbTables;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    // if no tables given then no need to proceed
                                    if (!tableNames || !tableNames.length)
                                        return [2 /*return*/, []];
                                    tableNamesString = tableNames.map(function (tableName) { return "'" + tableName + "'"; }).join(", ");
                                    return [4 /*yield*/, this.query("SELECT * FROM sqlite_master WHERE type = 'table' AND name IN (" + tableNamesString + ")")];
                                case 1:
                                    dbTables = _a.sent();
                                    // if tables were not found in the db, no need to proceed
                                    if (!dbTables || !dbTables.length)
                                        return [2 /*return*/, []];
                                    // create table schemas for loaded tables
                                    return [2 /*return*/, Promise.all(dbTables.map(function (dbTable) { return __awaiter(_this, void 0, void 0, function () {
                                            var table;
                                            return __generator(this, function (_a) {
                                                table = new Table_8.Table(dbTable["name"]);
                                                // load columns and indices
                                                /*const [dbColumns, dbIndices, dbForeignKeys]: ObjectLiteral[][] = await Promise.all([
                                                    this.query(`PRAGMA table_info("${dbTable["name"]}")`),
                                                    this.query(`PRAGMA index_list("${dbTable["name"]}")`),
                                                    this.query(`PRAGMA foreign_key_list("${dbTable["name"]}")`),
                                                ]);
                                    
                                                // find column name with auto increment
                                                let autoIncrementColumnName: string|undefined = undefined;
                                                const tableSql: string = dbTable["sql"];
                                                if (tableSql.indexOf("AUTOINCREMENT") !== -1) {
                                                    autoIncrementColumnName = tableSql.substr(0, tableSql.indexOf("AUTOINCREMENT"));
                                                    const comma = autoIncrementColumnName.lastIndexOf(",");
                                                    const bracket = autoIncrementColumnName.lastIndexOf("(");
                                                    if (comma !== -1) {
                                                        autoIncrementColumnName = autoIncrementColumnName.substr(comma);
                                                        autoIncrementColumnName = autoIncrementColumnName.substr(0, autoIncrementColumnName.lastIndexOf("\""));
                                                        autoIncrementColumnName = autoIncrementColumnName.substr(autoIncrementColumnName.indexOf("\"") + 1);
                                    
                                                    } else if (bracket !== -1) {
                                                        autoIncrementColumnName = autoIncrementColumnName.substr(bracket);
                                                        autoIncrementColumnName = autoIncrementColumnName.substr(0, autoIncrementColumnName.lastIndexOf("\""));
                                                        autoIncrementColumnName = autoIncrementColumnName.substr(autoIncrementColumnName.indexOf("\"") + 1);
                                                    }
                                                }
                                    
                                                // create columns from the loaded columns
                                                table.columns = dbColumns.map(dbColumn => {
                                                    const tableColumn = new TableColumn();
                                                    tableColumn.name = dbColumn["name"];
                                                    tableColumn.type = dbColumn["type"].toLowerCase();
                                                    tableColumn.default = dbColumn["dflt_value"] !== null && dbColumn["dflt_value"] !== undefined ? dbColumn["dflt_value"] : undefined;
                                                    tableColumn.isNullable = dbColumn["notnull"] === 0;
                                                    tableColumn.isPrimary = dbColumn["pk"] === 1;
                                                    tableColumn.comment = ""; // todo later
                                                    tableColumn.isGenerated = autoIncrementColumnName === dbColumn["name"];
                                                    const columnForeignKeys = dbForeignKeys
                                                        .filter(foreignKey => foreignKey["from"] === dbColumn["name"])
                                                        .map(foreignKey => {
                                                            const keyName = namingStrategy.foreignKeyName(dbTable["name"], [foreignKey["from"]], foreignKey["table"], [foreignKey["to"]]);
                                                            return new TableForeignKey(keyName, [foreignKey["from"]], [foreignKey["to"]], foreignKey["table"], foreignKey["on_delete"]); // todo: how sqlite return from and to when they are arrays? (multiple column foreign keys)
                                                        });
                                                    table.addForeignKeys(columnForeignKeys);
                                                    return tableColumn;
                                                });
                                    
                                                // create primary key schema
                                                await Promise.all(dbIndices
                                                    .filter(index => index["origin"] === "pk")
                                                    .map(async index => {
                                                        const indexInfos: ObjectLiteral[] = await this.query(`PRAGMA index_info("${index["name"]}")`);
                                                        const indexColumns = indexInfos.map(indexInfo => indexInfo["name"]);
                                                        indexColumns.forEach(indexColumn => {
                                                            table.primaryKeys.push(new TablePrimaryKey(index["name"], indexColumn));
                                                        });
                                                    }));
                                    
                                                // create index schemas from the loaded indices
                                                const indicesPromises = dbIndices
                                                    .filter(dbIndex => {
                                                        return  dbIndex["origin"] !== "pk" &&
                                                            (!table.foreignKeys.find(foreignKey => foreignKey.name === dbIndex["name"])) &&
                                                            (!table.primaryKeys.find(primaryKey => primaryKey.name === dbIndex["name"]));
                                                    })
                                                    .map(dbIndex => dbIndex["name"])
                                                    .filter((value, index, self) => self.indexOf(value) === index) // unqiue
                                                    .map(async dbIndexName => {
                                                        const dbIndex = dbIndices.find(dbIndex => dbIndex["name"] === dbIndexName);
                                                        const indexInfos: ObjectLiteral[] = await this.query(`PRAGMA index_info("${dbIndex!["name"]}")`);
                                                        const indexColumns = indexInfos.map(indexInfo => indexInfo["name"]);
                                    
                                                        // check if db index is generated by sqlite itself and has special use case
                                                        if (dbIndex!["name"].substr(0, "sqlite_autoindex".length) === "sqlite_autoindex") {
                                                            if (dbIndex!["unique"] === 1) { // this means we have a special index generated for a column
                                                                // so we find and update the column
                                                                indexColumns.forEach(columnName => {
                                                                    const column = table.columns.find(column => column.name === columnName);
                                                                    if (column)
                                                                        column.isUnique = true;
                                                                });
                                                            }
                                    
                                                            return Promise.resolve(undefined);
                                    
                                                        } else {
                                                            return new TableIndex(dbTable["name"], dbIndex!["name"], indexColumns, dbIndex!["unique"] === "1");
                                                        }
                                                    });
                                    
                                                const indices = await Promise.all(indicesPromises);
                                                table.indices = indices.filter(index => !!index) as TableIndex[];*/
                                                return [2 /*return*/, table];
                                            });
                                        }); }))];
                            }
                        });
                    });
                };
                /**
                 * Removes all tables from the currently connected database.
                 */
                WebsqlQueryRunner.prototype.clearDatabase = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var selectDropsQuery, dropQueries, error_9, rollbackError_12;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: 
                                // await this.query(`PRAGMA foreign_keys = OFF;`);
                                return [4 /*yield*/, this.startTransaction()];
                                case 1:
                                    // await this.query(`PRAGMA foreign_keys = OFF;`);
                                    _a.sent();
                                    _a.label = 2;
                                case 2:
                                    _a.trys.push([2, 6, , 11]);
                                    selectDropsQuery = "select 'drop table \"' || name || '\";' as query from sqlite_master where type = 'table' and name != 'sqlite_sequence'";
                                    return [4 /*yield*/, this.query(selectDropsQuery)];
                                case 3:
                                    dropQueries = _a.sent();
                                    return [4 /*yield*/, Promise.all(dropQueries.map(function (q) { return _this.query(q["query"]); }))];
                                case 4:
                                    _a.sent();
                                    return [4 /*yield*/, this.commitTransaction()];
                                case 5:
                                    _a.sent();
                                    return [3 /*break*/, 11];
                                case 6:
                                    error_9 = _a.sent();
                                    _a.label = 7;
                                case 7:
                                    _a.trys.push([7, 9, , 10]);
                                    return [4 /*yield*/, this.rollbackTransaction()];
                                case 8:
                                    _a.sent();
                                    return [3 /*break*/, 10];
                                case 9:
                                    rollbackError_12 = _a.sent();
                                    return [3 /*break*/, 10];
                                case 10: throw error_9;
                                case 11: return [2 /*return*/];
                            }
                        });
                    });
                };
                return WebsqlQueryRunner;
            }(AbstractSqliteQueryRunner_3.AbstractSqliteQueryRunner));
            exports_186("WebsqlQueryRunner", WebsqlQueryRunner);
        }
    };
});
System.register("typeorm/driver/websql/WebsqlDriver", ["typeorm/driver/DriverUtils", "typeorm/error/DriverOptionNotSetError", "typeorm/driver/websql/WebsqlQueryRunner", "typeorm/driver/sqlite-abstract/AbstractSqliteDriver"], function (exports_187, context_187) {
    "use strict";
    var __moduleName = context_187 && context_187.id;
    var DriverUtils_5, DriverOptionNotSetError_2, WebsqlQueryRunner_1, AbstractSqliteDriver_5, WebsqlDriver;
    return {
        setters: [
            function (DriverUtils_5_1) {
                DriverUtils_5 = DriverUtils_5_1;
            },
            function (DriverOptionNotSetError_2_1) {
                DriverOptionNotSetError_2 = DriverOptionNotSetError_2_1;
            },
            function (WebsqlQueryRunner_1_1) {
                WebsqlQueryRunner_1 = WebsqlQueryRunner_1_1;
            },
            function (AbstractSqliteDriver_5_1) {
                AbstractSqliteDriver_5 = AbstractSqliteDriver_5_1;
            }
        ],
        execute: function () {
            /**
             * Organizes communication with WebSQL in the browser.
             */
            WebsqlDriver = /** @class */ (function (_super) {
                __extends(WebsqlDriver, _super);
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function WebsqlDriver(connection) {
                    var _this = _super.call(this, connection) || this;
                    _this.options = connection.options;
                    Object.assign(connection.options, DriverUtils_5.DriverUtils.buildDriverOptions(connection.options)); // todo: do it better way
                    _this.database = _this.options.database;
                    // validate options to make sure everything is set
                    // if (!this.options.host)
                    //     throw new DriverOptionNotSetError("host");
                    // if (!this.options.username)
                    //     throw new DriverOptionNotSetError("username");
                    if (!_this.options.database)
                        throw new DriverOptionNotSetError_2.DriverOptionNotSetError("database");
                    return _this;
                    // todo: what about extra options: version, description, size
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Performs connection to the database.
                 */
                WebsqlDriver.prototype.connect = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            return [2 /*return*/, Promise.resolve()];
                        });
                    });
                };
                /**
                 * Closes connection with the database.
                 */
                WebsqlDriver.prototype.disconnect = function () {
                    return Promise.resolve();
                    // if (!this.databaseConnection)
                    //     throw new ConnectionIsNotSetError("websql");
                    // return new Promise<void>((ok, fail) => {
                    // const handler = (err: any) => err ? fail(err) : ok();
                    // todo: find out how to close connection
                    // ok();
                    // });
                };
                /**
                 * Creates a query runner used to execute database queries.
                 */
                WebsqlDriver.prototype.createQueryRunner = function (mode) {
                    if (mode === void 0) { mode = "master"; }
                    return new WebsqlQueryRunner_1.WebsqlQueryRunner(this);
                };
                /**
                 * Prepares given value to a value to be persisted, based on its column type and metadata.
                 */
                WebsqlDriver.prototype.preparePersistentValue = function (value, columnMetadata) {
                    if (columnMetadata.type === "json") {
                        return JSON.stringify(value);
                    }
                    return _super.prototype.preparePersistentValue.call(this, value, columnMetadata);
                };
                /**
                 * Prepares given value to a value to be persisted, based on its column type or metadata.
                 */
                WebsqlDriver.prototype.prepareHydratedValue = function (value, columnMetadata) {
                    if (columnMetadata.type === "json") {
                        return JSON.parse(value);
                    }
                    return _super.prototype.prepareHydratedValue.call(this, value, columnMetadata);
                };
                /**
                 * Replaces parameters in the given sql with special escaping character
                 * and an array of parameter names to be passed to a query.
                 */
                WebsqlDriver.prototype.escapeQueryWithParameters = function (sql, parameters) {
                    if (!parameters || !Object.keys(parameters).length)
                        return [sql, []];
                    var escapedParameters = [];
                    var keys = Object.keys(parameters).map(function (parameter) { return "(:" + parameter + "\\b)"; }).join("|");
                    sql = sql.replace(new RegExp(keys, "g"), function (key) {
                        var value = parameters[key.substr(1)];
                        if (value instanceof Function) {
                            return value();
                        }
                        // Websql doesn't support queries boolean values. Therefore 1 and 0 has to be used.
                        else if ((typeof value) === "boolean") {
                            escapedParameters.push((value ? 1 : 0));
                            return "?";
                        }
                        else {
                            escapedParameters.push(value);
                            return "?";
                        }
                    }); // todo: make replace only in value statements, otherwise problems
                    return [sql, escapedParameters];
                };
                /**
                 * Escapes a column name.
                 */
                WebsqlDriver.prototype.escape = function (columnName) {
                    return columnName; // "`" + columnName + "`";
                };
                return WebsqlDriver;
            }(AbstractSqliteDriver_5.AbstractSqliteDriver));
            exports_187("WebsqlDriver", WebsqlDriver);
        }
    };
});
System.register("typeorm/driver/sqlite/SqliteQueryRunner", ["typeorm/error/QueryRunnerAlreadyReleasedError", "typeorm/util/OrmUtils", "typeorm/error/QueryFailedError", "typeorm/driver/sqlite-abstract/AbstractSqliteQueryRunner"], function (exports_188, context_188) {
    "use strict";
    var __moduleName = context_188 && context_188.id;
    var QueryRunnerAlreadyReleasedError_7, OrmUtils_11, QueryFailedError_6, AbstractSqliteQueryRunner_4, SqliteQueryRunner;
    return {
        setters: [
            function (QueryRunnerAlreadyReleasedError_7_1) {
                QueryRunnerAlreadyReleasedError_7 = QueryRunnerAlreadyReleasedError_7_1;
            },
            function (OrmUtils_11_1) {
                OrmUtils_11 = OrmUtils_11_1;
            },
            function (QueryFailedError_6_1) {
                QueryFailedError_6 = QueryFailedError_6_1;
            },
            function (AbstractSqliteQueryRunner_4_1) {
                AbstractSqliteQueryRunner_4 = AbstractSqliteQueryRunner_4_1;
            }
        ],
        execute: function () {
            /**
             * Runs queries on a single sqlite database connection.
             *
             * Does not support compose primary keys with autoincrement field.
             * todo: need to throw exception for this case.
             */
            SqliteQueryRunner = /** @class */ (function (_super) {
                __extends(SqliteQueryRunner, _super);
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function SqliteQueryRunner(driver) {
                    var _this = _super.call(this, driver) || this;
                    _this.driver = driver;
                    _this.connection = driver.connection;
                    return _this;
                }
                /**
                 * Executes a given SQL query.
                 */
                SqliteQueryRunner.prototype.query = function (query, parameters) {
                    var _this = this;
                    if (this.isReleased)
                        throw new QueryRunnerAlreadyReleasedError_7.QueryRunnerAlreadyReleasedError();
                    return new Promise(function (ok, fail) { return __awaiter(_this, void 0, void 0, function () {
                        var _this = this;
                        var databaseConnection, queryStartTime;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.connect()];
                                case 1:
                                    databaseConnection = _a.sent();
                                    this.driver.connection.logger.logQuery(query, parameters, this);
                                    queryStartTime = +new Date();
                                    databaseConnection.all(query, parameters, function (err, result) {
                                        // log slow queries if maxQueryExecution time is set
                                        var maxQueryExecutionTime = _this.driver.connection.options.maxQueryExecutionTime;
                                        var queryEndTime = +new Date();
                                        var queryExecutionTime = queryEndTime - queryStartTime;
                                        if (maxQueryExecutionTime && queryExecutionTime > maxQueryExecutionTime)
                                            _this.driver.connection.logger.logQuerySlow(queryExecutionTime, query, parameters, _this);
                                        if (err) {
                                            _this.driver.connection.logger.logQueryError(err, query, parameters, _this);
                                            fail(new QueryFailedError_6.QueryFailedError(query, parameters, err));
                                        }
                                        else {
                                            ok(result);
                                        }
                                    });
                                    return [2 /*return*/];
                            }
                        });
                    }); });
                };
                /**
                 * Insert a new row with given values into the given table.
                 * Returns value of the generated column if given and generate column exist in the table.
                 */
                SqliteQueryRunner.prototype.insert = function (tableName, keyValues) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var keys, columns, values, generatedColumns, sql, parameters;
                        return __generator(this, function (_a) {
                            keys = Object.keys(keyValues);
                            columns = keys.map(function (key) { return "\"" + key + "\""; }).join(", ");
                            values = keys.map(function (key, index) { return "$" + (index + 1); }).join(",");
                            generatedColumns = this.connection.hasMetadata(tableName) ? this.connection.getMetadata(tableName).generatedColumns : [];
                            sql = columns.length > 0 ? ("INSERT INTO \"" + tableName + "\"(" + columns + ") VALUES (" + values + ")") : "INSERT INTO \"" + tableName + "\" DEFAULT VALUES";
                            parameters = keys.map(function (key) { return keyValues[key]; });
                            return [2 /*return*/, new Promise(function (ok, fail) { return __awaiter(_this, void 0, void 0, function () {
                                    var __this, databaseConnection;
                                    return __generator(this, function (_a) {
                                        switch (_a.label) {
                                            case 0:
                                                this.driver.connection.logger.logQuery(sql, parameters, this);
                                                __this = this;
                                                return [4 /*yield*/, this.connect()];
                                            case 1:
                                                databaseConnection = _a.sent();
                                                databaseConnection.run(sql, parameters, function (err) {
                                                    var _this = this;
                                                    if (err) {
                                                        __this.driver.connection.logger.logQueryError(err, sql, parameters, this);
                                                        fail(err);
                                                    }
                                                    else {
                                                        var generatedMap = generatedColumns.reduce(function (map, generatedColumn) {
                                                            var value = generatedColumn.isPrimary && generatedColumn.generationStrategy === "increment" && _this["lastID"] ? _this["lastID"] : keyValues[generatedColumn.databaseName];
                                                            if (!value)
                                                                return map;
                                                            return OrmUtils_11.OrmUtils.mergeDeep(map, generatedColumn.createValueMap(value));
                                                        }, {});
                                                        ok({
                                                            result: undefined,
                                                            generatedMap: Object.keys(generatedMap).length > 0 ? generatedMap : undefined
                                                        });
                                                    }
                                                });
                                                return [2 /*return*/];
                                        }
                                    });
                                }); })];
                        });
                    });
                };
                return SqliteQueryRunner;
            }(AbstractSqliteQueryRunner_4.AbstractSqliteQueryRunner));
            exports_188("SqliteQueryRunner", SqliteQueryRunner);
        }
    };
});
System.register("typeorm/driver/sqlite/SqliteDriver", ["typeorm/error/DriverPackageNotInstalledError", "typeorm/driver/sqlite/SqliteQueryRunner", "typeorm/error/DriverOptionNotSetError", "typeorm/platform/PlatformTools", "typeorm/driver/sqlite-abstract/AbstractSqliteDriver"], function (exports_189, context_189) {
    "use strict";
    var __moduleName = context_189 && context_189.id;
    var DriverPackageNotInstalledError_7, SqliteQueryRunner_1, DriverOptionNotSetError_3, PlatformTools_9, AbstractSqliteDriver_6, SqliteDriver;
    return {
        setters: [
            function (DriverPackageNotInstalledError_7_1) {
                DriverPackageNotInstalledError_7 = DriverPackageNotInstalledError_7_1;
            },
            function (SqliteQueryRunner_1_1) {
                SqliteQueryRunner_1 = SqliteQueryRunner_1_1;
            },
            function (DriverOptionNotSetError_3_1) {
                DriverOptionNotSetError_3 = DriverOptionNotSetError_3_1;
            },
            function (PlatformTools_9_1) {
                PlatformTools_9 = PlatformTools_9_1;
            },
            function (AbstractSqliteDriver_6_1) {
                AbstractSqliteDriver_6 = AbstractSqliteDriver_6_1;
            }
        ],
        execute: function () {
            /**
             * Organizes communication with sqlite DBMS.
             */
            SqliteDriver = /** @class */ (function (_super) {
                __extends(SqliteDriver, _super);
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function SqliteDriver(connection) {
                    var _this = _super.call(this, connection) || this;
                    _this.connection = connection;
                    _this.options = connection.options;
                    _this.database = _this.options.database;
                    // validate options to make sure everything is set
                    if (!_this.options.database)
                        throw new DriverOptionNotSetError_3.DriverOptionNotSetError("database");
                    // load sqlite package
                    _this.loadDependencies();
                    return _this;
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Closes connection with database.
                 */
                SqliteDriver.prototype.disconnect = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        return __generator(this, function (_a) {
                            return [2 /*return*/, new Promise(function (ok, fail) {
                                    _this.queryRunner = undefined;
                                    _this.databaseConnection.close(function (err) { return err ? fail(err) : ok(); });
                                })];
                        });
                    });
                };
                /**
                 * Creates a query runner used to execute database queries.
                 */
                SqliteDriver.prototype.createQueryRunner = function (mode) {
                    if (mode === void 0) { mode = "master"; }
                    if (!this.queryRunner)
                        this.queryRunner = new SqliteQueryRunner_1.SqliteQueryRunner(this);
                    return this.queryRunner;
                };
                SqliteDriver.prototype.normalizeType = function (column) {
                    if (column.type === Buffer) {
                        return "blob";
                    }
                    return _super.prototype.normalizeType.call(this, column);
                };
                // -------------------------------------------------------------------------
                // Protected Methods
                // -------------------------------------------------------------------------
                /**
                 * Creates connection with the database.
                 */
                SqliteDriver.prototype.createDatabaseConnection = function () {
                    var _this = this;
                    return new Promise(function (ok, fail) { return __awaiter(_this, void 0, void 0, function () {
                        var databaseConnection;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.createDatabaseDirectory(this.options.database)];
                                case 1:
                                    _a.sent();
                                    databaseConnection = new this.sqlite.Database(this.options.database, function (err) {
                                        if (err)
                                            return fail(err);
                                        // we need to enable foreign keys in sqlite to make sure all foreign key related features
                                        // working properly. this also makes onDelete to work with sqlite.
                                        databaseConnection.run("PRAGMA foreign_keys = ON;", function (err, result) {
                                            if (err)
                                                return fail(err);
                                            ok(databaseConnection);
                                        });
                                    });
                                    return [2 /*return*/];
                            }
                        });
                    }); });
                };
                /**
                 * If driver dependency is not given explicitly, then try to load it via "require".
                 */
                SqliteDriver.prototype.loadDependencies = function () {
                    try {
                        this.sqlite = PlatformTools_9.PlatformTools.load("sqlite3").verbose();
                    }
                    catch (e) {
                        throw new DriverPackageNotInstalledError_7.DriverPackageNotInstalledError("SQLite", "sqlite3");
                    }
                };
                /**
                 * Auto creates database directory if it does not exist.
                 */
                SqliteDriver.prototype.createDatabaseDirectory = function (fullPath) {
                    return new Promise(function (resolve, reject) {
                        var mkdirp = PlatformTools_9.PlatformTools.load("mkdirp");
                        var path = PlatformTools_9.PlatformTools.load("path");
                        mkdirp(path.dirname(fullPath), function (err) { return err ? reject(err) : resolve(); });
                    });
                };
                return SqliteDriver;
            }(AbstractSqliteDriver_6.AbstractSqliteDriver));
            exports_189("SqliteDriver", SqliteDriver);
        }
    };
});
System.register("typeorm/driver/cordova/CordovaQueryRunner", ["typeorm/error/QueryRunnerAlreadyReleasedError", "typeorm/util/OrmUtils", "typeorm/error/QueryFailedError", "typeorm/driver/sqlite-abstract/AbstractSqliteQueryRunner"], function (exports_190, context_190) {
    "use strict";
    var __moduleName = context_190 && context_190.id;
    var QueryRunnerAlreadyReleasedError_8, OrmUtils_12, QueryFailedError_7, AbstractSqliteQueryRunner_5, CordovaQueryRunner;
    return {
        setters: [
            function (QueryRunnerAlreadyReleasedError_8_1) {
                QueryRunnerAlreadyReleasedError_8 = QueryRunnerAlreadyReleasedError_8_1;
            },
            function (OrmUtils_12_1) {
                OrmUtils_12 = OrmUtils_12_1;
            },
            function (QueryFailedError_7_1) {
                QueryFailedError_7 = QueryFailedError_7_1;
            },
            function (AbstractSqliteQueryRunner_5_1) {
                AbstractSqliteQueryRunner_5 = AbstractSqliteQueryRunner_5_1;
            }
        ],
        execute: function () {
            /**
             * Runs queries on a single sqlite database connection.
             *
             * Does not support compose primary keys with autoincrement field.
             * todo: need to throw exception for this case.
             */
            CordovaQueryRunner = /** @class */ (function (_super) {
                __extends(CordovaQueryRunner, _super);
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function CordovaQueryRunner(driver) {
                    var _this = _super.call(this, driver) || this;
                    _this.driver = driver;
                    _this.connection = driver.connection;
                    return _this;
                }
                /**
                 * Executes a given SQL query.
                 */
                CordovaQueryRunner.prototype.query = function (query, parameters) {
                    var _this = this;
                    if (this.isReleased)
                        throw new QueryRunnerAlreadyReleasedError_8.QueryRunnerAlreadyReleasedError();
                    return new Promise(function (ok, fail) { return __awaiter(_this, void 0, void 0, function () {
                        var _this = this;
                        var databaseConnection, queryStartTime;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.connect()];
                                case 1:
                                    databaseConnection = _a.sent();
                                    this.driver.connection.logger.logQuery(query, parameters, this);
                                    queryStartTime = +new Date();
                                    databaseConnection.executeSql(query, parameters, function (result) {
                                        // log slow queries if maxQueryExecution time is set
                                        var maxQueryExecutionTime = _this.driver.connection.options.maxQueryExecutionTime;
                                        var queryEndTime = +new Date();
                                        var queryExecutionTime = queryEndTime - queryStartTime;
                                        if (maxQueryExecutionTime && queryExecutionTime > maxQueryExecutionTime)
                                            _this.driver.connection.logger.logQuerySlow(queryExecutionTime, query, parameters, _this);
                                        if (result.rows.length === 0) {
                                            ok([]);
                                        }
                                        var resultSet = [];
                                        for (var i = 0; i < result.rows.length; i++) {
                                            resultSet.push(result.rows.item(i));
                                        }
                                        ok(resultSet);
                                    }, function (err) {
                                        _this.driver.connection.logger.logQueryError(err, query, parameters, _this);
                                        fail(new QueryFailedError_7.QueryFailedError(query, parameters, err));
                                    });
                                    return [2 /*return*/];
                            }
                        });
                    }); });
                };
                /**
                 * Insert a new row with given values into the given table.
                 * Returns value of the generated column if given and generate column exist in the table.
                 */
                CordovaQueryRunner.prototype.insert = function (tableName, keyValues) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var keys, columns, values, generatedColumns, sql, parameters;
                        return __generator(this, function (_a) {
                            keys = Object.keys(keyValues);
                            columns = keys.map(function (key) { return "\"" + key + "\""; }).join(", ");
                            values = keys.map(function (key) { return "?"; }).join(",");
                            generatedColumns = this.connection.hasMetadata(tableName) ? this.connection.getMetadata(tableName).generatedColumns : [];
                            sql = columns.length > 0 ? ("INSERT INTO \"" + tableName + "\"(" + columns + ") VALUES (" + values + ")") : "INSERT INTO \"" + tableName + "\" DEFAULT VALUES";
                            parameters = keys.map(function (key) { return keyValues[key]; });
                            return [2 /*return*/, new Promise(function (ok, fail) { return __awaiter(_this, void 0, void 0, function () {
                                    var _this = this;
                                    var __this, databaseConnection;
                                    return __generator(this, function (_a) {
                                        switch (_a.label) {
                                            case 0:
                                                this.driver.connection.logger.logQuery(sql, parameters, this);
                                                __this = this;
                                                return [4 /*yield*/, this.connect()];
                                            case 1:
                                                databaseConnection = _a.sent();
                                                databaseConnection.executeSql(sql, parameters, function (resultSet) {
                                                    var generatedMap = generatedColumns.reduce(function (map, generatedColumn) {
                                                        var value = generatedColumn.isPrimary && generatedColumn.generationStrategy === "increment" && resultSet.insertId ? resultSet.insertId : keyValues[generatedColumn.databaseName];
                                                        if (!value)
                                                            return map;
                                                        return OrmUtils_12.OrmUtils.mergeDeep(map, generatedColumn.createValueMap(value));
                                                    }, {});
                                                    ok({
                                                        result: undefined,
                                                        generatedMap: Object.keys(generatedMap).length > 0 ? generatedMap : undefined
                                                    });
                                                }, function (err) {
                                                    __this.driver.connection.logger.logQueryError(err, sql, parameters, _this);
                                                    fail(err);
                                                });
                                                return [2 /*return*/];
                                        }
                                    });
                                }); })];
                        });
                    });
                };
                // -------------------------------------------------------------------------
                // Protected Methods
                // -------------------------------------------------------------------------
                /**
                 * Parametrizes given object of values. Used to create column=value queries.
                 */
                CordovaQueryRunner.prototype.parametrize = function (objectLiteral, startIndex) {
                    if (startIndex === void 0) { startIndex = 0; }
                    return Object.keys(objectLiteral).map(function (key, index) { return "\"" + key + "\"" + "=?"; });
                };
                return CordovaQueryRunner;
            }(AbstractSqliteQueryRunner_5.AbstractSqliteQueryRunner));
            exports_190("CordovaQueryRunner", CordovaQueryRunner);
        }
    };
});
System.register("typeorm/driver/cordova/CordovaDriver", ["typeorm/driver/sqlite-abstract/AbstractSqliteDriver", "typeorm/driver/cordova/CordovaQueryRunner", "typeorm/error/DriverOptionNotSetError", "typeorm/error/DriverPackageNotInstalledError"], function (exports_191, context_191) {
    "use strict";
    var __moduleName = context_191 && context_191.id;
    var AbstractSqliteDriver_7, CordovaQueryRunner_1, DriverOptionNotSetError_4, DriverPackageNotInstalledError_8, CordovaDriver;
    return {
        setters: [
            function (AbstractSqliteDriver_7_1) {
                AbstractSqliteDriver_7 = AbstractSqliteDriver_7_1;
            },
            function (CordovaQueryRunner_1_1) {
                CordovaQueryRunner_1 = CordovaQueryRunner_1_1;
            },
            function (DriverOptionNotSetError_4_1) {
                DriverOptionNotSetError_4 = DriverOptionNotSetError_4_1;
            },
            function (DriverPackageNotInstalledError_8_1) {
                DriverPackageNotInstalledError_8 = DriverPackageNotInstalledError_8_1;
            }
        ],
        execute: function () {
            CordovaDriver = /** @class */ (function (_super) {
                __extends(CordovaDriver, _super);
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function CordovaDriver(connection) {
                    var _this = _super.call(this, connection) || this;
                    // this.connection = connection;
                    // this.options = connection.options as CordovaConnectionOptions;
                    _this.database = _this.options.database;
                    // validate options to make sure everything is set
                    if (!_this.options.database)
                        throw new DriverOptionNotSetError_4.DriverOptionNotSetError("database");
                    if (!_this.options.location)
                        throw new DriverOptionNotSetError_4.DriverOptionNotSetError("location");
                    // load sqlite package
                    _this.loadDependencies();
                    return _this;
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Closes connection with database.
                 */
                CordovaDriver.prototype.disconnect = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        return __generator(this, function (_a) {
                            return [2 /*return*/, new Promise(function (ok, fail) {
                                    _this.queryRunner = undefined;
                                    _this.databaseConnection.close(ok, fail);
                                })];
                        });
                    });
                };
                /**
                 * Creates a query runner used to execute database queries.
                 */
                CordovaDriver.prototype.createQueryRunner = function (mode) {
                    if (mode === void 0) { mode = "master"; }
                    if (!this.queryRunner)
                        this.queryRunner = new CordovaQueryRunner_1.CordovaQueryRunner(this);
                    return this.queryRunner;
                };
                // -------------------------------------------------------------------------
                // Protected Methods
                // -------------------------------------------------------------------------
                /**
                 * Creates connection with the database.
                 */
                CordovaDriver.prototype.createDatabaseConnection = function () {
                    var _this = this;
                    return new Promise(function (ok, fail) {
                        var options = Object.assign({}, {
                            name: _this.options.database,
                            location: _this.options.location,
                        }, _this.options.extra || {});
                        _this.sqlite.openDatabase(options, function (db) {
                            var databaseConnection = db;
                            // we need to enable foreign keys in sqlite to make sure all foreign key related features
                            // working properly. this also makes onDelete to work with sqlite.
                            databaseConnection.executeSql("PRAGMA foreign_keys = ON;", [], function (result) {
                                ok(databaseConnection);
                            }, function (error) {
                                fail(error);
                            });
                        }, function (error) {
                            fail(error);
                        });
                    });
                };
                /**
                 * If driver dependency is not given explicitly, then try to load it via "require".
                 */
                CordovaDriver.prototype.loadDependencies = function () {
                    try {
                        this.sqlite = window.sqlitePlugin;
                    }
                    catch (e) {
                        throw new DriverPackageNotInstalledError_8.DriverPackageNotInstalledError("Cordova-SQLite", "cordova-sqlite-storage");
                    }
                };
                return CordovaDriver;
            }(AbstractSqliteDriver_7.AbstractSqliteDriver));
            exports_191("CordovaDriver", CordovaDriver);
        }
    };
});
System.register("typeorm/driver/DriverFactory", ["typeorm/error/MissingDriverError", "typeorm/driver/mongodb/MongoDriver", "typeorm/driver/websql/WebsqlDriver", "typeorm/driver/sqlserver/SqlServerDriver", "typeorm/driver/oracle/OracleDriver", "typeorm/driver/sqlite/SqliteDriver", "typeorm/driver/cordova/CordovaDriver", "typeorm/driver/sqljs/SqljsDriver", "typeorm/driver/mysql/MysqlDriver", "typeorm/driver/postgres/PostgresDriver"], function (exports_192, context_192) {
    "use strict";
    var __moduleName = context_192 && context_192.id;
    var MissingDriverError_1, MongoDriver_8, WebsqlDriver_1, SqlServerDriver_8, OracleDriver_3, SqliteDriver_1, CordovaDriver_1, SqljsDriver_3, MysqlDriver_5, PostgresDriver_6, DriverFactory;
    return {
        setters: [
            function (MissingDriverError_1_1) {
                MissingDriverError_1 = MissingDriverError_1_1;
            },
            function (MongoDriver_8_1) {
                MongoDriver_8 = MongoDriver_8_1;
            },
            function (WebsqlDriver_1_1) {
                WebsqlDriver_1 = WebsqlDriver_1_1;
            },
            function (SqlServerDriver_8_1) {
                SqlServerDriver_8 = SqlServerDriver_8_1;
            },
            function (OracleDriver_3_1) {
                OracleDriver_3 = OracleDriver_3_1;
            },
            function (SqliteDriver_1_1) {
                SqliteDriver_1 = SqliteDriver_1_1;
            },
            function (CordovaDriver_1_1) {
                CordovaDriver_1 = CordovaDriver_1_1;
            },
            function (SqljsDriver_3_1) {
                SqljsDriver_3 = SqljsDriver_3_1;
            },
            function (MysqlDriver_5_1) {
                MysqlDriver_5 = MysqlDriver_5_1;
            },
            function (PostgresDriver_6_1) {
                PostgresDriver_6 = PostgresDriver_6_1;
            }
        ],
        execute: function () {
            /**
             * Helps to create drivers.
             */
            DriverFactory = /** @class */ (function () {
                function DriverFactory() {
                }
                /**
                 * Creates a new driver depend on a given connection's driver type.
                 */
                DriverFactory.prototype.create = function (connection) {
                    var type = connection.options.type;
                    switch (type) {
                        case "mysql":
                            return new MysqlDriver_5.MysqlDriver(connection);
                        case "postgres":
                            return new PostgresDriver_6.PostgresDriver(connection);
                        case "mariadb":
                            return new MysqlDriver_5.MysqlDriver(connection);
                        case "sqlite":
                            return new SqliteDriver_1.SqliteDriver(connection);
                        case "cordova":
                            return new CordovaDriver_1.CordovaDriver(connection);
                        case "sqljs":
                            return new SqljsDriver_3.SqljsDriver(connection);
                        case "oracle":
                            return new OracleDriver_3.OracleDriver(connection);
                        case "mssql":
                            return new SqlServerDriver_8.SqlServerDriver(connection);
                        case "websql":
                            return new WebsqlDriver_1.WebsqlDriver(connection);
                        case "mongodb":
                            return new MongoDriver_8.MongoDriver(connection);
                        default:
                            throw new MissingDriverError_1.MissingDriverError(type);
                    }
                };
                return DriverFactory;
            }());
            exports_192("DriverFactory", DriverFactory);
        }
    };
});
System.register("typeorm/util/DirectoryExportedClassesLoader", ["typeorm/platform/PlatformTools"], function (exports_193, context_193) {
    "use strict";
    var __moduleName = context_193 && context_193.id;
    /**
     * Loads all exported classes from the given directory.
     */
    function importClassesFromDirectories(directories, formats) {
        if (formats === void 0) { formats = [".js", ".ts"]; }
        function loadFileClasses(exported, allLoaded) {
            if (typeof exported === "function") {
                allLoaded.push(exported);
            }
            else if (Array.isArray(exported)) {
                exported.forEach(function (i) { return loadFileClasses(i, allLoaded); });
            }
            else if (typeof exported === "object") {
                Object.keys(exported).forEach(function (key) { return loadFileClasses(exported[key], allLoaded); });
            }
            return allLoaded;
        }
        var allFiles = directories.reduce(function (allDirs, dir) {
            return allDirs.concat(PlatformTools_10.PlatformTools.load("glob").sync(PlatformTools_10.PlatformTools.pathNormalize(dir)));
        }, []);
        var dirs = allFiles
            .filter(function (file) {
            var dtsExtension = file.substring(file.length - 5, file.length);
            return formats.indexOf(PlatformTools_10.PlatformTools.pathExtname(file)) !== -1 && dtsExtension !== ".d.ts";
        })
            .map(function (file) { return PlatformTools_10.PlatformTools.load(PlatformTools_10.PlatformTools.pathResolve(file)); });
        return loadFileClasses(dirs, []);
    }
    exports_193("importClassesFromDirectories", importClassesFromDirectories);
    /**
     * Loads all json files from the given directory.
     */
    function importJsonsFromDirectories(directories, format) {
        if (format === void 0) { format = ".json"; }
        var allFiles = directories.reduce(function (allDirs, dir) {
            return allDirs.concat(PlatformTools_10.PlatformTools.load("glob").sync(PlatformTools_10.PlatformTools.pathNormalize(dir)));
        }, []);
        return allFiles
            .filter(function (file) { return PlatformTools_10.PlatformTools.pathExtname(file) === format; })
            .map(function (file) { return PlatformTools_10.PlatformTools.load(PlatformTools_10.PlatformTools.pathResolve(file)); });
    }
    exports_193("importJsonsFromDirectories", importJsonsFromDirectories);
    var PlatformTools_10;
    return {
        setters: [
            function (PlatformTools_10_1) {
                PlatformTools_10 = PlatformTools_10_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/container", [], function (exports_194, context_194) {
    "use strict";
    var __moduleName = context_194 && context_194.id;
    /**
     * Sets container to be used by this library.
     */
    function useContainer(iocContainer, options) {
        userContainer = iocContainer;
        userContainerOptions = options;
    }
    exports_194("useContainer", useContainer);
    /**
     * Gets the IOC container used by this library.
     */
    function getFromContainer(someClass) {
        if (userContainer) {
            try {
                var instance = userContainer.get(someClass);
                if (instance)
                    return instance;
                if (!userContainerOptions || !userContainerOptions.fallback)
                    return instance;
            }
            catch (error) {
                if (!userContainerOptions || !userContainerOptions.fallbackOnErrors)
                    throw error;
            }
        }
        return defaultContainer.get(someClass);
    }
    exports_194("getFromContainer", getFromContainer);
    var defaultContainer, userContainer, userContainerOptions;
    return {
        setters: [],
        execute: function () {
            /**
             * Container to be used by this library for inversion control. If container was not implicitly set then by default
             * container simply creates a new instance of the given class.
             */
            exports_194("defaultContainer", defaultContainer = new (/** @class */ (function () {
                function class_1() {
                    this.instances = [];
                }
                class_1.prototype.get = function (someClass) {
                    var instance = this.instances.find(function (instance) { return instance.type === someClass; });
                    if (!instance) {
                        instance = { type: someClass, object: new someClass() };
                        this.instances.push(instance);
                    }
                    return instance.object;
                };
                return class_1;
            }()))());
        }
    };
});
System.register("typeorm/metadata-args/NamingStrategyMetadataArgs", [], function (exports_195, context_195) {
    "use strict";
    var __moduleName = context_195 && context_195.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/metadata-args/JoinColumnMetadataArgs", [], function (exports_196, context_196) {
    "use strict";
    var __moduleName = context_196 && context_196.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/metadata-args/JoinTableMetadataArgs", [], function (exports_197, context_197) {
    "use strict";
    var __moduleName = context_197 && context_197.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/metadata-args/EntitySubscriberMetadataArgs", [], function (exports_198, context_198) {
    "use strict";
    var __moduleName = context_198 && context_198.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/metadata-args/InheritanceMetadataArgs", [], function (exports_199, context_199) {
    "use strict";
    var __moduleName = context_199 && context_199.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/metadata-args/DiscriminatorValueMetadataArgs", [], function (exports_200, context_200) {
    "use strict";
    var __moduleName = context_200 && context_200.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/metadata-args/EntityRepositoryMetadataArgs", [], function (exports_201, context_201) {
    "use strict";
    var __moduleName = context_201 && context_201.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/metadata-args/TransactionEntityMetadataArgs", [], function (exports_202, context_202) {
    "use strict";
    var __moduleName = context_202 && context_202.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/metadata-args/TransactionRepositoryMetadataArgs", [], function (exports_203, context_203) {
    "use strict";
    var __moduleName = context_203 && context_203.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/metadata-builder/MetadataUtils", [], function (exports_204, context_204) {
    "use strict";
    var __moduleName = context_204 && context_204.id;
    var MetadataUtils;
    return {
        setters: [],
        execute: function () {
            /**
             * Metadata args utility functions.
             */
            MetadataUtils = /** @class */ (function () {
                function MetadataUtils() {
                }
                /**
                 * Gets given's entity all inherited classes.
                 * Gives in order from parents to children.
                 * For example Post extends ContentModel which extends Unit it will give
                 * [Unit, ContentModel, Post]
                 */
                MetadataUtils.getInheritanceTree = function (entity) {
                    var tree = [entity];
                    var getPrototypeOf = function (object) {
                        var proto = Object.getPrototypeOf(object);
                        if (proto && proto.name) {
                            tree.push(proto);
                            getPrototypeOf(proto);
                        }
                    };
                    getPrototypeOf(entity);
                    return tree;
                };
                /**
                 * Checks if this table is inherited from another table.
                 */
                MetadataUtils.isInherited = function (target1, target2) {
                    return target1.prototype instanceof target2;
                };
                /**
                 * Filters given array of targets by a given classes.
                 * If classes are not given, then it returns array itself.
                 */
                MetadataUtils.filterByTarget = function (array, classes) {
                    if (!classes)
                        return array;
                    return array.filter(function (item) { return item.target && classes.indexOf(item.target) !== -1; });
                };
                return MetadataUtils;
            }());
            exports_204("MetadataUtils", MetadataUtils);
        }
    };
});
System.register("typeorm/metadata-args/GeneratedMetadataArgs", [], function (exports_205, context_205) {
    "use strict";
    var __moduleName = context_205 && context_205.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/metadata-args/MetadataArgsStorage", ["typeorm/metadata-builder/MetadataUtils"], function (exports_206, context_206) {
    "use strict";
    var __moduleName = context_206 && context_206.id;
    var MetadataUtils_1, MetadataArgsStorage;
    return {
        setters: [
            function (MetadataUtils_1_1) {
                MetadataUtils_1 = MetadataUtils_1_1;
            }
        ],
        execute: function () {
            /**
             * Storage all metadatas args of all available types: tables, columns, subscribers, relations, etc.
             * Each metadata args represents some specifications of what it represents.
             * MetadataArgs used to create a real Metadata objects.
             */
            MetadataArgsStorage = /** @class */ (function () {
                function MetadataArgsStorage() {
                    // -------------------------------------------------------------------------
                    // Properties
                    // -------------------------------------------------------------------------
                    this.tables = [];
                    this.entityRepositories = [];
                    this.transactionEntityManagers = [];
                    this.transactionRepositories = [];
                    this.namingStrategies = [];
                    this.entitySubscribers = [];
                    this.indices = [];
                    this.columns = [];
                    this.generations = [];
                    this.relations = [];
                    this.joinColumns = [];
                    this.joinTables = [];
                    this.entityListeners = [];
                    this.relationCounts = [];
                    this.relationIds = [];
                    this.embeddeds = [];
                    this.inheritances = [];
                    this.discriminatorValues = [];
                }
                MetadataArgsStorage.prototype.filterTables = function (target) {
                    return this.filterByTarget(this.tables, target);
                };
                MetadataArgsStorage.prototype.filterColumns = function (target) {
                    return this.filterByTargetAndWithoutDuplicateProperties(this.columns, target);
                };
                MetadataArgsStorage.prototype.findGenerated = function (target, propertyName) {
                    return this.generations.find(function (generated) {
                        return (target instanceof Array ? target.indexOf(generated.target) !== -1 : generated.target === target) && generated.propertyName === propertyName;
                    });
                };
                MetadataArgsStorage.prototype.filterRelations = function (target) {
                    return this.filterByTargetAndWithoutDuplicateProperties(this.relations, target);
                };
                MetadataArgsStorage.prototype.filterRelationIds = function (target) {
                    return this.filterByTargetAndWithoutDuplicateProperties(this.relationIds, target);
                };
                MetadataArgsStorage.prototype.filterRelationCounts = function (target) {
                    return this.filterByTargetAndWithoutDuplicateProperties(this.relationCounts, target);
                };
                MetadataArgsStorage.prototype.filterIndices = function (target) {
                    // todo: implement parent-entity overrides?
                    return this.indices.filter(function (index) {
                        return target instanceof Array ? target.indexOf(index.target) !== -1 : index.target === target;
                    });
                };
                MetadataArgsStorage.prototype.filterListeners = function (target) {
                    return this.filterByTarget(this.entityListeners, target);
                };
                MetadataArgsStorage.prototype.filterEmbeddeds = function (target) {
                    return this.filterByTargetAndWithoutDuplicateProperties(this.embeddeds, target);
                };
                MetadataArgsStorage.prototype.findJoinTable = function (target, propertyName) {
                    return this.joinTables.find(function (joinTable) {
                        return joinTable.target === target && joinTable.propertyName === propertyName;
                    });
                };
                MetadataArgsStorage.prototype.filterJoinColumns = function (target, propertyName) {
                    // todo: implement parent-entity overrides?
                    return this.joinColumns.filter(function (joinColumn) {
                        return joinColumn.target === target && joinColumn.propertyName === propertyName;
                    });
                };
                MetadataArgsStorage.prototype.filterSubscribers = function (target) {
                    return this.filterByTarget(this.entitySubscribers, target);
                };
                MetadataArgsStorage.prototype.filterNamingStrategies = function (target) {
                    return this.filterByTarget(this.namingStrategies, target);
                };
                MetadataArgsStorage.prototype.filterTransactionEntityManagers = function (target) {
                    return this.filterByTarget(this.transactionEntityManagers, target);
                };
                MetadataArgsStorage.prototype.filterTransactionRepository = function (target) {
                    return this.filterByTarget(this.transactionRepositories, target);
                };
                MetadataArgsStorage.prototype.filterSingleTableChildren = function (target) {
                    return this.tables.filter(function (table) {
                        return table.target instanceof Function
                            && target instanceof Function
                            && MetadataUtils_1.MetadataUtils.isInherited(table.target, target)
                            && table.type === "single-table-child";
                    });
                };
                MetadataArgsStorage.prototype.findInheritanceType = function (target) {
                    return this.inheritances.find(function (inheritance) { return inheritance.target === target; });
                };
                MetadataArgsStorage.prototype.findDiscriminatorValue = function (target) {
                    return this.discriminatorValues.find(function (discriminatorValue) { return discriminatorValue.target === target; });
                };
                // -------------------------------------------------------------------------
                // Protected Methods
                // -------------------------------------------------------------------------
                /**
                 * Filters given array by a given target or targets.
                 */
                MetadataArgsStorage.prototype.filterByTarget = function (array, target) {
                    return array.filter(function (table) {
                        return target instanceof Array ? target.indexOf(table.target) !== -1 : table.target === target;
                    });
                };
                /**
                 * Filters given array by a given target or targets and prevents duplicate property names.
                 */
                MetadataArgsStorage.prototype.filterByTargetAndWithoutDuplicateProperties = function (array, target) {
                    var newArray = [];
                    array.forEach(function (item) {
                        var sameTarget = target instanceof Array ? target.indexOf(item.target) !== -1 : item.target === target;
                        if (sameTarget) {
                            if (!newArray.find(function (newItem) { return newItem.propertyName === item.propertyName; }))
                                newArray.push(item);
                        }
                    });
                    return newArray;
                };
                return MetadataArgsStorage;
            }());
            exports_206("MetadataArgsStorage", MetadataArgsStorage);
        }
    };
});
System.register("typeorm/metadata-builder/JunctionEntityMetadataBuilder", ["typeorm/metadata/EntityMetadata", "typeorm/metadata/ColumnMetadata", "typeorm/metadata/ForeignKeyMetadata", "typeorm/metadata/IndexMetadata"], function (exports_207, context_207) {
    "use strict";
    var __moduleName = context_207 && context_207.id;
    var EntityMetadata_1, ColumnMetadata_2, ForeignKeyMetadata_1, IndexMetadata_1, JunctionEntityMetadataBuilder;
    return {
        setters: [
            function (EntityMetadata_1_1) {
                EntityMetadata_1 = EntityMetadata_1_1;
            },
            function (ColumnMetadata_2_1) {
                ColumnMetadata_2 = ColumnMetadata_2_1;
            },
            function (ForeignKeyMetadata_1_1) {
                ForeignKeyMetadata_1 = ForeignKeyMetadata_1_1;
            },
            function (IndexMetadata_1_1) {
                IndexMetadata_1 = IndexMetadata_1_1;
            }
        ],
        execute: function () {
            /**
             * Creates EntityMetadata for junction tables.
             * Junction tables are tables generated by many-to-many relations.
             */
            JunctionEntityMetadataBuilder = /** @class */ (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function JunctionEntityMetadataBuilder(connection) {
                    this.connection = connection;
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Builds EntityMetadata for the junction of the given many-to-many relation.
                 */
                JunctionEntityMetadataBuilder.prototype.build = function (relation, joinTable) {
                    var _this = this;
                    var referencedColumns = this.collectReferencedColumns(relation, joinTable);
                    var inverseReferencedColumns = this.collectInverseReferencedColumns(relation, joinTable);
                    var joinTableName = joinTable.name || this.connection.namingStrategy.joinTableName(relation.entityMetadata.tableNameWithoutPrefix, relation.inverseEntityMetadata.tableNameWithoutPrefix, relation.propertyPath, relation.inverseRelation ? relation.inverseRelation.propertyName : "");
                    var entityMetadata = new EntityMetadata_1.EntityMetadata({
                        connection: this.connection,
                        args: {
                            target: "",
                            name: joinTableName,
                            type: "junction",
                            database: joinTable.database || relation.entityMetadata.database,
                            schema: joinTable.schema || relation.entityMetadata.schema,
                        }
                    });
                    // create original side junction columns
                    var junctionColumns = referencedColumns.map(function (referencedColumn) {
                        var joinColumn = joinTable.joinColumns ? joinTable.joinColumns.find(function (joinColumnArgs) {
                            return (!joinColumnArgs.referencedColumnName || joinColumnArgs.referencedColumnName === referencedColumn.propertyName) &&
                                !!joinColumnArgs.name;
                        }) : undefined;
                        var columnName = joinColumn && joinColumn.name ? joinColumn.name
                            : _this.connection.namingStrategy.joinTableColumnName(relation.entityMetadata.tableNameWithoutPrefix, referencedColumn.propertyName, referencedColumn.databaseName);
                        return new ColumnMetadata_2.ColumnMetadata({
                            connection: _this.connection,
                            entityMetadata: entityMetadata,
                            referencedColumn: referencedColumn,
                            args: {
                                target: "",
                                mode: "virtual",
                                propertyName: columnName,
                                options: {
                                    name: columnName,
                                    length: referencedColumn.length,
                                    type: referencedColumn.type,
                                    nullable: false,
                                    primary: true,
                                }
                            }
                        });
                    });
                    // create inverse side junction columns
                    var inverseJunctionColumns = inverseReferencedColumns.map(function (inverseReferencedColumn) {
                        var joinColumn = joinTable.inverseJoinColumns ? joinTable.inverseJoinColumns.find(function (joinColumnArgs) {
                            return (!joinColumnArgs.referencedColumnName || joinColumnArgs.referencedColumnName === inverseReferencedColumn.propertyName) &&
                                !!joinColumnArgs.name;
                        }) : undefined;
                        var columnName = joinColumn && joinColumn.name ? joinColumn.name
                            : _this.connection.namingStrategy.joinTableInverseColumnName(relation.inverseEntityMetadata.tableNameWithoutPrefix, inverseReferencedColumn.propertyName, inverseReferencedColumn.databaseName);
                        return new ColumnMetadata_2.ColumnMetadata({
                            connection: _this.connection,
                            entityMetadata: entityMetadata,
                            referencedColumn: inverseReferencedColumn,
                            args: {
                                target: "",
                                mode: "virtual",
                                propertyName: columnName,
                                options: {
                                    length: inverseReferencedColumn.length,
                                    type: inverseReferencedColumn.type,
                                    name: columnName,
                                    nullable: false,
                                    primary: true,
                                }
                            }
                        });
                    });
                    this.changeDuplicatedColumnNames(junctionColumns, inverseJunctionColumns);
                    // set junction table columns
                    entityMetadata.ownerColumns = junctionColumns;
                    entityMetadata.inverseColumns = inverseJunctionColumns;
                    entityMetadata.ownColumns = junctionColumns.concat(inverseJunctionColumns);
                    entityMetadata.ownColumns.forEach(function (column) { return column.relationMetadata = relation; });
                    // create junction table foreign keys
                    entityMetadata.foreignKeys = [
                        new ForeignKeyMetadata_1.ForeignKeyMetadata({
                            entityMetadata: entityMetadata,
                            referencedEntityMetadata: relation.entityMetadata,
                            columns: junctionColumns,
                            referencedColumns: referencedColumns
                        }),
                        new ForeignKeyMetadata_1.ForeignKeyMetadata({
                            entityMetadata: entityMetadata,
                            referencedEntityMetadata: relation.inverseEntityMetadata,
                            columns: inverseJunctionColumns,
                            referencedColumns: inverseReferencedColumns
                        }),
                    ];
                    // create junction table indices
                    entityMetadata.indices = [
                        new IndexMetadata_1.IndexMetadata({
                            entityMetadata: entityMetadata,
                            columns: junctionColumns,
                            args: {
                                target: "",
                                unique: false
                            }
                        }),
                        new IndexMetadata_1.IndexMetadata({
                            entityMetadata: entityMetadata,
                            columns: inverseJunctionColumns,
                            args: {
                                target: "",
                                unique: false
                            }
                        })
                    ];
                    // finally return entity metadata
                    return entityMetadata;
                };
                // -------------------------------------------------------------------------
                // Protected Methods
                // -------------------------------------------------------------------------
                /**
                 * Collects referenced columns from the given join column args.
                 */
                JunctionEntityMetadataBuilder.prototype.collectReferencedColumns = function (relation, joinTable) {
                    var hasAnyReferencedColumnName = joinTable.joinColumns ? joinTable.joinColumns.find(function (joinColumn) { return !!joinColumn.referencedColumnName; }) : false;
                    if (!joinTable.joinColumns || (joinTable.joinColumns && !hasAnyReferencedColumnName)) {
                        return relation.entityMetadata.columns.filter(function (column) { return column.isPrimary; });
                    }
                    else {
                        return joinTable.joinColumns.map(function (joinColumn) {
                            var referencedColumn = relation.entityMetadata.columns.find(function (column) { return column.propertyName === joinColumn.referencedColumnName; });
                            if (!referencedColumn)
                                throw new Error("Referenced column " + joinColumn.referencedColumnName + " was not found in entity " + relation.entityMetadata.name);
                            return referencedColumn;
                        });
                    }
                };
                /**
                 * Collects inverse referenced columns from the given join column args.
                 */
                JunctionEntityMetadataBuilder.prototype.collectInverseReferencedColumns = function (relation, joinTable) {
                    var hasInverseJoinColumns = !!joinTable.inverseJoinColumns;
                    var hasAnyInverseReferencedColumnName = hasInverseJoinColumns ? joinTable.inverseJoinColumns.find(function (joinColumn) { return !!joinColumn.referencedColumnName; }) : false;
                    if (!hasInverseJoinColumns || (hasInverseJoinColumns && !hasAnyInverseReferencedColumnName)) {
                        return relation.inverseEntityMetadata.primaryColumns;
                    }
                    else {
                        return joinTable.inverseJoinColumns.map(function (joinColumn) {
                            var referencedColumn = relation.inverseEntityMetadata.ownColumns.find(function (column) { return column.propertyName === joinColumn.referencedColumnName; });
                            if (!referencedColumn)
                                throw new Error("Referenced column " + joinColumn.referencedColumnName + " was not found in entity " + relation.inverseEntityMetadata.name);
                            return referencedColumn;
                        });
                    }
                };
                JunctionEntityMetadataBuilder.prototype.changeDuplicatedColumnNames = function (junctionColumns, inverseJunctionColumns) {
                    var _this = this;
                    junctionColumns.forEach(function (junctionColumn) {
                        inverseJunctionColumns.forEach(function (inverseJunctionColumn) {
                            if (junctionColumn.givenDatabaseName === inverseJunctionColumn.givenDatabaseName) {
                                var junctionColumnName = _this.connection.namingStrategy.joinTableColumnDuplicationPrefix(junctionColumn.propertyName, 1);
                                junctionColumn.propertyName = junctionColumnName;
                                junctionColumn.givenDatabaseName = junctionColumnName;
                                var inverseJunctionColumnName = _this.connection.namingStrategy.joinTableColumnDuplicationPrefix(inverseJunctionColumn.propertyName, 2);
                                inverseJunctionColumn.propertyName = inverseJunctionColumnName;
                                inverseJunctionColumn.givenDatabaseName = inverseJunctionColumnName;
                            }
                        });
                    });
                };
                return JunctionEntityMetadataBuilder;
            }());
            exports_207("JunctionEntityMetadataBuilder", JunctionEntityMetadataBuilder);
        }
    };
});
System.register("typeorm/metadata-builder/ClosureJunctionEntityMetadataBuilder", ["typeorm/metadata/EntityMetadata", "typeorm/metadata/ColumnMetadata", "typeorm/metadata/ForeignKeyMetadata"], function (exports_208, context_208) {
    "use strict";
    var __moduleName = context_208 && context_208.id;
    var EntityMetadata_2, ColumnMetadata_3, ForeignKeyMetadata_2, ClosureJunctionEntityMetadataBuilder;
    return {
        setters: [
            function (EntityMetadata_2_1) {
                EntityMetadata_2 = EntityMetadata_2_1;
            },
            function (ColumnMetadata_3_1) {
                ColumnMetadata_3 = ColumnMetadata_3_1;
            },
            function (ForeignKeyMetadata_2_1) {
                ForeignKeyMetadata_2 = ForeignKeyMetadata_2_1;
            }
        ],
        execute: function () {
            /**
             * Creates EntityMetadata for junction tables of the closure entities.
             * Closure junction tables are tables generated by closure entities.
             */
            ClosureJunctionEntityMetadataBuilder = /** @class */ (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function ClosureJunctionEntityMetadataBuilder(connection) {
                    this.connection = connection;
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Builds EntityMetadata for the closure junction of the given closure entity.
                 */
                ClosureJunctionEntityMetadataBuilder.prototype.build = function (parentClosureEntityMetadata) {
                    var _this = this;
                    // create entity metadata itself
                    var entityMetadata = new EntityMetadata_2.EntityMetadata({
                        parentClosureEntityMetadata: parentClosureEntityMetadata,
                        connection: this.connection,
                        args: {
                            target: "",
                            name: parentClosureEntityMetadata.tableNameWithoutPrefix,
                            type: "closure-junction"
                        }
                    });
                    // create ancestor and descendant columns for new closure junction table
                    parentClosureEntityMetadata.primaryColumns.forEach(function (primaryColumn) {
                        entityMetadata.ownColumns.push(new ColumnMetadata_3.ColumnMetadata({
                            connection: _this.connection,
                            entityMetadata: entityMetadata,
                            args: {
                                target: "",
                                mode: "virtual",
                                propertyName: "ancestor",
                                options: {
                                    length: primaryColumn.length,
                                    type: primaryColumn.type,
                                }
                            }
                        }));
                        entityMetadata.ownColumns.push(new ColumnMetadata_3.ColumnMetadata({
                            connection: _this.connection,
                            entityMetadata: entityMetadata,
                            args: {
                                target: "",
                                mode: "virtual",
                                propertyName: "descendant",
                                options: {
                                    length: primaryColumn.length,
                                    type: primaryColumn.type,
                                }
                            }
                        }));
                    });
                    // if tree level column was defined by a closure entity then add it to the junction columns as well
                    if (parentClosureEntityMetadata.treeLevelColumn) {
                        entityMetadata.ownColumns.push(new ColumnMetadata_3.ColumnMetadata({
                            connection: this.connection,
                            entityMetadata: entityMetadata,
                            args: {
                                target: "",
                                mode: "virtual",
                                propertyName: "level",
                                options: {
                                    type: this.connection.driver.mappedDataTypes.treeLevel,
                                }
                            }
                        }));
                    }
                    // create junction table foreign keys
                    entityMetadata.foreignKeys = [
                        new ForeignKeyMetadata_2.ForeignKeyMetadata({
                            entityMetadata: entityMetadata,
                            referencedEntityMetadata: parentClosureEntityMetadata,
                            columns: [entityMetadata.ownColumns[0]],
                            referencedColumns: parentClosureEntityMetadata.primaryColumns
                        }),
                        new ForeignKeyMetadata_2.ForeignKeyMetadata({
                            entityMetadata: entityMetadata,
                            referencedEntityMetadata: parentClosureEntityMetadata,
                            columns: [entityMetadata.ownColumns[1]],
                            referencedColumns: parentClosureEntityMetadata.primaryColumns
                        }),
                    ];
                    return entityMetadata;
                };
                return ClosureJunctionEntityMetadataBuilder;
            }());
            exports_208("ClosureJunctionEntityMetadataBuilder", ClosureJunctionEntityMetadataBuilder);
        }
    };
});
System.register("typeorm/metadata-builder/RelationJoinColumnBuilder", ["typeorm/metadata/ColumnMetadata", "typeorm/metadata/ForeignKeyMetadata"], function (exports_209, context_209) {
    "use strict";
    var __moduleName = context_209 && context_209.id;
    var ColumnMetadata_4, ForeignKeyMetadata_3, RelationJoinColumnBuilder;
    return {
        setters: [
            function (ColumnMetadata_4_1) {
                ColumnMetadata_4 = ColumnMetadata_4_1;
            },
            function (ForeignKeyMetadata_3_1) {
                ForeignKeyMetadata_3 = ForeignKeyMetadata_3_1;
            }
        ],
        execute: function () {
            /**
             * Builds join column for the many-to-one and one-to-one owner relations.
             *
             * Cases it should cover:
             * 1. when join column is set with custom name and without referenced column name
             * we need automatically set referenced column name - primary ids by default
             * @JoinColumn({ name: "custom_name" })
             *
             * 2. when join column is set with only referenced column name
             * we need automatically set join column name - relation name + referenced column name
             * @JoinColumn({ referencedColumnName: "title" })
             *
             * 3. when join column is set without both referenced column name and join column name
             * we need to automatically set both of them
             * @JoinColumn()
             *
             * 4. when join column is not set at all (as in case of @ManyToOne relation)
             * we need to create join column for it with proper referenced column name and join column name
             *
             * 5. when multiple join columns set none of referencedColumnName and name can be optional
             * both options are required
             * @JoinColumn([
             *      { name: "category_title", referencedColumnName: "type" },
             *      { name: "category_title", referencedColumnName: "name" },
             * ])
             *
             * Since for many-to-one relations having JoinColumn decorator is not required,
             * we need to go thought each many-to-one relation without join column decorator set
             * and create join column metadata args for them.
             */
            RelationJoinColumnBuilder = /** @class */ (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function RelationJoinColumnBuilder(connection) {
                    this.connection = connection;
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Builds a foreign key of the many-to-one or one-to-one owner relations.
                 */
                RelationJoinColumnBuilder.prototype.build = function (joinColumns, relation) {
                    var referencedColumns = this.collectReferencedColumns(joinColumns, relation);
                    if (!referencedColumns.length)
                        return undefined; // this case is possible only for one-to-one non owning side
                    var columns = this.collectColumns(joinColumns, relation, referencedColumns);
                    return new ForeignKeyMetadata_3.ForeignKeyMetadata({
                        entityMetadata: relation.entityMetadata,
                        referencedEntityMetadata: relation.inverseEntityMetadata,
                        namingStrategy: this.connection.namingStrategy,
                        columns: columns,
                        referencedColumns: referencedColumns,
                        onDelete: relation.onDelete,
                    });
                };
                // -------------------------------------------------------------------------
                // Protected Methods
                // -------------------------------------------------------------------------
                /**
                 * Collects referenced columns from the given join column args.
                 */
                RelationJoinColumnBuilder.prototype.collectReferencedColumns = function (joinColumns, relation) {
                    var hasAnyReferencedColumnName = joinColumns.find(function (joinColumnArgs) { return !!joinColumnArgs.referencedColumnName; });
                    var manyToOneWithoutJoinColumn = joinColumns.length === 0 && relation.isManyToOne;
                    var hasJoinColumnWithoutAnyReferencedColumnName = joinColumns.length > 0 && !hasAnyReferencedColumnName;
                    if (manyToOneWithoutJoinColumn || hasJoinColumnWithoutAnyReferencedColumnName) { // covers case3 and case1
                        return relation.inverseEntityMetadata.primaryColumns;
                    }
                    else { // cases with referenced columns defined
                        return joinColumns.map(function (joinColumn) {
                            var referencedColumn = relation.inverseEntityMetadata.ownColumns.find(function (column) { return column.propertyName === joinColumn.referencedColumnName; }); // todo: can we also search in relations?
                            if (!referencedColumn)
                                throw new Error("Referenced column " + joinColumn.referencedColumnName + " was not found in entity " + relation.inverseEntityMetadata.name);
                            return referencedColumn;
                        });
                    }
                };
                /**
                 * Collects columns from the given join column args.
                 */
                RelationJoinColumnBuilder.prototype.collectColumns = function (joinColumns, relation, referencedColumns) {
                    var _this = this;
                    return referencedColumns.map(function (referencedColumn) {
                        // in the case if relation has join column with only name set we need this check
                        var joinColumnMetadataArg = joinColumns.find(function (joinColumn) {
                            return (!joinColumn.referencedColumnName || joinColumn.referencedColumnName === referencedColumn.propertyName) &&
                                !!joinColumn.name;
                        });
                        var joinColumnName = joinColumnMetadataArg ? joinColumnMetadataArg.name : _this.connection.namingStrategy.joinColumnName(relation.propertyName, referencedColumn.propertyName);
                        var relationalColumn = relation.entityMetadata.ownColumns.find(function (column) { return column.databaseName === joinColumnName; });
                        if (!relationalColumn) {
                            relationalColumn = new ColumnMetadata_4.ColumnMetadata({
                                connection: _this.connection,
                                entityMetadata: relation.entityMetadata,
                                args: {
                                    target: "",
                                    mode: "virtual",
                                    propertyName: relation.propertyName,
                                    options: {
                                        name: joinColumnName,
                                        type: referencedColumn.type,
                                        length: referencedColumn.length,
                                        charset: referencedColumn.charset,
                                        collation: referencedColumn.collation,
                                        precision: referencedColumn.precision,
                                        scale: referencedColumn.scale,
                                        comment: referencedColumn.comment,
                                        primary: relation.isPrimary,
                                        nullable: relation.isNullable,
                                    }
                                }
                            });
                            relation.entityMetadata.registerColumn(relationalColumn);
                        }
                        relationalColumn.referencedColumn = referencedColumn; // its important to set it here because we need to set referenced column for user defined join column
                        relationalColumn.type = referencedColumn.type; // also since types of relational column and join column must be equal we override user defined column type
                        relationalColumn.relationMetadata = relation;
                        relationalColumn.build(_this.connection);
                        return relationalColumn;
                    });
                };
                return RelationJoinColumnBuilder;
            }());
            exports_209("RelationJoinColumnBuilder", RelationJoinColumnBuilder);
        }
    };
});
System.register("typeorm/metadata-builder/EntityMetadataBuilder", ["typeorm/metadata/EntityMetadata", "typeorm/metadata/ColumnMetadata", "typeorm/metadata/IndexMetadata", "typeorm/metadata/RelationMetadata", "typeorm/metadata/EmbeddedMetadata", "typeorm/metadata/RelationIdMetadata", "typeorm/metadata/RelationCountMetadata", "typeorm/metadata-builder/MetadataUtils", "typeorm/metadata-builder/JunctionEntityMetadataBuilder", "typeorm/metadata-builder/ClosureJunctionEntityMetadataBuilder", "typeorm/metadata-builder/RelationJoinColumnBuilder", "typeorm/metadata/EntityListenerMetadata", "typeorm/metadata/ForeignKeyMetadata", "typeorm/lazy-loading/LazyRelationsWrapper"], function (exports_210, context_210) {
    "use strict";
    var __moduleName = context_210 && context_210.id;
    var EntityMetadata_3, ColumnMetadata_5, IndexMetadata_2, RelationMetadata_1, EmbeddedMetadata_1, RelationIdMetadata_1, RelationCountMetadata_1, MetadataUtils_2, JunctionEntityMetadataBuilder_1, ClosureJunctionEntityMetadataBuilder_1, RelationJoinColumnBuilder_1, EntityListenerMetadata_1, ForeignKeyMetadata_4, LazyRelationsWrapper_2, EntityMetadataBuilder;
    return {
        setters: [
            function (EntityMetadata_3_1) {
                EntityMetadata_3 = EntityMetadata_3_1;
            },
            function (ColumnMetadata_5_1) {
                ColumnMetadata_5 = ColumnMetadata_5_1;
            },
            function (IndexMetadata_2_1) {
                IndexMetadata_2 = IndexMetadata_2_1;
            },
            function (RelationMetadata_1_1) {
                RelationMetadata_1 = RelationMetadata_1_1;
            },
            function (EmbeddedMetadata_1_1) {
                EmbeddedMetadata_1 = EmbeddedMetadata_1_1;
            },
            function (RelationIdMetadata_1_1) {
                RelationIdMetadata_1 = RelationIdMetadata_1_1;
            },
            function (RelationCountMetadata_1_1) {
                RelationCountMetadata_1 = RelationCountMetadata_1_1;
            },
            function (MetadataUtils_2_1) {
                MetadataUtils_2 = MetadataUtils_2_1;
            },
            function (JunctionEntityMetadataBuilder_1_1) {
                JunctionEntityMetadataBuilder_1 = JunctionEntityMetadataBuilder_1_1;
            },
            function (ClosureJunctionEntityMetadataBuilder_1_1) {
                ClosureJunctionEntityMetadataBuilder_1 = ClosureJunctionEntityMetadataBuilder_1_1;
            },
            function (RelationJoinColumnBuilder_1_1) {
                RelationJoinColumnBuilder_1 = RelationJoinColumnBuilder_1_1;
            },
            function (EntityListenerMetadata_1_1) {
                EntityListenerMetadata_1 = EntityListenerMetadata_1_1;
            },
            function (ForeignKeyMetadata_4_1) {
                ForeignKeyMetadata_4 = ForeignKeyMetadata_4_1;
            },
            function (LazyRelationsWrapper_2_1) {
                LazyRelationsWrapper_2 = LazyRelationsWrapper_2_1;
            }
        ],
        execute: function () {
            /**
             * Builds EntityMetadata objects and all its sub-metadatas.
             */
            EntityMetadataBuilder = /** @class */ (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function EntityMetadataBuilder(connection, metadataArgsStorage) {
                    this.connection = connection;
                    this.metadataArgsStorage = metadataArgsStorage;
                    this.junctionEntityMetadataBuilder = new JunctionEntityMetadataBuilder_1.JunctionEntityMetadataBuilder(connection);
                    this.closureJunctionEntityMetadataBuilder = new ClosureJunctionEntityMetadataBuilder_1.ClosureJunctionEntityMetadataBuilder(connection);
                    this.relationJoinColumnBuilder = new RelationJoinColumnBuilder_1.RelationJoinColumnBuilder(connection);
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Builds a complete entity metadatas for the given entity classes.
                 */
                EntityMetadataBuilder.prototype.build = function (entityClasses) {
                    var _this = this;
                    // if entity classes to filter entities by are given then do filtering, otherwise use all
                    var allTables = entityClasses ? this.metadataArgsStorage.filterTables(entityClasses) : this.metadataArgsStorage.tables;
                    // filter out table metadata args for those we really create entity metadatas and tables in the db
                    var realTables = allTables.filter(function (table) { return table.type === "regular" || table.type === "closure" || table.type === "class-table-child" || table.type === "single-table-child"; });
                    // create entity metadatas for a user defined entities (marked with @Entity decorator or loaded from entity schemas)
                    var entityMetadatas = realTables.map(function (tableArgs) { return _this.createEntityMetadata(tableArgs); });
                    // calculate entity metadata computed properties and all its sub-metadatas
                    entityMetadatas.forEach(function (entityMetadata) { return _this.computeEntityMetadata(entityMetadata); });
                    // calculate entity metadata's inverse properties
                    entityMetadatas.forEach(function (entityMetadata) { return _this.computeInverseProperties(entityMetadata, entityMetadatas); });
                    // go through all entity metadatas and create foreign keys / junction entity metadatas for their relations
                    entityMetadatas
                        .filter(function (entityMetadata) { return entityMetadata.tableType !== "single-table-child"; })
                        .forEach(function (entityMetadata) {
                        // create entity's relations join columns (for many-to-one and one-to-one owner)
                        entityMetadata.relations.filter(function (relation) { return relation.isOneToOne || relation.isManyToOne; }).forEach(function (relation) {
                            var joinColumns = _this.metadataArgsStorage.filterJoinColumns(relation.target, relation.propertyName);
                            var foreignKey = _this.relationJoinColumnBuilder.build(joinColumns, relation); // create a foreign key based on its metadata args
                            if (foreignKey) {
                                relation.registerForeignKeys(foreignKey); // push it to the relation and thus register there a join column
                                entityMetadata.foreignKeys.push(foreignKey);
                            }
                        });
                        // create junction entity metadatas for entity many-to-many relations
                        entityMetadata.relations.filter(function (relation) { return relation.isManyToMany; }).forEach(function (relation) {
                            var joinTable = _this.metadataArgsStorage.findJoinTable(relation.target, relation.propertyName);
                            if (!joinTable)
                                return; // no join table set - no need to do anything (it means this is many-to-many inverse side)
                            // here we create a junction entity metadata for a new junction table of many-to-many relation
                            var junctionEntityMetadata = _this.junctionEntityMetadataBuilder.build(relation, joinTable);
                            relation.registerForeignKeys.apply(relation, junctionEntityMetadata.foreignKeys);
                            relation.registerJunctionEntityMetadata(junctionEntityMetadata);
                            // compute new entity metadata properties and push it to entity metadatas pool
                            _this.computeEntityMetadata(junctionEntityMetadata);
                            _this.computeInverseProperties(junctionEntityMetadata, entityMetadatas);
                            entityMetadatas.push(junctionEntityMetadata);
                        });
                        // update entity metadata depend properties
                        entityMetadata.relationsWithJoinColumns = entityMetadata.relations.filter(function (relation) { return relation.isWithJoinColumn; });
                        entityMetadata.hasNonNullableRelations = entityMetadata.relationsWithJoinColumns.some(function (relation) { return !relation.isNullable || relation.isPrimary; });
                    });
                    // generate closure junction tables for all closure tables
                    entityMetadatas
                        .filter(function (metadata) { return metadata.isClosure; })
                        .forEach(function (entityMetadata) {
                        var closureJunctionEntityMetadata = _this.closureJunctionEntityMetadataBuilder.build(entityMetadata);
                        entityMetadata.closureJunctionTable = closureJunctionEntityMetadata;
                        _this.computeEntityMetadata(closureJunctionEntityMetadata);
                        _this.computeInverseProperties(closureJunctionEntityMetadata, entityMetadatas);
                        entityMetadatas.push(closureJunctionEntityMetadata);
                    });
                    // after all metadatas created we set parent entity metadata for class-table inheritance
                    entityMetadatas
                        .filter(function (metadata) { return metadata.tableType === "single-table-child" || metadata.tableType === "class-table-child"; })
                        .forEach(function (entityMetadata) {
                        var inheritanceTree = entityMetadata.target instanceof Function
                            ? MetadataUtils_2.MetadataUtils.getInheritanceTree(entityMetadata.target)
                            : [entityMetadata.target];
                        var parentMetadata = entityMetadatas.find(function (metadata) {
                            return inheritanceTree.find(function (inheritance) { return inheritance === metadata.target; }) && (metadata.inheritanceType === "single-table" || metadata.inheritanceType === "class-table");
                        });
                        if (parentMetadata) {
                            entityMetadata.parentEntityMetadata = parentMetadata;
                            if (parentMetadata.inheritanceType === "single-table")
                                entityMetadata.tableName = parentMetadata.tableName;
                        }
                    });
                    // after all metadatas created we set child entity metadatas for class-table inheritance
                    entityMetadatas.forEach(function (metadata) {
                        metadata.childEntityMetadatas = entityMetadatas.filter(function (childMetadata) {
                            return metadata.target instanceof Function
                                && childMetadata.target instanceof Function
                                && MetadataUtils_2.MetadataUtils.isInherited(childMetadata.target, metadata.target);
                        });
                    });
                    // generate keys for tables with single-table inheritance
                    entityMetadatas
                        .filter(function (metadata) { return metadata.inheritanceType === "single-table" && metadata.discriminatorColumn; })
                        .forEach(function (entityMetadata) { return _this.createKeysForTableInheritance(entityMetadata); });
                    // build all indices (need to do it after relations and their join columns are built)
                    entityMetadatas.forEach(function (entityMetadata) {
                        entityMetadata.indices.forEach(function (index) { return index.build(_this.connection.namingStrategy); });
                    });
                    entityMetadatas
                        .filter(function (metadata) { return !!metadata.parentEntityMetadata && metadata.tableType === "class-table-child"; })
                        .forEach(function (metadata) {
                        var parentPrimaryColumns = metadata.parentEntityMetadata.primaryColumns;
                        var parentRelationColumns = parentPrimaryColumns.map(function (parentPrimaryColumn) {
                            var columnName = _this.connection.namingStrategy.classTableInheritanceParentColumnName(metadata.parentEntityMetadata.tableName, parentPrimaryColumn.propertyPath);
                            var column = new ColumnMetadata_5.ColumnMetadata({
                                connection: _this.connection,
                                entityMetadata: metadata,
                                referencedColumn: parentPrimaryColumn,
                                args: {
                                    target: metadata.target,
                                    propertyName: columnName,
                                    mode: "parentId",
                                    options: {
                                        name: columnName,
                                        type: parentPrimaryColumn.type,
                                        unique: false,
                                        nullable: false,
                                        primary: true
                                    }
                                }
                            });
                            metadata.registerColumn(column);
                            column.build(_this.connection);
                            return column;
                        });
                        metadata.foreignKeys = [
                            new ForeignKeyMetadata_4.ForeignKeyMetadata({
                                entityMetadata: metadata,
                                referencedEntityMetadata: metadata.parentEntityMetadata,
                                namingStrategy: _this.connection.namingStrategy,
                                columns: parentRelationColumns,
                                referencedColumns: parentPrimaryColumns,
                                onDelete: "CASCADE"
                            })
                        ];
                    });
                    // add lazy initializer for entity relations
                    entityMetadatas
                        .filter(function (metadata) { return metadata.target instanceof Function; })
                        .forEach(function (entityMetadata) {
                        entityMetadata.relations
                            .filter(function (relation) { return relation.isLazy; })
                            .forEach(function (relation) {
                            var lazyRelationsWrapper = new LazyRelationsWrapper_2.LazyRelationsWrapper(_this.connection);
                            lazyRelationsWrapper.wrap(entityMetadata.target.prototype, relation);
                        });
                    });
                    entityMetadatas.forEach(function (entityMetadata) {
                        entityMetadata.columns.forEach(function (column) {
                            // const target = column.embeddedMetadata ? column.embeddedMetadata.type : column.target;
                            var generated = _this.metadataArgsStorage.findGenerated(column.target, column.propertyName);
                            if (generated) {
                                column.isGenerated = true;
                                column.generationStrategy = generated.strategy;
                                column.type = generated.strategy === "increment" ? (column.type || Number) : "uuid";
                                column.build(_this.connection);
                                _this.computeEntityMetadata(entityMetadata);
                            }
                        });
                    });
                    return entityMetadatas;
                };
                // -------------------------------------------------------------------------
                // Protected Methods
                // -------------------------------------------------------------------------
                /**
                 * Creates entity metadata from the given table args.
                 * Creates column, relation, etc. metadatas for everything this entity metadata owns.
                 */
                EntityMetadataBuilder.prototype.createEntityMetadata = function (tableArgs) {
                    var _this = this;
                    // we take all "inheritance tree" from a target entity to collect all stored metadata args
                    // (by decorators or inside entity schemas). For example for target Post < ContentModel < Unit
                    // it will be an array of [Post, ContentModel, Unit] and we can then get all metadata args of those classes
                    var inheritanceTree = tableArgs.target instanceof Function
                        ? MetadataUtils_2.MetadataUtils.getInheritanceTree(tableArgs.target)
                        : [tableArgs.target]; // todo: implement later here inheritance for string-targets
                    // if single table inheritance used, we need to copy all children columns in to parent table
                    var singleTableChildrenTargets;
                    if (tableArgs.type === "single-table-child") {
                        singleTableChildrenTargets = this.metadataArgsStorage
                            .filterSingleTableChildren(tableArgs.target)
                            .map(function (args) { return args.target; })
                            .filter(function (target) { return target instanceof Function; });
                        inheritanceTree.push.apply(inheritanceTree, singleTableChildrenTargets);
                    }
                    else if (tableArgs.type === "class-table-child") {
                        inheritanceTree.forEach(function (inheritanceTreeItem) {
                            var isParent = !!_this.metadataArgsStorage.inheritances.find(function (i) { return i.target === inheritanceTreeItem; });
                            if (isParent)
                                inheritanceTree.splice(inheritanceTree.indexOf(inheritanceTreeItem), 1);
                        });
                    }
                    var entityMetadata = new EntityMetadata_3.EntityMetadata({
                        connection: this.connection,
                        args: tableArgs
                    });
                    var inheritanceType = this.metadataArgsStorage.findInheritanceType(tableArgs.target);
                    entityMetadata.inheritanceType = inheritanceType ? inheritanceType.type : undefined;
                    var discriminatorValue = this.metadataArgsStorage.findDiscriminatorValue(tableArgs.target);
                    entityMetadata.discriminatorValue = discriminatorValue ? discriminatorValue.value : tableArgs.target.name; // todo: pass this to naming strategy to generate a name
                    entityMetadata.embeddeds = this.createEmbeddedsRecursively(entityMetadata, this.metadataArgsStorage.filterEmbeddeds(inheritanceTree));
                    entityMetadata.ownColumns = this.metadataArgsStorage
                        .filterColumns(inheritanceTree)
                        .map(function (args) {
                        var column = new ColumnMetadata_5.ColumnMetadata({ connection: _this.connection, entityMetadata: entityMetadata, args: args });
                        // console.log(column.propertyName);
                        // if single table inheritance used, we need to mark all inherit table columns as nullable
                        if (singleTableChildrenTargets && singleTableChildrenTargets.indexOf(args.target) !== -1)
                            column.isNullable = true;
                        return column;
                    });
                    entityMetadata.ownRelations = this.metadataArgsStorage.filterRelations(inheritanceTree).map(function (args) {
                        return new RelationMetadata_1.RelationMetadata({ entityMetadata: entityMetadata, args: args });
                    });
                    entityMetadata.relationIds = this.metadataArgsStorage.filterRelationIds(inheritanceTree).map(function (args) {
                        return new RelationIdMetadata_1.RelationIdMetadata({ entityMetadata: entityMetadata, args: args });
                    });
                    entityMetadata.relationCounts = this.metadataArgsStorage.filterRelationCounts(inheritanceTree).map(function (args) {
                        return new RelationCountMetadata_1.RelationCountMetadata({ entityMetadata: entityMetadata, args: args });
                    });
                    entityMetadata.ownIndices = this.metadataArgsStorage.filterIndices(inheritanceTree).map(function (args) {
                        return new IndexMetadata_2.IndexMetadata({ entityMetadata: entityMetadata, args: args });
                    });
                    entityMetadata.ownListeners = this.metadataArgsStorage.filterListeners(inheritanceTree).map(function (args) {
                        return new EntityListenerMetadata_1.EntityListenerMetadata({ entityMetadata: entityMetadata, args: args });
                    });
                    return entityMetadata;
                };
                /**
                 * Creates from the given embedded metadata args real embedded metadatas with its columns and relations,
                 * and does the same for all its sub-embeddeds (goes recursively).
                 */
                EntityMetadataBuilder.prototype.createEmbeddedsRecursively = function (entityMetadata, embeddedArgs) {
                    var _this = this;
                    return embeddedArgs.map(function (embeddedArgs) {
                        var embeddedMetadata = new EmbeddedMetadata_1.EmbeddedMetadata({ entityMetadata: entityMetadata, args: embeddedArgs });
                        var targets = MetadataUtils_2.MetadataUtils.getInheritanceTree(embeddedMetadata.type);
                        embeddedMetadata.columns = _this.metadataArgsStorage.filterColumns(targets).map(function (args) {
                            return new ColumnMetadata_5.ColumnMetadata({ connection: _this.connection, entityMetadata: entityMetadata, embeddedMetadata: embeddedMetadata, args: args });
                        });
                        embeddedMetadata.relations = _this.metadataArgsStorage.filterRelations(targets).map(function (args) {
                            return new RelationMetadata_1.RelationMetadata({ entityMetadata: entityMetadata, embeddedMetadata: embeddedMetadata, args: args });
                        });
                        embeddedMetadata.listeners = _this.metadataArgsStorage.filterListeners(targets).map(function (args) {
                            return new EntityListenerMetadata_1.EntityListenerMetadata({ entityMetadata: entityMetadata, embeddedMetadata: embeddedMetadata, args: args });
                        });
                        embeddedMetadata.indices = _this.metadataArgsStorage.filterIndices(targets).map(function (args) {
                            return new IndexMetadata_2.IndexMetadata({ entityMetadata: entityMetadata, embeddedMetadata: embeddedMetadata, args: args });
                        });
                        embeddedMetadata.relationIds = _this.metadataArgsStorage.filterRelationIds(targets).map(function (args) {
                            return new RelationIdMetadata_1.RelationIdMetadata({ entityMetadata: entityMetadata, args: args });
                        });
                        embeddedMetadata.relationCounts = _this.metadataArgsStorage.filterRelationCounts(targets).map(function (args) {
                            return new RelationCountMetadata_1.RelationCountMetadata({ entityMetadata: entityMetadata, args: args });
                        });
                        embeddedMetadata.embeddeds = _this.createEmbeddedsRecursively(entityMetadata, _this.metadataArgsStorage.filterEmbeddeds(targets));
                        embeddedMetadata.embeddeds.forEach(function (subEmbedded) { return subEmbedded.parentEmbeddedMetadata = embeddedMetadata; });
                        return embeddedMetadata;
                    });
                };
                /**
                 * Computes all entity metadata's computed properties, and all its sub-metadatas (relations, columns, embeds, etc).
                 */
                EntityMetadataBuilder.prototype.computeEntityMetadata = function (entityMetadata) {
                    var _this = this;
                    entityMetadata.embeddeds.forEach(function (embedded) { return embedded.build(_this.connection); });
                    entityMetadata.embeddeds.forEach(function (embedded) {
                        embedded.columnsFromTree.forEach(function (column) { return column.build(_this.connection); });
                        embedded.relationsFromTree.forEach(function (relation) { return relation.build(); });
                    });
                    entityMetadata.ownColumns.forEach(function (column) { return column.build(_this.connection); });
                    entityMetadata.ownRelations.forEach(function (relation) { return relation.build(); });
                    entityMetadata.relations = entityMetadata.embeddeds.reduce(function (relations, embedded) { return relations.concat(embedded.relationsFromTree); }, entityMetadata.ownRelations);
                    entityMetadata.eagerRelations = entityMetadata.relations.filter(function (relation) { return relation.isEager; });
                    entityMetadata.lazyRelations = entityMetadata.relations.filter(function (relation) { return relation.isLazy; });
                    entityMetadata.oneToOneRelations = entityMetadata.relations.filter(function (relation) { return relation.isOneToOne; });
                    entityMetadata.oneToManyRelations = entityMetadata.relations.filter(function (relation) { return relation.isOneToMany; });
                    entityMetadata.manyToOneRelations = entityMetadata.relations.filter(function (relation) { return relation.isManyToOne; });
                    entityMetadata.manyToManyRelations = entityMetadata.relations.filter(function (relation) { return relation.isManyToMany; });
                    entityMetadata.ownerOneToOneRelations = entityMetadata.relations.filter(function (relation) { return relation.isOneToOneOwner; });
                    entityMetadata.ownerManyToManyRelations = entityMetadata.relations.filter(function (relation) { return relation.isManyToManyOwner; });
                    entityMetadata.treeParentRelation = entityMetadata.relations.find(function (relation) { return relation.isTreeParent; });
                    entityMetadata.treeChildrenRelation = entityMetadata.relations.find(function (relation) { return relation.isTreeChildren; });
                    entityMetadata.columns = entityMetadata.embeddeds.reduce(function (columns, embedded) { return columns.concat(embedded.columnsFromTree); }, entityMetadata.ownColumns);
                    entityMetadata.listeners = entityMetadata.embeddeds.reduce(function (columns, embedded) { return columns.concat(embedded.listenersFromTree); }, entityMetadata.ownListeners);
                    entityMetadata.indices = entityMetadata.embeddeds.reduce(function (columns, embedded) { return columns.concat(embedded.indicesFromTree); }, entityMetadata.ownIndices);
                    entityMetadata.primaryColumns = entityMetadata.columns.filter(function (column) { return column.isPrimary; });
                    entityMetadata.hasMultiplePrimaryKeys = entityMetadata.primaryColumns.length > 1;
                    entityMetadata.generatedColumns = entityMetadata.columns.filter(function (column) { return column.isGenerated || column.isObjectId; });
                    entityMetadata.createDateColumn = entityMetadata.columns.find(function (column) { return column.isCreateDate; });
                    entityMetadata.updateDateColumn = entityMetadata.columns.find(function (column) { return column.isUpdateDate; });
                    entityMetadata.versionColumn = entityMetadata.columns.find(function (column) { return column.isVersion; });
                    entityMetadata.discriminatorColumn = entityMetadata.columns.find(function (column) { return column.isDiscriminator; });
                    entityMetadata.treeLevelColumn = entityMetadata.columns.find(function (column) { return column.isTreeLevel; });
                    entityMetadata.parentIdColumns = entityMetadata.columns.filter(function (column) { return column.isParentId; });
                    entityMetadata.objectIdColumn = entityMetadata.columns.find(function (column) { return column.isObjectId; });
                    entityMetadata.foreignKeys.forEach(function (foreignKey) { return foreignKey.build(_this.connection.namingStrategy); });
                    entityMetadata.propertiesMap = entityMetadata.createPropertiesMap();
                    entityMetadata.relationIds.forEach(function (relationId) { return relationId.build(); });
                    entityMetadata.relationCounts.forEach(function (relationCount) { return relationCount.build(); });
                    entityMetadata.embeddeds.forEach(function (embedded) {
                        embedded.relationIdsFromTree.forEach(function (relationId) { return relationId.build(); });
                        embedded.relationCountsFromTree.forEach(function (relationCount) { return relationCount.build(); });
                    });
                };
                /**
                 * Computes entity metadata's relations inverse side properties.
                 */
                EntityMetadataBuilder.prototype.computeInverseProperties = function (entityMetadata, entityMetadatas) {
                    entityMetadata.relations.forEach(function (relation) {
                        // compute inverse side (related) entity metadatas for all relation metadatas
                        var inverseEntityMetadata = entityMetadatas.find(function (m) { return m.target === relation.type || (typeof relation.type === "string" && m.targetName === relation.type); });
                        if (!inverseEntityMetadata)
                            throw new Error("Entity metadata for " + entityMetadata.name + "#" + relation.propertyPath + " was not found. Check if you specified a correct entity object, check its really entity and its connected in the connection options.");
                        relation.inverseEntityMetadata = inverseEntityMetadata;
                        relation.inverseSidePropertyPath = relation.buildInverseSidePropertyPath();
                        // and compute inverse relation and mark if it has such
                        relation.inverseRelation = inverseEntityMetadata.relations.find(function (foundRelation) { return foundRelation.propertyPath === relation.inverseSidePropertyPath; });
                    });
                };
                /**
                 * Creates indices for the table of single table inheritance.
                 */
                EntityMetadataBuilder.prototype.createKeysForTableInheritance = function (entityMetadata) {
                    entityMetadata.indices.push(new IndexMetadata_2.IndexMetadata({
                        entityMetadata: entityMetadata,
                        columns: [entityMetadata.discriminatorColumn],
                        args: {
                            target: entityMetadata.target,
                            unique: false
                        }
                    }), new IndexMetadata_2.IndexMetadata({
                        entityMetadata: entityMetadata,
                        columns: entityMetadata.primaryColumns.concat([entityMetadata.discriminatorColumn]),
                        args: {
                            target: entityMetadata.target,
                            unique: false
                        }
                    }));
                };
                return EntityMetadataBuilder;
            }());
            exports_210("EntityMetadataBuilder", EntityMetadataBuilder);
            // generate virtual column with foreign key for class-table inheritance
            /*entityMetadatas.forEach(entityMetadata => {
             if (!entityMetadata.parentEntityMetadata)
             return;
            
             const parentPrimaryColumns = entityMetadata.parentEntityMetadata.primaryColumns;
             const parentIdColumns = parentPrimaryColumns.map(primaryColumn => {
             const columnName = this.namingStrategy.classTableInheritanceParentColumnName(entityMetadata.parentEntityMetadata.tableName, primaryColumn.propertyName);
             const column = new ColumnMetadataBuilder(entityMetadata);
             column.type = primaryColumn.type;
             column.propertyName = primaryColumn.propertyName; // todo: check why needed
             column.givenName = columnName;
             column.mode = "parentId";
             column.isUnique = true;
             column.isNullable = false;
             // column.entityTarget = entityMetadata.target;
             return column;
             });
            
             // add foreign key
             const foreignKey = new ForeignKeyMetadataBuilder(
             entityMetadata,
             parentIdColumns,
             entityMetadata.parentEntityMetadata,
             parentPrimaryColumns,
             "CASCADE"
             );
             entityMetadata.ownColumns.push(...parentIdColumns);
             entityMetadata.foreignKeys.push(foreignKey);
             });*/
            /*protected createEntityMetadata(metadata: EntityMetadata, options: {
             userSpecifiedTableName?: string,
             closureOwnerTableName?: string,
             }) {
            
             const tableNameUserSpecified = options.userSpecifiedTableName;
             const isClosureJunction = metadata.tableType === "closure-junction";
             const targetName = metadata.target instanceof Function ? (metadata.target as any).name : metadata.target;
             const tableNameWithoutPrefix = isClosureJunction
             ? this.namingStrategy.closureJunctionTableName(options.closureOwnerTableName!)
             : this.namingStrategy.tableName(targetName, options.userSpecifiedTableName);
            
             const tableName = this.namingStrategy.prefixTableName(this.driver.options.tablesPrefix, tableNameWithoutPrefix);
            
             // for virtual tables (like junction table) target is equal to undefined at this moment
             // we change this by setting virtual's table name to a target name
             // todo: add validation so targets with same schema names won't conflicts with virtual table names
             metadata.target = metadata.target ? metadata.target : tableName;
             metadata.targetName = targetName;
             metadata.givenTableName = tableNameUserSpecified;
             metadata.tableNameWithoutPrefix = tableNameWithoutPrefix;
             metadata.tableName = tableName;
             metadata.name = targetName ? targetName : tableName;
             // metadata.namingStrategy = this.namingStrategy;
             }*/
            /*protected createEntityMetadata(tableArgs: any, argsForTable: any, ): EntityMetadata {
             const metadata = new EntityMetadata({
             junction: false,
             target: tableArgs.target,
             tablesPrefix: this.driver.options.tablesPrefix,
             namingStrategy: this.namingStrategy,
             tableName: argsForTable.name,
             tableType: argsForTable.type,
             orderBy: argsForTable.orderBy,
             engine: argsForTable.engine,
             skipSchemaSync: argsForTable.skipSchemaSync,
             columnMetadatas: columns,
             relationMetadatas: relations,
             relationIdMetadatas: relationIds,
             relationCountMetadatas: relationCounts,
             indexMetadatas: indices,
             embeddedMetadatas: embeddeds,
             inheritanceType: mergedArgs.inheritance ? mergedArgs.inheritance.type : undefined,
             discriminatorValue: discriminatorValueArgs ? discriminatorValueArgs.value : (tableArgs.target as any).name // todo: pass this to naming strategy to generate a name
             }, this.lazyRelationsWrapper);
             return metadata;
             }*/
            // const tables = [mergedArgs.table].concat(mergedArgs.children);
            // tables.forEach(tableArgs => {
            // find embeddable tables for embeddeds registered in this table and create EmbeddedMetadatas from them
            // const findEmbeddedsRecursively = (embeddedArgs: EmbeddedMetadataArgs[]) => {
            //     const embeddeds: EmbeddedMetadata[] = [];
            //     embeddedArgs.forEach(embedded => {
            //         const embeddableTable = embeddableMergedArgs.find(embeddedMergedArgs => embeddedMergedArgs.table.target === embedded.type());
            //         if (embeddableTable) {
            //             const columns = embeddableTable.columns.toArray().map(args => new ColumnMetadata(args));
            //             const relations = embeddableTable.relations.toArray().map(args => new RelationMetadata(args));
            //             const subEmbeddeds = findEmbeddedsRecursively(embeddableTable.embeddeds.toArray());
            //             embeddeds.push(new EmbeddedMetadata(columns, relations, subEmbeddeds, embedded));
            //         }
            //     });
            //     return embeddeds;
            // };
            // const embeddeds = findEmbeddedsRecursively(mergedArgs.embeddeds.toArray());
            // create metadatas from args
            // const argsForTable = mergedArgs.inheritance && mergedArgs.inheritance.type === "single-table" ? mergedArgs.table : tableArgs;
            // const table = new TableMetadata(argsForTable);
            // const columns = mergedArgs.columns.toArray().map(args => {
            //
            //     // if column's target is a child table then this column should have all nullable columns
            //     if (mergedArgs.inheritance &&
            //         mergedArgs.inheritance.type === "single-table" &&
            //         args.target !== mergedArgs.table.target && !!mergedArgs.children.find(childTable => childTable.target === args.target)) {
            //         args.options.nullable = true;
            //     }
            //     return new ColumnMetadata(args);
            // });
            // const discriminatorValueArgs = mergedArgs.discriminatorValues.find(discriminatorValueArgs => {
            //     return discriminatorValueArgs.target === tableArgs.target;
            // });
            // after all metadatas created we set parent entity metadata for class-table inheritance
            // entityMetadatas.forEach(entityMetadata => {
            //     const mergedArgs = realTables.find(args => args.target === entityMetadata.target);
            //     if (mergedArgs && mergedArgs.parent) {
            //         const parentEntityMetadata = entityMetadatas.find(entityMetadata => entityMetadata.target === (mergedArgs!.parent! as any).target); // todo: weird compiler error here, thats why type casing is used
            //         if (parentEntityMetadata)
            //             entityMetadata.parentEntityMetadata = parentEntityMetadata;
            //     }
            // });
        }
    };
});
System.register("typeorm/decorator/options/JoinTableOptions", [], function (exports_211, context_211) {
    "use strict";
    var __moduleName = context_211 && context_211.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/entity-schema/EntitySchemaTransformer", ["typeorm/metadata-args/MetadataArgsStorage"], function (exports_212, context_212) {
    "use strict";
    var __moduleName = context_212 && context_212.id;
    var MetadataArgsStorage_1, EntitySchemaTransformer;
    return {
        setters: [
            function (MetadataArgsStorage_1_1) {
                MetadataArgsStorage_1 = MetadataArgsStorage_1_1;
            }
        ],
        execute: function () {
            /**
             * Transforms entity schema into metadata args storage.
             * The result will be just like entities read from decorators.
             */
            EntitySchemaTransformer = /** @class */ (function () {
                function EntitySchemaTransformer() {
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Transforms entity schema into new metadata args storage object.
                 */
                EntitySchemaTransformer.prototype.transform = function (schemas) {
                    var metadataArgsStorage = new MetadataArgsStorage_1.MetadataArgsStorage();
                    schemas.forEach(function (schema) {
                        // add table metadata args from the schema
                        var table = schema.table || {};
                        var tableMetadata = {
                            target: schema.target || schema.name,
                            name: table.name,
                            type: table.type || "regular",
                            orderBy: table.orderBy
                        };
                        metadataArgsStorage.tables.push(tableMetadata);
                        // add columns metadata args from the schema
                        Object.keys(schema.columns).forEach(function (columnName) {
                            var tableColumn = schema.columns[columnName];
                            var mode = "regular";
                            if (tableColumn.createDate)
                                mode = "createDate";
                            if (tableColumn.updateDate)
                                mode = "updateDate";
                            if (tableColumn.version)
                                mode = "version";
                            if (tableColumn.treeChildrenCount)
                                mode = "treeChildrenCount";
                            if (tableColumn.treeLevel)
                                mode = "treeLevel";
                            var columnAgrs = {
                                target: schema.target || schema.name,
                                mode: mode,
                                propertyName: columnName,
                                options: {
                                    type: tableColumn.type,
                                    name: tableColumn.name,
                                    length: tableColumn.length,
                                    primary: tableColumn.primary,
                                    unique: tableColumn.unique,
                                    nullable: tableColumn.nullable,
                                    comment: tableColumn.comment,
                                    default: tableColumn.default,
                                    precision: tableColumn.precision,
                                    scale: tableColumn.scale
                                }
                            };
                            metadataArgsStorage.columns.push(columnAgrs);
                            if (tableColumn.generated) {
                                var generationArgs = {
                                    target: schema.target || schema.name,
                                    propertyName: columnName,
                                    strategy: typeof tableColumn.generated === "string" ? tableColumn.generated : "increment"
                                };
                                metadataArgsStorage.generations.push(generationArgs);
                            }
                        });
                        // add relation metadata args from the schema
                        if (schema.relations) {
                            Object.keys(schema.relations).forEach(function (relationName) {
                                var relationSchema = schema.relations[relationName];
                                var relation = {
                                    target: schema.target || schema.name,
                                    propertyName: relationName,
                                    relationType: relationSchema.type,
                                    isLazy: relationSchema.isLazy || false,
                                    type: relationSchema.target,
                                    inverseSideProperty: relationSchema.inverseSide,
                                    isTreeParent: relationSchema.isTreeParent,
                                    isTreeChildren: relationSchema.isTreeChildren,
                                    options: {
                                        cascadeAll: relationSchema.cascadeAll,
                                        cascadeInsert: relationSchema.cascadeInsert,
                                        cascadeUpdate: relationSchema.cascadeUpdate,
                                        cascadeRemove: relationSchema.cascadeRemove,
                                        nullable: relationSchema.nullable,
                                        onDelete: relationSchema.onDelete
                                    }
                                };
                                metadataArgsStorage.relations.push(relation);
                                // add join column
                                if (relationSchema.joinColumn) {
                                    if (typeof relationSchema.joinColumn === "boolean") {
                                        var joinColumn = {
                                            target: schema.target || schema.name,
                                            propertyName: relationName
                                        };
                                        metadataArgsStorage.joinColumns.push(joinColumn);
                                    }
                                    else {
                                        var joinColumn = {
                                            target: schema.target || schema.name,
                                            propertyName: relationName,
                                            name: relationSchema.joinColumn.name,
                                            referencedColumnName: relationSchema.joinColumn.referencedColumnName
                                        };
                                        metadataArgsStorage.joinColumns.push(joinColumn);
                                    }
                                }
                                // add join table
                                if (relationSchema.joinTable) {
                                    if (typeof relationSchema.joinTable === "boolean") {
                                        var joinTable = {
                                            target: schema.target || schema.name,
                                            propertyName: relationName
                                        };
                                        metadataArgsStorage.joinTables.push(joinTable);
                                    }
                                    else {
                                        var joinTable = {
                                            target: schema.target || schema.name,
                                            propertyName: relationName,
                                            name: relationSchema.joinTable.name,
                                            joinColumns: (relationSchema.joinTable.joinColumn ? [relationSchema.joinTable.joinColumn] : relationSchema.joinTable.joinColumns),
                                            inverseJoinColumns: (relationSchema.joinTable.inverseJoinColumn ? [relationSchema.joinTable.inverseJoinColumn] : relationSchema.joinTable.inverseJoinColumns),
                                        };
                                        metadataArgsStorage.joinTables.push(joinTable);
                                    }
                                }
                            });
                        }
                        // add relation metadata args from the schema
                        if (schema.indices) {
                            Object.keys(schema.indices).forEach(function (indexName) {
                                var tableIndex = schema.indices[indexName];
                                var indexAgrs = {
                                    target: schema.target || schema.name,
                                    name: indexName,
                                    unique: tableIndex.unique,
                                    sparse: tableIndex.sparse,
                                    columns: tableIndex.columns
                                };
                                metadataArgsStorage.indices.push(indexAgrs);
                            });
                        }
                    });
                    return metadataArgsStorage;
                };
                return EntitySchemaTransformer;
            }());
            exports_212("EntitySchemaTransformer", EntitySchemaTransformer);
        }
    };
});
System.register("typeorm/connection/ConnectionMetadataBuilder", ["typeorm/util/DirectoryExportedClassesLoader", "typeorm/util/OrmUtils", "typeorm/container", "typeorm/index", "typeorm/metadata-builder/EntityMetadataBuilder", "typeorm/entity-schema/EntitySchemaTransformer"], function (exports_213, context_213) {
    "use strict";
    var __moduleName = context_213 && context_213.id;
    var DirectoryExportedClassesLoader_1, OrmUtils_13, container_1, index_3, EntityMetadataBuilder_1, EntitySchemaTransformer_1, ConnectionMetadataBuilder;
    return {
        setters: [
            function (DirectoryExportedClassesLoader_1_1) {
                DirectoryExportedClassesLoader_1 = DirectoryExportedClassesLoader_1_1;
            },
            function (OrmUtils_13_1) {
                OrmUtils_13 = OrmUtils_13_1;
            },
            function (container_1_1) {
                container_1 = container_1_1;
            },
            function (index_3_1) {
                index_3 = index_3_1;
            },
            function (EntityMetadataBuilder_1_1) {
                EntityMetadataBuilder_1 = EntityMetadataBuilder_1_1;
            },
            function (EntitySchemaTransformer_1_1) {
                EntitySchemaTransformer_1 = EntitySchemaTransformer_1_1;
            }
        ],
        execute: function () {
            /**
             * Builds migration instances, subscriber instances and entity metadatas for the given classes.
             */
            ConnectionMetadataBuilder = /** @class */ (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function ConnectionMetadataBuilder(connection) {
                    this.connection = connection;
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Builds migration instances for the given classes or directories.
                 */
                ConnectionMetadataBuilder.prototype.buildMigrations = function (migrations) {
                    var _a = OrmUtils_13.OrmUtils.splitClassesAndStrings(migrations), migrationClasses = _a[0], migrationDirectories = _a[1];
                    var allMigrationClasses = migrationClasses.concat(DirectoryExportedClassesLoader_1.importClassesFromDirectories(migrationDirectories));
                    return allMigrationClasses.map(function (migrationClass) { return container_1.getFromContainer(migrationClass); });
                };
                /**
                 * Builds subscriber instances for the given classes or directories.
                 */
                ConnectionMetadataBuilder.prototype.buildSubscribers = function (subscribers) {
                    var _a = OrmUtils_13.OrmUtils.splitClassesAndStrings(subscribers || []), subscriberClasses = _a[0], subscriberDirectories = _a[1];
                    var allSubscriberClasses = subscriberClasses.concat(DirectoryExportedClassesLoader_1.importClassesFromDirectories(subscriberDirectories));
                    return index_3.getMetadataArgsStorage()
                        .filterSubscribers(allSubscriberClasses)
                        .map(function (metadata) { return container_1.getFromContainer(metadata.target); });
                };
                /**
                 * Builds entity metadatas for the given classes or directories.
                 */
                ConnectionMetadataBuilder.prototype.buildEntityMetadatas = function (entities, schemas) {
                    var _a = OrmUtils_13.OrmUtils.splitClassesAndStrings(entities || []), entityClasses = _a[0], entityDirectories = _a[1];
                    var allEntityClasses = entityClasses.concat(DirectoryExportedClassesLoader_1.importClassesFromDirectories(entityDirectories));
                    var decoratorEntityMetadatas = new EntityMetadataBuilder_1.EntityMetadataBuilder(this.connection, index_3.getMetadataArgsStorage()).build(allEntityClasses);
                    var _b = OrmUtils_13.OrmUtils.splitClassesAndStrings(schemas || []), entitySchemaClasses = _b[0], entitySchemaDirectories = _b[1];
                    var allEntitySchemaClasses = entitySchemaClasses.concat(DirectoryExportedClassesLoader_1.importJsonsFromDirectories(entitySchemaDirectories));
                    var metadataArgsStorageFromSchema = new EntitySchemaTransformer_1.EntitySchemaTransformer().transform(allEntitySchemaClasses);
                    var schemaEntityMetadatas = new EntityMetadataBuilder_1.EntityMetadataBuilder(this.connection, metadataArgsStorageFromSchema).build();
                    return decoratorEntityMetadatas.concat(schemaEntityMetadatas);
                };
                return ConnectionMetadataBuilder;
            }());
            exports_213("ConnectionMetadataBuilder", ConnectionMetadataBuilder);
        }
    };
});
System.register("typeorm/logger/SimpleConsoleLogger", [], function (exports_214, context_214) {
    "use strict";
    var __moduleName = context_214 && context_214.id;
    var SimpleConsoleLogger;
    return {
        setters: [],
        execute: function () {
            /**
             * Performs logging of the events in TypeORM.
             * This version of logger uses console to log events and does not use syntax highlighting.
             */
            SimpleConsoleLogger = /** @class */ (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function SimpleConsoleLogger(options) {
                    this.options = options;
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Logs query and parameters used in it.
                 */
                SimpleConsoleLogger.prototype.logQuery = function (query, parameters, queryRunner) {
                    if (this.options === "all" || this.options === true || (this.options instanceof Array && this.options.indexOf("query") !== -1)) {
                        var sql = query + (parameters && parameters.length ? " -- PARAMETERS: " + this.stringifyParams(parameters) : "");
                        console.log("executing query" + ": " + sql);
                    }
                };
                /**
                 * Logs query that is failed.
                 */
                SimpleConsoleLogger.prototype.logQueryError = function (error, query, parameters, queryRunner) {
                    if (this.options === "all" || this.options === true || (this.options instanceof Array && this.options.indexOf("error") !== -1)) {
                        var sql = query + (parameters && parameters.length ? " -- PARAMETERS: " + this.stringifyParams(parameters) : "");
                        console.log("query failed: " + sql);
                        console.log("error:", error);
                    }
                };
                /**
                 * Logs query that is slow.
                 */
                SimpleConsoleLogger.prototype.logQuerySlow = function (time, query, parameters, queryRunner) {
                    var sql = query + (parameters && parameters.length ? " -- PARAMETERS: " + this.stringifyParams(parameters) : "");
                    console.log("query is slow: " + sql);
                    console.log("execution time: " + time);
                };
                /**
                 * Logs events from the schema build process.
                 */
                SimpleConsoleLogger.prototype.logSchemaBuild = function (message, queryRunner) {
                    if (this.options === "all" || (this.options instanceof Array && this.options.indexOf("schema") !== -1)) {
                        console.log(message);
                    }
                };
                /**
                 * Logs events from the migrations run process.
                 */
                SimpleConsoleLogger.prototype.logMigration = function (message, queryRunner) {
                    console.log(message);
                };
                /**
                 * Perform logging using given logger, or by default to the console.
                 * Log has its own level and message.
                 */
                SimpleConsoleLogger.prototype.log = function (level, message, queryRunner) {
                    switch (level) {
                        case "log":
                            if (this.options === "all" || (this.options instanceof Array && this.options.indexOf("log") !== -1))
                                console.log(message);
                            break;
                        case "info":
                            if (this.options === "all" || (this.options instanceof Array && this.options.indexOf("info") !== -1))
                                console.info(message);
                            break;
                        case "warn":
                            if (this.options === "all" || (this.options instanceof Array && this.options.indexOf("warn") !== -1))
                                console.warn(message);
                            break;
                    }
                };
                // -------------------------------------------------------------------------
                // Protected Methods
                // -------------------------------------------------------------------------
                /**
                 * Converts parameters to a string.
                 * Sometimes parameters can have circular objects and therefor we are handle this case too.
                 */
                SimpleConsoleLogger.prototype.stringifyParams = function (parameters) {
                    try {
                        return JSON.stringify(parameters);
                    }
                    catch (error) { // most probably circular objects in parameters
                        return parameters;
                    }
                };
                return SimpleConsoleLogger;
            }());
            exports_214("SimpleConsoleLogger", SimpleConsoleLogger);
        }
    };
});
System.register("typeorm/logger/AdvancedConsoleLogger", ["typeorm/platform/PlatformTools"], function (exports_215, context_215) {
    "use strict";
    var __moduleName = context_215 && context_215.id;
    var PlatformTools_11, AdvancedConsoleLogger;
    return {
        setters: [
            function (PlatformTools_11_1) {
                PlatformTools_11 = PlatformTools_11_1;
            }
        ],
        execute: function () {
            /**
             * Performs logging of the events in TypeORM.
             * This version of logger uses console to log events and use syntax highlighting.
             */
            AdvancedConsoleLogger = /** @class */ (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function AdvancedConsoleLogger(options) {
                    this.options = options;
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Logs query and parameters used in it.
                 */
                AdvancedConsoleLogger.prototype.logQuery = function (query, parameters, queryRunner) {
                    if (this.options === "all" || this.options === true || (this.options instanceof Array && this.options.indexOf("query") !== -1)) {
                        var sql = query + (parameters && parameters.length ? " -- PARAMETERS: " + this.stringifyParams(parameters) : "");
                        PlatformTools_11.PlatformTools.logInfo("executing query:", PlatformTools_11.PlatformTools.highlightSql(sql));
                    }
                };
                /**
                 * Logs query that is failed.
                 */
                AdvancedConsoleLogger.prototype.logQueryError = function (error, query, parameters, queryRunner) {
                    if (this.options === "all" || this.options === true || (this.options instanceof Array && this.options.indexOf("error") !== -1)) {
                        var sql = query + (parameters && parameters.length ? " -- PARAMETERS: " + this.stringifyParams(parameters) : "");
                        PlatformTools_11.PlatformTools.logError("query failed:", PlatformTools_11.PlatformTools.highlightSql(sql));
                        PlatformTools_11.PlatformTools.logError("error:", error);
                    }
                };
                /**
                 * Logs query that is slow.
                 */
                AdvancedConsoleLogger.prototype.logQuerySlow = function (time, query, parameters, queryRunner) {
                    var sql = query + (parameters && parameters.length ? " -- PARAMETERS: " + this.stringifyParams(parameters) : "");
                    PlatformTools_11.PlatformTools.logWarn("query is slow:", PlatformTools_11.PlatformTools.highlightSql(sql));
                    PlatformTools_11.PlatformTools.logWarn("execution time:", time);
                };
                /**
                 * Logs events from the schema build process.
                 */
                AdvancedConsoleLogger.prototype.logSchemaBuild = function (message, queryRunner) {
                    if (this.options === "all" || (this.options instanceof Array && this.options.indexOf("schema") !== -1)) {
                        PlatformTools_11.PlatformTools.log(message);
                    }
                };
                /**
                 * Logs events from the migration run process.
                 */
                AdvancedConsoleLogger.prototype.logMigration = function (message, queryRunner) {
                    PlatformTools_11.PlatformTools.log(message);
                };
                /**
                 * Perform logging using given logger, or by default to the console.
                 * Log has its own level and message.
                 */
                AdvancedConsoleLogger.prototype.log = function (level, message, queryRunner) {
                    switch (level) {
                        case "log":
                            if (this.options === "all" || (this.options instanceof Array && this.options.indexOf("log") !== -1))
                                console.log(message);
                            break;
                        case "info":
                            if (this.options === "all" || (this.options instanceof Array && this.options.indexOf("info") !== -1))
                                console.info(message);
                            break;
                        case "warn":
                            if (this.options === "all" || (this.options instanceof Array && this.options.indexOf("warn") !== -1))
                                console.warn(PlatformTools_11.PlatformTools.warn(message));
                            break;
                    }
                };
                // -------------------------------------------------------------------------
                // Protected Methods
                // -------------------------------------------------------------------------
                /**
                 * Converts parameters to a string.
                 * Sometimes parameters can have circular objects and therefor we are handle this case too.
                 */
                AdvancedConsoleLogger.prototype.stringifyParams = function (parameters) {
                    try {
                        return JSON.stringify(parameters);
                    }
                    catch (error) { // most probably circular objects in parameters
                        return parameters;
                    }
                };
                return AdvancedConsoleLogger;
            }());
            exports_215("AdvancedConsoleLogger", AdvancedConsoleLogger);
        }
    };
});
System.register("typeorm/logger/FileLogger", ["typeorm/platform/PlatformTools"], function (exports_216, context_216) {
    "use strict";
    var __moduleName = context_216 && context_216.id;
    var PlatformTools_12, FileLogger;
    return {
        setters: [
            function (PlatformTools_12_1) {
                PlatformTools_12 = PlatformTools_12_1;
            }
        ],
        execute: function () {
            /**
             * Performs logging of the events in TypeORM.
             * This version of logger logs everything into ormlogs.log file.
             */
            FileLogger = /** @class */ (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function FileLogger(options) {
                    this.options = options;
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Logs query and parameters used in it.
                 */
                FileLogger.prototype.logQuery = function (query, parameters, queryRunner) {
                    if (this.options === "all" || this.options === true || (this.options instanceof Array && this.options.indexOf("query") !== -1)) {
                        var sql = query + (parameters && parameters.length ? " -- PARAMETERS: " + this.stringifyParams(parameters) : "");
                        this.write("[QUERY]: " + sql);
                    }
                };
                /**
                 * Logs query that is failed.
                 */
                FileLogger.prototype.logQueryError = function (error, query, parameters, queryRunner) {
                    if (this.options === "all" || this.options === true || (this.options instanceof Array && this.options.indexOf("error") !== -1)) {
                        var sql = query + (parameters && parameters.length ? " -- PARAMETERS: " + this.stringifyParams(parameters) : "");
                        this.write([
                            "[FAILED QUERY]: " + sql,
                            "[QUERY ERROR]: " + error
                        ]);
                    }
                };
                /**
                 * Logs query that is slow.
                 */
                FileLogger.prototype.logQuerySlow = function (time, query, parameters, queryRunner) {
                    var sql = query + (parameters && parameters.length ? " -- PARAMETERS: " + this.stringifyParams(parameters) : "");
                    this.write("[SLOW QUERY: " + time + " ms]: " + sql);
                };
                /**
                 * Logs events from the schema build process.
                 */
                FileLogger.prototype.logSchemaBuild = function (message, queryRunner) {
                    if (this.options === "all" || (this.options instanceof Array && this.options.indexOf("schema") !== -1)) {
                        this.write(message);
                    }
                };
                /**
                 * Logs events from the migrations run process.
                 */
                FileLogger.prototype.logMigration = function (message, queryRunner) {
                    this.write(message);
                };
                /**
                 * Perform logging using given logger, or by default to the console.
                 * Log has its own level and message.
                 */
                FileLogger.prototype.log = function (level, message, queryRunner) {
                    switch (level) {
                        case "log":
                            if (this.options === "all" || (this.options instanceof Array && this.options.indexOf("log") !== -1))
                                this.write("[LOG]: " + message);
                            break;
                        case "info":
                            if (this.options === "all" || (this.options instanceof Array && this.options.indexOf("info") !== -1))
                                this.write("[INFO]: " + message);
                            break;
                        case "warn":
                            if (this.options === "all" || (this.options instanceof Array && this.options.indexOf("warn") !== -1))
                                this.write("[WARN]: " + message);
                            break;
                    }
                };
                // -------------------------------------------------------------------------
                // Protected Methods
                // -------------------------------------------------------------------------
                /**
                 * Writes given strings into the log file.
                 */
                FileLogger.prototype.write = function (strings) {
                    strings = strings instanceof Array ? strings : [strings];
                    var basePath = PlatformTools_12.PlatformTools.load("app-root-path").path;
                    strings = strings.map(function (str) { return "[" + new Date().toISOString() + "]" + str; });
                    PlatformTools_12.PlatformTools.appendFileSync(basePath + "/ormlogs.log", strings.join("\r\n") + "\r\n"); // todo: use async or implement promises?
                };
                /**
                 * Converts parameters to a string.
                 * Sometimes parameters can have circular objects and therefor we are handle this case too.
                 */
                FileLogger.prototype.stringifyParams = function (parameters) {
                    try {
                        return JSON.stringify(parameters);
                    }
                    catch (error) { // most probably circular objects in parameters
                        return parameters;
                    }
                };
                return FileLogger;
            }());
            exports_216("FileLogger", FileLogger);
        }
    };
});
System.register("typeorm/logger/DebugLogger", ["typeorm/platform/PlatformTools"], function (exports_217, context_217) {
    "use strict";
    var __moduleName = context_217 && context_217.id;
    var PlatformTools_13, DebugLogger;
    return {
        setters: [
            function (PlatformTools_13_1) {
                PlatformTools_13 = PlatformTools_13_1;
            }
        ],
        execute: function () {
            /**
             * Performs logging of the events in TypeORM via debug library.
             */
            DebugLogger = /** @class */ (function () {
                function DebugLogger() {
                    this.debug = PlatformTools_13.PlatformTools.load("debug");
                    this.debugQueryLog = this.debug("typeorm:query:log");
                    this.debugQueryError = this.debug("typeorm:query:error");
                    this.debugQuerySlow = this.debug("typeorm:query:slow");
                    this.debugSchemaBuild = this.debug("typeorm:schema");
                    this.debugMigration = this.debug("typeorm:migration");
                    this.debugLog = this.debug("typeorm:log");
                    this.debugInfo = this.debug("typeorm:info");
                    this.debugWarn = this.debug("typeorm:warn");
                }
                /**
                 * Logs query and parameters used in it.
                 */
                DebugLogger.prototype.logQuery = function (query, parameters, queryRunner) {
                    if (this.debugQueryLog.enabled) {
                        this.debugQueryLog(PlatformTools_13.PlatformTools.highlightSql(query) + ";");
                        if (parameters && parameters.length) {
                            this.debugQueryLog("parameters:", parameters);
                        }
                    }
                };
                /**
                 * Logs query that failed.
                 */
                DebugLogger.prototype.logQueryError = function (error, query, parameters, queryRunner) {
                    if (this.debugQueryError.enabled) {
                        this.debugQueryError(PlatformTools_13.PlatformTools.highlightSql(query) + ";");
                        if (parameters && parameters.length) {
                            this.debugQueryError("parameters:", parameters);
                        }
                        this.debugQueryError("error: ", error);
                    }
                };
                /**
                 * Logs query that is slow.
                 */
                DebugLogger.prototype.logQuerySlow = function (time, query, parameters, queryRunner) {
                    if (this.debugQuerySlow.enabled) {
                        this.debugQuerySlow(PlatformTools_13.PlatformTools.highlightSql(query) + ";");
                        if (parameters && parameters.length) {
                            this.debugQuerySlow("parameters:", parameters);
                        }
                        this.debugQuerySlow("execution time:", time);
                    }
                };
                /**
                 * Logs events from the schema build process.
                 */
                DebugLogger.prototype.logSchemaBuild = function (message, queryRunner) {
                    if (this.debugSchemaBuild.enabled) {
                        this.debugSchemaBuild(message);
                    }
                };
                /**
                 * Logs events from the migration run process.
                 */
                DebugLogger.prototype.logMigration = function (message, queryRunner) {
                    if (this.debugMigration.enabled) {
                        this.debugMigration(message);
                    }
                };
                /**
                 * Perform logging using given logger.
                 * Log has its own level and message.
                 */
                DebugLogger.prototype.log = function (level, message, queryRunner) {
                    switch (level) {
                        case "log":
                            if (this.debugLog.enabled) {
                                this.debugLog(message);
                            }
                            break;
                        case "info":
                            if (this.debugInfo.enabled) {
                                this.debugInfo(message);
                            }
                            break;
                        case "warn":
                            if (this.debugWarn.enabled) {
                                this.debugWarn(message);
                            }
                            break;
                    }
                };
                return DebugLogger;
            }());
            exports_217("DebugLogger", DebugLogger);
        }
    };
});
System.register("typeorm/logger/LoggerFactory", ["typeorm/logger/SimpleConsoleLogger", "typeorm/logger/AdvancedConsoleLogger", "typeorm/logger/FileLogger", "typeorm/logger/DebugLogger"], function (exports_218, context_218) {
    "use strict";
    var __moduleName = context_218 && context_218.id;
    var SimpleConsoleLogger_1, AdvancedConsoleLogger_1, FileLogger_1, DebugLogger_1, LoggerFactory;
    return {
        setters: [
            function (SimpleConsoleLogger_1_1) {
                SimpleConsoleLogger_1 = SimpleConsoleLogger_1_1;
            },
            function (AdvancedConsoleLogger_1_1) {
                AdvancedConsoleLogger_1 = AdvancedConsoleLogger_1_1;
            },
            function (FileLogger_1_1) {
                FileLogger_1 = FileLogger_1_1;
            },
            function (DebugLogger_1_1) {
                DebugLogger_1 = DebugLogger_1_1;
            }
        ],
        execute: function () {
            /**
             * Helps to create logger instances.
             */
            LoggerFactory = /** @class */ (function () {
                function LoggerFactory() {
                }
                /**
                 * Creates a new logger depend on a given connection's driver.
                 */
                LoggerFactory.prototype.create = function (logger, options) {
                    if (logger instanceof Object)
                        return logger;
                    if (logger) {
                        switch (logger) {
                            case "simple-console":
                                return new SimpleConsoleLogger_1.SimpleConsoleLogger(options);
                            case "file":
                                return new FileLogger_1.FileLogger(options);
                            case "advanced-console":
                                return new AdvancedConsoleLogger_1.AdvancedConsoleLogger(options);
                            case "debug":
                                return new DebugLogger_1.DebugLogger();
                        }
                    }
                    return new AdvancedConsoleLogger_1.AdvancedConsoleLogger(options);
                };
                return LoggerFactory;
            }());
            exports_218("LoggerFactory", LoggerFactory);
        }
    };
});
System.register("typeorm/cache/QueryResultCache", [], function (exports_219, context_219) {
    "use strict";
    var __moduleName = context_219 && context_219.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/cache/RedisQueryResultCache", ["typeorm/platform/PlatformTools"], function (exports_220, context_220) {
    "use strict";
    var __moduleName = context_220 && context_220.id;
    var PlatformTools_14, RedisQueryResultCache;
    return {
        setters: [
            function (PlatformTools_14_1) {
                PlatformTools_14 = PlatformTools_14_1;
            }
        ],
        execute: function () {
            /**
             * Caches query result into Redis database.
             */
            RedisQueryResultCache = /** @class */ (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function RedisQueryResultCache(connection) {
                    this.connection = connection;
                    this.redis = this.loadRedis();
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Creates a connection with given cache provider.
                 */
                RedisQueryResultCache.prototype.connect = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var cacheOptions;
                        return __generator(this, function (_a) {
                            cacheOptions = this.connection.options.cache;
                            if (cacheOptions && cacheOptions.options) {
                                this.client = this.redis.createClient(cacheOptions.options);
                            }
                            else {
                                this.client = this.redis.createClient();
                            }
                            return [2 /*return*/];
                        });
                    });
                };
                /**
                 * Creates a connection with given cache provider.
                 */
                RedisQueryResultCache.prototype.disconnect = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        return __generator(this, function (_a) {
                            return [2 /*return*/, new Promise(function (ok, fail) {
                                    _this.client.quit(function (err, result) {
                                        if (err)
                                            return fail(err);
                                        ok();
                                        _this.client = undefined;
                                    });
                                })];
                        });
                    });
                };
                /**
                 * Creates table for storing cache if it does not exist yet.
                 */
                RedisQueryResultCache.prototype.synchronize = function (queryRunner) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            return [2 /*return*/];
                        });
                    });
                };
                /**
                 * Caches given query result.
                 * Returns cache result if found.
                 * Returns undefined if result is not cached.
                 */
                RedisQueryResultCache.prototype.getFromCache = function (options, queryRunner) {
                    var _this = this;
                    return new Promise(function (ok, fail) {
                        if (options.identifier) {
                            _this.client.get(options.identifier, function (err, result) {
                                if (err)
                                    return fail(err);
                                ok(JSON.parse(result));
                            });
                        }
                        else if (options.query) {
                            _this.client.get(options.query, function (err, result) {
                                if (err)
                                    return fail(err);
                                ok(JSON.parse(result));
                            });
                        }
                        else {
                            ok(undefined);
                        }
                    });
                };
                /**
                 * Checks if cache is expired or not.
                 */
                RedisQueryResultCache.prototype.isExpired = function (savedCache) {
                    return (savedCache.time + savedCache.duration) < new Date().getTime();
                };
                /**
                 * Stores given query result in the cache.
                 */
                RedisQueryResultCache.prototype.storeInCache = function (options, savedCache, queryRunner) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        return __generator(this, function (_a) {
                            return [2 /*return*/, new Promise(function (ok, fail) {
                                    if (options.identifier) {
                                        _this.client.set(options.identifier, JSON.stringify(options), function (err, result) {
                                            if (err)
                                                return fail(err);
                                            ok();
                                        });
                                    }
                                    else if (options.query) {
                                        _this.client.set(options.query, JSON.stringify(options), function (err, result) {
                                            if (err)
                                                return fail(err);
                                            ok();
                                        });
                                    }
                                })];
                        });
                    });
                };
                /**
                 * Clears everything stored in the cache.
                 */
                RedisQueryResultCache.prototype.clear = function (queryRunner) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        return __generator(this, function (_a) {
                            return [2 /*return*/, new Promise(function (ok, fail) {
                                    _this.client.flushdb(function (err, result) {
                                        if (err)
                                            return fail(err);
                                        ok();
                                    });
                                })];
                        });
                    });
                };
                /**
                 * Removes all cached results by given identifiers from cache.
                 */
                RedisQueryResultCache.prototype.remove = function (identifiers, queryRunner) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, Promise.all(identifiers.map(function (identifier) {
                                        return _this.deleteKey(identifier);
                                    }))];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                // -------------------------------------------------------------------------
                // Protected Methods
                // -------------------------------------------------------------------------
                /**
                 * Removes a single key from redis database.
                 */
                RedisQueryResultCache.prototype.deleteKey = function (key) {
                    var _this = this;
                    return new Promise(function (ok, fail) {
                        _this.client.del(key, function (err, result) {
                            if (err)
                                return fail(err);
                            ok();
                        });
                    });
                };
                /**
                 * Loads redis dependency.
                 */
                RedisQueryResultCache.prototype.loadRedis = function () {
                    try {
                        return PlatformTools_14.PlatformTools.load("redis");
                    }
                    catch (e) {
                        throw new Error("Cannot use cache because redis is not installed. Please run \"npm i redis --save\".");
                    }
                };
                return RedisQueryResultCache;
            }());
            exports_220("RedisQueryResultCache", RedisQueryResultCache);
        }
    };
});
System.register("typeorm/cache/DbQueryResultCache", ["typeorm/schema-builder/schema/Table", "typeorm/schema-builder/schema/TableColumn", "typeorm/driver/sqlserver/SqlServerDriver", "typeorm/driver/sqlserver/MssqlParameter"], function (exports_221, context_221) {
    "use strict";
    var __moduleName = context_221 && context_221.id;
    var Table_9, TableColumn_9, SqlServerDriver_9, MssqlParameter_4, DbQueryResultCache;
    return {
        setters: [
            function (Table_9_1) {
                Table_9 = Table_9_1;
            },
            function (TableColumn_9_1) {
                TableColumn_9 = TableColumn_9_1;
            },
            function (SqlServerDriver_9_1) {
                SqlServerDriver_9 = SqlServerDriver_9_1;
            },
            function (MssqlParameter_4_1) {
                MssqlParameter_4 = MssqlParameter_4_1;
            }
        ],
        execute: function () {
            /**
             * Caches query result into current database, into separate table called "query-result-cache".
             */
            DbQueryResultCache = /** @class */ (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function DbQueryResultCache(connection) {
                    this.connection = connection;
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Creates a connection with given cache provider.
                 */
                DbQueryResultCache.prototype.connect = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            return [2 /*return*/];
                        });
                    });
                };
                /**
                 * Disconnects with given cache provider.
                 */
                DbQueryResultCache.prototype.disconnect = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            return [2 /*return*/];
                        });
                    });
                };
                /**
                 * Creates table for storing cache if it does not exist yet.
                 */
                DbQueryResultCache.prototype.synchronize = function (queryRunner) {
                    return __awaiter(this, void 0, void 0, function () {
                        var driver, tableExist;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    queryRunner = this.getQueryRunner(queryRunner);
                                    driver = this.connection.driver;
                                    return [4 /*yield*/, queryRunner.hasTable("query-result-cache")];
                                case 1:
                                    tableExist = _a.sent();
                                    if (tableExist)
                                        return [2 /*return*/];
                                    return [4 /*yield*/, queryRunner.createTable(new Table_9.Table("query-result-cache", [
                                            new TableColumn_9.TableColumn({
                                                name: "id",
                                                isNullable: true,
                                                isPrimary: true,
                                                type: driver.normalizeType({ type: driver.mappedDataTypes.cacheId }),
                                                generationStrategy: "increment",
                                                isGenerated: true
                                            }),
                                            new TableColumn_9.TableColumn({
                                                name: "identifier",
                                                type: driver.normalizeType({ type: driver.mappedDataTypes.cacheIdentifier }),
                                                isNullable: true
                                            }),
                                            new TableColumn_9.TableColumn({
                                                name: "time",
                                                type: driver.normalizeType({ type: driver.mappedDataTypes.cacheTime }),
                                                isPrimary: false,
                                                isNullable: false
                                            }),
                                            new TableColumn_9.TableColumn({
                                                name: "duration",
                                                type: driver.normalizeType({ type: driver.mappedDataTypes.cacheDuration }),
                                                isPrimary: false,
                                                isNullable: false
                                            }),
                                            new TableColumn_9.TableColumn({
                                                name: "query",
                                                type: driver.normalizeType({ type: driver.mappedDataTypes.cacheQuery }),
                                                isPrimary: false,
                                                isNullable: false
                                            }),
                                            new TableColumn_9.TableColumn({
                                                name: "result",
                                                type: driver.normalizeType({ type: driver.mappedDataTypes.cacheResult }),
                                                isNullable: false
                                            }),
                                        ]))];
                                case 2:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Caches given query result.
                 * Returns cache result if found.
                 * Returns undefined if result is not cached.
                 */
                DbQueryResultCache.prototype.getFromCache = function (options, queryRunner) {
                    queryRunner = this.getQueryRunner(queryRunner);
                    var qb = this.connection
                        .createQueryBuilder(queryRunner)
                        .select()
                        .from("query-result-cache", "cache");
                    if (options.identifier) {
                        return qb
                            .where(qb.escape("cache") + "." + qb.escape("identifier") + " = :identifier")
                            .setParameters({ identifier: this.connection.driver instanceof SqlServerDriver_9.SqlServerDriver ? new MssqlParameter_4.MssqlParameter(options.identifier, "nvarchar") : options.identifier })
                            .getRawOne();
                    }
                    else if (options.query) {
                        return qb
                            .where(qb.escape("cache") + "." + qb.escape("query") + " = :query")
                            .setParameters({ query: this.connection.driver instanceof SqlServerDriver_9.SqlServerDriver ? new MssqlParameter_4.MssqlParameter(options.query, "nvarchar") : options.query })
                            .getRawOne();
                    }
                    return Promise.resolve(undefined);
                };
                /**
                 * Checks if cache is expired or not.
                 */
                DbQueryResultCache.prototype.isExpired = function (savedCache) {
                    return ((typeof savedCache.time === "string" ? parseInt(savedCache.time) : savedCache.time) + savedCache.duration) < new Date().getTime();
                };
                /**
                 * Stores given query result in the cache.
                 */
                DbQueryResultCache.prototype.storeInCache = function (options, savedCache, queryRunner) {
                    return __awaiter(this, void 0, void 0, function () {
                        var insertedValues;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    queryRunner = this.getQueryRunner(queryRunner);
                                    insertedValues = options;
                                    if (this.connection.driver instanceof SqlServerDriver_9.SqlServerDriver) { // todo: bad abstraction, re-implement this part, probably better if we create an entity metadata for cache table
                                        insertedValues = {
                                            identifier: new MssqlParameter_4.MssqlParameter(options.identifier, "nvarchar"),
                                            time: new MssqlParameter_4.MssqlParameter(options.time, "bigint"),
                                            duration: new MssqlParameter_4.MssqlParameter(options.duration, "int"),
                                            query: new MssqlParameter_4.MssqlParameter(options.query, "nvarchar"),
                                            result: new MssqlParameter_4.MssqlParameter(options.result, "nvarchar"),
                                        };
                                    }
                                    if (!(savedCache && savedCache.identifier)) return [3 /*break*/, 2];
                                    return [4 /*yield*/, queryRunner.update("query-result-cache", insertedValues, { identifier: insertedValues.identifier })];
                                case 1:
                                    _a.sent();
                                    return [3 /*break*/, 6];
                                case 2:
                                    if (!(savedCache && savedCache.query)) return [3 /*break*/, 4];
                                    return [4 /*yield*/, queryRunner.update("query-result-cache", insertedValues, { query: insertedValues.query })];
                                case 3:
                                    _a.sent();
                                    return [3 /*break*/, 6];
                                case 4: // otherwise insert
                                return [4 /*yield*/, queryRunner.insert("query-result-cache", insertedValues)];
                                case 5:
                                    _a.sent();
                                    _a.label = 6;
                                case 6: return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Clears everything stored in the cache.
                 */
                DbQueryResultCache.prototype.clear = function (queryRunner) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            return [2 /*return*/, this.getQueryRunner(queryRunner).truncate("query-result-cache")];
                        });
                    });
                };
                /**
                 * Removes all cached results by given identifiers from cache.
                 */
                DbQueryResultCache.prototype.remove = function (identifiers, queryRunner) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, Promise.all(identifiers.map(function (identifier) {
                                        return _this.getQueryRunner(queryRunner).delete("query-result-cache", { identifier: identifier });
                                    }))];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                // -------------------------------------------------------------------------
                // Protected Methods
                // -------------------------------------------------------------------------
                /**
                 * Gets a query runner to work with.
                 */
                DbQueryResultCache.prototype.getQueryRunner = function (queryRunner) {
                    if (queryRunner)
                        return queryRunner;
                    return this.connection.createQueryRunner("master");
                };
                return DbQueryResultCache;
            }());
            exports_221("DbQueryResultCache", DbQueryResultCache);
        }
    };
});
System.register("typeorm/cache/QueryResultCacheFactory", ["typeorm/cache/RedisQueryResultCache", "typeorm/cache/DbQueryResultCache"], function (exports_222, context_222) {
    "use strict";
    var __moduleName = context_222 && context_222.id;
    var RedisQueryResultCache_1, DbQueryResultCache_1, QueryResultCacheFactory;
    return {
        setters: [
            function (RedisQueryResultCache_1_1) {
                RedisQueryResultCache_1 = RedisQueryResultCache_1_1;
            },
            function (DbQueryResultCache_1_1) {
                DbQueryResultCache_1 = DbQueryResultCache_1_1;
            }
        ],
        execute: function () {
            /**
             * Caches query result into Redis database.
             */
            QueryResultCacheFactory = /** @class */ (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function QueryResultCacheFactory(connection) {
                    this.connection = connection;
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Creates a new query result cache based on connection options.
                 */
                QueryResultCacheFactory.prototype.create = function () {
                    if (!this.connection.options.cache)
                        throw new Error("To use cache you need to enable it in connection options by setting cache: true or providing some caching options. Example: { host: ..., username: ..., cache: true }");
                    if (this.connection.options.cache.type === "redis")
                        return new RedisQueryResultCache_1.RedisQueryResultCache(this.connection);
                    return new DbQueryResultCache_1.DbQueryResultCache(this.connection);
                };
                return QueryResultCacheFactory;
            }());
            exports_222("QueryResultCacheFactory", QueryResultCacheFactory);
        }
    };
});
System.register("typeorm/connection/Connection", ["typeorm/naming-strategy/DefaultNamingStrategy", "typeorm/error/CannotExecuteNotConnectedError", "typeorm/error/CannotConnectAlreadyConnectedError", "typeorm/error/EntityMetadataNotFound", "typeorm/migration/MigrationExecutor", "typeorm/driver/mongodb/MongoDriver", "typeorm/entity-manager/MongoEntityManager", "typeorm/metadata-builder/EntityMetadataValidator", "typeorm/error/QueryRunnerProviderAlreadyReleasedError", "typeorm/entity-manager/EntityManagerFactory", "typeorm/driver/DriverFactory", "typeorm/connection/ConnectionMetadataBuilder", "typeorm/query-builder/SelectQueryBuilder", "typeorm/logger/LoggerFactory", "typeorm/cache/QueryResultCacheFactory", "typeorm/driver/sqlserver/SqlServerDriver", "typeorm/driver/mysql/MysqlDriver", "typeorm/util/PromiseUtils", "typeorm/entity-manager/SqljsEntityManager"], function (exports_223, context_223) {
    "use strict";
    var __moduleName = context_223 && context_223.id;
    var DefaultNamingStrategy_1, CannotExecuteNotConnectedError_1, CannotConnectAlreadyConnectedError_1, EntityMetadataNotFound_1, MigrationExecutor_1, MongoDriver_9, MongoEntityManager_2, EntityMetadataValidator_1, QueryRunnerProviderAlreadyReleasedError_2, EntityManagerFactory_1, DriverFactory_1, ConnectionMetadataBuilder_1, SelectQueryBuilder_1, LoggerFactory_1, QueryResultCacheFactory_1, SqlServerDriver_10, MysqlDriver_6, PromiseUtils_5, SqljsEntityManager_2, Connection;
    return {
        setters: [
            function (DefaultNamingStrategy_1_1) {
                DefaultNamingStrategy_1 = DefaultNamingStrategy_1_1;
            },
            function (CannotExecuteNotConnectedError_1_1) {
                CannotExecuteNotConnectedError_1 = CannotExecuteNotConnectedError_1_1;
            },
            function (CannotConnectAlreadyConnectedError_1_1) {
                CannotConnectAlreadyConnectedError_1 = CannotConnectAlreadyConnectedError_1_1;
            },
            function (EntityMetadataNotFound_1_1) {
                EntityMetadataNotFound_1 = EntityMetadataNotFound_1_1;
            },
            function (MigrationExecutor_1_1) {
                MigrationExecutor_1 = MigrationExecutor_1_1;
            },
            function (MongoDriver_9_1) {
                MongoDriver_9 = MongoDriver_9_1;
            },
            function (MongoEntityManager_2_1) {
                MongoEntityManager_2 = MongoEntityManager_2_1;
            },
            function (EntityMetadataValidator_1_1) {
                EntityMetadataValidator_1 = EntityMetadataValidator_1_1;
            },
            function (QueryRunnerProviderAlreadyReleasedError_2_1) {
                QueryRunnerProviderAlreadyReleasedError_2 = QueryRunnerProviderAlreadyReleasedError_2_1;
            },
            function (EntityManagerFactory_1_1) {
                EntityManagerFactory_1 = EntityManagerFactory_1_1;
            },
            function (DriverFactory_1_1) {
                DriverFactory_1 = DriverFactory_1_1;
            },
            function (ConnectionMetadataBuilder_1_1) {
                ConnectionMetadataBuilder_1 = ConnectionMetadataBuilder_1_1;
            },
            function (SelectQueryBuilder_1_1) {
                SelectQueryBuilder_1 = SelectQueryBuilder_1_1;
            },
            function (LoggerFactory_1_1) {
                LoggerFactory_1 = LoggerFactory_1_1;
            },
            function (QueryResultCacheFactory_1_1) {
                QueryResultCacheFactory_1 = QueryResultCacheFactory_1_1;
            },
            function (SqlServerDriver_10_1) {
                SqlServerDriver_10 = SqlServerDriver_10_1;
            },
            function (MysqlDriver_6_1) {
                MysqlDriver_6 = MysqlDriver_6_1;
            },
            function (PromiseUtils_5_1) {
                PromiseUtils_5 = PromiseUtils_5_1;
            },
            function (SqljsEntityManager_2_1) {
                SqljsEntityManager_2 = SqljsEntityManager_2_1;
            }
        ],
        execute: function () {
            /**
             * Connection is a single database ORM connection to a specific database.
             * Its not required to be a database connection, depend on database type it can create connection pool.
             * You can have multiple connections to multiple databases in your application.
             */
            Connection = /** @class */ (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function Connection(options) {
                    /**
                     * Indicates if connection is initialized or not.
                     */
                    this.isConnected = false;
                    /**
                     * Migration instances that are registered for this connection.
                     */
                    this.migrations = [];
                    /**
                     * Entity subscriber instances that are registered for this connection.
                     */
                    this.subscribers = [];
                    /**
                     * All entity metadatas that are registered for this connection.
                     */
                    this.entityMetadatas = [];
                    this.name = options.name || "default";
                    this.options = options;
                    this.logger = new LoggerFactory_1.LoggerFactory().create(this.options.logger, this.options.logging);
                    this.driver = new DriverFactory_1.DriverFactory().create(this);
                    this.manager = this.createEntityManager();
                    this.namingStrategy = options.namingStrategy || new DefaultNamingStrategy_1.DefaultNamingStrategy();
                    this.queryResultCache = options.cache ? new QueryResultCacheFactory_1.QueryResultCacheFactory(this).create() : undefined;
                }
                Object.defineProperty(Connection.prototype, "mongoManager", {
                    // -------------------------------------------------------------------------
                    // Public Accessors
                    // -------------------------------------------------------------------------
                    /**
                     * Gets the mongodb entity manager that allows to perform mongodb-specific repository operations
                     * with any entity in this connection.
                     *
                     * Available only in mongodb connections.
                     */
                    get: function () {
                        if (!(this.manager instanceof MongoEntityManager_2.MongoEntityManager))
                            throw new Error("MongoEntityManager is only available for MongoDB databases.");
                        return this.manager;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Connection.prototype, "sqljsManager", {
                    /**
                     * Gets a sql.js specific Entity Manager that allows to perform special load and save operations
                     *
                     * Available only in connection with the sqljs driver.
                     */
                    get: function () {
                        if (!(this.manager instanceof SqljsEntityManager_2.SqljsEntityManager))
                            throw new Error("SqljsEntityManager is only available for Sqljs databases.");
                        return this.manager;
                    },
                    enumerable: true,
                    configurable: true
                });
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Performs connection to the database.
                 * This method should be called once on application bootstrap.
                 * This method not necessarily creates database connection (depend on database type),
                 * but it also can setup a connection pool with database to use.
                 */
                Connection.prototype.connect = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var error_10;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isConnected)
                                        throw new CannotConnectAlreadyConnectedError_1.CannotConnectAlreadyConnectedError(this.name);
                                    // connect to the database via its driver
                                    return [4 /*yield*/, this.driver.connect()];
                                case 1:
                                    // connect to the database via its driver
                                    _a.sent();
                                    if (!this.queryResultCache) return [3 /*break*/, 3];
                                    return [4 /*yield*/, this.queryResultCache.connect()];
                                case 2:
                                    _a.sent();
                                    _a.label = 3;
                                case 3:
                                    // set connected status for the current connection
                                    Object.assign(this, { isConnected: true });
                                    _a.label = 4;
                                case 4:
                                    _a.trys.push([4, 12, , 14]);
                                    // build all metadatas registered in the current connection
                                    this.buildMetadatas();
                                    return [4 /*yield*/, this.driver.afterConnect()];
                                case 5:
                                    _a.sent();
                                    if (!this.options.dropSchema) return [3 /*break*/, 7];
                                    return [4 /*yield*/, this.dropDatabase()];
                                case 6:
                                    _a.sent();
                                    _a.label = 7;
                                case 7:
                                    if (!this.options.synchronize) return [3 /*break*/, 9];
                                    return [4 /*yield*/, this.synchronize()];
                                case 8:
                                    _a.sent();
                                    _a.label = 9;
                                case 9:
                                    if (!this.options.migrationsRun) return [3 /*break*/, 11];
                                    return [4 /*yield*/, this.runMigrations()];
                                case 10:
                                    _a.sent();
                                    _a.label = 11;
                                case 11: return [3 /*break*/, 14];
                                case 12:
                                    error_10 = _a.sent();
                                    // if for some reason build metadata fail (for example validation error during entity metadata check)
                                    // connection needs to be closed
                                    return [4 /*yield*/, this.close()];
                                case 13:
                                    // if for some reason build metadata fail (for example validation error during entity metadata check)
                                    // connection needs to be closed
                                    _a.sent();
                                    throw error_10;
                                case 14: return [2 /*return*/, this];
                            }
                        });
                    });
                };
                /**
                 * Closes connection with the database.
                 * Once connection is closed, you cannot use repositories or perform any operations except opening connection again.
                 */
                Connection.prototype.close = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (!this.isConnected)
                                        throw new CannotExecuteNotConnectedError_1.CannotExecuteNotConnectedError(this.name);
                                    return [4 /*yield*/, this.driver.disconnect()];
                                case 1:
                                    _a.sent();
                                    if (!this.queryResultCache) return [3 /*break*/, 3];
                                    return [4 /*yield*/, this.queryResultCache.disconnect()];
                                case 2:
                                    _a.sent();
                                    _a.label = 3;
                                case 3:
                                    Object.assign(this, { isConnected: false });
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Creates database schema for all entities registered in this connection.
                 * Can be used only after connection to the database is established.
                 *
                 * @param dropBeforeSync If set to true then it drops the database with all its tables and data
                 */
                Connection.prototype.synchronize = function (dropBeforeSync) {
                    if (dropBeforeSync === void 0) { dropBeforeSync = false; }
                    return __awaiter(this, void 0, void 0, function () {
                        var schemaBuilder;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (!this.isConnected)
                                        throw new CannotExecuteNotConnectedError_1.CannotExecuteNotConnectedError(this.name);
                                    if (!dropBeforeSync) return [3 /*break*/, 2];
                                    return [4 /*yield*/, this.dropDatabase()];
                                case 1:
                                    _a.sent();
                                    _a.label = 2;
                                case 2:
                                    schemaBuilder = this.driver.createSchemaBuilder();
                                    return [4 /*yield*/, schemaBuilder.build()];
                                case 3:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Drops the database and all its data.
                 * Be careful with this method on production since this method will erase all your database tables and their data.
                 * Can be used only after connection to the database is established.
                 */
                Connection.prototype.dropDatabase = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var queryRunner, schemas, databases_1;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.createQueryRunner("master")];
                                case 1:
                                    queryRunner = _a.sent();
                                    schemas = this.entityMetadatas
                                        .filter(function (metadata) { return metadata.schema; })
                                        .map(function (metadata) { return metadata.schema; });
                                    if (!(this.driver instanceof SqlServerDriver_10.SqlServerDriver || this.driver instanceof MysqlDriver_6.MysqlDriver)) return [3 /*break*/, 3];
                                    databases_1 = this.driver.database ? [this.driver.database] : [];
                                    this.entityMetadatas.forEach(function (metadata) {
                                        if (metadata.database && databases_1.indexOf(metadata.database) === -1)
                                            databases_1.push(metadata.database);
                                    });
                                    return [4 /*yield*/, PromiseUtils_5.PromiseUtils.runInSequence(databases_1, function (database) { return queryRunner.clearDatabase(schemas, database); })];
                                case 2:
                                    _a.sent();
                                    return [3 /*break*/, 5];
                                case 3: return [4 /*yield*/, queryRunner.clearDatabase(schemas)];
                                case 4:
                                    _a.sent();
                                    _a.label = 5;
                                case 5: return [4 /*yield*/, queryRunner.release()];
                                case 6:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Runs all pending migrations.
                 * Can be used only after connection to the database is established.
                 */
                Connection.prototype.runMigrations = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var migrationExecutor;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (!this.isConnected)
                                        throw new CannotExecuteNotConnectedError_1.CannotExecuteNotConnectedError(this.name);
                                    migrationExecutor = new MigrationExecutor_1.MigrationExecutor(this);
                                    return [4 /*yield*/, migrationExecutor.executePendingMigrations()];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Reverts last executed migration.
                 * Can be used only after connection to the database is established.
                 */
                Connection.prototype.undoLastMigration = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var migrationExecutor;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (!this.isConnected)
                                        throw new CannotExecuteNotConnectedError_1.CannotExecuteNotConnectedError(this.name);
                                    migrationExecutor = new MigrationExecutor_1.MigrationExecutor(this);
                                    return [4 /*yield*/, migrationExecutor.undoLastMigration()];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Checks if entity metadata exist for the given entity class, target name or table name.
                 */
                Connection.prototype.hasMetadata = function (target) {
                    return !!this.findMetadata(target);
                };
                /**
                 * Gets entity metadata for the given entity class or schema name.
                 */
                Connection.prototype.getMetadata = function (target) {
                    var metadata = this.findMetadata(target);
                    if (!metadata)
                        throw new EntityMetadataNotFound_1.EntityMetadataNotFound(target);
                    return metadata;
                };
                /**
                 * Gets repository for the given entity.
                 */
                Connection.prototype.getRepository = function (target) {
                    return this.manager.getRepository(target);
                };
                /**
                 * Gets tree repository for the given entity class or name.
                 * Only tree-type entities can have a TreeRepository, like ones decorated with @ClosureEntity decorator.
                 */
                Connection.prototype.getTreeRepository = function (target) {
                    return this.manager.getTreeRepository(target);
                };
                /**
                 * Gets mongodb-specific repository for the given entity class or name.
                 * Works only if connection is mongodb-specific.
                 */
                Connection.prototype.getMongoRepository = function (target) {
                    if (!(this.driver instanceof MongoDriver_9.MongoDriver))
                        throw new Error("You can use getMongoRepository only for MongoDB connections.");
                    return this.manager.getRepository(target);
                };
                /**
                 * Gets custom entity repository marked with @EntityRepository decorator.
                 */
                Connection.prototype.getCustomRepository = function (customRepository) {
                    return this.manager.getCustomRepository(customRepository);
                };
                /**
                 * Wraps given function execution (and all operations made there) into a transaction.
                 * All database operations must be executed using provided entity manager.
                 */
                Connection.prototype.transaction = function (runInTransaction) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            return [2 /*return*/, this.manager.transaction(runInTransaction)];
                        });
                    });
                };
                /**
                 * Executes raw SQL query and returns raw database results.
                 */
                Connection.prototype.query = function (query, parameters, queryRunner) {
                    return __awaiter(this, void 0, void 0, function () {
                        var usedQueryRunner;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this instanceof MongoEntityManager_2.MongoEntityManager)
                                        throw new Error("Queries aren't supported by MongoDB.");
                                    if (queryRunner && queryRunner.isReleased)
                                        throw new QueryRunnerProviderAlreadyReleasedError_2.QueryRunnerProviderAlreadyReleasedError();
                                    usedQueryRunner = queryRunner || this.createQueryRunner("master");
                                    _a.label = 1;
                                case 1:
                                    _a.trys.push([1, , 3, 6]);
                                    return [4 /*yield*/, usedQueryRunner.query(query, parameters)];
                                case 2: return [2 /*return*/, _a.sent()]; // await is needed here because we are using finally
                                case 3:
                                    if (!!queryRunner) return [3 /*break*/, 5];
                                    return [4 /*yield*/, usedQueryRunner.release()];
                                case 4:
                                    _a.sent();
                                    _a.label = 5;
                                case 5: return [7 /*endfinally*/];
                                case 6: return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Creates a new query builder that can be used to build a sql query.
                 */
                Connection.prototype.createQueryBuilder = function (entityOrRunner, alias, queryRunner) {
                    if (this instanceof MongoEntityManager_2.MongoEntityManager)
                        throw new Error("Query Builder is not supported by MongoDB.");
                    if (alias) {
                        var metadata = this.getMetadata(entityOrRunner);
                        return new SelectQueryBuilder_1.SelectQueryBuilder(this, queryRunner)
                            .select(alias)
                            .from(metadata.target, alias);
                    }
                    else {
                        return new SelectQueryBuilder_1.SelectQueryBuilder(this, entityOrRunner);
                    }
                };
                /**
                 * Creates a query runner used for perform queries on a single database connection.
                 * Using query runners you can control your queries to execute using single database connection and
                 * manually control your database transaction.
                 *
                 * Mode is used in replication mode and indicates whatever you want to connect
                 * to master database or any of slave databases.
                 * If you perform writes you must use master database,
                 * if you perform reads you can use slave databases.
                 */
                Connection.prototype.createQueryRunner = function (mode) {
                    if (mode === void 0) { mode = "master"; }
                    var queryRunner = this.driver.createQueryRunner(mode);
                    var manager = this.createEntityManager(queryRunner);
                    Object.assign(queryRunner, { manager: manager });
                    return queryRunner;
                };
                /**
                 * Gets entity metadata of the junction table (many-to-many table).
                 */
                Connection.prototype.getManyToManyMetadata = function (entityTarget, relationPropertyPath) {
                    var relationMetadata = this.getMetadata(entityTarget).findRelationWithPropertyPath(relationPropertyPath);
                    if (!relationMetadata)
                        throw new Error("Relation \"" + relationPropertyPath + "\" was not found in " + entityTarget + " entity.");
                    if (!relationMetadata.isManyToMany)
                        throw new Error("Relation \"" + entityTarget + "#" + relationPropertyPath + "\" does not have a many-to-many relationship." +
                            "You can use this method only on many-to-many relations.");
                    return relationMetadata.junctionEntityMetadata;
                };
                /**
                 * Creates an Entity Manager for the current connection with the help of the EntityManagerFactory.
                 */
                Connection.prototype.createEntityManager = function (queryRunner) {
                    return new EntityManagerFactory_1.EntityManagerFactory().create(this, queryRunner);
                };
                // -------------------------------------------------------------------------
                // Protected Methods
                // -------------------------------------------------------------------------
                /**
                 * Finds exist entity metadata by the given entity class, target name or table name.
                 */
                Connection.prototype.findMetadata = function (target) {
                    return this.entityMetadatas.find(function (metadata) {
                        if (metadata.target === target)
                            return true;
                        if (typeof target === "string") {
                            if (target.indexOf(".") !== -1) {
                                return metadata.tablePath === target;
                            }
                            else {
                                return metadata.name === target || metadata.tableName === target;
                            }
                        }
                        return false;
                    });
                };
                /**
                 * Builds metadatas for all registered classes inside this connection.
                 */
                Connection.prototype.buildMetadatas = function () {
                    var connectionMetadataBuilder = new ConnectionMetadataBuilder_1.ConnectionMetadataBuilder(this);
                    var entityMetadataValidator = new EntityMetadataValidator_1.EntityMetadataValidator();
                    // create subscribers instances if they are not disallowed from high-level (for example they can disallowed from migrations run process)
                    var subscribers = connectionMetadataBuilder.buildSubscribers(this.options.subscribers || []);
                    Object.assign(this, { subscribers: subscribers });
                    // build entity metadatas
                    var entityMetadatas = connectionMetadataBuilder.buildEntityMetadatas(this.options.entities || [], this.options.entitySchemas || []);
                    Object.assign(this, { entityMetadatas: entityMetadatas });
                    // create migration instances
                    var migrations = connectionMetadataBuilder.buildMigrations(this.options.migrations || []);
                    Object.assign(this, { migrations: migrations });
                    // validate all created entity metadatas to make sure user created entities are valid and correct
                    entityMetadataValidator.validateMany(this.entityMetadatas, this.driver);
                };
                return Connection;
            }());
            exports_223("Connection", Connection);
        }
    };
});
System.register("typeorm/error/ConnectionNotFoundError", [], function (exports_224, context_224) {
    "use strict";
    var __moduleName = context_224 && context_224.id;
    var ConnectionNotFoundError;
    return {
        setters: [],
        execute: function () {
            /**
             * Thrown when consumer tries to get connection that does not exist.
             */
            ConnectionNotFoundError = /** @class */ (function (_super) {
                __extends(ConnectionNotFoundError, _super);
                function ConnectionNotFoundError(name) {
                    var _this = _super.call(this) || this;
                    _this.name = "ConnectionNotFoundError";
                    _this.message = "Connection \"" + name + "\" was not found.";
                    _this.stack = new Error().stack;
                    return _this;
                }
                return ConnectionNotFoundError;
            }(Error));
            exports_224("ConnectionNotFoundError", ConnectionNotFoundError);
        }
    };
});
System.register("typeorm/error/AlreadyHasActiveConnectionError", [], function (exports_225, context_225) {
    "use strict";
    var __moduleName = context_225 && context_225.id;
    var AlreadyHasActiveConnectionError;
    return {
        setters: [],
        execute: function () {
            /**
             * Thrown when consumer tries to recreate connection with the same name, but previous connection was not closed yet.
             */
            AlreadyHasActiveConnectionError = /** @class */ (function (_super) {
                __extends(AlreadyHasActiveConnectionError, _super);
                function AlreadyHasActiveConnectionError(connectionName) {
                    var _this = _super.call(this) || this;
                    _this.name = "AlreadyHasActiveConnectionError";
                    _this.message = "Cannot create a new connection named \"" + connectionName + "\", because connection with such name " +
                        "already exist and it now has an active connection session.";
                    _this.stack = new Error().stack;
                    return _this;
                }
                return AlreadyHasActiveConnectionError;
            }(Error));
            exports_225("AlreadyHasActiveConnectionError", AlreadyHasActiveConnectionError);
        }
    };
});
System.register("typeorm/connection/ConnectionManager", ["typeorm/connection/Connection", "typeorm/error/ConnectionNotFoundError", "typeorm/error/AlreadyHasActiveConnectionError"], function (exports_226, context_226) {
    "use strict";
    var __moduleName = context_226 && context_226.id;
    var Connection_1, ConnectionNotFoundError_1, AlreadyHasActiveConnectionError_1, ConnectionManager;
    return {
        setters: [
            function (Connection_1_1) {
                Connection_1 = Connection_1_1;
            },
            function (ConnectionNotFoundError_1_1) {
                ConnectionNotFoundError_1 = ConnectionNotFoundError_1_1;
            },
            function (AlreadyHasActiveConnectionError_1_1) {
                AlreadyHasActiveConnectionError_1 = AlreadyHasActiveConnectionError_1_1;
            }
        ],
        execute: function () {
            /**
             * ConnectionManager is used to store and manage multiple orm connections.
             * It also provides useful factory methods to simplify connection creation.
             */
            ConnectionManager = /** @class */ (function () {
                function ConnectionManager() {
                    // -------------------------------------------------------------------------
                    // Protected Properties
                    // -------------------------------------------------------------------------
                    /**
                     * List of connections registered in this connection manager.
                     */
                    this.connections = [];
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Checks if connection with the given name exist in the manager.
                 */
                ConnectionManager.prototype.has = function (name) {
                    return !!this.connections.find(function (connection) { return connection.name === name; });
                };
                /**
                 * Gets registered connection with the given name.
                 * If connection name is not given then it will get a default connection.
                 * Throws error if connection with the given name was not found.
                 */
                ConnectionManager.prototype.get = function (name) {
                    if (name === void 0) { name = "default"; }
                    var connection = this.connections.find(function (connection) { return connection.name === name; });
                    if (!connection)
                        throw new ConnectionNotFoundError_1.ConnectionNotFoundError(name);
                    return connection;
                };
                /**
                 * Creates a new connection based on the given connection options and registers it in the manager.
                 * Connection won't be established, you'll need to manually call connect method to establish connection.
                 */
                ConnectionManager.prototype.create = function (options) {
                    // check if such connection is already registered
                    var existConnection = this.connections.find(function (connection) { return connection.name === (options.name || "default"); });
                    if (existConnection) {
                        // if connection is registered and its not closed then throw an error
                        if (existConnection.isConnected)
                            throw new AlreadyHasActiveConnectionError_1.AlreadyHasActiveConnectionError(options.name || "default");
                        // if its registered but closed then simply remove it from the manager
                        this.connections.splice(this.connections.indexOf(existConnection), 1);
                    }
                    // create a new connection
                    var connection = new Connection_1.Connection(options);
                    this.connections.push(connection);
                    return connection;
                };
                return ConnectionManager;
            }());
            exports_226("ConnectionManager", ConnectionManager);
        }
    };
});
System.register("typeorm/connection/options-reader/ConnectionOptionsEnvReader", ["typeorm/platform/PlatformTools", "typeorm/util/OrmUtils"], function (exports_227, context_227) {
    "use strict";
    var __moduleName = context_227 && context_227.id;
    var PlatformTools_15, OrmUtils_14, ConnectionOptionsEnvReader;
    return {
        setters: [
            function (PlatformTools_15_1) {
                PlatformTools_15 = PlatformTools_15_1;
            },
            function (OrmUtils_14_1) {
                OrmUtils_14 = OrmUtils_14_1;
            }
        ],
        execute: function () {
            /**
             * Reads connection options from environment variables.
             * Environment variables can have only a single connection.
             * Its strongly required to define TYPEORM_CONNECTION env variable.
             */
            ConnectionOptionsEnvReader = /** @class */ (function () {
                function ConnectionOptionsEnvReader() {
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Reads connection options from environment variables.
                 */
                ConnectionOptionsEnvReader.prototype.read = function () {
                    return {
                        type: PlatformTools_15.PlatformTools.getEnvVariable("TYPEORM_CONNECTION"),
                        url: PlatformTools_15.PlatformTools.getEnvVariable("TYPEORM_URL"),
                        host: PlatformTools_15.PlatformTools.getEnvVariable("TYPEORM_HOST"),
                        port: PlatformTools_15.PlatformTools.getEnvVariable("TYPEORM_PORT"),
                        username: PlatformTools_15.PlatformTools.getEnvVariable("TYPEORM_USERNAME"),
                        password: PlatformTools_15.PlatformTools.getEnvVariable("TYPEORM_PASSWORD"),
                        database: PlatformTools_15.PlatformTools.getEnvVariable("TYPEORM_DATABASE"),
                        sid: PlatformTools_15.PlatformTools.getEnvVariable("TYPEORM_SID"),
                        schema: PlatformTools_15.PlatformTools.getEnvVariable("TYPEORM_SCHEMA"),
                        extra: PlatformTools_15.PlatformTools.getEnvVariable("TYPEORM_DRIVER_EXTRA") ? JSON.parse(PlatformTools_15.PlatformTools.getEnvVariable("TYPEORM_DRIVER_EXTRA")) : undefined,
                        synchronize: OrmUtils_14.OrmUtils.toBoolean(PlatformTools_15.PlatformTools.getEnvVariable("TYPEORM_SYNCHRONIZE")),
                        dropSchema: OrmUtils_14.OrmUtils.toBoolean(PlatformTools_15.PlatformTools.getEnvVariable("TYPEORM_DROP_SCHEMA")),
                        migrationsRun: OrmUtils_14.OrmUtils.toBoolean(PlatformTools_15.PlatformTools.getEnvVariable("TYPEORM_MIGRATIONS_RUN")),
                        entities: this.stringToArray(PlatformTools_15.PlatformTools.getEnvVariable("TYPEORM_ENTITIES")),
                        migrations: this.stringToArray(PlatformTools_15.PlatformTools.getEnvVariable("TYPEORM_MIGRATIONS")),
                        subscribers: this.stringToArray(PlatformTools_15.PlatformTools.getEnvVariable("TYPEORM_SUBSCRIBERS")),
                        entitySchemas: this.stringToArray(PlatformTools_15.PlatformTools.getEnvVariable("TYPEORM_ENTITY_SCHEMAS")),
                        logging: this.transformLogging(PlatformTools_15.PlatformTools.getEnvVariable("TYPEORM_LOGGING")),
                        logger: PlatformTools_15.PlatformTools.getEnvVariable("TYPEORM_LOGGER"),
                        entityPrefix: PlatformTools_15.PlatformTools.getEnvVariable("TYPEORM_ENTITY_PREFIX"),
                        maxQueryExecutionTime: PlatformTools_15.PlatformTools.getEnvVariable("TYPEORM_MAX_QUERY_EXECUTION_TIME"),
                        cli: {
                            entitiesDir: PlatformTools_15.PlatformTools.getEnvVariable("TYPEORM_ENTITIES_DIR"),
                            migrationsDir: PlatformTools_15.PlatformTools.getEnvVariable("TYPEORM_MIGRATIONS_DIR"),
                            subscribersDir: PlatformTools_15.PlatformTools.getEnvVariable("TYPEORM_SUBSCRIBERS_DIR"),
                        }
                    };
                };
                // -------------------------------------------------------------------------
                // Protected Methods
                // -------------------------------------------------------------------------
                /**
                 * Transforms logging string into real logging value connection requires.
                 */
                ConnectionOptionsEnvReader.prototype.transformLogging = function (logging) {
                    if (logging === "true" || logging === "TRUE" || logging === "1")
                        return true;
                    if (logging === "all")
                        return "all";
                    return this.stringToArray(logging);
                };
                /**
                 * Converts a string which contains multiple elements split by comma into a string array of strings.
                 */
                ConnectionOptionsEnvReader.prototype.stringToArray = function (variable) {
                    if (!variable)
                        return [];
                    return variable.split(",").map(function (str) { return str.trim(); });
                };
                return ConnectionOptionsEnvReader;
            }());
            exports_227("ConnectionOptionsEnvReader", ConnectionOptionsEnvReader);
        }
    };
});
System.register("typeorm/connection/options-reader/ConnectionOptionsYmlReader", ["typeorm/platform/PlatformTools"], function (exports_228, context_228) {
    "use strict";
    var __moduleName = context_228 && context_228.id;
    var PlatformTools_16, ConnectionOptionsYmlReader;
    return {
        setters: [
            function (PlatformTools_16_1) {
                PlatformTools_16 = PlatformTools_16_1;
            }
        ],
        execute: function () {
            /**
             * Reads connection options defined in the yml file.
             */
            ConnectionOptionsYmlReader = /** @class */ (function () {
                function ConnectionOptionsYmlReader() {
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Reads connection options from given yml file.
                 */
                ConnectionOptionsYmlReader.prototype.read = function (path) {
                    var ymlParser = PlatformTools_16.PlatformTools.load("js-yaml");
                    var config = ymlParser.safeLoad(PlatformTools_16.PlatformTools.readFileSync(path));
                    return Object.keys(config).map(function (connectionName) {
                        return Object.assign({ name: connectionName }, config[connectionName]);
                    });
                };
                return ConnectionOptionsYmlReader;
            }());
            exports_228("ConnectionOptionsYmlReader", ConnectionOptionsYmlReader);
        }
    };
});
System.register("typeorm/connection/options-reader/ConnectionOptionsXmlReader", ["typeorm/platform/PlatformTools"], function (exports_229, context_229) {
    "use strict";
    var __moduleName = context_229 && context_229.id;
    var PlatformTools_17, ConnectionOptionsXmlReader;
    return {
        setters: [
            function (PlatformTools_17_1) {
                PlatformTools_17 = PlatformTools_17_1;
            }
        ],
        execute: function () {
            /**
             * Reads connection options defined in the xml file.
             */
            ConnectionOptionsXmlReader = /** @class */ (function () {
                function ConnectionOptionsXmlReader() {
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Reads connection options from given xml file.
                 */
                ConnectionOptionsXmlReader.prototype.read = function (path) {
                    return __awaiter(this, void 0, void 0, function () {
                        var xml;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.readXml(path)];
                                case 1:
                                    xml = _a.sent();
                                    return [2 /*return*/, xml.connection.map(function (connection) {
                                            return {
                                                name: connection.$.name,
                                                type: connection.$.type,
                                                url: connection.url ? connection.url[0] : undefined,
                                                host: connection.host ? connection.host[0] : undefined,
                                                port: connection.port && connection.port[0] ? parseInt(connection.port[0]) : undefined,
                                                username: connection.username ? connection.username[0] : undefined,
                                                password: connection.password ? connection.password[0] : undefined,
                                                database: connection.database ? connection.database[0] : undefined,
                                                sid: connection.sid ? connection.sid[0] : undefined,
                                                extra: connection.extra ? connection.extra[0] : undefined,
                                                synchronize: connection.synchronize ? connection.synchronize[0] : undefined,
                                                entities: connection.entities ? connection.entities[0].entity : [],
                                                subscribers: connection.subscribers ? connection.subscribers[0].entity : [],
                                                entitySchemas: connection.entitySchemas ? connection.entitySchemas[0].entity : [],
                                                logging: connection.logging[0] ? connection.logging[0].split(",") : undefined,
                                            };
                                        })];
                            }
                        });
                    });
                };
                // -------------------------------------------------------------------------
                // Protected Methods
                // -------------------------------------------------------------------------
                /**
                 * Reads xml file contents and returns them in a promise.
                 */
                ConnectionOptionsXmlReader.prototype.readXml = function (path) {
                    var xmlParser = PlatformTools_17.PlatformTools.load("xml2js").parseString;
                    var xmlOptions = { trim: true, explicitRoot: false };
                    return new Promise(function (ok, fail) {
                        xmlParser(PlatformTools_17.PlatformTools.readFileSync(path), xmlOptions, function (err, result) { return err ? fail(err) : ok(result); });
                    });
                };
                return ConnectionOptionsXmlReader;
            }());
            exports_229("ConnectionOptionsXmlReader", ConnectionOptionsXmlReader);
        }
    };
});
System.register("typeorm/connection/ConnectionOptionsReader", ["typeorm/platform/PlatformTools", "typeorm/connection/options-reader/ConnectionOptionsEnvReader", "typeorm/connection/options-reader/ConnectionOptionsYmlReader", "typeorm/connection/options-reader/ConnectionOptionsXmlReader"], function (exports_230, context_230) {
    "use strict";
    var __moduleName = context_230 && context_230.id;
    var PlatformTools_18, ConnectionOptionsEnvReader_1, ConnectionOptionsYmlReader_1, ConnectionOptionsXmlReader_1, ConnectionOptionsReader;
    return {
        setters: [
            function (PlatformTools_18_1) {
                PlatformTools_18 = PlatformTools_18_1;
            },
            function (ConnectionOptionsEnvReader_1_1) {
                ConnectionOptionsEnvReader_1 = ConnectionOptionsEnvReader_1_1;
            },
            function (ConnectionOptionsYmlReader_1_1) {
                ConnectionOptionsYmlReader_1 = ConnectionOptionsYmlReader_1_1;
            },
            function (ConnectionOptionsXmlReader_1_1) {
                ConnectionOptionsXmlReader_1 = ConnectionOptionsXmlReader_1_1;
            }
        ],
        execute: function () {
            /**
             * Reads connection options from the ormconfig.
             * Can read from multiple file extensions including env, json, js, xml and yml.
             */
            ConnectionOptionsReader = /** @class */ (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function ConnectionOptionsReader(options) {
                    this.options = options;
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Returns all connection options read from the ormconfig.
                 */
                ConnectionOptionsReader.prototype.all = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            return [2 /*return*/, this.load()];
                        });
                    });
                };
                /**
                 * Gets a connection with a given name read from ormconfig.
                 * If connection with such name would not be found then it throw error.
                 */
                ConnectionOptionsReader.prototype.get = function (name) {
                    return __awaiter(this, void 0, void 0, function () {
                        var allOptions, targetOptions;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.all()];
                                case 1:
                                    allOptions = _a.sent();
                                    targetOptions = allOptions.find(function (options) { return options.name === name || (name === "default" && !options.name); });
                                    if (!targetOptions)
                                        throw new Error("Cannot find connection " + name + " because its not defined in any orm configuration files.");
                                    return [2 /*return*/, targetOptions];
                            }
                        });
                    });
                };
                // -------------------------------------------------------------------------
                // Protected Methods
                // -------------------------------------------------------------------------
                /**
                 * Loads all connection options from a configuration file.
                 *
                 * todo: get in count NODE_ENV somehow
                 */
                ConnectionOptionsReader.prototype.load = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var foundFileFormat, dotenv, dotenv, connectionOptions;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    foundFileFormat = ["env", "js", "json", "yml", "yaml", "xml"].find(function (format) {
                                        return PlatformTools_18.PlatformTools.fileExist(_this.baseFilePath + "." + format);
                                    });
                                    // if .env file found then load all its variables into process.env using dotenv package
                                    if (foundFileFormat === "env") {
                                        dotenv = PlatformTools_18.PlatformTools.load("dotenv");
                                        dotenv.config({ path: this.baseFilePath + ".env" });
                                    }
                                    else if (PlatformTools_18.PlatformTools.fileExist(".env")) {
                                        dotenv = PlatformTools_18.PlatformTools.load("dotenv");
                                        dotenv.config({ path: ".env" });
                                    }
                                    if (!PlatformTools_18.PlatformTools.getEnvVariable("TYPEORM_CONNECTION")) return [3 /*break*/, 1];
                                    connectionOptions = new ConnectionOptionsEnvReader_1.ConnectionOptionsEnvReader().read();
                                    return [3 /*break*/, 8];
                                case 1:
                                    if (!(foundFileFormat === "js")) return [3 /*break*/, 2];
                                    connectionOptions = PlatformTools_18.PlatformTools.load(this.baseFilePath + ".js");
                                    return [3 /*break*/, 8];
                                case 2:
                                    if (!(foundFileFormat === "json")) return [3 /*break*/, 3];
                                    connectionOptions = PlatformTools_18.PlatformTools.load(this.baseFilePath + ".json");
                                    return [3 /*break*/, 8];
                                case 3:
                                    if (!(foundFileFormat === "yml")) return [3 /*break*/, 4];
                                    connectionOptions = new ConnectionOptionsYmlReader_1.ConnectionOptionsYmlReader().read(this.baseFilePath + ".yml");
                                    return [3 /*break*/, 8];
                                case 4:
                                    if (!(foundFileFormat === "yaml")) return [3 /*break*/, 5];
                                    connectionOptions = new ConnectionOptionsYmlReader_1.ConnectionOptionsYmlReader().read(this.baseFilePath + ".yaml");
                                    return [3 /*break*/, 8];
                                case 5:
                                    if (!(foundFileFormat === "xml")) return [3 /*break*/, 7];
                                    return [4 /*yield*/, new ConnectionOptionsXmlReader_1.ConnectionOptionsXmlReader().read(this.baseFilePath + ".xml")];
                                case 6:
                                    connectionOptions = _a.sent();
                                    return [3 /*break*/, 8];
                                case 7: throw new Error("No connection options were found in any of configurations file.");
                                case 8: 
                                // normalize and return connection options
                                return [2 /*return*/, this.normalizeConnectionOptions(connectionOptions)];
                            }
                        });
                    });
                };
                /**
                 * Normalize connection options.
                 */
                ConnectionOptionsReader.prototype.normalizeConnectionOptions = function (connectionOptions) {
                    var _this = this;
                    if (!(connectionOptions instanceof Array))
                        connectionOptions = [connectionOptions];
                    connectionOptions.forEach(function (options) {
                        if (options.entities) {
                            var entities = options.entities.map(function (entity) {
                                if (typeof entity === "string" && entity.substr(0, 1) !== "/")
                                    return _this.baseFilePath + "/" + entity;
                                return entity;
                            });
                            Object.assign(connectionOptions, { entities: entities });
                        }
                        if (options.subscribers) {
                            var subscribers = options.subscribers.map(function (subscriber) {
                                if (typeof subscriber === "string" && subscriber.substr(0, 1) !== "/")
                                    return _this.baseFilePath + "/" + subscriber;
                                return subscriber;
                            });
                            Object.assign(connectionOptions, { subscribers: subscribers });
                        }
                        if (options.migrations) {
                            var migrations = options.migrations.map(function (migration) {
                                if (typeof migration === "string" && migration.substr(0, 1) !== "/")
                                    return _this.baseFilePath + "/" + migration;
                                return migration;
                            });
                            Object.assign(connectionOptions, { migrations: migrations });
                        }
                        // make database path file in sqlite relative to package.json
                        if (options.type === "sqlite") {
                            if (typeof options.database === "string" && options.database.substr(0, 1) !== "/" && options.database !== ":memory:") {
                                Object.assign(options, {
                                    database: _this.baseDirectory + "/" + options.database
                                });
                            }
                        }
                    });
                    return connectionOptions;
                };
                Object.defineProperty(ConnectionOptionsReader.prototype, "baseFilePath", {
                    /**
                     * Gets directory where configuration file should be located and configuration file name without extension.
                     */
                    get: function () {
                        return this.baseDirectory + "/" + this.baseConfigName;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ConnectionOptionsReader.prototype, "baseDirectory", {
                    /**
                     * Gets directory where configuration file should be located.
                     */
                    get: function () {
                        if (this.options && this.options.root)
                            return this.options.root;
                        return PlatformTools_18.PlatformTools.load("app-root-path").path;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ConnectionOptionsReader.prototype, "baseConfigName", {
                    /**
                     * Gets configuration file name.
                     */
                    get: function () {
                        if (this.options && this.options.configName)
                            return this.options.configName;
                        return "ormconfig";
                    },
                    enumerable: true,
                    configurable: true
                });
                return ConnectionOptionsReader;
            }());
            exports_230("ConnectionOptionsReader", ConnectionOptionsReader);
        }
    };
});
System.register("typeorm/decorator/options/ColumnCommonOptions", [], function (exports_231, context_231) {
    "use strict";
    var __moduleName = context_231 && context_231.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/options/ColumnWithLengthOptions", [], function (exports_232, context_232) {
    "use strict";
    var __moduleName = context_232 && context_232.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/options/ColumnNumericOptions", [], function (exports_233, context_233) {
    "use strict";
    var __moduleName = context_233 && context_233.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/options/ColumnEnumOptions", [], function (exports_234, context_234) {
    "use strict";
    var __moduleName = context_234 && context_234.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/options/ColumnEmbeddedOptions", [], function (exports_235, context_235) {
    "use strict";
    var __moduleName = context_235 && context_235.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/columns/Column", ["typeorm/index"], function (exports_236, context_236) {
    "use strict";
    var __moduleName = context_236 && context_236.id;
    /**
     * Column decorator is used to mark a specific class property as a table column.
     * Only properties decorated with this decorator will be persisted to the database when entity be saved.
     */
    function Column(typeOrOptions, options) {
        var type;
        if (typeof typeOrOptions === "string" || typeOrOptions instanceof Function) {
            type = typeOrOptions;
        }
        else if (typeOrOptions) {
            options = typeOrOptions;
            type = typeOrOptions.type;
        }
        return function (object, propertyName) {
            if (typeOrOptions instanceof Function) {
                var reflectMetadataType = Reflect && Reflect.getMetadata ? Reflect.getMetadata("design:type", object, propertyName) : undefined;
                var isArray = reflectMetadataType === Array || (options && (options.isArray === true || options.array === true)) ? true : false;
                var args = {
                    target: object.constructor,
                    propertyName: propertyName,
                    isArray: isArray,
                    prefix: options && options.prefix !== undefined ? options.prefix : undefined,
                    type: typeOrOptions
                };
                index_4.getMetadataArgsStorage().embeddeds.push(args);
            }
            else {
                // if type is not given implicitly then try to guess it
                if (!type) {
                    var reflectMetadataType = Reflect && Reflect.getMetadata ? Reflect.getMetadata("design:type", object, propertyName) : undefined;
                    if (reflectMetadataType)
                        type = reflectMetadataType; // todo: need to determine later on driver level
                }
                // if column options are not given then create a new empty options
                if (!options)
                    options = {};
                // check if there is no type in column options then set type from first function argument, or guessed one
                if (!options.type && type)
                    options = Object.assign({ type: type }, options);
                // create and register a new column metadata
                var args = {
                    target: object.constructor,
                    propertyName: propertyName,
                    mode: "regular",
                    options: options
                };
                index_4.getMetadataArgsStorage().columns.push(args);
            }
        };
    }
    exports_236("Column", Column);
    var index_4;
    return {
        setters: [
            function (index_4_1) {
                index_4 = index_4_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/columns/CreateDateColumn", ["typeorm/index"], function (exports_237, context_237) {
    "use strict";
    var __moduleName = context_237 && context_237.id;
    /**
     * This column will store a creation date of the inserted object.
     * Creation date is generated and inserted only once,
     * at the first time when you create an object, the value is inserted into the table, and is never touched again.
     */
    function CreateDateColumn(options) {
        return function (object, propertyName) {
            // const reflectedType = ColumnTypes.typeToString((Reflect as any).getMetadata("design:type", object, propertyName));
            // if column options are not given then create a new empty options
            if (!options)
                options = {};
            // implicitly set a type, because this column's type cannot be anything else except date
            // options = Object.assign({ type: Date } as ColumnOptions, options);
            // create and register a new column metadata
            var args = {
                target: object.constructor,
                propertyName: propertyName,
                // propertyType: reflectedType,
                mode: "createDate",
                options: options
            };
            index_5.getMetadataArgsStorage().columns.push(args);
        };
    }
    exports_237("CreateDateColumn", CreateDateColumn);
    var index_5;
    return {
        setters: [
            function (index_5_1) {
                index_5 = index_5_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/columns/DiscriminatorColumn", ["typeorm/index"], function (exports_238, context_238) {
    "use strict";
    var __moduleName = context_238 && context_238.id;
    /**
     * DiscriminatorColumn is a special type column used on entity class (not entity property)
     * and creates a special column which will contain an entity type.
     * This type is required for entities which use single table inheritance pattern.
     */
    function DiscriminatorColumn(discriminatorOptions) {
        return function (target) {
            // if column options are not given then create a new empty options
            var options = {
                name: discriminatorOptions.name,
                type: discriminatorOptions.type
            };
            // create and register a new column metadata
            var args = {
                target: target,
                mode: "discriminator",
                propertyName: discriminatorOptions.name,
                options: options
            };
            index_6.getMetadataArgsStorage().columns.push(args);
        };
    }
    exports_238("DiscriminatorColumn", DiscriminatorColumn);
    var index_6;
    return {
        setters: [
            function (index_6_1) {
                index_6 = index_6_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/options/PrimaryGeneratedColumnNumericOptions", [], function (exports_239, context_239) {
    "use strict";
    var __moduleName = context_239 && context_239.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/options/PrimaryGeneratedColumnUUIDOptions", [], function (exports_240, context_240) {
    "use strict";
    var __moduleName = context_240 && context_240.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/columns/PrimaryGeneratedColumn", ["typeorm/index"], function (exports_241, context_241) {
    "use strict";
    var __moduleName = context_241 && context_241.id;
    /**
     * Column decorator is used to mark a specific class property as a table column.
     * Only properties decorated with this decorator will be persisted to the database when entity be saved.
     * This column creates an integer PRIMARY COLUMN with generated set to true.
     */
    function PrimaryGeneratedColumn(strategyOrOptions, maybeOptions) {
        var options = {};
        var strategy;
        if (strategyOrOptions) {
            if (typeof strategyOrOptions === "string")
                strategy = strategyOrOptions;
            if (strategyOrOptions instanceof Object) {
                strategy = "increment";
                Object.assign(options, strategyOrOptions);
            }
        }
        else {
            strategy = "increment";
        }
        if (maybeOptions instanceof Object)
            Object.assign(options, maybeOptions);
        return function (object, propertyName) {
            // check if there is no type in column options then set the int type - by default for auto generated column
            if (!options.type) {
                if (strategy === "increment") {
                    Object.assign(options, { type: Number });
                }
                else {
                    Object.assign(options, { type: "uuid" });
                }
            }
            // implicitly set a primary and generated to column options
            Object.assign(options, { primary: true });
            // create and register a new column metadata
            var columnArgs = {
                target: object.constructor,
                propertyName: propertyName,
                mode: "regular",
                options: options
            };
            index_7.getMetadataArgsStorage().columns.push(columnArgs);
            var generationArgs = {
                target: object.constructor,
                propertyName: propertyName,
                strategy: strategy
            };
            index_7.getMetadataArgsStorage().generations.push(generationArgs);
        };
    }
    exports_241("PrimaryGeneratedColumn", PrimaryGeneratedColumn);
    var index_7;
    return {
        setters: [
            function (index_7_1) {
                index_7 = index_7_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/error/ColumnTypeUndefinedError", [], function (exports_242, context_242) {
    "use strict";
    var __moduleName = context_242 && context_242.id;
    var ColumnTypeUndefinedError;
    return {
        setters: [],
        execute: function () {
            ColumnTypeUndefinedError = /** @class */ (function (_super) {
                __extends(ColumnTypeUndefinedError, _super);
                function ColumnTypeUndefinedError(object, propertyName) {
                    var _this = _super.call(this) || this;
                    _this.name = "ColumnTypeUndefinedError";
                    _this.message = "Column type for " + object.constructor.name + "#" + propertyName + " is not defined or cannot be guessed. " +
                        "Try to explicitly provide a column type to the @Column decorator.";
                    return _this;
                }
                return ColumnTypeUndefinedError;
            }(Error));
            exports_242("ColumnTypeUndefinedError", ColumnTypeUndefinedError);
        }
    };
});
System.register("typeorm/error/PrimaryColumnCannotBeNullableError", [], function (exports_243, context_243) {
    "use strict";
    var __moduleName = context_243 && context_243.id;
    var PrimaryColumnCannotBeNullableError;
    return {
        setters: [],
        execute: function () {
            PrimaryColumnCannotBeNullableError = /** @class */ (function (_super) {
                __extends(PrimaryColumnCannotBeNullableError, _super);
                function PrimaryColumnCannotBeNullableError(object, propertyName) {
                    var _this = _super.call(this) || this;
                    _this.name = "PrimaryColumnCannotBeNullableError";
                    _this.message = "Primary column " + object.constructor.name + "#" + propertyName + " cannot be nullable. " +
                        "Its not allowed for primary keys. Try to remove nullable option.";
                    return _this;
                }
                return PrimaryColumnCannotBeNullableError;
            }(Error));
            exports_243("PrimaryColumnCannotBeNullableError", PrimaryColumnCannotBeNullableError);
        }
    };
});
System.register("typeorm/decorator/columns/PrimaryColumn", ["typeorm/error/ColumnTypeUndefinedError", "typeorm/index", "typeorm/error/PrimaryColumnCannotBeNullableError"], function (exports_244, context_244) {
    "use strict";
    var __moduleName = context_244 && context_244.id;
    /**
     * Column decorator is used to mark a specific class property as a table column.
     * Only properties decorated with this decorator will be persisted to the database when entity be saved.
     * Primary columns also creates a PRIMARY KEY for this column in a db.
     */
    function PrimaryColumn(typeOrOptions, options) {
        var type;
        if (typeof typeOrOptions === "string") {
            type = typeOrOptions;
        }
        else {
            options = typeOrOptions;
        }
        return function (object, propertyName) {
            // const reflectedType = ColumnTypes.typeToString((Reflect as any).getMetadata("design:type", object, propertyName));
            // if type is not given implicitly then try to guess it
            if (!type) {
                var reflectMetadataType = Reflect && Reflect.getMetadata ? Reflect.getMetadata("design:type", object, propertyName) : undefined;
                if (reflectMetadataType)
                    type = reflectMetadataType;
            }
            // if column options are not given then create a new empty options
            if (!options)
                options = {};
            // check if there is no type in column options then set type from first function argument, or guessed one
            if (!options.type && type)
                options = Object.assign({ type: type }, options);
            // if we still don't have a type then we need to give error to user that type is required
            if (!options.type)
                throw new ColumnTypeUndefinedError_1.ColumnTypeUndefinedError(object, propertyName);
            // check if column is not nullable, because we cannot allow a primary key to be nullable
            if (options.nullable)
                throw new PrimaryColumnCannotBeNullableError_1.PrimaryColumnCannotBeNullableError(object, propertyName);
            // implicitly set a primary to column options
            options = Object.assign({ primary: true }, options);
            // create and register a new column metadata
            var args = {
                target: object.constructor,
                propertyName: propertyName,
                // propertyType: reflectedType,
                mode: "regular",
                options: options
            };
            index_8.getMetadataArgsStorage().columns.push(args);
        };
    }
    exports_244("PrimaryColumn", PrimaryColumn);
    var ColumnTypeUndefinedError_1, index_8, PrimaryColumnCannotBeNullableError_1;
    return {
        setters: [
            function (ColumnTypeUndefinedError_1_1) {
                ColumnTypeUndefinedError_1 = ColumnTypeUndefinedError_1_1;
            },
            function (index_8_1) {
                index_8 = index_8_1;
            },
            function (PrimaryColumnCannotBeNullableError_1_1) {
                PrimaryColumnCannotBeNullableError_1 = PrimaryColumnCannotBeNullableError_1_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/columns/UpdateDateColumn", ["typeorm/index"], function (exports_245, context_245) {
    "use strict";
    var __moduleName = context_245 && context_245.id;
    /**
     * This column will store an update date of the updated object.
     * This date is being updated each time you persist the object.
     */
    function UpdateDateColumn(options) {
        return function (object, propertyName) {
            var args = {
                target: object.constructor,
                propertyName: propertyName,
                mode: "updateDate",
                options: options ? options : {}
            };
            index_9.getMetadataArgsStorage().columns.push(args);
        };
    }
    exports_245("UpdateDateColumn", UpdateDateColumn);
    var index_9;
    return {
        setters: [
            function (index_9_1) {
                index_9 = index_9_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/columns/VersionColumn", ["typeorm/index"], function (exports_246, context_246) {
    "use strict";
    var __moduleName = context_246 && context_246.id;
    /**
     * This column will store a number - version of the entity.
     * Every time your entity will be persisted, this number will be increased by one -
     * so you can organize visioning and update strategies of your entity.
     */
    function VersionColumn(options) {
        return function (object, propertyName) {
            // if column options are not given then create a new empty options
            if (!options)
                options = {};
            // create and register a new column metadata
            var args = {
                target: object.constructor,
                propertyName: propertyName,
                mode: "version",
                options: options
            };
            index_10.getMetadataArgsStorage().columns.push(args);
        };
    }
    exports_246("VersionColumn", VersionColumn);
    var index_10;
    return {
        setters: [
            function (index_10_1) {
                index_10 = index_10_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/columns/ObjectIdColumn", ["typeorm/index"], function (exports_247, context_247) {
    "use strict";
    var __moduleName = context_247 && context_247.id;
    /**
     * Special type of column that is available only for MongoDB database.
     * Marks your entity's column to be an object id.
     */
    function ObjectIdColumn(options) {
        return function (object, propertyName) {
            // if column options are not given then create a new empty options
            if (!options)
                options = {};
            options = Object.assign(options, {
                primary: true,
                name: options.name ? options.name : "_id"
            });
            // create and register a new column metadata
            var args = {
                target: object.constructor,
                propertyName: propertyName,
                mode: "objectId",
                options: options
            };
            index_11.getMetadataArgsStorage().columns.push(args);
        };
    }
    exports_247("ObjectIdColumn", ObjectIdColumn);
    var index_11;
    return {
        setters: [
            function (index_11_1) {
                index_11 = index_11_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/listeners/AfterInsert", ["typeorm/index", "typeorm/metadata/types/EventListenerTypes"], function (exports_248, context_248) {
    "use strict";
    var __moduleName = context_248 && context_248.id;
    /**
     * Calls a method on which this decorator is applied after this entity insertion.
     */
    function AfterInsert() {
        return function (object, propertyName) {
            var args = {
                target: object.constructor,
                propertyName: propertyName,
                type: EventListenerTypes_2.EventListenerTypes.AFTER_INSERT
            };
            index_12.getMetadataArgsStorage().entityListeners.push(args);
        };
    }
    exports_248("AfterInsert", AfterInsert);
    var index_12, EventListenerTypes_2;
    return {
        setters: [
            function (index_12_1) {
                index_12 = index_12_1;
            },
            function (EventListenerTypes_2_1) {
                EventListenerTypes_2 = EventListenerTypes_2_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/listeners/AfterLoad", ["typeorm/index", "typeorm/metadata/types/EventListenerTypes"], function (exports_249, context_249) {
    "use strict";
    var __moduleName = context_249 && context_249.id;
    /**
     * Calls a method on which this decorator is applied after entity is loaded.
     */
    function AfterLoad() {
        return function (object, propertyName) {
            var args = {
                target: object.constructor,
                propertyName: propertyName,
                type: EventListenerTypes_3.EventListenerTypes.AFTER_LOAD
            };
            index_13.getMetadataArgsStorage().entityListeners.push(args);
        };
    }
    exports_249("AfterLoad", AfterLoad);
    var index_13, EventListenerTypes_3;
    return {
        setters: [
            function (index_13_1) {
                index_13 = index_13_1;
            },
            function (EventListenerTypes_3_1) {
                EventListenerTypes_3 = EventListenerTypes_3_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/listeners/AfterRemove", ["typeorm/index", "typeorm/metadata/types/EventListenerTypes"], function (exports_250, context_250) {
    "use strict";
    var __moduleName = context_250 && context_250.id;
    /**
     * Calls a method on which this decorator is applied after this entity removal.
     */
    function AfterRemove() {
        return function (object, propertyName) {
            var args = {
                target: object.constructor,
                propertyName: propertyName,
                type: EventListenerTypes_4.EventListenerTypes.AFTER_REMOVE
            };
            index_14.getMetadataArgsStorage().entityListeners.push(args);
        };
    }
    exports_250("AfterRemove", AfterRemove);
    var index_14, EventListenerTypes_4;
    return {
        setters: [
            function (index_14_1) {
                index_14 = index_14_1;
            },
            function (EventListenerTypes_4_1) {
                EventListenerTypes_4 = EventListenerTypes_4_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/listeners/AfterUpdate", ["typeorm/index", "typeorm/metadata/types/EventListenerTypes"], function (exports_251, context_251) {
    "use strict";
    var __moduleName = context_251 && context_251.id;
    /**
     * Calls a method on which this decorator is applied after this entity update.
     */
    function AfterUpdate() {
        return function (object, propertyName) {
            var args = {
                target: object.constructor,
                propertyName: propertyName,
                type: EventListenerTypes_5.EventListenerTypes.AFTER_UPDATE
            };
            index_15.getMetadataArgsStorage().entityListeners.push(args);
        };
    }
    exports_251("AfterUpdate", AfterUpdate);
    var index_15, EventListenerTypes_5;
    return {
        setters: [
            function (index_15_1) {
                index_15 = index_15_1;
            },
            function (EventListenerTypes_5_1) {
                EventListenerTypes_5 = EventListenerTypes_5_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/listeners/BeforeInsert", ["typeorm/index", "typeorm/metadata/types/EventListenerTypes"], function (exports_252, context_252) {
    "use strict";
    var __moduleName = context_252 && context_252.id;
    /**
     * Calls a method on which this decorator is applied before this entity insertion.
     */
    function BeforeInsert() {
        return function (object, propertyName) {
            var args = {
                target: object.constructor,
                propertyName: propertyName,
                type: EventListenerTypes_6.EventListenerTypes.BEFORE_INSERT
            };
            index_16.getMetadataArgsStorage().entityListeners.push(args);
        };
    }
    exports_252("BeforeInsert", BeforeInsert);
    var index_16, EventListenerTypes_6;
    return {
        setters: [
            function (index_16_1) {
                index_16 = index_16_1;
            },
            function (EventListenerTypes_6_1) {
                EventListenerTypes_6 = EventListenerTypes_6_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/listeners/BeforeRemove", ["typeorm/index", "typeorm/metadata/types/EventListenerTypes"], function (exports_253, context_253) {
    "use strict";
    var __moduleName = context_253 && context_253.id;
    /**
     * Calls a method on which this decorator is applied before this entity removal.
     */
    function BeforeRemove() {
        return function (object, propertyName) {
            var args = {
                target: object.constructor,
                propertyName: propertyName,
                type: EventListenerTypes_7.EventListenerTypes.BEFORE_REMOVE
            };
            index_17.getMetadataArgsStorage().entityListeners.push(args);
        };
    }
    exports_253("BeforeRemove", BeforeRemove);
    var index_17, EventListenerTypes_7;
    return {
        setters: [
            function (index_17_1) {
                index_17 = index_17_1;
            },
            function (EventListenerTypes_7_1) {
                EventListenerTypes_7 = EventListenerTypes_7_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/listeners/BeforeUpdate", ["typeorm/index", "typeorm/metadata/types/EventListenerTypes"], function (exports_254, context_254) {
    "use strict";
    var __moduleName = context_254 && context_254.id;
    /**
     * Calls a method on which this decorator is applied before this entity update.
     */
    function BeforeUpdate() {
        return function (object, propertyName) {
            var args = {
                target: object.constructor,
                propertyName: propertyName,
                type: EventListenerTypes_8.EventListenerTypes.BEFORE_UPDATE
            };
            index_18.getMetadataArgsStorage().entityListeners.push(args);
        };
    }
    exports_254("BeforeUpdate", BeforeUpdate);
    var index_18, EventListenerTypes_8;
    return {
        setters: [
            function (index_18_1) {
                index_18 = index_18_1;
            },
            function (EventListenerTypes_8_1) {
                EventListenerTypes_8 = EventListenerTypes_8_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/listeners/EventSubscriber", ["typeorm/index"], function (exports_255, context_255) {
    "use strict";
    var __moduleName = context_255 && context_255.id;
    /**
     * Classes decorated with this decorator will listen to ORM events and their methods will be triggered when event
     * occurs. Those classes must implement EventSubscriberInterface interface.
     */
    function EventSubscriber() {
        return function (target) {
            var args = {
                target: target
            };
            index_19.getMetadataArgsStorage().entitySubscribers.push(args);
        };
    }
    exports_255("EventSubscriber", EventSubscriber);
    var index_19;
    return {
        setters: [
            function (index_19_1) {
                index_19 = index_19_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/options/IndexOptions", [], function (exports_256, context_256) {
    "use strict";
    var __moduleName = context_256 && context_256.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/options/EntityOptions", [], function (exports_257, context_257) {
    "use strict";
    var __moduleName = context_257 && context_257.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/relations/JoinColumn", ["typeorm/index"], function (exports_258, context_258) {
    "use strict";
    var __moduleName = context_258 && context_258.id;
    /**
     * JoinColumn decorator used on one-to-one relations to specify owner side of relationship.
     * It also can be used on both one-to-one and many-to-one relations to specify custom column name
     * or custom referenced column.
     */
    function JoinColumn(optionsOrOptionsArray) {
        return function (object, propertyName) {
            var options = optionsOrOptionsArray instanceof Array ? optionsOrOptionsArray : [optionsOrOptionsArray || {}];
            options.forEach(function (options) {
                var args = {
                    target: object.constructor,
                    propertyName: propertyName,
                    name: options.name,
                    referencedColumnName: options.referencedColumnName
                };
                index_20.getMetadataArgsStorage().joinColumns.push(args);
            });
        };
    }
    exports_258("JoinColumn", JoinColumn);
    var index_20;
    return {
        setters: [
            function (index_20_1) {
                index_20 = index_20_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/relations/JoinTable", ["typeorm/index"], function (exports_259, context_259) {
    "use strict";
    var __moduleName = context_259 && context_259.id;
    /**
     * JoinTable decorator is used in many-to-many relationship to specify owner side of relationship.
     * Its also used to set a custom junction table's name, column names and referenced columns.
     */
    function JoinTable(options) {
        return function (object, propertyName) {
            options = options || {};
            var args = {
                target: object.constructor,
                propertyName: propertyName,
                name: options.name,
                joinColumns: (options && options.joinColumn ? [options.joinColumn] : options.joinColumns),
                inverseJoinColumns: (options && options.inverseJoinColumn ? [options.inverseJoinColumn] : options.inverseJoinColumns),
                schema: options && options.schema ? options.schema : undefined,
                database: options && options.database ? options.database : undefined,
            };
            index_21.getMetadataArgsStorage().joinTables.push(args);
        };
    }
    exports_259("JoinTable", JoinTable);
    var index_21;
    return {
        setters: [
            function (index_21_1) {
                index_21 = index_21_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/relations/ManyToMany", ["typeorm/index"], function (exports_260, context_260) {
    "use strict";
    var __moduleName = context_260 && context_260.id;
    /**
     * Many-to-many is a type of relationship when Entity1 can have multiple instances of Entity2, and Entity2 can have
     * multiple instances of Entity1. To achieve it, this type of relation creates a junction table, where it storage
     * entity1 and entity2 ids. This is owner side of the relationship.
     */
    function ManyToMany(typeFunction, inverseSideOrOptions, options) {
        var inverseSideProperty;
        if (typeof inverseSideOrOptions === "object") {
            options = inverseSideOrOptions;
        }
        else {
            inverseSideProperty = inverseSideOrOptions;
        }
        return function (object, propertyName) {
            if (!options)
                options = {};
            // now try to determine it its lazy relation
            var isLazy = options && options.lazy === true ? true : false;
            if (!isLazy && Reflect && Reflect.getMetadata) { // automatic determination
                var reflectedType = Reflect.getMetadata("design:type", object, propertyName);
                if (reflectedType && typeof reflectedType.name === "string" && reflectedType.name.toLowerCase() === "promise")
                    isLazy = true;
            }
            var args = {
                target: object.constructor,
                propertyName: propertyName,
                // propertyType: reflectedType,
                relationType: "many-to-many",
                isLazy: isLazy,
                type: typeFunction,
                inverseSideProperty: inverseSideProperty,
                options: options
            };
            index_22.getMetadataArgsStorage().relations.push(args);
        };
    }
    exports_260("ManyToMany", ManyToMany);
    var index_22;
    return {
        setters: [
            function (index_22_1) {
                index_22 = index_22_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/relations/ManyToOne", ["typeorm/index"], function (exports_261, context_261) {
    "use strict";
    var __moduleName = context_261 && context_261.id;
    /**
     * Many-to-one relation allows to create type of relation when Entity1 can have single instance of Entity2, but
     * Entity2 can have a multiple instances of Entity1. Entity1 is an owner of the relationship, and storages Entity2 id
     * on its own side.
     */
    function ManyToOne(typeFunction, inverseSideOrOptions, options) {
        var inverseSideProperty;
        if (typeof inverseSideOrOptions === "object") {
            options = inverseSideOrOptions;
        }
        else {
            inverseSideProperty = inverseSideOrOptions;
        }
        return function (object, propertyName) {
            if (!options)
                options = {};
            // now try to determine it its lazy relation
            var isLazy = options && options.lazy === true ? true : false;
            if (!isLazy && Reflect && Reflect.getMetadata) { // automatic determination
                var reflectedType = Reflect.getMetadata("design:type", object, propertyName);
                if (reflectedType && typeof reflectedType.name === "string" && reflectedType.name.toLowerCase() === "promise")
                    isLazy = true;
            }
            var args = {
                target: object.constructor,
                propertyName: propertyName,
                // propertyType: reflectedType,
                relationType: "many-to-one",
                isLazy: isLazy,
                type: typeFunction,
                inverseSideProperty: inverseSideProperty,
                options: options
            };
            index_23.getMetadataArgsStorage().relations.push(args);
        };
    }
    exports_261("ManyToOne", ManyToOne);
    var index_23;
    return {
        setters: [
            function (index_23_1) {
                index_23 = index_23_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/relations/OneToMany", ["typeorm/index"], function (exports_262, context_262) {
    "use strict";
    var __moduleName = context_262 && context_262.id;
    // todo: make decorators which use inverse side string separate
    /**
     * One-to-many relation allows to create type of relation when Entity2 can have multiple instances of Entity1.
     * Entity1 have only one Entity2. Entity1 is an owner of the relationship, and storages Entity2 id on its own side.
     */
    function OneToMany(typeFunction, inverseSide, options) {
        return function (object, propertyName) {
            if (!options)
                options = {};
            // now try to determine it its lazy relation
            var isLazy = options && options.lazy === true ? true : false;
            if (!isLazy && Reflect && Reflect.getMetadata) { // automatic determination
                var reflectedType = Reflect.getMetadata("design:type", object, propertyName);
                if (reflectedType && typeof reflectedType.name === "string" && reflectedType.name.toLowerCase() === "promise")
                    isLazy = true;
            }
            var args = {
                target: object.constructor,
                propertyName: propertyName,
                // propertyType: reflectedType,
                isLazy: isLazy,
                relationType: "one-to-many",
                type: typeFunction,
                inverseSideProperty: inverseSide,
                options: options
            };
            index_24.getMetadataArgsStorage().relations.push(args);
        };
    }
    exports_262("OneToMany", OneToMany);
    var index_24;
    return {
        setters: [
            function (index_24_1) {
                index_24 = index_24_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/relations/OneToOne", ["typeorm/index"], function (exports_263, context_263) {
    "use strict";
    var __moduleName = context_263 && context_263.id;
    /**
     * One-to-one relation allows to create direct relation between two entities. Entity1 have only one Entity2.
     * Entity1 is an owner of the relationship, and storages Entity1 id on its own side.
     */
    function OneToOne(typeFunction, inverseSideOrOptions, options) {
        var inverseSideProperty;
        if (typeof inverseSideOrOptions === "object") {
            options = inverseSideOrOptions;
        }
        else {
            inverseSideProperty = inverseSideOrOptions;
        }
        return function (object, propertyName) {
            if (!options)
                options = {};
            // now try to determine it its lazy relation
            var isLazy = options && options.lazy === true ? true : false;
            if (!isLazy && Reflect && Reflect.getMetadata) { // automatic determination
                var reflectedType = Reflect.getMetadata("design:type", object, propertyName);
                if (reflectedType && typeof reflectedType.name === "string" && reflectedType.name.toLowerCase() === "promise")
                    isLazy = true;
            }
            var args = {
                target: object.constructor,
                propertyName: propertyName,
                // propertyType: reflectedType,
                isLazy: isLazy,
                relationType: "one-to-one",
                type: typeFunction,
                inverseSideProperty: inverseSideProperty,
                options: options
            };
            index_25.getMetadataArgsStorage().relations.push(args);
        };
    }
    exports_263("OneToOne", OneToOne);
    var index_25;
    return {
        setters: [
            function (index_25_1) {
                index_25 = index_25_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/relations/RelationCount", ["typeorm/index"], function (exports_264, context_264) {
    "use strict";
    var __moduleName = context_264 && context_264.id;
    /**
     * Holds a number of children in the closure table of the column.
     */
    function RelationCount(relation, alias, queryBuilderFactory) {
        return function (object, propertyName) {
            var args = {
                target: object.constructor,
                propertyName: propertyName,
                relation: relation,
                alias: alias,
                queryBuilderFactory: queryBuilderFactory
            };
            index_26.getMetadataArgsStorage().relationCounts.push(args);
        };
    }
    exports_264("RelationCount", RelationCount);
    var index_26;
    return {
        setters: [
            function (index_26_1) {
                index_26 = index_26_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/relations/RelationId", ["typeorm/index"], function (exports_265, context_265) {
    "use strict";
    var __moduleName = context_265 && context_265.id;
    /**
     * Special decorator used to extract relation id into separate entity property.
     */
    function RelationId(relation, alias, queryBuilderFactory) {
        return function (object, propertyName) {
            var args = {
                target: object.constructor,
                propertyName: propertyName,
                relation: relation,
                alias: alias,
                queryBuilderFactory: queryBuilderFactory
            };
            index_27.getMetadataArgsStorage().relationIds.push(args);
        };
    }
    exports_265("RelationId", RelationId);
    var index_27;
    return {
        setters: [
            function (index_27_1) {
                index_27 = index_27_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/entity/Entity", ["typeorm/index"], function (exports_266, context_266) {
    "use strict";
    var __moduleName = context_266 && context_266.id;
    /**
     * This decorator is used to mark classes that will be an entity (table or document depend on database type).
     * Database schema will be created for all classes decorated with it, and Repository can be retrieved and used for it.
     */
    function Entity(nameOrOptions, maybeOptions) {
        var options = (typeof nameOrOptions === "object" ? nameOrOptions : maybeOptions) || {};
        var name = typeof nameOrOptions === "string" ? nameOrOptions : options.name;
        return function (target) {
            var args = {
                target: target,
                name: name,
                type: "regular",
                orderBy: options && options.orderBy ? options.orderBy : undefined,
                engine: options && options.engine ? options.engine : undefined,
                database: options && options.database ? options.database : undefined,
                schema: options && options.schema ? options.schema : undefined,
                skipSync: !!(options && options.skipSync === true)
            };
            index_28.getMetadataArgsStorage().tables.push(args);
        };
    }
    exports_266("Entity", Entity);
    var index_28;
    return {
        setters: [
            function (index_28_1) {
                index_28 = index_28_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/entity/ClassEntityChild", ["typeorm/index"], function (exports_267, context_267) {
    "use strict";
    var __moduleName = context_267 && context_267.id;
    /**
     * Special type of the entity used in the class-table inherited tables.
     */
    function ClassEntityChild(tableName, options) {
        return function (target) {
            var args = {
                target: target,
                name: tableName,
                type: "class-table-child",
                orderBy: options && options.orderBy ? options.orderBy : undefined,
                skipSync: !!(options && options.skipSync === true)
            };
            index_29.getMetadataArgsStorage().tables.push(args);
        };
    }
    exports_267("ClassEntityChild", ClassEntityChild);
    var index_29;
    return {
        setters: [
            function (index_29_1) {
                index_29 = index_29_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/entity/ClosureEntity", ["typeorm/index"], function (exports_268, context_268) {
    "use strict";
    var __moduleName = context_268 && context_268.id;
    /**
     * Used on a entities that stores its children in a tree using closure design pattern.
     */
    function ClosureEntity(name, options) {
        return function (target) {
            var args = {
                target: target,
                name: name,
                type: "closure",
                orderBy: options && options.orderBy ? options.orderBy : undefined,
                skipSync: !!(options && options.skipSync === true)
            };
            index_30.getMetadataArgsStorage().tables.push(args);
        };
    }
    exports_268("ClosureEntity", ClosureEntity);
    var index_30;
    return {
        setters: [
            function (index_30_1) {
                index_30 = index_30_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/entity/SingleEntityChild", ["typeorm/index"], function (exports_269, context_269) {
    "use strict";
    var __moduleName = context_269 && context_269.id;
    /**
     * Special type of the table used in the single-table inherited tables.
     */
    function SingleEntityChild() {
        return function (target) {
            var args = {
                target: target,
                name: undefined,
                type: "single-table-child",
                orderBy: undefined
            };
            index_31.getMetadataArgsStorage().tables.push(args);
        };
    }
    exports_269("SingleEntityChild", SingleEntityChild);
    var index_31;
    return {
        setters: [
            function (index_31_1) {
                index_31 = index_31_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/entity/TableInheritance", ["typeorm/index"], function (exports_270, context_270) {
    "use strict";
    var __moduleName = context_270 && context_270.id;
    /**
     * Sets what kind of table-inheritance table will use.
     */
    function TableInheritance(type) {
        return function (target) {
            var args = {
                target: target,
                type: type
            };
            index_32.getMetadataArgsStorage().inheritances.push(args);
        };
    }
    exports_270("TableInheritance", TableInheritance);
    var index_32;
    return {
        setters: [
            function (index_32_1) {
                index_32 = index_32_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/transaction/Transaction", ["typeorm/index"], function (exports_271, context_271) {
    "use strict";
    var __moduleName = context_271 && context_271.id;
    /**
     * Wraps some method into the transaction.
     * Note, method result will return a promise if this decorator applied.
     * Note, all database operations in the wrapped method should be executed using entity managed passed as a first parameter
     * into the wrapped method.
     * If you want to control at what position in your method parameters entity manager should be injected,
     * then use @TransactionEntityManager() decorator.
     * If you want to use repositories instead of bare entity manager,
     * then use @TransactionRepository() decorator.
     */
    function Transaction(connectionName) {
        if (connectionName === void 0) { connectionName = "default"; }
        return function (target, methodName, descriptor) {
            // save original method - we gonna need it
            var originalMethod = descriptor.value;
            // override method descriptor with proxy method
            descriptor.value = function () {
                var _this = this;
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return index_33.getConnection(connectionName)
                    .manager
                    .transaction(function (entityManager) {
                    var argsWithInjectedTransactionManagerAndRepositories;
                    // gets all @TransactionEntityManager() decorator usages for this method
                    var transactionEntityManagerMetadatas = index_33.getMetadataArgsStorage()
                        .filterTransactionEntityManagers(target.constructor)
                        .filter(function (transactionEntityManagerMetadata) {
                        return transactionEntityManagerMetadata.methodName === methodName;
                    })
                        .reverse();
                    // gets all @TransactionRepository() decorator usages for this method
                    var transactionRepositoryMetadatas = index_33.getMetadataArgsStorage()
                        .filterTransactionRepository(target.constructor)
                        .filter(function (transactionRepositoryMetadata) {
                        return transactionRepositoryMetadata.methodName === methodName;
                    })
                        .reverse();
                    // if there are @TransactionEntityManager() decorator usages the inject them
                    if (transactionEntityManagerMetadatas.length > 0) {
                        argsWithInjectedTransactionManagerAndRepositories = args.slice();
                        // replace method params with injection of transactionEntityManager
                        transactionEntityManagerMetadatas.forEach(function (metadata) {
                            argsWithInjectedTransactionManagerAndRepositories.splice(metadata.index, 0, entityManager);
                        });
                    }
                    else if (transactionRepositoryMetadatas.length === 0) { // otherwise if there's no transaction repositories in use, inject it as a first parameter
                        argsWithInjectedTransactionManagerAndRepositories = [entityManager].concat(args);
                    }
                    else {
                        argsWithInjectedTransactionManagerAndRepositories = args.slice();
                    }
                    // for every usage of @TransactionRepository decorator
                    transactionRepositoryMetadatas.forEach(function (metadata) {
                        var repositoryInstance;
                        // detect type of the repository and get instance from transaction entity manager
                        switch (metadata.repositoryType) {
                            case index_33.Repository:
                                repositoryInstance = entityManager.getRepository(metadata.entityType);
                                break;
                            case index_33.MongoRepository:
                                repositoryInstance = entityManager.getMongoRepository(metadata.entityType);
                                break;
                            case index_33.TreeRepository:
                                repositoryInstance = entityManager.getTreeRepository(metadata.entityType);
                                break;
                            // if not the TypeORM's ones, there must be custom repository classes
                            default:
                                repositoryInstance = entityManager.getCustomRepository(metadata.repositoryType);
                        }
                        // replace method param with injection of repository instance
                        argsWithInjectedTransactionManagerAndRepositories.splice(metadata.index, 0, repositoryInstance);
                    });
                    return originalMethod.apply(_this, argsWithInjectedTransactionManagerAndRepositories);
                });
            };
        };
    }
    exports_271("Transaction", Transaction);
    var index_33;
    return {
        setters: [
            function (index_33_1) {
                index_33 = index_33_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/transaction/TransactionManager", ["typeorm/index"], function (exports_272, context_272) {
    "use strict";
    var __moduleName = context_272 && context_272.id;
    /**
     * Injects transaction's entity manager into the method wrapped with @Transaction decorator.
     */
    function TransactionManager() {
        return function (object, methodName, index) {
            var args = {
                target: object.constructor,
                methodName: methodName,
                index: index,
            };
            index_34.getMetadataArgsStorage().transactionEntityManagers.push(args);
        };
    }
    exports_272("TransactionManager", TransactionManager);
    var index_34;
    return {
        setters: [
            function (index_34_1) {
                index_34 = index_34_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/transaction/TransactionRepository", ["typeorm/index"], function (exports_273, context_273) {
    "use strict";
    var __moduleName = context_273 && context_273.id;
    /**
     * Injects transaction's repository into the method wrapped with @Transaction decorator.
     */
    function TransactionRepository(entityType) {
        return function (object, methodName, index) {
            var repositoryType;
            try {
                repositoryType = Reflect.getOwnMetadata("design:paramtypes", object, methodName)[index];
            }
            catch (err) {
                throw new Error("Cannot get reflected type for a \"" + methodName + "\" method's parameter of " + object.constructor.name + " class. " +
                    "Make sure you have turned on an \"emitDecoratorMetadata\": true, option in tsconfig.json. " +
                    "Also make sure you have imported \"reflect-metadata\" on top of the main entry file in your application.");
            }
            var args = {
                target: object.constructor,
                methodName: methodName,
                index: index,
                repositoryType: repositoryType,
                entityType: entityType,
            };
            index_35.getMetadataArgsStorage().transactionRepositories.push(args);
        };
    }
    exports_273("TransactionRepository", TransactionRepository);
    var index_35;
    return {
        setters: [
            function (index_35_1) {
                index_35 = index_35_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/tree/TreeLevelColumn", ["typeorm/index"], function (exports_274, context_274) {
    "use strict";
    var __moduleName = context_274 && context_274.id;
    /**
     * Creates a "level"/"length" column to the table that holds a closure table.
     */
    function TreeLevelColumn() {
        return function (object, propertyName) {
            // create and register a new column metadata
            var args = {
                target: object.constructor,
                propertyName: propertyName,
                mode: "treeLevel",
                options: {}
            };
            index_36.getMetadataArgsStorage().columns.push(args);
        };
    }
    exports_274("TreeLevelColumn", TreeLevelColumn);
    var index_36;
    return {
        setters: [
            function (index_36_1) {
                index_36 = index_36_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/tree/TreeParent", ["typeorm/index"], function (exports_275, context_275) {
    "use strict";
    var __moduleName = context_275 && context_275.id;
    /**
     * Marks a specific property of the class as a parent of the tree.
     */
    function TreeParent(options) {
        return function (object, propertyName) {
            if (!options)
                options = {};
            // now try to determine it its lazy relation
            var isLazy = options && options.lazy === true ? true : false;
            if (!isLazy && Reflect && Reflect.getMetadata) { // automatic determination
                var reflectedType = Reflect.getMetadata("design:type", object, propertyName);
                if (reflectedType && typeof reflectedType.name === "string" && reflectedType.name.toLowerCase() === "promise")
                    isLazy = true;
            }
            var args = {
                isTreeParent: true,
                target: object.constructor,
                propertyName: propertyName,
                // propertyType: reflectedType,
                isLazy: isLazy,
                relationType: "many-to-one",
                type: function () { return object.constructor; },
                options: options
            };
            index_37.getMetadataArgsStorage().relations.push(args);
        };
    }
    exports_275("TreeParent", TreeParent);
    var index_37;
    return {
        setters: [
            function (index_37_1) {
                index_37 = index_37_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/tree/TreeChildren", ["typeorm/index"], function (exports_276, context_276) {
    "use strict";
    var __moduleName = context_276 && context_276.id;
    /**
     * Marks a specific property of the class as a children of the tree.
     */
    function TreeChildren(options) {
        return function (object, propertyName) {
            if (!options)
                options = {};
            // now try to determine it its lazy relation
            var isLazy = options && options.lazy === true ? true : false;
            if (!isLazy && Reflect && Reflect.getMetadata) { // automatic determination
                var reflectedType = Reflect.getMetadata("design:type", object, propertyName);
                if (reflectedType && typeof reflectedType.name === "string" && reflectedType.name.toLowerCase() === "promise")
                    isLazy = true;
            }
            // add one-to-many relation for this 
            var args = {
                isTreeChildren: true,
                target: object.constructor,
                propertyName: propertyName,
                // propertyType: reflectedType,
                isLazy: isLazy,
                relationType: "one-to-many",
                type: function () { return object.constructor; },
                options: options
            };
            index_38.getMetadataArgsStorage().relations.push(args);
        };
    }
    exports_276("TreeChildren", TreeChildren);
    var index_38;
    return {
        setters: [
            function (index_38_1) {
                index_38 = index_38_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/Index", ["typeorm/index"], function (exports_277, context_277) {
    "use strict";
    var __moduleName = context_277 && context_277.id;
    /**
     * Composite index must be set on entity classes and must specify entity's fields to be indexed.
     */
    function Index(nameOrFieldsOrOptions, maybeFieldsOrOptions, maybeOptions) {
        var name = typeof nameOrFieldsOrOptions === "string" ? nameOrFieldsOrOptions : undefined;
        var fields = typeof nameOrFieldsOrOptions === "string" ? maybeFieldsOrOptions : nameOrFieldsOrOptions;
        var options = (typeof nameOrFieldsOrOptions === "object" && !Array.isArray(nameOrFieldsOrOptions)) ? nameOrFieldsOrOptions : maybeOptions;
        if (!options)
            options = (typeof maybeFieldsOrOptions === "object" && !Array.isArray(maybeFieldsOrOptions)) ? maybeFieldsOrOptions : maybeOptions;
        return function (clsOrObject, propertyName) {
            var args = {
                target: propertyName ? clsOrObject.constructor : clsOrObject,
                name: name,
                columns: propertyName ? [propertyName] : fields,
                unique: options && options.unique ? true : false,
                sparse: options && options.sparse ? true : false
            };
            index_39.getMetadataArgsStorage().indices.push(args);
        };
    }
    exports_277("Index", Index);
    var index_39;
    return {
        setters: [
            function (index_39_1) {
                index_39 = index_39_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/Generated", ["typeorm/index"], function (exports_278, context_278) {
    "use strict";
    var __moduleName = context_278 && context_278.id;
    /**
     * Generated decorator is used to mark a specific class property as a generated table column.
     */
    function Generated(strategy) {
        if (strategy === void 0) { strategy = "increment"; }
        return function (object, propertyName) {
            var args = {
                target: object.constructor,
                propertyName: propertyName,
                strategy: strategy
            };
            index_40.getMetadataArgsStorage().generations.push(args);
        };
    }
    exports_278("Generated", Generated);
    var index_40;
    return {
        setters: [
            function (index_40_1) {
                index_40 = index_40_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/DiscriminatorValue", ["typeorm/index"], function (exports_279, context_279) {
    "use strict";
    var __moduleName = context_279 && context_279.id;
    /**
     * If entity is a child table of some table, it should have a discriminator value.
     * This decorator sets custom discriminator value for the entity.
     */
    function DiscriminatorValue(value) {
        return function (target) {
            var args = {
                target: target,
                value: value
            };
            index_41.getMetadataArgsStorage().discriminatorValues.push(args);
        };
    }
    exports_279("DiscriminatorValue", DiscriminatorValue);
    var index_41;
    return {
        setters: [
            function (index_41_1) {
                index_41 = index_41_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/EntityRepository", ["typeorm/index"], function (exports_280, context_280) {
    "use strict";
    var __moduleName = context_280 && context_280.id;
    /**
     * Used to declare a class as a custom repository.
     * Custom repository can either manage some specific entity, either just be generic.
     * Custom repository can extend AbstractRepository or regular Repository or TreeRepository.
     */
    function EntityRepository(entity) {
        return function (target) {
            var args = {
                target: target,
                entity: entity,
            };
            index_42.getMetadataArgsStorage().entityRepositories.push(args);
        };
    }
    exports_280("EntityRepository", EntityRepository);
    var index_42;
    return {
        setters: [
            function (index_42_1) {
                index_42 = index_42_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/repository/BaseEntity", ["typeorm/index"], function (exports_281, context_281) {
    "use strict";
    var __moduleName = context_281 && context_281.id;
    var index_43, BaseEntity;
    return {
        setters: [
            function (index_43_1) {
                index_43 = index_43_1;
            }
        ],
        execute: function () {
            /**
             * Base abstract entity for all entities, used in ActiveRecord patterns.
             */
            BaseEntity = /** @class */ (function () {
                function BaseEntity() {
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Checks if entity has an id.
                 * If entity composite compose ids, it will check them all.
                 */
                BaseEntity.prototype.hasId = function () {
                    return this.constructor.getRepository().hasId(this);
                };
                /**
                 * Saves current entity in the database.
                 * If entity does not exist in the database then inserts, otherwise updates.
                 */
                BaseEntity.prototype.save = function () {
                    return this.constructor.getRepository().save(this);
                };
                /**
                 * Removes current entity from the database.
                 */
                BaseEntity.prototype.remove = function () {
                    return this.constructor.getRepository().remove(this);
                };
                // -------------------------------------------------------------------------
                // Public Static Methods
                // -------------------------------------------------------------------------
                /**
                 * Sets connection to be used by entity.
                 */
                BaseEntity.useConnection = function (connection) {
                    this.usedConnection = connection;
                };
                /**
                 * Gets current entity's Repository.
                 */
                BaseEntity.getRepository = function () {
                    var connection = this.usedConnection || index_43.getConnection();
                    return connection.getRepository(this);
                };
                Object.defineProperty(BaseEntity, "target", {
                    /**
                     * Returns object that is managed by this repository.
                     * If this repository manages entity from schema,
                     * then it returns a name of that schema instead.
                     */
                    get: function () {
                        return this.getRepository().target;
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Checks entity has an id.
                 * If entity composite compose ids, it will check them all.
                 */
                BaseEntity.hasId = function (entity) {
                    return this.getRepository().hasId(entity);
                };
                /**
                 * Gets entity mixed id.
                 */
                BaseEntity.getId = function (entity) {
                    return this.getRepository().getId(entity);
                };
                /**
                 * Creates a new query builder that can be used to build a sql query.
                 */
                BaseEntity.createQueryBuilder = function (alias) {
                    return this.getRepository().createQueryBuilder(alias);
                };
                /**
                 * Creates a new entity instance and copies all entity properties from this object into a new entity.
                 * Note that it copies only properties that present in entity schema.
                 */
                BaseEntity.create = function (entityOrEntities) {
                    return this.getRepository().create(entityOrEntities);
                };
                /**
                 * Merges multiple entities (or entity-like objects) into a given entity.
                 */
                BaseEntity.merge = function (mergeIntoEntity) {
                    var entityLikes = [];
                    for (var _i = 1; _i < arguments.length; _i++) {
                        entityLikes[_i - 1] = arguments[_i];
                    }
                    return (_a = this.getRepository()).merge.apply(_a, [mergeIntoEntity].concat(entityLikes));
                    var _a;
                };
                /**
                 * Creates a new entity from the given plan javascript object. If entity already exist in the database, then
                 * it loads it (and everything related to it), replaces all values with the new ones from the given object
                 * and returns this new entity. This new entity is actually a loaded from the db entity with all properties
                 * replaced from the new object.
                 *
                 * Note that given entity-like object must have an entity id / primary key to find entity by.
                 * Returns undefined if entity with given id was not found.
                 */
                BaseEntity.preload = function (entityLike) {
                    return this.getRepository().preload(entityLike);
                };
                /**
                 * Saves one or many given entities.
                 */
                BaseEntity.save = function (entityOrEntities, options) {
                    return this.getRepository().save(entityOrEntities, options);
                };
                /**
                 * Updates entity partially. Entity can be found by a given conditions.
                 */
                BaseEntity.update = function (conditionsOrFindOptions, partialEntity, options) {
                    return this.getRepository().update(conditionsOrFindOptions, partialEntity, options);
                };
                /**
                 * Updates entity partially. Entity will be found by a given id.
                 */
                BaseEntity.updateById = function (id, partialEntity, options) {
                    return this.getRepository().updateById(id, partialEntity, options);
                };
                /**
                 * Removes one or many given entities.
                 */
                BaseEntity.remove = function (entityOrEntities, options) {
                    return this.getRepository().remove(entityOrEntities, options);
                };
                /**
                 * Removes entity by a given entity id.
                 */
                BaseEntity.removeById = function (id, options) {
                    return this.getRepository().deleteById(id, options);
                };
                /**
                 * Counts entities that match given find options or conditions.
                 */
                BaseEntity.count = function (optionsOrConditions) {
                    return this.getRepository().count(optionsOrConditions);
                };
                /**
                 * Finds entities that match given find options or conditions.
                 */
                BaseEntity.find = function (optionsOrConditions) {
                    return this.getRepository().find(optionsOrConditions);
                };
                /**
                 * Finds entities that match given find options or conditions.
                 * Also counts all entities that match given conditions,
                 * but ignores pagination settings (from and take options).
                 */
                BaseEntity.findAndCount = function (optionsOrConditions) {
                    return this.getRepository().findAndCount(optionsOrConditions);
                };
                /**
                 * Finds entities by ids.
                 * Optionally find options can be applied.
                 */
                BaseEntity.findByIds = function (ids, optionsOrConditions) {
                    return this.getRepository().findByIds(ids, optionsOrConditions);
                };
                /**
                 * Finds first entity that matches given conditions.
                 */
                BaseEntity.findOne = function (optionsOrConditions) {
                    return this.getRepository().findOne(optionsOrConditions);
                };
                /**
                 * Finds entity by given id.
                 * Optionally find options or conditions can be applied.
                 */
                BaseEntity.findOneById = function (id, optionsOrConditions) {
                    return this.getRepository().findOneById(id, optionsOrConditions);
                };
                /**
                 * Executes a raw SQL query and returns a raw database results.
                 * Raw query execution is supported only by relational databases (MongoDB is not supported).
                 */
                BaseEntity.query = function (query, parameters) {
                    return this.getRepository().query(query, parameters);
                };
                /**
                 * Clears all the data from the given table/collection (truncates/drops it).
                 */
                BaseEntity.clear = function () {
                    return this.getRepository().clear();
                };
                return BaseEntity;
            }());
            exports_281("BaseEntity", BaseEntity);
        }
    };
});
System.register("typeorm/index", ["typeorm/connection/ConnectionManager", "typeorm/metadata-args/MetadataArgsStorage", "typeorm/container", "typeorm/platform/PlatformTools", "typeorm/connection/ConnectionOptionsReader", "typeorm/util/PromiseUtils", "typeorm/error/QueryFailedError", "typeorm/decorator/columns/Column", "typeorm/decorator/columns/CreateDateColumn", "typeorm/decorator/columns/DiscriminatorColumn", "typeorm/decorator/columns/PrimaryGeneratedColumn", "typeorm/decorator/columns/PrimaryColumn", "typeorm/decorator/columns/UpdateDateColumn", "typeorm/decorator/columns/VersionColumn", "typeorm/decorator/columns/ObjectIdColumn", "typeorm/decorator/listeners/AfterInsert", "typeorm/decorator/listeners/AfterLoad", "typeorm/decorator/listeners/AfterRemove", "typeorm/decorator/listeners/AfterUpdate", "typeorm/decorator/listeners/BeforeInsert", "typeorm/decorator/listeners/BeforeRemove", "typeorm/decorator/listeners/BeforeUpdate", "typeorm/decorator/listeners/EventSubscriber", "typeorm/decorator/relations/JoinColumn", "typeorm/decorator/relations/JoinTable", "typeorm/decorator/relations/ManyToMany", "typeorm/decorator/relations/ManyToOne", "typeorm/decorator/relations/OneToMany", "typeorm/decorator/relations/OneToOne", "typeorm/decorator/relations/RelationCount", "typeorm/decorator/relations/RelationId", "typeorm/decorator/entity/Entity", "typeorm/decorator/entity/ClassEntityChild", "typeorm/decorator/entity/ClosureEntity", "typeorm/decorator/entity/SingleEntityChild", "typeorm/decorator/entity/TableInheritance", "typeorm/decorator/transaction/Transaction", "typeorm/decorator/transaction/TransactionManager", "typeorm/decorator/transaction/TransactionRepository", "typeorm/decorator/tree/TreeLevelColumn", "typeorm/decorator/tree/TreeParent", "typeorm/decorator/tree/TreeChildren", "typeorm/decorator/Index", "typeorm/decorator/Generated", "typeorm/decorator/DiscriminatorValue", "typeorm/decorator/EntityRepository", "typeorm/logger/AdvancedConsoleLogger", "typeorm/logger/SimpleConsoleLogger", "typeorm/logger/FileLogger", "typeorm/metadata/EntityMetadataUtils", "typeorm/entity-manager/EntityManager", "typeorm/repository/AbstractRepository", "typeorm/repository/Repository", "typeorm/repository/BaseEntity", "typeorm/repository/TreeRepository", "typeorm/repository/MongoRepository", "typeorm/schema-builder/schema/TableColumn", "typeorm/schema-builder/schema/TableForeignKey", "typeorm/schema-builder/schema/TableIndex", "typeorm/schema-builder/schema/TablePrimaryKey", "typeorm/schema-builder/schema/Table", "typeorm/driver/mongodb/typings", "typeorm/driver/sqlserver/MssqlParameter", "typeorm/connection/Connection", "typeorm/query-builder/QueryBuilder", "typeorm/query-builder/SelectQueryBuilder", "typeorm/query-builder/DeleteQueryBuilder", "typeorm/query-builder/InsertQueryBuilder", "typeorm/query-builder/UpdateQueryBuilder", "typeorm/query-builder/RelationQueryBuilder", "typeorm/query-builder/Brackets", "typeorm/entity-manager/MongoEntityManager", "typeorm/naming-strategy/DefaultNamingStrategy"], function (exports_282, context_282) {
    "use strict";
    var __moduleName = context_282 && context_282.id;
    // -------------------------------------------------------------------------
    // Deprecated
    // -------------------------------------------------------------------------
    // -------------------------------------------------------------------------
    // Commonly used functionality
    // -------------------------------------------------------------------------
    /**
     * Gets metadata args storage.
     */
    function getMetadataArgsStorage() {
        // we should store metadata storage in a global variable otherwise it brings too much problems
        // one of the problem is that if any entity (or any other) will be imported before consumer will call
        // useContainer method with his own container implementation, that entity will be registered in the
        // old old container (default one post probably) and consumer will his entity.
        // calling useContainer before he imports any entity (or any other) is not always convenient.
        // another reason is that when we run migrations typeorm is being called from a global package
        // and it may load entities which register decorators in typeorm of local package
        // this leads to impossibility of usage of entities in migrations and cli related operations
        var globalScope = PlatformTools_19.PlatformTools.getGlobalVariable();
        if (!globalScope.typeormMetadataArgsStorage)
            globalScope.typeormMetadataArgsStorage = new MetadataArgsStorage_2.MetadataArgsStorage();
        return globalScope.typeormMetadataArgsStorage;
    }
    exports_282("getMetadataArgsStorage", getMetadataArgsStorage);
    /**
     * Reads connection options stored in ormconfig configuration file.
     */
    function getConnectionOptions(connectionName) {
        if (connectionName === void 0) { connectionName = "default"; }
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, new ConnectionOptionsReader_1.ConnectionOptionsReader().get(connectionName)];
            });
        });
    }
    exports_282("getConnectionOptions", getConnectionOptions);
    /**
     * Gets a ConnectionManager which creates connections.
     */
    function getConnectionManager() {
        return container_2.getFromContainer(ConnectionManager_1.ConnectionManager);
    }
    exports_282("getConnectionManager", getConnectionManager);
    /**
     * Creates a new connection and registers it in the manager.
     *
     * If connection options were not specified, then it will try to create connection automatically,
     * based on content of ormconfig (json/js/yml/xml/env) file or environment variables.
     * Only one connection from ormconfig will be created (name "default" or connection without name).
     */
    function createConnection(optionsOrName) {
        return __awaiter(this, void 0, void 0, function () {
            var connectionName, options, _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        connectionName = typeof optionsOrName === "string" ? optionsOrName : "default";
                        if (!(optionsOrName instanceof Object)) return [3 /*break*/, 1];
                        _a = optionsOrName;
                        return [3 /*break*/, 3];
                    case 1: return [4 /*yield*/, getConnectionOptions(connectionName)];
                    case 2:
                        _a = _b.sent();
                        _b.label = 3;
                    case 3:
                        options = _a;
                        return [2 /*return*/, getConnectionManager().create(options).connect()];
                }
            });
        });
    }
    exports_282("createConnection", createConnection);
    /**
     * Creates new connections and registers them in the manager.
     *
     * If connection options were not specified, then it will try to create connection automatically,
     * based on content of ormconfig (json/js/yml/xml/env) file or environment variables.
     * All connections from the ormconfig will be created.
     */
    function createConnections(options) {
        return __awaiter(this, void 0, void 0, function () {
            var connections;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!!options) return [3 /*break*/, 2];
                        return [4 /*yield*/, new ConnectionOptionsReader_1.ConnectionOptionsReader().all()];
                    case 1:
                        options = _a.sent();
                        _a.label = 2;
                    case 2:
                        connections = options.map(function (options) { return getConnectionManager().create(options); });
                        return [2 /*return*/, PromiseUtils_6.PromiseUtils.runInSequence(connections, function (connection) { return connection.connect(); })];
                }
            });
        });
    }
    exports_282("createConnections", createConnections);
    /**
     * Gets connection from the connection manager.
     * If connection name wasn't specified, then "default" connection will be retrieved.
     */
    function getConnection(connectionName) {
        if (connectionName === void 0) { connectionName = "default"; }
        return getConnectionManager().get(connectionName);
    }
    exports_282("getConnection", getConnection);
    /**
     * Gets entity manager from the connection.
     * If connection name wasn't specified, then "default" connection will be retrieved.
     */
    function getManager(connectionName) {
        if (connectionName === void 0) { connectionName = "default"; }
        return getConnectionManager().get(connectionName).manager;
    }
    exports_282("getManager", getManager);
    /**
     * Gets MongoDB entity manager from the connection.
     * If connection name wasn't specified, then "default" connection will be retrieved.
     */
    function getMongoManager(connectionName) {
        if (connectionName === void 0) { connectionName = "default"; }
        return getConnectionManager().get(connectionName).manager;
    }
    exports_282("getMongoManager", getMongoManager);
    function getSqljsManager(connectionName) {
        if (connectionName === void 0) { connectionName = "default"; }
        return getConnectionManager().get(connectionName).manager;
    }
    exports_282("getSqljsManager", getSqljsManager);
    /**
     * Gets repository for the given entity class.
     */
    function getRepository(entityClass, connectionName) {
        if (connectionName === void 0) { connectionName = "default"; }
        return getConnectionManager().get(connectionName).getRepository(entityClass);
    }
    exports_282("getRepository", getRepository);
    /**
     * Gets tree repository for the given entity class.
     */
    function getTreeRepository(entityClass, connectionName) {
        if (connectionName === void 0) { connectionName = "default"; }
        return getConnectionManager().get(connectionName).getTreeRepository(entityClass);
    }
    exports_282("getTreeRepository", getTreeRepository);
    /**
     * Gets tree repository for the given entity class.
     */
    function getCustomRepository(customRepository, connectionName) {
        if (connectionName === void 0) { connectionName = "default"; }
        return getConnectionManager().get(connectionName).getCustomRepository(customRepository);
    }
    exports_282("getCustomRepository", getCustomRepository);
    /**
     * Gets mongodb repository for the given entity class or name.
     */
    function getMongoRepository(entityClass, connectionName) {
        if (connectionName === void 0) { connectionName = "default"; }
        return getConnectionManager().get(connectionName).getMongoRepository(entityClass);
    }
    exports_282("getMongoRepository", getMongoRepository);
    var ConnectionManager_1, MetadataArgsStorage_2, container_2, PlatformTools_19, ConnectionOptionsReader_1, PromiseUtils_6;
    var exportedNames_1 = {
        "getMetadataArgsStorage": true,
        "getConnectionOptions": true,
        "getConnectionManager": true,
        "createConnection": true,
        "createConnections": true,
        "getConnection": true,
        "getManager": true,
        "getMongoManager": true,
        "getSqljsManager": true,
        "getRepository": true,
        "getTreeRepository": true,
        "getCustomRepository": true,
        "getMongoRepository": true,
        "ConnectionOptionsReader": true,
        "Connection": true,
        "ConnectionManager": true,
        "QueryBuilder": true,
        "SelectQueryBuilder": true,
        "DeleteQueryBuilder": true,
        "InsertQueryBuilder": true,
        "UpdateQueryBuilder": true,
        "RelationQueryBuilder": true,
        "Brackets": true,
        "EntityManager": true,
        "MongoEntityManager": true,
        "DefaultNamingStrategy": true,
        "Repository": true,
        "TreeRepository": true,
        "MongoRepository": true,
        "BaseEntity": true,
        "PromiseUtils": true
    };
    function exportStar_1(m) {
        var exports = {};
        for (var n in m) {
            if (n !== "default" && !exportedNames_1.hasOwnProperty(n)) exports[n] = m[n];
        }
        exports_282(exports);
    }
    return {
        setters: [
            function (ConnectionManager_1_1) {
                ConnectionManager_1 = ConnectionManager_1_1;
                exports_282({
                    "ConnectionManager": ConnectionManager_1_1["ConnectionManager"]
                });
            },
            function (MetadataArgsStorage_2_1) {
                MetadataArgsStorage_2 = MetadataArgsStorage_2_1;
            },
            function (container_2_1) {
                container_2 = container_2_1;
                exportStar_1(container_2_1);
            },
            function (PlatformTools_19_1) {
                PlatformTools_19 = PlatformTools_19_1;
            },
            function (ConnectionOptionsReader_1_1) {
                ConnectionOptionsReader_1 = ConnectionOptionsReader_1_1;
                exports_282({
                    "ConnectionOptionsReader": ConnectionOptionsReader_1_1["ConnectionOptionsReader"]
                });
            },
            function (PromiseUtils_6_1) {
                PromiseUtils_6 = PromiseUtils_6_1;
                exports_282({
                    "PromiseUtils": PromiseUtils_6_1["PromiseUtils"]
                });
            },
            function (QueryFailedError_8_1) {
                exportStar_1(QueryFailedError_8_1);
            },
            function (Column_1_1) {
                exportStar_1(Column_1_1);
            },
            function (CreateDateColumn_1_1) {
                exportStar_1(CreateDateColumn_1_1);
            },
            function (DiscriminatorColumn_1_1) {
                exportStar_1(DiscriminatorColumn_1_1);
            },
            function (PrimaryGeneratedColumn_1_1) {
                exportStar_1(PrimaryGeneratedColumn_1_1);
            },
            function (PrimaryColumn_1_1) {
                exportStar_1(PrimaryColumn_1_1);
            },
            function (UpdateDateColumn_1_1) {
                exportStar_1(UpdateDateColumn_1_1);
            },
            function (VersionColumn_1_1) {
                exportStar_1(VersionColumn_1_1);
            },
            function (ObjectIdColumn_1_1) {
                exportStar_1(ObjectIdColumn_1_1);
            },
            function (AfterInsert_1_1) {
                exportStar_1(AfterInsert_1_1);
            },
            function (AfterLoad_1_1) {
                exportStar_1(AfterLoad_1_1);
            },
            function (AfterRemove_1_1) {
                exportStar_1(AfterRemove_1_1);
            },
            function (AfterUpdate_1_1) {
                exportStar_1(AfterUpdate_1_1);
            },
            function (BeforeInsert_1_1) {
                exportStar_1(BeforeInsert_1_1);
            },
            function (BeforeRemove_1_1) {
                exportStar_1(BeforeRemove_1_1);
            },
            function (BeforeUpdate_1_1) {
                exportStar_1(BeforeUpdate_1_1);
            },
            function (EventSubscriber_1_1) {
                exportStar_1(EventSubscriber_1_1);
            },
            function (JoinColumn_1_1) {
                exportStar_1(JoinColumn_1_1);
            },
            function (JoinTable_1_1) {
                exportStar_1(JoinTable_1_1);
            },
            function (ManyToMany_1_1) {
                exportStar_1(ManyToMany_1_1);
            },
            function (ManyToOne_1_1) {
                exportStar_1(ManyToOne_1_1);
            },
            function (OneToMany_1_1) {
                exportStar_1(OneToMany_1_1);
            },
            function (OneToOne_1_1) {
                exportStar_1(OneToOne_1_1);
            },
            function (RelationCount_1_1) {
                exportStar_1(RelationCount_1_1);
            },
            function (RelationId_1_1) {
                exportStar_1(RelationId_1_1);
            },
            function (Entity_1_1) {
                exportStar_1(Entity_1_1);
            },
            function (ClassEntityChild_1_1) {
                exportStar_1(ClassEntityChild_1_1);
            },
            function (ClosureEntity_1_1) {
                exportStar_1(ClosureEntity_1_1);
            },
            function (SingleEntityChild_1_1) {
                exportStar_1(SingleEntityChild_1_1);
            },
            function (TableInheritance_1_1) {
                exportStar_1(TableInheritance_1_1);
            },
            function (Transaction_1_1) {
                exportStar_1(Transaction_1_1);
            },
            function (TransactionManager_1_1) {
                exportStar_1(TransactionManager_1_1);
            },
            function (TransactionRepository_1_1) {
                exportStar_1(TransactionRepository_1_1);
            },
            function (TreeLevelColumn_1_1) {
                exportStar_1(TreeLevelColumn_1_1);
            },
            function (TreeParent_1_1) {
                exportStar_1(TreeParent_1_1);
            },
            function (TreeChildren_1_1) {
                exportStar_1(TreeChildren_1_1);
            },
            function (Index_1_1) {
                exportStar_1(Index_1_1);
            },
            function (Generated_1_1) {
                exportStar_1(Generated_1_1);
            },
            function (DiscriminatorValue_1_1) {
                exportStar_1(DiscriminatorValue_1_1);
            },
            function (EntityRepository_1_1) {
                exportStar_1(EntityRepository_1_1);
            },
            function (AdvancedConsoleLogger_2_1) {
                exportStar_1(AdvancedConsoleLogger_2_1);
            },
            function (SimpleConsoleLogger_2_1) {
                exportStar_1(SimpleConsoleLogger_2_1);
            },
            function (FileLogger_2_1) {
                exportStar_1(FileLogger_2_1);
            },
            function (EntityMetadataUtils_3_1) {
                exportStar_1(EntityMetadataUtils_3_1);
            },
            function (EntityManager_4_1) {
                exportStar_1(EntityManager_4_1);
                exports_282({
                    "EntityManager": EntityManager_4_1["EntityManager"]
                });
            },
            function (AbstractRepository_2_1) {
                exportStar_1(AbstractRepository_2_1);
            },
            function (Repository_5_1) {
                exportStar_1(Repository_5_1);
                exports_282({
                    "Repository": Repository_5_1["Repository"]
                });
            },
            function (BaseEntity_1_1) {
                exportStar_1(BaseEntity_1_1);
                exports_282({
                    "BaseEntity": BaseEntity_1_1["BaseEntity"]
                });
            },
            function (TreeRepository_3_1) {
                exportStar_1(TreeRepository_3_1);
                exports_282({
                    "TreeRepository": TreeRepository_3_1["TreeRepository"]
                });
            },
            function (MongoRepository_2_1) {
                exportStar_1(MongoRepository_2_1);
                exports_282({
                    "MongoRepository": MongoRepository_2_1["MongoRepository"]
                });
            },
            function (TableColumn_10_1) {
                exportStar_1(TableColumn_10_1);
            },
            function (TableForeignKey_7_1) {
                exportStar_1(TableForeignKey_7_1);
            },
            function (TableIndex_7_1) {
                exportStar_1(TableIndex_7_1);
            },
            function (TablePrimaryKey_7_1) {
                exportStar_1(TablePrimaryKey_7_1);
            },
            function (Table_10_1) {
                exportStar_1(Table_10_1);
            },
            function (typings_1_1) {
                exportStar_1(typings_1_1);
            },
            function (MssqlParameter_5_1) {
                exportStar_1(MssqlParameter_5_1);
            },
            function (Connection_2_1) {
                exports_282({
                    "Connection": Connection_2_1["Connection"]
                });
            },
            function (QueryBuilder_6_1) {
                exports_282({
                    "QueryBuilder": QueryBuilder_6_1["QueryBuilder"]
                });
            },
            function (SelectQueryBuilder_2_1) {
                exports_282({
                    "SelectQueryBuilder": SelectQueryBuilder_2_1["SelectQueryBuilder"]
                });
            },
            function (DeleteQueryBuilder_1_1) {
                exports_282({
                    "DeleteQueryBuilder": DeleteQueryBuilder_1_1["DeleteQueryBuilder"]
                });
            },
            function (InsertQueryBuilder_1_1) {
                exports_282({
                    "InsertQueryBuilder": InsertQueryBuilder_1_1["InsertQueryBuilder"]
                });
            },
            function (UpdateQueryBuilder_1_1) {
                exports_282({
                    "UpdateQueryBuilder": UpdateQueryBuilder_1_1["UpdateQueryBuilder"]
                });
            },
            function (RelationQueryBuilder_1_1) {
                exports_282({
                    "RelationQueryBuilder": RelationQueryBuilder_1_1["RelationQueryBuilder"]
                });
            },
            function (Brackets_2_1) {
                exports_282({
                    "Brackets": Brackets_2_1["Brackets"]
                });
            },
            function (MongoEntityManager_3_1) {
                exports_282({
                    "MongoEntityManager": MongoEntityManager_3_1["MongoEntityManager"]
                });
            },
            function (DefaultNamingStrategy_2_1) {
                exports_282({
                    "DefaultNamingStrategy": DefaultNamingStrategy_2_1["DefaultNamingStrategy"]
                });
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm", ["typeorm/index"], function (exports_283, context_283) {
    "use strict";
    var __moduleName = context_283 && context_283.id;
    function exportStar_2(m) {
        var exports = {};
        for (var n in m) {
            if (n !== "default") exports[n] = m[n];
        }
        exports_283(exports);
    }
    return {
        setters: [
            function (index_44_1) {
                exportStar_2(index_44_1);
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/error/CannotGetEntityManagerNotConnectedError", [], function (exports_284, context_284) {
    "use strict";
    var __moduleName = context_284 && context_284.id;
    var CannotGetEntityManagerNotConnectedError;
    return {
        setters: [],
        execute: function () {
            /**
             * Thrown when consumer tries to access entity manager before connection is established.
             */
            CannotGetEntityManagerNotConnectedError = /** @class */ (function (_super) {
                __extends(CannotGetEntityManagerNotConnectedError, _super);
                function CannotGetEntityManagerNotConnectedError(connectionName) {
                    var _this = _super.call(this) || this;
                    _this.name = "CannotGetEntityManagerNotConnectedError";
                    _this.message = "Cannot get entity manager for \"" + connectionName + "\" connection because connection is not yet established.";
                    _this.stack = new Error().stack;
                    return _this;
                }
                return CannotGetEntityManagerNotConnectedError;
            }(Error));
            exports_284("CannotGetEntityManagerNotConnectedError", CannotGetEntityManagerNotConnectedError);
        }
    };
});
System.register("typeorm/error/CascadesNotAllowedError", [], function (exports_285, context_285) {
    "use strict";
    var __moduleName = context_285 && context_285.id;
    var CascadesNotAllowedError;
    return {
        setters: [],
        execute: function () {
            /**
             */
            CascadesNotAllowedError = /** @class */ (function (_super) {
                __extends(CascadesNotAllowedError, _super);
                // todo: remove metadata attribute since its present in relation attribute
                function CascadesNotAllowedError(type, metadata, relation) {
                    var _this = _super.call(this) || this;
                    _this.name = "CascadesNotAllowedError";
                    _this.message = "Cascades (" + type + ") are not allowed for the given relation " + metadata.name + "#" + relation.joinColumns[0].referencedColumn.databaseName;
                    return _this;
                }
                return CascadesNotAllowedError;
            }(Error));
            exports_285("CascadesNotAllowedError", CascadesNotAllowedError);
        }
    };
});
System.register("typeorm/error/CustomRepositoryReusedError", [], function (exports_286, context_286) {
    "use strict";
    var __moduleName = context_286 && context_286.id;
    var CustomRepositoryReusedError;
    return {
        setters: [],
        execute: function () {
            /**
             * Thrown if same custom repository instance is reused between different connections.
             */
            CustomRepositoryReusedError = /** @class */ (function (_super) {
                __extends(CustomRepositoryReusedError, _super);
                function CustomRepositoryReusedError(repository) {
                    var _this = _super.call(this, "Custom entity repository " + (repository instanceof Function ? repository.name : repository.constructor.name) + " " +
                        "was already used in the different connection. You can't share entity repositories between different connections " +
                        "when useContainer is set to true for the entity repository.") || this;
                    _this.name = "CustomRepositoryReusedError";
                    return _this;
                }
                return CustomRepositoryReusedError;
            }(Error));
            exports_286("CustomRepositoryReusedError", CustomRepositoryReusedError);
        }
    };
});
System.register("typeorm/error/GeneratedOnlyForPrimaryError", [], function (exports_287, context_287) {
    "use strict";
    var __moduleName = context_287 && context_287.id;
    var GeneratedOnlyForPrimaryError;
    return {
        setters: [],
        execute: function () {
            GeneratedOnlyForPrimaryError = /** @class */ (function (_super) {
                __extends(GeneratedOnlyForPrimaryError, _super);
                function GeneratedOnlyForPrimaryError(object, propertyName) {
                    var _this = _super.call(this) || this;
                    _this.name = "GeneratedOnlyForPrimaryError";
                    _this.message = "Column for property " + object.constructor.name + "#" + propertyName + " cannot have a generated " +
                        "value. Generated values supports only in PrimaryColumn decorator or UUID column type.";
                    return _this;
                }
                return GeneratedOnlyForPrimaryError;
            }(Error));
            exports_287("GeneratedOnlyForPrimaryError", GeneratedOnlyForPrimaryError);
        }
    };
});
System.register("typeorm/error/MetadataAlreadyExistsError", [], function (exports_288, context_288) {
    "use strict";
    var __moduleName = context_288 && context_288.id;
    var MetadataAlreadyExistsError;
    return {
        setters: [],
        execute: function () {
            /**
             */
            MetadataAlreadyExistsError = /** @class */ (function (_super) {
                __extends(MetadataAlreadyExistsError, _super);
                function MetadataAlreadyExistsError(metadataType, constructor, propertyName) {
                    var _this = _super.call(this) || this;
                    _this.name = "MetadataAlreadyExistsError";
                    _this.message = metadataType + " metadata already exists for the class constructor " + JSON.stringify(constructor) +
                        (propertyName ? " on property " + propertyName : ". If you previously renamed or moved entity class, make sure" +
                            " that compiled version of old entity class source wasn't left in the compiler output directory.");
                    return _this;
                }
                return MetadataAlreadyExistsError;
            }(Error));
            exports_288("MetadataAlreadyExistsError", MetadataAlreadyExistsError);
        }
    };
});
System.register("typeorm/error/MetadataWithSuchNameAlreadyExistsError", [], function (exports_289, context_289) {
    "use strict";
    var __moduleName = context_289 && context_289.id;
    var MetadataWithSuchNameAlreadyExistsError;
    return {
        setters: [],
        execute: function () {
            /**
             */
            MetadataWithSuchNameAlreadyExistsError = /** @class */ (function (_super) {
                __extends(MetadataWithSuchNameAlreadyExistsError, _super);
                function MetadataWithSuchNameAlreadyExistsError(metadataType, name) {
                    var _this = _super.call(this) || this;
                    _this.name = "MetadataWithSuchNameAlreadyExistsError";
                    _this.message = metadataType + " metadata with such name " + name + " already exists. " +
                        "Do you apply decorator twice? Or maybe try to change a name?";
                    return _this;
                }
                return MetadataWithSuchNameAlreadyExistsError;
            }(Error));
            exports_289("MetadataWithSuchNameAlreadyExistsError", MetadataWithSuchNameAlreadyExistsError);
        }
    };
});
System.register("typeorm/error/MissingJoinColumnError", [], function (exports_290, context_290) {
    "use strict";
    var __moduleName = context_290 && context_290.id;
    var MissingJoinColumnError;
    return {
        setters: [],
        execute: function () {
            /**
             */
            MissingJoinColumnError = /** @class */ (function (_super) {
                __extends(MissingJoinColumnError, _super);
                function MissingJoinColumnError(entityMetadata, relation) {
                    var _this = _super.call(this) || this;
                    _this.name = "MissingJoinColumnError";
                    if (relation.inverseRelation) {
                        _this.message = "JoinColumn is missing on both sides of " + entityMetadata.name + "#" + relation.propertyName + " and " +
                            (relation.inverseEntityMetadata.name + "#" + relation.inverseRelation.propertyName + " one-to-one relationship. ") +
                            "You need to put JoinColumn decorator on one of the sides.";
                    }
                    else {
                        _this.message = "JoinColumn is missing on " + entityMetadata.name + "#" + relation.propertyName + " one-to-one relationship. " +
                            "You need to put JoinColumn decorator on it.";
                    }
                    return _this;
                }
                return MissingJoinColumnError;
            }(Error));
            exports_290("MissingJoinColumnError", MissingJoinColumnError);
        }
    };
});
System.register("typeorm/error/MissingJoinTableError", [], function (exports_291, context_291) {
    "use strict";
    var __moduleName = context_291 && context_291.id;
    var MissingJoinTableError;
    return {
        setters: [],
        execute: function () {
            /**
             */
            MissingJoinTableError = /** @class */ (function (_super) {
                __extends(MissingJoinTableError, _super);
                function MissingJoinTableError(entityMetadata, relation) {
                    var _this = _super.call(this) || this;
                    _this.name = "MissingJoinTableError";
                    if (relation.inverseRelation) {
                        _this.message = "JoinTable is missing on both sides of " + entityMetadata.name + "#" + relation.propertyName + " and " +
                            (relation.inverseEntityMetadata.name + "#" + relation.inverseRelation.propertyName + " many-to-many relationship. ") +
                            "You need to put decorator decorator on one of the sides.";
                    }
                    else {
                        _this.message = "JoinTable is missing on " + entityMetadata.name + "#" + relation.propertyName + " many-to-many relationship. " +
                            "You need to put JoinTable decorator on it.";
                    }
                    return _this;
                }
                return MissingJoinTableError;
            }(Error));
            exports_291("MissingJoinTableError", MissingJoinTableError);
        }
    };
});
System.register("typeorm/error/NamingStrategyNotFoundError", [], function (exports_292, context_292) {
    "use strict";
    var __moduleName = context_292 && context_292.id;
    var NamingStrategyNotFoundError;
    return {
        setters: [],
        execute: function () {
            /**
             * Thrown when consumer tries to use naming strategy that does not exist.
             */
            NamingStrategyNotFoundError = /** @class */ (function (_super) {
                __extends(NamingStrategyNotFoundError, _super);
                function NamingStrategyNotFoundError(strategyName, connectionName) {
                    var _this = _super.call(this) || this;
                    _this.name = "NamingStrategyNotFoundError";
                    var name = strategyName instanceof Function ? strategyName.name : strategyName;
                    _this.message = "Naming strategy \"" + name + "\" was not found. Looks like this naming strategy does not " +
                        ("exist or it was not registered in current \"" + connectionName + "\" connection?");
                    _this.stack = new Error().stack;
                    return _this;
                }
                return NamingStrategyNotFoundError;
            }(Error));
            exports_292("NamingStrategyNotFoundError", NamingStrategyNotFoundError);
        }
    };
});
System.register("typeorm/error/NoConnectionForRepositoryError", [], function (exports_293, context_293) {
    "use strict";
    var __moduleName = context_293 && context_293.id;
    var NoConnectionForRepositoryError;
    return {
        setters: [],
        execute: function () {
            /**
             * Thrown when consumer tries to access repository before connection is established.
             */
            NoConnectionForRepositoryError = /** @class */ (function (_super) {
                __extends(NoConnectionForRepositoryError, _super);
                function NoConnectionForRepositoryError(connectionName) {
                    var _this = _super.call(this) || this;
                    _this.name = "NoConnectionForRepositoryError";
                    _this.message = "Cannot get a Repository for \"" + connectionName + " connection, because connection with the database " +
                        "is not established yet. Call connection#connect method to establish connection.";
                    _this.stack = new Error().stack;
                    return _this;
                }
                return NoConnectionForRepositoryError;
            }(Error));
            exports_293("NoConnectionForRepositoryError", NoConnectionForRepositoryError);
        }
    };
});
System.register("typeorm/error/PersistedEntityNotFoundError", [], function (exports_294, context_294) {
    "use strict";
    var __moduleName = context_294 && context_294.id;
    var PersistedEntityNotFoundError;
    return {
        setters: [],
        execute: function () {
            /**
             * Thrown . Theoretically can't be thrown.
             */
            PersistedEntityNotFoundError = /** @class */ (function (_super) {
                __extends(PersistedEntityNotFoundError, _super);
                function PersistedEntityNotFoundError() {
                    var _this = _super.call(this) || this;
                    _this.name = "PersistedEntityNotFoundError";
                    _this.message = "Internal error. Persisted entity was not found in the list of prepared operated entities.";
                    return _this;
                }
                return PersistedEntityNotFoundError;
            }(Error));
            exports_294("PersistedEntityNotFoundError", PersistedEntityNotFoundError);
        }
    };
});
System.register("typeorm/error/UsingJoinColumnIsNotAllowedError", [], function (exports_295, context_295) {
    "use strict";
    var __moduleName = context_295 && context_295.id;
    var UsingJoinColumnIsNotAllowedError;
    return {
        setters: [],
        execute: function () {
            /**
             */
            UsingJoinColumnIsNotAllowedError = /** @class */ (function (_super) {
                __extends(UsingJoinColumnIsNotAllowedError, _super);
                function UsingJoinColumnIsNotAllowedError(entityMetadata, relation) {
                    var _this = _super.call(this) || this;
                    _this.name = "UsingJoinColumnIsNotAllowedError";
                    _this.message = "Using JoinColumn on " + entityMetadata.name + "#" + relation.propertyName + " is wrong. " +
                        "You can use JoinColumn only on one-to-one and many-to-one relations.";
                    return _this;
                }
                return UsingJoinColumnIsNotAllowedError;
            }(Error));
            exports_295("UsingJoinColumnIsNotAllowedError", UsingJoinColumnIsNotAllowedError);
        }
    };
});
System.register("typeorm/error/UsingJoinColumnOnlyOnOneSideAllowedError", [], function (exports_296, context_296) {
    "use strict";
    var __moduleName = context_296 && context_296.id;
    var UsingJoinColumnOnlyOnOneSideAllowedError;
    return {
        setters: [],
        execute: function () {
            /**
             */
            UsingJoinColumnOnlyOnOneSideAllowedError = /** @class */ (function (_super) {
                __extends(UsingJoinColumnOnlyOnOneSideAllowedError, _super);
                function UsingJoinColumnOnlyOnOneSideAllowedError(entityMetadata, relation) {
                    var _this = _super.call(this) || this;
                    _this.name = "UsingJoinColumnOnlyOnOneSideAllowedError";
                    _this.message = "Using JoinColumn is allowed only on one side of the one-to-one relationship. " +
                        ("Both " + entityMetadata.name + "#" + relation.propertyName + " and " + relation.inverseEntityMetadata.name + "#" + relation.inverseRelation.propertyName + " ") +
                        "has JoinTable decorators. Choose one of them and left JoinTable decorator only on it.";
                    return _this;
                }
                return UsingJoinColumnOnlyOnOneSideAllowedError;
            }(Error));
            exports_296("UsingJoinColumnOnlyOnOneSideAllowedError", UsingJoinColumnOnlyOnOneSideAllowedError);
        }
    };
});
System.register("typeorm/error/UsingJoinTableIsNotAllowedError", [], function (exports_297, context_297) {
    "use strict";
    var __moduleName = context_297 && context_297.id;
    var UsingJoinTableIsNotAllowedError;
    return {
        setters: [],
        execute: function () {
            /**
             */
            UsingJoinTableIsNotAllowedError = /** @class */ (function (_super) {
                __extends(UsingJoinTableIsNotAllowedError, _super);
                function UsingJoinTableIsNotAllowedError(entityMetadata, relation) {
                    var _this = _super.call(this) || this;
                    _this.name = "UsingJoinTableIsNotAllowedError";
                    _this.message = "Using JoinTable on " + entityMetadata.name + "#" + relation.propertyName + " is wrong. " +
                        (entityMetadata.name + "#" + relation.propertyName + " has " + relation.relationType + " relation, ") +
                        "however you can use JoinTable only on many-to-many relations.";
                    return _this;
                }
                return UsingJoinTableIsNotAllowedError;
            }(Error));
            exports_297("UsingJoinTableIsNotAllowedError", UsingJoinTableIsNotAllowedError);
        }
    };
});
System.register("typeorm/error/UsingJoinTableOnlyOnOneSideAllowedError", [], function (exports_298, context_298) {
    "use strict";
    var __moduleName = context_298 && context_298.id;
    var UsingJoinTableOnlyOnOneSideAllowedError;
    return {
        setters: [],
        execute: function () {
            /**
             */
            UsingJoinTableOnlyOnOneSideAllowedError = /** @class */ (function (_super) {
                __extends(UsingJoinTableOnlyOnOneSideAllowedError, _super);
                function UsingJoinTableOnlyOnOneSideAllowedError(entityMetadata, relation) {
                    var _this = _super.call(this) || this;
                    _this.name = "UsingJoinTableOnlyOnOneSideAllowedError";
                    _this.message = "Using JoinTable is allowed only on one side of the many-to-many relationship. " +
                        ("Both " + entityMetadata.name + "#" + relation.propertyName + " and " + relation.inverseEntityMetadata.name + "#" + relation.inverseRelation.propertyName + " ") +
                        "has JoinTable decorators. Choose one of them and left JoinColumn decorator only on it.";
                    return _this;
                }
                return UsingJoinTableOnlyOnOneSideAllowedError;
            }(Error));
            exports_298("UsingJoinTableOnlyOnOneSideAllowedError", UsingJoinTableOnlyOnOneSideAllowedError);
        }
    };
});
System.register("typeorm/query-builder/JoinOptions", [], function (exports_299, context_299) {
    "use strict";
    var __moduleName = context_299 && context_299.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
/*import {TableSchema} from "./schema/TableSchema";

export class Schema {

    createTable(name: string): TableSchema;
    createTable(entity: Function): TableSchema;
    createTable(nameOrEntity: Function|string): TableSchema {
        return new TableSchema(nameOrEntity as string);
    }

    updateTable(table: TableSchema): Promise<void> {

    }

    dropTable(name: string): Promise<void>;
    dropTable(entity: Function): Promise<void>;
    dropTable(nameOrEntity: Function|string): Promise<void> {
    }


    hasTable(name: string): Promise<boolean>;
    hasTable(entity: Function): Promise<boolean>;
    hasTable(nameOrEntity: Function|string): Promise<boolean> {
    }

    getTables(): Promise<TableSchema[]> {

    }


    getTableNames(): Promise<string[]> {

    }

}*/ 

//# sourceMappingURL=typeorm-browser.js.map
